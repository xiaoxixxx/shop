if (typeof Promise !== "undefined" && !Promise.prototype.finally) {
  Promise.prototype.finally = function(callback) {
    const promise = this.constructor;
    return this.then(
      (value) => promise.resolve(callback()).then(() => value),
      (reason) => promise.resolve(callback()).then(() => {
        throw reason;
      })
    );
  };
}
;
if (typeof uni !== "undefined" && uni && uni.requireGlobal) {
  const global2 = uni.requireGlobal();
  ArrayBuffer = global2.ArrayBuffer;
  Int8Array = global2.Int8Array;
  Uint8Array = global2.Uint8Array;
  Uint8ClampedArray = global2.Uint8ClampedArray;
  Int16Array = global2.Int16Array;
  Uint16Array = global2.Uint16Array;
  Int32Array = global2.Int32Array;
  Uint32Array = global2.Uint32Array;
  Float32Array = global2.Float32Array;
  Float64Array = global2.Float64Array;
  BigInt64Array = global2.BigInt64Array;
  BigUint64Array = global2.BigUint64Array;
}
;
if (uni.restoreGlobal) {
  uni.restoreGlobal(Vue, weex, plus, setTimeout, clearTimeout, setInterval, clearInterval);
}
(function(vue, shared) {
  "use strict";
  const ON_LOAD = "onLoad";
  function formatAppLog(type, filename, ...args) {
    if (uni.__log__) {
      uni.__log__(type, filename, ...args);
    } else {
      console[type].apply(console, [...args, filename]);
    }
  }
  function resolveEasycom(component, easycom) {
    return typeof component === "string" ? easycom : component;
  }
  const createHook = (lifecycle) => (hook, target = vue.getCurrentInstance()) => {
    !vue.isInSSRComponentSetup && vue.injectHook(lifecycle, hook, target);
  };
  const onLoad = /* @__PURE__ */ createHook(ON_LOAD);
  /*!
    * @intlify/shared v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const inBrowser$2 = typeof window !== "undefined";
  let mark;
  let measure;
  {
    const perf2 = inBrowser$2 && window.performance;
    if (perf2 && perf2.mark && perf2.measure && perf2.clearMarks && perf2.clearMeasures) {
      mark = (tag) => perf2.mark(tag);
      measure = (name2, startTag, endTag) => {
        perf2.measure(name2, startTag, endTag);
        perf2.clearMarks(startTag);
        perf2.clearMarks(endTag);
      };
    }
  }
  const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
  function format$2(message, ...args) {
    if (args.length === 1 && isObject$3(args[0])) {
      args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
      args = {};
    }
    return message.replace(RE_ARGS, (match, identifier) => {
      return args.hasOwnProperty(identifier) ? args[identifier] : "";
    });
  }
  const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  const makeSymbol = (name2) => hasSymbol ? Symbol(name2) : name2;
  const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
  const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
  const isNumber = (val) => typeof val === "number" && isFinite(val);
  const isDate$1 = (val) => toTypeString(val) === "[object Date]";
  const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
  const isEmptyObject = (val) => isPlainObject$1(val) && Object.keys(val).length === 0;
  function warn(msg, err) {
    if (typeof console !== "undefined") {
      console.warn(`[intlify] ` + msg);
      if (err) {
        console.warn(err.stack);
      }
    }
  }
  const assign$2 = Object.assign;
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function escapeHtml(rawText) {
    return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  function hasOwn$2(obj, key) {
    return hasOwnProperty$3.call(obj, key);
  }
  const isArray = Array.isArray;
  const isFunction$1 = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isBoolean = (val) => typeof val === "boolean";
  const isObject$3 = (val) => (
    // eslint-disable-line
    val !== null && typeof val === "object"
  );
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
  const toDisplayString = (val) => {
    return val == null ? "" : isArray(val) || isPlainObject$1(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
  };
  const RANGE = 2;
  function generateCodeFrame(source, start2 = 0, end2 = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i2 = 0; i2 < lines.length; i2++) {
      count += lines[i2].length + 1;
      if (count >= start2) {
        for (let j = i2 - RANGE; j <= i2 + RANGE || end2 > count; j++) {
          if (j < 0 || j >= lines.length)
            continue;
          const line = j + 1;
          res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j]}`);
          const lineLength = lines[j].length;
          if (j === i2) {
            const pad = start2 - (count - lineLength) + 1;
            const length = Math.max(1, end2 > count ? lineLength - pad : end2 - start2);
            res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
          } else if (j > i2) {
            if (end2 > count) {
              const length = Math.max(Math.min(end2 - count, lineLength), 1);
              res.push(`   |  ` + "^".repeat(length));
            }
            count += lineLength + 1;
          }
        }
        break;
      }
    }
    return res.join("\n");
  }
  function createEmitter() {
    const events = /* @__PURE__ */ new Map();
    const emitter = {
      events,
      on(event, handler) {
        const handlers = events.get(event);
        const added = handlers && handlers.push(handler);
        if (!added) {
          events.set(event, [handler]);
        }
      },
      off(event, handler) {
        const handlers = events.get(event);
        if (handlers) {
          handlers.splice(handlers.indexOf(handler) >>> 0, 1);
        }
      },
      emit(event, payload) {
        (events.get(event) || []).slice().map((handler) => handler(payload));
        (events.get("*") || []).slice().map((handler) => handler(event, payload));
      }
    };
    return emitter;
  }
  /*!
    * @intlify/message-resolver v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function hasOwn$1(obj, key) {
    return hasOwnProperty$2.call(obj, key);
  }
  const isObject$2 = (val) => (
    // eslint-disable-line
    val !== null && typeof val === "object"
  );
  const pathStateMachine = [];
  pathStateMachine[
    0
    /* BEFORE_PATH */
  ] = {
    [
      "w"
      /* WORKSPACE */
    ]: [
      0
      /* BEFORE_PATH */
    ],
    [
      "i"
      /* IDENT */
    ]: [
      3,
      0
      /* APPEND */
    ],
    [
      "["
      /* LEFT_BRACKET */
    ]: [
      4
      /* IN_SUB_PATH */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: [
      7
      /* AFTER_PATH */
    ]
  };
  pathStateMachine[
    1
    /* IN_PATH */
  ] = {
    [
      "w"
      /* WORKSPACE */
    ]: [
      1
      /* IN_PATH */
    ],
    [
      "."
      /* DOT */
    ]: [
      2
      /* BEFORE_IDENT */
    ],
    [
      "["
      /* LEFT_BRACKET */
    ]: [
      4
      /* IN_SUB_PATH */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: [
      7
      /* AFTER_PATH */
    ]
  };
  pathStateMachine[
    2
    /* BEFORE_IDENT */
  ] = {
    [
      "w"
      /* WORKSPACE */
    ]: [
      2
      /* BEFORE_IDENT */
    ],
    [
      "i"
      /* IDENT */
    ]: [
      3,
      0
      /* APPEND */
    ],
    [
      "0"
      /* ZERO */
    ]: [
      3,
      0
      /* APPEND */
    ]
  };
  pathStateMachine[
    3
    /* IN_IDENT */
  ] = {
    [
      "i"
      /* IDENT */
    ]: [
      3,
      0
      /* APPEND */
    ],
    [
      "0"
      /* ZERO */
    ]: [
      3,
      0
      /* APPEND */
    ],
    [
      "w"
      /* WORKSPACE */
    ]: [
      1,
      1
      /* PUSH */
    ],
    [
      "."
      /* DOT */
    ]: [
      2,
      1
      /* PUSH */
    ],
    [
      "["
      /* LEFT_BRACKET */
    ]: [
      4,
      1
      /* PUSH */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: [
      7,
      1
      /* PUSH */
    ]
  };
  pathStateMachine[
    4
    /* IN_SUB_PATH */
  ] = {
    [
      "'"
      /* SINGLE_QUOTE */
    ]: [
      5,
      0
      /* APPEND */
    ],
    [
      '"'
      /* DOUBLE_QUOTE */
    ]: [
      6,
      0
      /* APPEND */
    ],
    [
      "["
      /* LEFT_BRACKET */
    ]: [
      4,
      2
      /* INC_SUB_PATH_DEPTH */
    ],
    [
      "]"
      /* RIGHT_BRACKET */
    ]: [
      1,
      3
      /* PUSH_SUB_PATH */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* ELSE */
    ]: [
      4,
      0
      /* APPEND */
    ]
  };
  pathStateMachine[
    5
    /* IN_SINGLE_QUOTE */
  ] = {
    [
      "'"
      /* SINGLE_QUOTE */
    ]: [
      4,
      0
      /* APPEND */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* ELSE */
    ]: [
      5,
      0
      /* APPEND */
    ]
  };
  pathStateMachine[
    6
    /* IN_DOUBLE_QUOTE */
  ] = {
    [
      '"'
      /* DOUBLE_QUOTE */
    ]: [
      4,
      0
      /* APPEND */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* ELSE */
    ]: [
      6,
      0
      /* APPEND */
    ]
  };
  const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function isLiteral(exp) {
    return literalValueRE.test(exp);
  }
  function stripQuotes(str) {
    const a2 = str.charCodeAt(0);
    const b2 = str.charCodeAt(str.length - 1);
    return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
  }
  function getPathCharType(ch) {
    if (ch === void 0 || ch === null) {
      return "o";
    }
    const code2 = ch.charCodeAt(0);
    switch (code2) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return ch;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function formatSubPath(path) {
    const trimmed = path.trim();
    if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
      return false;
    }
    return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
  }
  function parse$1(path) {
    const keys = [];
    let index2 = -1;
    let mode = 0;
    let subPathDepth = 0;
    let c2;
    let key;
    let newChar;
    let type;
    let transition;
    let action;
    let typeMap;
    const actions = [];
    actions[
      0
      /* APPEND */
    ] = () => {
      if (key === void 0) {
        key = newChar;
      } else {
        key += newChar;
      }
    };
    actions[
      1
      /* PUSH */
    ] = () => {
      if (key !== void 0) {
        keys.push(key);
        key = void 0;
      }
    };
    actions[
      2
      /* INC_SUB_PATH_DEPTH */
    ] = () => {
      actions[
        0
        /* APPEND */
      ]();
      subPathDepth++;
    };
    actions[
      3
      /* PUSH_SUB_PATH */
    ] = () => {
      if (subPathDepth > 0) {
        subPathDepth--;
        mode = 4;
        actions[
          0
          /* APPEND */
        ]();
      } else {
        subPathDepth = 0;
        if (key === void 0) {
          return false;
        }
        key = formatSubPath(key);
        if (key === false) {
          return false;
        } else {
          actions[
            1
            /* PUSH */
          ]();
        }
      }
    };
    function maybeUnescapeQuote() {
      const nextChar = path[index2 + 1];
      if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
        index2++;
        newChar = "\\" + nextChar;
        actions[
          0
          /* APPEND */
        ]();
        return true;
      }
    }
    while (mode !== null) {
      index2++;
      c2 = path[index2];
      if (c2 === "\\" && maybeUnescapeQuote()) {
        continue;
      }
      type = getPathCharType(c2);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap[
        "l"
        /* ELSE */
      ] || 8;
      if (transition === 8) {
        return;
      }
      mode = transition[0];
      if (transition[1] !== void 0) {
        action = actions[transition[1]];
        if (action) {
          newChar = c2;
          if (action() === false) {
            return;
          }
        }
      }
      if (mode === 7) {
        return keys;
      }
    }
  }
  const cache = /* @__PURE__ */ new Map();
  function resolveValue(obj, path) {
    if (!isObject$2(obj)) {
      return null;
    }
    let hit = cache.get(path);
    if (!hit) {
      hit = parse$1(path);
      if (hit) {
        cache.set(path, hit);
      }
    }
    if (!hit) {
      return null;
    }
    const len = hit.length;
    let last = obj;
    let i2 = 0;
    while (i2 < len) {
      const val = last[hit[i2]];
      if (val === void 0) {
        return null;
      }
      last = val;
      i2++;
    }
    return last;
  }
  function handleFlatJson(obj) {
    if (!isObject$2(obj)) {
      return obj;
    }
    for (const key in obj) {
      if (!hasOwn$1(obj, key)) {
        continue;
      }
      if (!key.includes(
        "."
        /* DOT */
      )) {
        if (isObject$2(obj[key])) {
          handleFlatJson(obj[key]);
        }
      } else {
        const subKeys = key.split(
          "."
          /* DOT */
        );
        const lastIndex = subKeys.length - 1;
        let currentObj = obj;
        for (let i2 = 0; i2 < lastIndex; i2++) {
          if (!(subKeys[i2] in currentObj)) {
            currentObj[subKeys[i2]] = {};
          }
          currentObj = currentObj[subKeys[i2]];
        }
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
        if (isObject$2(currentObj[subKeys[lastIndex]])) {
          handleFlatJson(currentObj[subKeys[lastIndex]]);
        }
      }
    }
    return obj;
  }
  /*!
    * @intlify/runtime v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const DEFAULT_MODIFIER = (str) => str;
  const DEFAULT_MESSAGE = (ctx) => "";
  const DEFAULT_MESSAGE_DATA_TYPE = "text";
  const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : values.join("");
  const DEFAULT_INTERPOLATE = toDisplayString;
  function pluralDefault(choice, choicesLength) {
    choice = Math.abs(choice);
    if (choicesLength === 2) {
      return choice ? choice > 1 ? 1 : 0 : 1;
    }
    return choice ? Math.min(choice, 2) : 0;
  }
  function getPluralIndex(options) {
    const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
    return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
  }
  function normalizeNamed(pluralIndex, props2) {
    if (!props2.count) {
      props2.count = pluralIndex;
    }
    if (!props2.n) {
      props2.n = pluralIndex;
    }
  }
  function createMessageContext(options = {}) {
    const locale = options.locale;
    const pluralIndex = getPluralIndex(options);
    const pluralRule = isObject$3(options.pluralRules) && isString(locale) && isFunction$1(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
    const orgPluralRule = isObject$3(options.pluralRules) && isString(locale) && isFunction$1(options.pluralRules[locale]) ? pluralDefault : void 0;
    const plural = (messages2) => messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
    const _list = options.list || [];
    const list = (index2) => _list[index2];
    const _named = options.named || {};
    isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
    const named = (key) => _named[key];
    function message(key) {
      const msg = isFunction$1(options.messages) ? options.messages(key) : isObject$3(options.messages) ? options.messages[key] : false;
      return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
    }
    const _modifier = (name2) => options.modifiers ? options.modifiers[name2] : DEFAULT_MODIFIER;
    const normalize = isPlainObject$1(options.processor) && isFunction$1(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
    const interpolate = isPlainObject$1(options.processor) && isFunction$1(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
    const type = isPlainObject$1(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
    const ctx = {
      [
        "list"
        /* LIST */
      ]: list,
      [
        "named"
        /* NAMED */
      ]: named,
      [
        "plural"
        /* PLURAL */
      ]: plural,
      [
        "linked"
        /* LINKED */
      ]: (key, modifier) => {
        const msg = message(key)(ctx);
        return isString(modifier) ? _modifier(modifier)(msg) : msg;
      },
      [
        "message"
        /* MESSAGE */
      ]: message,
      [
        "type"
        /* TYPE */
      ]: type,
      [
        "interpolate"
        /* INTERPOLATE */
      ]: interpolate,
      [
        "normalize"
        /* NORMALIZE */
      ]: normalize
    };
    return ctx;
  }
  /*!
    * @intlify/message-compiler v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const errorMessages$2 = {
    // tokenizer error messages
    [
      0
      /* EXPECTED_TOKEN */
    ]: `Expected token: '{0}'`,
    [
      1
      /* INVALID_TOKEN_IN_PLACEHOLDER */
    ]: `Invalid token in placeholder: '{0}'`,
    [
      2
      /* UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER */
    ]: `Unterminated single quote in placeholder`,
    [
      3
      /* UNKNOWN_ESCAPE_SEQUENCE */
    ]: `Unknown escape sequence: \\{0}`,
    [
      4
      /* INVALID_UNICODE_ESCAPE_SEQUENCE */
    ]: `Invalid unicode escape sequence: {0}`,
    [
      5
      /* UNBALANCED_CLOSING_BRACE */
    ]: `Unbalanced closing brace`,
    [
      6
      /* UNTERMINATED_CLOSING_BRACE */
    ]: `Unterminated closing brace`,
    [
      7
      /* EMPTY_PLACEHOLDER */
    ]: `Empty placeholder`,
    [
      8
      /* NOT_ALLOW_NEST_PLACEHOLDER */
    ]: `Not allowed nest placeholder`,
    [
      9
      /* INVALID_LINKED_FORMAT */
    ]: `Invalid linked format`,
    // parser error messages
    [
      10
      /* MUST_HAVE_MESSAGES_IN_PLURAL */
    ]: `Plural must have messages`,
    [
      11
      /* UNEXPECTED_EMPTY_LINKED_MODIFIER */
    ]: `Unexpected empty linked modifier`,
    [
      12
      /* UNEXPECTED_EMPTY_LINKED_KEY */
    ]: `Unexpected empty linked key`,
    [
      13
      /* UNEXPECTED_LEXICAL_ANALYSIS */
    ]: `Unexpected lexical analysis in token: '{0}'`
  };
  function createCompileError(code2, loc, options = {}) {
    const { domain, messages: messages2, args } = options;
    const msg = format$2((messages2 || errorMessages$2)[code2] || "", ...args || []);
    const error2 = new SyntaxError(String(msg));
    error2.code = code2;
    if (loc) {
      error2.location = loc;
    }
    error2.domain = domain;
    return error2;
  }
  /*!
    * @intlify/devtools-if v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const IntlifyDevToolsHooks = {
    I18nInit: "i18n:init",
    FunctionTranslate: "function:translate"
  };
  /*!
    * @intlify/core-base v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  let devtools = null;
  function setDevToolsHook(hook) {
    devtools = hook;
  }
  function initI18nDevTools(i18n2, version2, meta) {
    devtools && devtools.emit(IntlifyDevToolsHooks.I18nInit, {
      timestamp: Date.now(),
      i18n: i18n2,
      version: version2,
      meta
    });
  }
  const translateDevTools = /* @__PURE__ */ createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);
  function createDevToolsHook(hook) {
    return (payloads) => devtools && devtools.emit(hook, payloads);
  }
  const warnMessages$1 = {
    [
      0
      /* NOT_FOUND_KEY */
    ]: `Not found '{key}' key in '{locale}' locale messages.`,
    [
      1
      /* FALLBACK_TO_TRANSLATE */
    ]: `Fall back to translate '{key}' key with '{target}' locale.`,
    [
      2
      /* CANNOT_FORMAT_NUMBER */
    ]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
    [
      3
      /* FALLBACK_TO_NUMBER_FORMAT */
    ]: `Fall back to number format '{key}' key with '{target}' locale.`,
    [
      4
      /* CANNOT_FORMAT_DATE */
    ]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
    [
      5
      /* FALLBACK_TO_DATE_FORMAT */
    ]: `Fall back to datetime format '{key}' key with '{target}' locale.`
  };
  function getWarnMessage$1(code2, ...args) {
    return format$2(warnMessages$1[code2], ...args);
  }
  const VERSION$1 = "9.1.9";
  const NOT_REOSLVED = -1;
  const MISSING_RESOLVE_VALUE = "";
  function getDefaultLinkedModifiers() {
    return {
      upper: (val) => isString(val) ? val.toUpperCase() : val,
      lower: (val) => isString(val) ? val.toLowerCase() : val,
      // prettier-ignore
      capitalize: (val) => isString(val) ? `${val.charAt(0).toLocaleUpperCase()}${val.substr(1)}` : val
    };
  }
  let _compiler;
  let _additionalMeta = null;
  const setAdditionalMeta = (meta) => {
    _additionalMeta = meta;
  };
  const getAdditionalMeta = () => _additionalMeta;
  let _cid = 0;
  function createCoreContext(options = {}) {
    const version2 = isString(options.version) ? options.version : VERSION$1;
    const locale = isString(options.locale) ? options.locale : "en-US";
    const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
    const messages2 = isPlainObject$1(options.messages) ? options.messages : { [locale]: {} };
    const datetimeFormats = isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [locale]: {} };
    const numberFormats = isPlainObject$1(options.numberFormats) ? options.numberFormats : { [locale]: {} };
    const modifiers = assign$2({}, options.modifiers || {}, getDefaultLinkedModifiers());
    const pluralRules = options.pluralRules || {};
    const missing = isFunction$1(options.missing) ? options.missing : null;
    const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    const fallbackFormat = !!options.fallbackFormat;
    const unresolving = !!options.unresolving;
    const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    const processor = isPlainObject$1(options.processor) ? options.processor : null;
    const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    const escapeParameter = !!options.escapeParameter;
    const messageCompiler = isFunction$1(options.messageCompiler) ? options.messageCompiler : _compiler;
    const onWarn = isFunction$1(options.onWarn) ? options.onWarn : warn;
    const internalOptions = options;
    const __datetimeFormatters = isObject$3(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
    const __numberFormatters = isObject$3(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
    const __meta = isObject$3(internalOptions.__meta) ? internalOptions.__meta : {};
    _cid++;
    const context = {
      version: version2,
      cid: _cid,
      locale,
      fallbackLocale,
      messages: messages2,
      datetimeFormats,
      numberFormats,
      modifiers,
      pluralRules,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackFormat,
      unresolving,
      postTranslation,
      processor,
      warnHtmlMessage,
      escapeParameter,
      messageCompiler,
      onWarn,
      __datetimeFormatters,
      __numberFormatters,
      __meta
    };
    {
      context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : void 0;
    }
    {
      initI18nDevTools(context, version2, __meta);
    }
    return context;
  }
  function isTranslateFallbackWarn(fallback, key) {
    return fallback instanceof RegExp ? fallback.test(key) : fallback;
  }
  function isTranslateMissingWarn(missing, key) {
    return missing instanceof RegExp ? missing.test(key) : missing;
  }
  function handleMissing(context, key, locale, missingWarn, type) {
    const { missing, onWarn } = context;
    {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("missing", {
          locale,
          key,
          type,
          groupId: `${type}:${key}`
        });
      }
    }
    if (missing !== null) {
      const ret = missing(context, locale, key, type);
      return isString(ret) ? ret : key;
    } else {
      if (isTranslateMissingWarn(missingWarn, key)) {
        onWarn(getWarnMessage$1(0, { key, locale }));
      }
      return key;
    }
  }
  function getLocaleChain(ctx, fallback, start2) {
    const context = ctx;
    if (!context.__localeChainCache) {
      context.__localeChainCache = /* @__PURE__ */ new Map();
    }
    let chain = context.__localeChainCache.get(start2);
    if (!chain) {
      chain = [];
      let block = [start2];
      while (isArray(block)) {
        block = appendBlockToChain(chain, block, fallback);
      }
      const defaults = isArray(fallback) ? fallback : isPlainObject$1(fallback) ? fallback["default"] ? fallback["default"] : null : fallback;
      block = isString(defaults) ? [defaults] : defaults;
      if (isArray(block)) {
        appendBlockToChain(chain, block, false);
      }
      context.__localeChainCache.set(start2, chain);
    }
    return chain;
  }
  function appendBlockToChain(chain, block, blocks) {
    let follow = true;
    for (let i2 = 0; i2 < block.length && isBoolean(follow); i2++) {
      const locale = block[i2];
      if (isString(locale)) {
        follow = appendLocaleToChain(chain, block[i2], blocks);
      }
    }
    return follow;
  }
  function appendLocaleToChain(chain, locale, blocks) {
    let follow;
    const tokens = locale.split("-");
    do {
      const target = tokens.join("-");
      follow = appendItemToChain(chain, target, blocks);
      tokens.splice(-1, 1);
    } while (tokens.length && follow === true);
    return follow;
  }
  function appendItemToChain(chain, target, blocks) {
    let follow = false;
    if (!chain.includes(target)) {
      follow = true;
      if (target) {
        follow = target[target.length - 1] !== "!";
        const locale = target.replace(/!/g, "");
        chain.push(locale);
        if ((isArray(blocks) || isPlainObject$1(blocks)) && blocks[locale]) {
          follow = blocks[locale];
        }
      }
    }
    return follow;
  }
  function updateFallbackLocale(ctx, locale, fallback) {
    const context = ctx;
    context.__localeChainCache = /* @__PURE__ */ new Map();
    getLocaleChain(ctx, fallback, locale);
  }
  function createCoreError(code2) {
    return createCompileError(code2, null, { messages: errorMessages$1 });
  }
  const errorMessages$1 = {
    [
      14
      /* INVALID_ARGUMENT */
    ]: "Invalid arguments",
    [
      15
      /* INVALID_DATE_ARGUMENT */
    ]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
    [
      16
      /* INVALID_ISO_DATE_ARGUMENT */
    ]: "The argument provided is not a valid ISO date string"
  };
  const NOOP_MESSAGE_FUNCTION = () => "";
  const isMessageFunction = (val) => isFunction$1(val);
  function translate(context, ...args) {
    const { fallbackFormat, postTranslation, unresolving, fallbackLocale, messages: messages2 } = context;
    const [key, options] = parseTranslateArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
    const resolvedMessage = !!options.resolvedMessage;
    const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : key : fallbackFormat ? key : "";
    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
    const locale = isString(options.locale) ? options.locale : context.locale;
    escapeParameter && escapeParams(options);
    let [format2, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
      key,
      locale,
      messages2[locale] || {}
    ];
    let cacheBaseKey = key;
    if (!resolvedMessage && !(isString(format2) || isMessageFunction(format2))) {
      if (enableDefaultMsg) {
        format2 = defaultMsgOrKey;
        cacheBaseKey = format2;
      }
    }
    if (!resolvedMessage && (!(isString(format2) || isMessageFunction(format2)) || !isString(targetLocale))) {
      return unresolving ? NOT_REOSLVED : key;
    }
    if (isString(format2) && context.messageCompiler == null) {
      warn(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${key}'.`);
      return key;
    }
    let occurred = false;
    const errorDetector = () => {
      occurred = true;
    };
    const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, errorDetector) : format2;
    if (occurred) {
      return format2;
    }
    const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
    const msgContext = createMessageContext(ctxOptions);
    const messaged = evaluateMessage(context, msg, msgContext);
    const ret = postTranslation ? postTranslation(messaged) : messaged;
    {
      const payloads = {
        timestamp: Date.now(),
        key: isString(key) ? key : isMessageFunction(format2) ? format2.key : "",
        locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
        format: isString(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
        message: ret
      };
      payloads.meta = assign$2({}, context.__meta, getAdditionalMeta() || {});
      translateDevTools(payloads);
    }
    return ret;
  }
  function escapeParams(options) {
    if (isArray(options.list)) {
      options.list = options.list.map((item) => isString(item) ? escapeHtml(item) : item);
    } else if (isObject$3(options.named)) {
      Object.keys(options.named).forEach((key) => {
        if (isString(options.named[key])) {
          options.named[key] = escapeHtml(options.named[key]);
        }
      });
    }
  }
  function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
    const { messages: messages2, onWarn } = context;
    const locales = getLocaleChain(context, fallbackLocale, locale);
    let message = {};
    let targetLocale;
    let format2 = null;
    let from = locale;
    let to = null;
    const type = "translate";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = to = locales[i2];
      if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
        onWarn(getWarnMessage$1(1, {
          key,
          target: targetLocale
        }));
      }
      if (locale !== targetLocale) {
        const emitter = context.__v_emitter;
        if (emitter) {
          emitter.emit("fallback", {
            type,
            key,
            from,
            to,
            groupId: `${type}:${key}`
          });
        }
      }
      message = messages2[targetLocale] || {};
      let start2 = null;
      let startTag;
      let endTag;
      if (inBrowser$2) {
        start2 = window.performance.now();
        startTag = "intlify-message-resolve-start";
        endTag = "intlify-message-resolve-end";
        mark && mark(startTag);
      }
      if ((format2 = resolveValue(message, key)) === null) {
        format2 = message[key];
      }
      if (inBrowser$2) {
        const end2 = window.performance.now();
        const emitter = context.__v_emitter;
        if (emitter && start2 && format2) {
          emitter.emit("message-resolve", {
            type: "message-resolve",
            key,
            message: format2,
            time: end2 - start2,
            groupId: `${type}:${key}`
          });
        }
        if (startTag && endTag && mark && measure) {
          mark(endTag);
          measure("intlify message resolve", startTag, endTag);
        }
      }
      if (isString(format2) || isFunction$1(format2))
        break;
      const missingRet = handleMissing(context, key, targetLocale, missingWarn, type);
      if (missingRet !== key) {
        format2 = missingRet;
      }
      from = to;
    }
    return [format2, targetLocale, message];
  }
  function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, errorDetector) {
    const { messageCompiler, warnHtmlMessage } = context;
    if (isMessageFunction(format2)) {
      const msg2 = format2;
      msg2.locale = msg2.locale || targetLocale;
      msg2.key = msg2.key || key;
      return msg2;
    }
    let start2 = null;
    let startTag;
    let endTag;
    if (inBrowser$2) {
      start2 = window.performance.now();
      startTag = "intlify-message-compilation-start";
      endTag = "intlify-message-compilation-end";
      mark && mark(startTag);
    }
    const msg = messageCompiler(format2, getCompileOptions(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, errorDetector));
    if (inBrowser$2) {
      const end2 = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start2) {
        emitter.emit("message-compilation", {
          type: "message-compilation",
          message: format2,
          time: end2 - start2,
          groupId: `${"translate"}:${key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message compilation", startTag, endTag);
      }
    }
    msg.locale = targetLocale;
    msg.key = key;
    msg.source = format2;
    return msg;
  }
  function evaluateMessage(context, msg, msgCtx) {
    let start2 = null;
    let startTag;
    let endTag;
    if (inBrowser$2) {
      start2 = window.performance.now();
      startTag = "intlify-message-evaluation-start";
      endTag = "intlify-message-evaluation-end";
      mark && mark(startTag);
    }
    const messaged = msg(msgCtx);
    if (inBrowser$2) {
      const end2 = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start2) {
        emitter.emit("message-evaluation", {
          type: "message-evaluation",
          value: messaged,
          time: end2 - start2,
          groupId: `${"translate"}:${msg.key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message evaluation", startTag, endTag);
      }
    }
    return messaged;
  }
  function parseTranslateArgs(...args) {
    const [arg1, arg2, arg3] = args;
    const options = {};
    if (!isString(arg1) && !isNumber(arg1) && !isMessageFunction(arg1)) {
      throw createCoreError(
        14
        /* INVALID_ARGUMENT */
      );
    }
    const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
    if (isNumber(arg2)) {
      options.plural = arg2;
    } else if (isString(arg2)) {
      options.default = arg2;
    } else if (isPlainObject$1(arg2) && !isEmptyObject(arg2)) {
      options.named = arg2;
    } else if (isArray(arg2)) {
      options.list = arg2;
    }
    if (isNumber(arg3)) {
      options.plural = arg3;
    } else if (isString(arg3)) {
      options.default = arg3;
    } else if (isPlainObject$1(arg3)) {
      assign$2(options, arg3);
    }
    return [key, options];
  }
  function getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {
    return {
      warnHtmlMessage,
      onError: (err) => {
        errorDetector && errorDetector(err);
        {
          const message = `Message compilation error: ${err.message}`;
          const codeFrame = err.location && generateCodeFrame(source, err.location.start.offset, err.location.end.offset);
          const emitter = context.__v_emitter;
          if (emitter) {
            emitter.emit("compile-error", {
              message: source,
              error: err.message,
              start: err.location && err.location.start.offset,
              end: err.location && err.location.end.offset,
              groupId: `${"translate"}:${key}`
            });
          }
          console.error(codeFrame ? `${message}
${codeFrame}` : message);
        }
      },
      onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
    };
  }
  function getMessageContextOptions(context, locale, message, options) {
    const { modifiers, pluralRules } = context;
    const resolveMessage = (key) => {
      const val = resolveValue(message, key);
      if (isString(val)) {
        let occurred = false;
        const errorDetector = () => {
          occurred = true;
        };
        const msg = compileMessageFormat(context, key, locale, val, key, errorDetector);
        return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
      } else if (isMessageFunction(val)) {
        return val;
      } else {
        return NOOP_MESSAGE_FUNCTION;
      }
    };
    const ctxOptions = {
      locale,
      modifiers,
      pluralRules,
      messages: resolveMessage
    };
    if (context.processor) {
      ctxOptions.processor = context.processor;
    }
    if (options.list) {
      ctxOptions.list = options.list;
    }
    if (options.named) {
      ctxOptions.named = options.named;
    }
    if (isNumber(options.plural)) {
      ctxOptions.pluralIndex = options.plural;
    }
    return ctxOptions;
  }
  const intlDefined = typeof Intl !== "undefined";
  const Availabilities = {
    dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== "undefined",
    numberFormat: intlDefined && typeof Intl.NumberFormat !== "undefined"
  };
  function datetime(context, ...args) {
    const { datetimeFormats, unresolving, fallbackLocale, onWarn } = context;
    const { __datetimeFormatters } = context;
    if (!Availabilities.dateTimeFormat) {
      onWarn(getWarnMessage$1(
        4
        /* CANNOT_FORMAT_DATE */
      ));
      return MISSING_RESOLVE_VALUE;
    }
    const [key, value, options, overrides] = parseDateTimeArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale = isString(options.locale) ? options.locale : context.locale;
    const locales = getLocaleChain(context, fallbackLocale, locale);
    if (!isString(key) || key === "") {
      return new Intl.DateTimeFormat(locale).format(value);
    }
    let datetimeFormat = {};
    let targetLocale;
    let format2 = null;
    let from = locale;
    let to = null;
    const type = "datetime format";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = to = locales[i2];
      if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
        onWarn(getWarnMessage$1(5, {
          key,
          target: targetLocale
        }));
      }
      if (locale !== targetLocale) {
        const emitter = context.__v_emitter;
        if (emitter) {
          emitter.emit("fallback", {
            type,
            key,
            from,
            to,
            groupId: `${type}:${key}`
          });
        }
      }
      datetimeFormat = datetimeFormats[targetLocale] || {};
      format2 = datetimeFormat[key];
      if (isPlainObject$1(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
      from = to;
    }
    if (!isPlainObject$1(format2) || !isString(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __datetimeFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.DateTimeFormat(targetLocale, assign$2({}, format2, overrides));
      __datetimeFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  function parseDateTimeArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    let options = {};
    let overrides = {};
    let value;
    if (isString(arg1)) {
      if (!/\d{4}-\d{2}-\d{2}(T.*)?/.test(arg1)) {
        throw createCoreError(
          16
          /* INVALID_ISO_DATE_ARGUMENT */
        );
      }
      value = new Date(arg1);
      try {
        value.toISOString();
      } catch (e2) {
        throw createCoreError(
          16
          /* INVALID_ISO_DATE_ARGUMENT */
        );
      }
    } else if (isDate$1(arg1)) {
      if (isNaN(arg1.getTime())) {
        throw createCoreError(
          15
          /* INVALID_DATE_ARGUMENT */
        );
      }
      value = arg1;
    } else if (isNumber(arg1)) {
      value = arg1;
    } else {
      throw createCoreError(
        14
        /* INVALID_ARGUMENT */
      );
    }
    if (isString(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$1(arg2)) {
      options = arg2;
    }
    if (isString(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$1(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$1(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearDateTimeFormat(ctx, locale, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale}__${key}`;
      if (!context.__datetimeFormatters.has(id)) {
        continue;
      }
      context.__datetimeFormatters.delete(id);
    }
  }
  function number$1(context, ...args) {
    const { numberFormats, unresolving, fallbackLocale, onWarn } = context;
    const { __numberFormatters } = context;
    if (!Availabilities.numberFormat) {
      onWarn(getWarnMessage$1(
        2
        /* CANNOT_FORMAT_NUMBER */
      ));
      return MISSING_RESOLVE_VALUE;
    }
    const [key, value, options, overrides] = parseNumberArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale = isString(options.locale) ? options.locale : context.locale;
    const locales = getLocaleChain(context, fallbackLocale, locale);
    if (!isString(key) || key === "") {
      return new Intl.NumberFormat(locale).format(value);
    }
    let numberFormat = {};
    let targetLocale;
    let format2 = null;
    let from = locale;
    let to = null;
    const type = "number format";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = to = locales[i2];
      if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
        onWarn(getWarnMessage$1(3, {
          key,
          target: targetLocale
        }));
      }
      if (locale !== targetLocale) {
        const emitter = context.__v_emitter;
        if (emitter) {
          emitter.emit("fallback", {
            type,
            key,
            from,
            to,
            groupId: `${type}:${key}`
          });
        }
      }
      numberFormat = numberFormats[targetLocale] || {};
      format2 = numberFormat[key];
      if (isPlainObject$1(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
      from = to;
    }
    if (!isPlainObject$1(format2) || !isString(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __numberFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.NumberFormat(targetLocale, assign$2({}, format2, overrides));
      __numberFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  function parseNumberArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    let options = {};
    let overrides = {};
    if (!isNumber(arg1)) {
      throw createCoreError(
        14
        /* INVALID_ARGUMENT */
      );
    }
    const value = arg1;
    if (isString(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$1(arg2)) {
      options = arg2;
    }
    if (isString(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$1(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$1(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearNumberFormat(ctx, locale, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale}__${key}`;
      if (!context.__numberFormatters.has(id)) {
        continue;
      }
      context.__numberFormatters.delete(id);
    }
  }
  function getDevtoolsGlobalHook$1() {
    return getTarget$1().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget$1() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  }
  const isProxyAvailable$1 = typeof Proxy === "function";
  const HOOK_SETUP$1 = "devtools-plugin:setup";
  const HOOK_PLUGIN_SETTINGS_SET$1 = "plugin:settings:set";
  let ApiProxy$1 = class ApiProxy {
    constructor(plugin, hook) {
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      const defaultSettings = {};
      if (plugin.settings) {
        for (const id in plugin.settings) {
          const item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
      let currentSettings = { ...defaultSettings };
      try {
        const raw = localStorage.getItem(localSettingsSaveId);
        const data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e2) {
      }
      this.fallbacks = {
        getSettings() {
          return currentSettings;
        },
        setSettings(value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e2) {
          }
          currentSettings = value;
        }
      };
      hook.on(HOOK_PLUGIN_SETTINGS_SET$1, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
      this.proxiedOn = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target.on[prop];
          } else {
            return (...args) => {
              this.onQueue.push({
                method: prop,
                args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target[prop];
          } else if (prop === "on") {
            return this.proxiedOn;
          } else if (Object.keys(this.fallbacks).includes(prop)) {
            return (...args) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: () => {
                }
              });
              return this.fallbacks[prop](...args);
            };
          } else {
            return (...args) => {
              return new Promise((resolve) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve
                });
              });
            };
          }
        }
      });
    }
    async setRealTarget(target) {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(await this.target[item.method](...item.args));
      }
    }
  };
  function setupDevtoolsPlugin$1(pluginDescriptor, setupFn) {
    const target = getTarget$1();
    const hook = getDevtoolsGlobalHook$1();
    const enableProxy = isProxyAvailable$1 && pluginDescriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP$1, pluginDescriptor, setupFn);
    } else {
      const proxy = enableProxy ? new ApiProxy$1(pluginDescriptor, hook) : null;
      const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor,
        setupFn,
        proxy
      });
      if (proxy)
        setupFn(proxy.proxiedTarget);
    }
  }
  /*!
    * @intlify/vue-devtools v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const VueDevToolsLabels = {
    [
      "vue-devtools-plugin-vue-i18n"
      /* PLUGIN */
    ]: "Vue I18n devtools",
    [
      "vue-i18n-resource-inspector"
      /* CUSTOM_INSPECTOR */
    ]: "I18n Resources",
    [
      "vue-i18n-timeline"
      /* TIMELINE */
    ]: "Vue I18n"
  };
  const VueDevToolsPlaceholders = {
    [
      "vue-i18n-resource-inspector"
      /* CUSTOM_INSPECTOR */
    ]: "Search for scopes ..."
  };
  const VueDevToolsTimelineColors = {
    [
      "vue-i18n-timeline"
      /* TIMELINE */
    ]: 16764185
  };
  /*!
    * vue-i18n v9.1.9
    * (c) 2022 kazuya kawaguchi
    * Released under the MIT License.
    */
  const VERSION = "9.1.9";
  function initFeatureFlags() {
    let needWarn = false;
    {
      needWarn = true;
    }
    if (needWarn) {
      console.warn(`You are running the esm-bundler build of vue-i18n. It is recommended to configure your bundler to explicitly replace feature flag globals with boolean literals to get proper tree-shaking in the final bundle.`);
    }
  }
  const warnMessages = {
    [
      6
      /* FALLBACK_TO_ROOT */
    ]: `Fall back to {type} '{key}' with root locale.`,
    [
      7
      /* NOT_SUPPORTED_PRESERVE */
    ]: `Not supported 'preserve'.`,
    [
      8
      /* NOT_SUPPORTED_FORMATTER */
    ]: `Not supported 'formatter'.`,
    [
      9
      /* NOT_SUPPORTED_PRESERVE_DIRECTIVE */
    ]: `Not supported 'preserveDirectiveContent'.`,
    [
      10
      /* NOT_SUPPORTED_GET_CHOICE_INDEX */
    ]: `Not supported 'getChoiceIndex'.`,
    [
      11
      /* COMPONENT_NAME_LEGACY_COMPATIBLE */
    ]: `Component name legacy compatible: '{name}' -> 'i18n'`,
    [
      12
      /* NOT_FOUND_PARENT_SCOPE */
    ]: `Not found parent scope. use the global scope.`
  };
  function getWarnMessage(code2, ...args) {
    return format$2(warnMessages[code2], ...args);
  }
  function createI18nError(code2, ...args) {
    return createCompileError(code2, null, { messages: errorMessages, args });
  }
  const errorMessages = {
    [
      14
      /* UNEXPECTED_RETURN_TYPE */
    ]: "Unexpected return type in composer",
    [
      15
      /* INVALID_ARGUMENT */
    ]: "Invalid argument",
    [
      16
      /* MUST_BE_CALL_SETUP_TOP */
    ]: "Must be called at the top of a `setup` function",
    [
      17
      /* NOT_INSLALLED */
    ]: "Need to install with `app.use` function",
    [
      22
      /* UNEXPECTED_ERROR */
    ]: "Unexpected error",
    [
      18
      /* NOT_AVAILABLE_IN_LEGACY_MODE */
    ]: "Not available in legacy mode",
    [
      19
      /* REQUIRED_VALUE */
    ]: `Required in value: {0}`,
    [
      20
      /* INVALID_VALUE */
    ]: `Invalid value`,
    [
      21
      /* CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN */
    ]: `Cannot setup vue-devtools plugin`
  };
  const DEVTOOLS_META = "__INTLIFY_META__";
  const TransrateVNodeSymbol = makeSymbol("__transrateVNode");
  const DatetimePartsSymbol = makeSymbol("__datetimeParts");
  const NumberPartsSymbol = makeSymbol("__numberParts");
  const EnableEmitter = makeSymbol("__enableEmitter");
  const DisableEmitter = makeSymbol("__disableEmitter");
  const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
  const InejctWithOption = makeSymbol("__injectWithOption");
  let composerID = 0;
  function defineCoreMissingHandler(missing) {
    return (ctx, locale, key, type) => {
      return missing(locale, key, vue.getCurrentInstance() || void 0, type);
    };
  }
  function getLocaleMessages(locale, options) {
    const { messages: messages2, __i18n } = options;
    const ret = isPlainObject$1(messages2) ? messages2 : isArray(__i18n) ? {} : { [locale]: {} };
    if (isArray(__i18n)) {
      __i18n.forEach(({ locale: locale2, resource }) => {
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy$1(resource, ret[locale2]);
        } else {
          deepCopy$1(resource, ret);
        }
      });
    }
    if (options.flatJson) {
      for (const key in ret) {
        if (hasOwn$2(ret, key)) {
          handleFlatJson(ret[key]);
        }
      }
    }
    return ret;
  }
  const isNotObjectOrIsArray = (val) => !isObject$3(val) || isArray(val);
  function deepCopy$1(src, des) {
    if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
      throw createI18nError(
        20
        /* INVALID_VALUE */
      );
    }
    for (const key in src) {
      if (hasOwn$2(src, key)) {
        if (isNotObjectOrIsArray(src[key]) || isNotObjectOrIsArray(des[key])) {
          des[key] = src[key];
        } else {
          deepCopy$1(src[key], des[key]);
        }
      }
    }
  }
  const getMetaInfo = () => {
    const instance2 = vue.getCurrentInstance();
    return instance2 && instance2.type[DEVTOOLS_META] ? { [DEVTOOLS_META]: instance2.type[DEVTOOLS_META] } : null;
  };
  function createComposer(options = {}) {
    const { __root } = options;
    const _isGlobal = __root === void 0;
    let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
    const _locale = vue.ref(
      // prettier-ignore
      __root && _inheritLocale ? __root.locale.value : isString(options.locale) ? options.locale : "en-US"
    );
    const _fallbackLocale = vue.ref(
      // prettier-ignore
      __root && _inheritLocale ? __root.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
    );
    const _messages = vue.ref(getLocaleMessages(_locale.value, options));
    const _datetimeFormats = vue.ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = vue.ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
    let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    let _fallbackFormat = !!options.fallbackFormat;
    let _missing = isFunction$1(options.missing) ? options.missing : null;
    let _runtimeMissing = isFunction$1(options.missing) ? defineCoreMissingHandler(options.missing) : null;
    let _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    let _warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    let _escapeParameter = !!options.escapeParameter;
    const _modifiers = __root ? __root.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
    let _pluralRules = options.pluralRules || __root && __root.pluralRules;
    let _context;
    function getCoreContext() {
      return createCoreContext({
        version: VERSION,
        locale: _locale.value,
        fallbackLocale: _fallbackLocale.value,
        messages: _messages.value,
        messageCompiler: function compileToFunction(source) {
          return (ctx) => {
            return ctx.normalize([source]);
          };
        },
        datetimeFormats: _datetimeFormats.value,
        numberFormats: _numberFormats.value,
        modifiers: _modifiers,
        pluralRules: _pluralRules,
        missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
        missingWarn: _missingWarn,
        fallbackWarn: _fallbackWarn,
        fallbackFormat: _fallbackFormat,
        unresolving: true,
        postTranslation: _postTranslation === null ? void 0 : _postTranslation,
        warnHtmlMessage: _warnHtmlMessage,
        escapeParameter: _escapeParameter,
        __datetimeFormatters: isPlainObject$1(_context) ? _context.__datetimeFormatters : void 0,
        __numberFormatters: isPlainObject$1(_context) ? _context.__numberFormatters : void 0,
        __v_emitter: isPlainObject$1(_context) ? _context.__v_emitter : void 0,
        __meta: { framework: "vue" }
      });
    }
    _context = getCoreContext();
    updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
    function trackReactivityValues() {
      return [
        _locale.value,
        _fallbackLocale.value,
        _messages.value,
        _datetimeFormats.value,
        _numberFormats.value
      ];
    }
    const locale = vue.computed({
      get: () => _locale.value,
      set: (val) => {
        _locale.value = val;
        _context.locale = _locale.value;
      }
    });
    const fallbackLocale = vue.computed({
      get: () => _fallbackLocale.value,
      set: (val) => {
        _fallbackLocale.value = val;
        _context.fallbackLocale = _fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, val);
      }
    });
    const messages2 = vue.computed(() => _messages.value);
    const datetimeFormats = vue.computed(() => _datetimeFormats.value);
    const numberFormats = vue.computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
      return isFunction$1(_postTranslation) ? _postTranslation : null;
    }
    function setPostTranslationHandler(handler) {
      _postTranslation = handler;
      _context.postTranslation = handler;
    }
    function getMissingHandler() {
      return _missing;
    }
    function setMissingHandler(handler) {
      if (handler !== null) {
        _runtimeMissing = defineCoreMissingHandler(handler);
      }
      _missing = handler;
      _context.missing = _runtimeMissing;
    }
    function isResolvedTranslateMessage(type, arg) {
      return type !== "translate" || !!arg.resolvedMessage === false;
    }
    function wrapWithDeps(fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) {
      trackReactivityValues();
      let ret;
      {
        try {
          setAdditionalMeta(getMetaInfo());
          ret = fn(_context);
        } finally {
          setAdditionalMeta(null);
        }
      }
      if (isNumber(ret) && ret === NOT_REOSLVED) {
        const [key, arg2] = argumentParser();
        if (__root && isString(key) && isResolvedTranslateMessage(warnType, arg2)) {
          if (_fallbackRoot && (isTranslateFallbackWarn(_fallbackWarn, key) || isTranslateMissingWarn(_missingWarn, key))) {
            warn(getWarnMessage(6, {
              key,
              type: warnType
            }));
          }
          {
            const { __v_emitter: emitter } = _context;
            if (emitter && _fallbackRoot) {
              emitter.emit("fallback", {
                type: warnType,
                key,
                to: "global",
                groupId: `${warnType}:${key}`
              });
            }
          }
        }
        return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
      } else if (successCondition(ret)) {
        return ret;
      } else {
        throw createI18nError(
          14
          /* UNEXPECTED_RETURN_TYPE */
        );
      }
    }
    function t2(...args) {
      return wrapWithDeps((context) => translate(context, ...args), () => parseTranslateArgs(...args), "translate", (root) => root.t(...args), (key) => key, (val) => isString(val));
    }
    function rt(...args) {
      const [arg1, arg2, arg3] = args;
      if (arg3 && !isObject$3(arg3)) {
        throw createI18nError(
          15
          /* INVALID_ARGUMENT */
        );
      }
      return t2(...[arg1, arg2, assign$2({ resolvedMessage: true }, arg3 || {})]);
    }
    function d2(...args) {
      return wrapWithDeps((context) => datetime(context, ...args), () => parseDateTimeArgs(...args), "datetime format", (root) => root.d(...args), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
    }
    function n2(...args) {
      return wrapWithDeps((context) => number$1(context, ...args), () => parseNumberArgs(...args), "number format", (root) => root.n(...args), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
    }
    function normalize(values) {
      return values.map((val) => isString(val) ? vue.createVNode(vue.Text, null, val, 0) : val);
    }
    const interpolate = (val) => val;
    const processor = {
      normalize,
      interpolate,
      type: "vnode"
    };
    function transrateVNode(...args) {
      return wrapWithDeps(
        (context) => {
          let ret;
          const _context2 = context;
          try {
            _context2.processor = processor;
            ret = translate(_context2, ...args);
          } finally {
            _context2.processor = null;
          }
          return ret;
        },
        () => parseTranslateArgs(...args),
        "translate",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (root) => root[TransrateVNodeSymbol](...args),
        (key) => [vue.createVNode(vue.Text, null, key, 0)],
        (val) => isArray(val)
      );
    }
    function numberParts(...args) {
      return wrapWithDeps(
        (context) => number$1(context, ...args),
        () => parseNumberArgs(...args),
        "number format",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (root) => root[NumberPartsSymbol](...args),
        () => [],
        (val) => isString(val) || isArray(val)
      );
    }
    function datetimeParts(...args) {
      return wrapWithDeps(
        (context) => datetime(context, ...args),
        () => parseDateTimeArgs(...args),
        "datetime format",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (root) => root[DatetimePartsSymbol](...args),
        () => [],
        (val) => isString(val) || isArray(val)
      );
    }
    function setPluralRules(rules) {
      _pluralRules = rules;
      _context.pluralRules = _pluralRules;
    }
    function te(key, locale2) {
      const targetLocale = isString(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      return resolveValue(message, key) !== null;
    }
    function resolveMessages(key) {
      let messages22 = null;
      const locales = getLocaleChain(_context, _fallbackLocale.value, _locale.value);
      for (let i2 = 0; i2 < locales.length; i2++) {
        const targetLocaleMessages = _messages.value[locales[i2]] || {};
        const messageValue = resolveValue(targetLocaleMessages, key);
        if (messageValue != null) {
          messages22 = messageValue;
          break;
        }
      }
      return messages22;
    }
    function tm(key) {
      const messages22 = resolveMessages(key);
      return messages22 != null ? messages22 : __root ? __root.tm(key) || {} : {};
    }
    function getLocaleMessage(locale2) {
      return _messages.value[locale2] || {};
    }
    function setLocaleMessage(locale2, message) {
      _messages.value[locale2] = message;
      _context.messages = _messages.value;
    }
    function mergeLocaleMessage(locale2, message) {
      _messages.value[locale2] = _messages.value[locale2] || {};
      deepCopy$1(message, _messages.value[locale2]);
      _context.messages = _messages.value;
    }
    function getDateTimeFormat(locale2) {
      return _datetimeFormats.value[locale2] || {};
    }
    function setDateTimeFormat(locale2, format2) {
      _datetimeFormats.value[locale2] = format2;
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale2, format2);
    }
    function mergeDateTimeFormat(locale2, format2) {
      _datetimeFormats.value[locale2] = assign$2(_datetimeFormats.value[locale2] || {}, format2);
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale2, format2);
    }
    function getNumberFormat(locale2) {
      return _numberFormats.value[locale2] || {};
    }
    function setNumberFormat(locale2, format2) {
      _numberFormats.value[locale2] = format2;
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale2, format2);
    }
    function mergeNumberFormat(locale2, format2) {
      _numberFormats.value[locale2] = assign$2(_numberFormats.value[locale2] || {}, format2);
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale2, format2);
    }
    composerID++;
    if (__root) {
      vue.watch(__root.locale, (val) => {
        if (_inheritLocale) {
          _locale.value = val;
          _context.locale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
      vue.watch(__root.fallbackLocale, (val) => {
        if (_inheritLocale) {
          _fallbackLocale.value = val;
          _context.fallbackLocale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
    }
    const composer = {
      id: composerID,
      locale,
      fallbackLocale,
      get inheritLocale() {
        return _inheritLocale;
      },
      set inheritLocale(val) {
        _inheritLocale = val;
        if (val && __root) {
          _locale.value = __root.locale.value;
          _fallbackLocale.value = __root.fallbackLocale.value;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      },
      get availableLocales() {
        return Object.keys(_messages.value).sort();
      },
      messages: messages2,
      datetimeFormats,
      numberFormats,
      get modifiers() {
        return _modifiers;
      },
      get pluralRules() {
        return _pluralRules || {};
      },
      get isGlobal() {
        return _isGlobal;
      },
      get missingWarn() {
        return _missingWarn;
      },
      set missingWarn(val) {
        _missingWarn = val;
        _context.missingWarn = _missingWarn;
      },
      get fallbackWarn() {
        return _fallbackWarn;
      },
      set fallbackWarn(val) {
        _fallbackWarn = val;
        _context.fallbackWarn = _fallbackWarn;
      },
      get fallbackRoot() {
        return _fallbackRoot;
      },
      set fallbackRoot(val) {
        _fallbackRoot = val;
      },
      get fallbackFormat() {
        return _fallbackFormat;
      },
      set fallbackFormat(val) {
        _fallbackFormat = val;
        _context.fallbackFormat = _fallbackFormat;
      },
      get warnHtmlMessage() {
        return _warnHtmlMessage;
      },
      set warnHtmlMessage(val) {
        _warnHtmlMessage = val;
        _context.warnHtmlMessage = val;
      },
      get escapeParameter() {
        return _escapeParameter;
      },
      set escapeParameter(val) {
        _escapeParameter = val;
        _context.escapeParameter = val;
      },
      t: t2,
      rt,
      d: d2,
      n: n2,
      te,
      tm,
      getLocaleMessage,
      setLocaleMessage,
      mergeLocaleMessage,
      getDateTimeFormat,
      setDateTimeFormat,
      mergeDateTimeFormat,
      getNumberFormat,
      setNumberFormat,
      mergeNumberFormat,
      getPostTranslationHandler,
      setPostTranslationHandler,
      getMissingHandler,
      setMissingHandler,
      [TransrateVNodeSymbol]: transrateVNode,
      [NumberPartsSymbol]: numberParts,
      [DatetimePartsSymbol]: datetimeParts,
      [SetPluralRulesSymbol]: setPluralRules,
      [InejctWithOption]: options.__injectWithOption
      // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    {
      composer[EnableEmitter] = (emitter) => {
        _context.__v_emitter = emitter;
      };
      composer[DisableEmitter] = () => {
        _context.__v_emitter = void 0;
      };
    }
    return composer;
  }
  function convertComposerOptions(options) {
    const locale = isString(options.locale) ? options.locale : "en-US";
    const fallbackLocale = isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
    const missing = isFunction$1(options.missing) ? options.missing : void 0;
    const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
    const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
    const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    const fallbackFormat = !!options.formatFallbackMessages;
    const modifiers = isPlainObject$1(options.modifiers) ? options.modifiers : {};
    const pluralizationRules = options.pluralizationRules;
    const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : void 0;
    const warnHtmlMessage = isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
    const escapeParameter = !!options.escapeParameterHtml;
    const inheritLocale = isBoolean(options.sync) ? options.sync : true;
    if (options.formatter) {
      warn(getWarnMessage(
        8
        /* NOT_SUPPORTED_FORMATTER */
      ));
    }
    if (options.preserveDirectiveContent) {
      warn(getWarnMessage(
        9
        /* NOT_SUPPORTED_PRESERVE_DIRECTIVE */
      ));
    }
    let messages2 = options.messages;
    if (isPlainObject$1(options.sharedMessages)) {
      const sharedMessages = options.sharedMessages;
      const locales = Object.keys(sharedMessages);
      messages2 = locales.reduce((messages22, locale2) => {
        const message = messages22[locale2] || (messages22[locale2] = {});
        assign$2(message, sharedMessages[locale2]);
        return messages22;
      }, messages2 || {});
    }
    const { __i18n, __root, __injectWithOption } = options;
    const datetimeFormats = options.datetimeFormats;
    const numberFormats = options.numberFormats;
    const flatJson = options.flatJson;
    return {
      locale,
      fallbackLocale,
      messages: messages2,
      flatJson,
      datetimeFormats,
      numberFormats,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackRoot,
      fallbackFormat,
      modifiers,
      pluralRules: pluralizationRules,
      postTranslation,
      warnHtmlMessage,
      escapeParameter,
      inheritLocale,
      __i18n,
      __root,
      __injectWithOption
    };
  }
  function createVueI18n(options = {}) {
    const composer = createComposer(convertComposerOptions(options));
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        warn(getWarnMessage(
          8
          /* NOT_SUPPORTED_FORMATTER */
        ));
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
        warn(getWarnMessage(
          8
          /* NOT_SUPPORTED_FORMATTER */
        ));
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        warn(getWarnMessage(
          9
          /* NOT_SUPPORTED_PRESERVE_DIRECTIVE */
        ));
        return true;
      },
      set preserveDirectiveContent(val) {
        warn(getWarnMessage(
          9
          /* NOT_SUPPORTED_PRESERVE_DIRECTIVE */
        ));
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(
            15
            /* INVALID_ARGUMENT */
          );
        }
        const key = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return composer.t(key, list || named || {}, options2);
      },
      rt(...args) {
        return composer.rt(...args);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(
            15
            /* INVALID_ARGUMENT */
          );
        }
        const key = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isNumber(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isString(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return composer.t(key, list || named || {}, options2);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return composer.d(...args);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      // n
      n(...args) {
        return composer.n(...args);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        warn(getWarnMessage(
          10
          /* NOT_SUPPORTED_GET_CHOICE_INDEX */
        ));
        return -1;
      },
      // for internal
      __onComponentInstanceCreated(target) {
        const { componentInstanceCreatedListener } = options;
        if (componentInstanceCreatedListener) {
          componentInstanceCreatedListener(target, vueI18n);
        }
      }
    };
    {
      vueI18n.__enableEmitter = (emitter) => {
        const __composer = composer;
        __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
      };
      vueI18n.__disableEmitter = () => {
        const __composer = composer;
        __composer[DisableEmitter] && __composer[DisableEmitter]();
      };
    }
    return vueI18n;
  }
  const baseFormatProps = {
    tag: {
      type: [String, Object]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: (val) => val === "parent" || val === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };
  const Translation = {
    /* eslint-disable */
    name: "i18n-t",
    props: assign$2({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [Number, String],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        validator: (val) => isNumber(val) || !isNaN(val)
      }
    }, baseFormatProps),
    /* eslint-enable */
    setup(props2, context) {
      const { slots, attrs } = context;
      const i18n2 = props2.i18n || useI18n({
        useScope: props2.scope,
        __useComponent: true
      });
      const keys = Object.keys(slots).filter((key) => key !== "_");
      return () => {
        const options = {};
        if (props2.locale) {
          options.locale = props2.locale;
        }
        if (props2.plural !== void 0) {
          options.plural = isString(props2.plural) ? +props2.plural : props2.plural;
        }
        const arg = getInterpolateArg(context, keys);
        const children = i18n2[TransrateVNodeSymbol](props2.keypath, arg, options);
        const assignedAttrs = assign$2({}, attrs);
        return isString(props2.tag) ? vue.h(props2.tag, assignedAttrs, children) : isObject$3(props2.tag) ? vue.h(props2.tag, assignedAttrs, children) : vue.h(vue.Fragment, assignedAttrs, children);
      };
    }
  };
  function getInterpolateArg({ slots }, keys) {
    if (keys.length === 1 && keys[0] === "default") {
      return slots.default ? slots.default() : [];
    } else {
      return keys.reduce((arg, key) => {
        const slot = slots[key];
        if (slot) {
          arg[key] = slot();
        }
        return arg;
      }, {});
    }
  }
  function renderFormatter(props2, context, slotKeys, partFormatter) {
    const { slots, attrs } = context;
    return () => {
      const options = { part: true };
      let overrides = {};
      if (props2.locale) {
        options.locale = props2.locale;
      }
      if (isString(props2.format)) {
        options.key = props2.format;
      } else if (isObject$3(props2.format)) {
        if (isString(props2.format.key)) {
          options.key = props2.format.key;
        }
        overrides = Object.keys(props2.format).reduce((options2, prop) => {
          return slotKeys.includes(prop) ? assign$2({}, options2, { [prop]: props2.format[prop] }) : options2;
        }, {});
      }
      const parts = partFormatter(...[props2.value, options, overrides]);
      let children = [options.key];
      if (isArray(parts)) {
        children = parts.map((part, index2) => {
          const slot = slots[part.type];
          return slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
        });
      } else if (isString(parts)) {
        children = [parts];
      }
      const assignedAttrs = assign$2({}, attrs);
      return isString(props2.tag) ? vue.h(props2.tag, assignedAttrs, children) : isObject$3(props2.tag) ? vue.h(props2.tag, assignedAttrs, children) : vue.h(vue.Fragment, assignedAttrs, children);
    };
  }
  const NUMBER_FORMAT_KEYS = [
    "localeMatcher",
    "style",
    "unit",
    "unitDisplay",
    "currency",
    "currencyDisplay",
    "useGrouping",
    "numberingSystem",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "notation",
    "formatMatcher"
  ];
  const NumberFormat = {
    /* eslint-disable */
    name: "i18n-n",
    props: assign$2({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    setup(props2, context) {
      const i18n2 = props2.i18n || useI18n({ useScope: "parent", __useComponent: true });
      return renderFormatter(props2, context, NUMBER_FORMAT_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[NumberPartsSymbol](...args)
      ));
    }
  };
  const DATETIME_FORMAT_KEYS = [
    "dateStyle",
    "timeStyle",
    "fractionalSecondDigits",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "localeMatcher",
    "timeZone",
    "hour12",
    "hourCycle",
    "formatMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName"
  ];
  const DatetimeFormat = {
    /* eslint-disable */
    name: "i18n-d",
    props: assign$2({
      value: {
        type: [Number, Date],
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    setup(props2, context) {
      const i18n2 = props2.i18n || useI18n({ useScope: "parent", __useComponent: true });
      return renderFormatter(props2, context, DATETIME_FORMAT_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[DatetimePartsSymbol](...args)
      ));
    }
  };
  function getComposer$2(i18n2, instance2) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      return i18nInternal.__getInstance(instance2) || i18n2.global;
    } else {
      const vueI18n = i18nInternal.__getInstance(instance2);
      return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
    }
  }
  function vTDirective(i18n2) {
    const bind = (el, { instance: instance2, value, modifiers }) => {
      if (!instance2 || !instance2.$) {
        throw createI18nError(
          22
          /* UNEXPECTED_ERROR */
        );
      }
      const composer = getComposer$2(i18n2, instance2.$);
      if (modifiers.preserve) {
        warn(getWarnMessage(
          7
          /* NOT_SUPPORTED_PRESERVE */
        ));
      }
      const parsedValue = parseValue(value);
      el.textContent = composer.t(...makeParams(parsedValue));
    };
    return {
      beforeMount: bind,
      beforeUpdate: bind
    };
  }
  function parseValue(value) {
    if (isString(value)) {
      return { path: value };
    } else if (isPlainObject$1(value)) {
      if (!("path" in value)) {
        throw createI18nError(19, "path");
      }
      return value;
    } else {
      throw createI18nError(
        20
        /* INVALID_VALUE */
      );
    }
  }
  function makeParams(value) {
    const { path, locale, args, choice, plural } = value;
    const options = {};
    const named = args || {};
    if (isString(locale)) {
      options.locale = locale;
    }
    if (isNumber(choice)) {
      options.plural = choice;
    }
    if (isNumber(plural)) {
      options.plural = plural;
    }
    return [path, named, options];
  }
  function apply(app, i18n2, ...options) {
    const pluginOptions = isPlainObject$1(options[0]) ? options[0] : {};
    const useI18nComponentName = !!pluginOptions.useI18nComponentName;
    const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
    if (globalInstall && useI18nComponentName) {
      warn(getWarnMessage(11, {
        name: Translation.name
      }));
    }
    if (globalInstall) {
      app.component(!useI18nComponentName ? Translation.name : "i18n", Translation);
      app.component(NumberFormat.name, NumberFormat);
      app.component(DatetimeFormat.name, DatetimeFormat);
    }
    app.directive("t", vTDirective(i18n2));
  }
  const VUE_I18N_COMPONENT_TYPES = "vue-i18n: composer properties";
  let devtoolsApi;
  async function enableDevTools(app, i18n2) {
    return new Promise((resolve, reject) => {
      try {
        setupDevtoolsPlugin$1({
          id: "vue-devtools-plugin-vue-i18n",
          label: VueDevToolsLabels[
            "vue-devtools-plugin-vue-i18n"
            /* PLUGIN */
          ],
          packageName: "vue-i18n",
          homepage: "https://vue-i18n.intlify.dev",
          logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
          componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
          app
        }, (api) => {
          devtoolsApi = api;
          api.on.visitComponentTree(({ componentInstance, treeNode }) => {
            updateComponentTreeTags(componentInstance, treeNode, i18n2);
          });
          api.on.inspectComponent(({ componentInstance, instanceData }) => {
            if (componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
              if (i18n2.mode === "legacy") {
                if (componentInstance.vnode.el.__VUE_I18N__ !== i18n2.global.__composer) {
                  inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
                }
              } else {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            }
          });
          api.addInspector({
            id: "vue-i18n-resource-inspector",
            label: VueDevToolsLabels[
              "vue-i18n-resource-inspector"
              /* CUSTOM_INSPECTOR */
            ],
            icon: "language",
            treeFilterPlaceholder: VueDevToolsPlaceholders[
              "vue-i18n-resource-inspector"
              /* CUSTOM_INSPECTOR */
            ]
          });
          api.on.getInspectorTree((payload) => {
            if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
              registerScope(payload, i18n2);
            }
          });
          api.on.getInspectorState((payload) => {
            if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
              inspectScope(payload, i18n2);
            }
          });
          api.on.editInspectorState((payload) => {
            if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
              editScope(payload, i18n2);
            }
          });
          api.addTimelineLayer({
            id: "vue-i18n-timeline",
            label: VueDevToolsLabels[
              "vue-i18n-timeline"
              /* TIMELINE */
            ],
            color: VueDevToolsTimelineColors[
              "vue-i18n-timeline"
              /* TIMELINE */
            ]
          });
          resolve(true);
        });
      } catch (e2) {
        console.error(e2);
        reject(false);
      }
    });
  }
  function updateComponentTreeTags(instance2, treeNode, i18n2) {
    const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    if (instance2 && instance2.vnode.el.__VUE_I18N__) {
      if (instance2.vnode.el.__VUE_I18N__ !== global2) {
        const label = instance2.type.name || instance2.type.displayName || instance2.type.__file;
        const tag = {
          label: `i18n (${label} Scope)`,
          textColor: 0,
          backgroundColor: 16764185
        };
        treeNode.tags.push(tag);
      }
    }
  }
  function inspectComposer(instanceData, composer) {
    const type = VUE_I18N_COMPONENT_TYPES;
    instanceData.state.push({
      type,
      key: "locale",
      editable: true,
      value: composer.locale.value
    });
    instanceData.state.push({
      type,
      key: "availableLocales",
      editable: false,
      value: composer.availableLocales
    });
    instanceData.state.push({
      type,
      key: "fallbackLocale",
      editable: true,
      value: composer.fallbackLocale.value
    });
    instanceData.state.push({
      type,
      key: "inheritLocale",
      editable: true,
      value: composer.inheritLocale
    });
    instanceData.state.push({
      type,
      key: "messages",
      editable: false,
      value: getLocaleMessageValue(composer.messages.value)
    });
    instanceData.state.push({
      type,
      key: "datetimeFormats",
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: "numberFormats",
      editable: false,
      value: composer.numberFormats.value
    });
  }
  function getLocaleMessageValue(messages2) {
    const value = {};
    Object.keys(messages2).forEach((key) => {
      const v2 = messages2[key];
      if (isFunction$1(v2) && "source" in v2) {
        value[key] = getMessageFunctionDetails(v2);
      } else if (isObject$3(v2)) {
        value[key] = getLocaleMessageValue(v2);
      } else {
        value[key] = v2;
      }
    });
    return value;
  }
  const ESC = {
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "&": "&amp;"
  };
  function escape(s2) {
    return s2.replace(/[<>"&]/g, escapeChar);
  }
  function escapeChar(a2) {
    return ESC[a2] || a2;
  }
  function getMessageFunctionDetails(func2) {
    const argString = func2.source ? `("${escape(func2.source)}")` : `(?)`;
    return {
      _custom: {
        type: "function",
        display: `<span>ƒ</span> ${argString}`
      }
    };
  }
  function registerScope(payload, i18n2) {
    payload.rootNodes.push({
      id: "global",
      label: "Global Scope"
    });
    const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    for (const [keyInstance, instance2] of i18n2.__instances) {
      const composer = i18n2.mode === "composition" ? instance2 : instance2.__composer;
      if (global2 === composer) {
        continue;
      }
      const label = keyInstance.type.name || keyInstance.type.displayName || keyInstance.type.__file;
      payload.rootNodes.push({
        id: composer.id.toString(),
        label: `${label} Scope`
      });
    }
  }
  function getComposer$1(nodeId, i18n2) {
    if (nodeId === "global") {
      return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    } else {
      const instance2 = Array.from(i18n2.__instances.values()).find((item) => item.id.toString() === nodeId);
      if (instance2) {
        return i18n2.mode === "composition" ? instance2 : instance2.__composer;
      } else {
        return null;
      }
    }
  }
  function inspectScope(payload, i18n2) {
    const composer = getComposer$1(payload.nodeId, i18n2);
    if (composer) {
      payload.state = makeScopeInspectState(composer);
    }
  }
  function makeScopeInspectState(composer) {
    const state = {};
    const localeType = "Locale related info";
    const localeStates = [
      {
        type: localeType,
        key: "locale",
        editable: true,
        value: composer.locale.value
      },
      {
        type: localeType,
        key: "fallbackLocale",
        editable: true,
        value: composer.fallbackLocale.value
      },
      {
        type: localeType,
        key: "availableLocales",
        editable: false,
        value: composer.availableLocales
      },
      {
        type: localeType,
        key: "inheritLocale",
        editable: true,
        value: composer.inheritLocale
      }
    ];
    state[localeType] = localeStates;
    const localeMessagesType = "Locale messages info";
    const localeMessagesStates = [
      {
        type: localeMessagesType,
        key: "messages",
        editable: false,
        value: getLocaleMessageValue(composer.messages.value)
      }
    ];
    state[localeMessagesType] = localeMessagesStates;
    const datetimeFormatsType = "Datetime formats info";
    const datetimeFormatsStates = [
      {
        type: datetimeFormatsType,
        key: "datetimeFormats",
        editable: false,
        value: composer.datetimeFormats.value
      }
    ];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = "Datetime formats info";
    const numberFormatsStates = [
      {
        type: numberFormatsType,
        key: "numberFormats",
        editable: false,
        value: composer.numberFormats.value
      }
    ];
    state[numberFormatsType] = numberFormatsStates;
    return state;
  }
  function addTimelineEvent(event, payload) {
    if (devtoolsApi) {
      let groupId;
      if (payload && "groupId" in payload) {
        groupId = payload.groupId;
        delete payload.groupId;
      }
      devtoolsApi.addTimelineEvent({
        layerId: "vue-i18n-timeline",
        event: {
          title: event,
          groupId,
          time: Date.now(),
          meta: {},
          data: payload || {},
          logType: event === "compile-error" ? "error" : event === "fallback" || event === "missing" ? "warning" : "default"
        }
      });
    }
  }
  function editScope(payload, i18n2) {
    const composer = getComposer$1(payload.nodeId, i18n2);
    if (composer) {
      const [field] = payload.path;
      if (field === "locale" && isString(payload.state.value)) {
        composer.locale.value = payload.state.value;
      } else if (field === "fallbackLocale" && (isString(payload.state.value) || isArray(payload.state.value) || isObject$3(payload.state.value))) {
        composer.fallbackLocale.value = payload.state.value;
      } else if (field === "inheritLocale" && isBoolean(payload.state.value)) {
        composer.inheritLocale = payload.state.value;
      }
    }
  }
  function defineMixin(vuei18n, composer, i18n2) {
    return {
      beforeCreate() {
        const instance2 = vue.getCurrentInstance();
        if (!instance2) {
          throw createI18nError(
            22
            /* UNEXPECTED_ERROR */
          );
        }
        const options = this.$options;
        if (options.i18n) {
          const optionsI18n = options.i18n;
          if (options.__i18n) {
            optionsI18n.__i18n = options.__i18n;
          }
          optionsI18n.__root = composer;
          if (this === this.$root) {
            this.$i18n = mergeToRoot(vuei18n, optionsI18n);
          } else {
            optionsI18n.__injectWithOption = true;
            this.$i18n = createVueI18n(optionsI18n);
          }
        } else if (options.__i18n) {
          if (this === this.$root) {
            this.$i18n = mergeToRoot(vuei18n, options);
          } else {
            this.$i18n = createVueI18n({
              __i18n: options.__i18n,
              __injectWithOption: true,
              __root: composer
            });
          }
        } else {
          this.$i18n = vuei18n;
        }
        vuei18n.__onComponentInstanceCreated(this.$i18n);
        i18n2.__setInstance(instance2, this.$i18n);
        this.$t = (...args) => this.$i18n.t(...args);
        this.$rt = (...args) => this.$i18n.rt(...args);
        this.$tc = (...args) => this.$i18n.tc(...args);
        this.$te = (key, locale) => this.$i18n.te(key, locale);
        this.$d = (...args) => this.$i18n.d(...args);
        this.$n = (...args) => this.$i18n.n(...args);
        this.$tm = (key) => this.$i18n.tm(key);
      },
      mounted() {
        {
          this.$el.__VUE_I18N__ = this.$i18n.__composer;
          const emitter = this.__v_emitter = createEmitter();
          const _vueI18n = this.$i18n;
          _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          emitter.on("*", addTimelineEvent);
        }
      },
      beforeUnmount() {
        const instance2 = vue.getCurrentInstance();
        if (!instance2) {
          throw createI18nError(
            22
            /* UNEXPECTED_ERROR */
          );
        }
        {
          if (this.__v_emitter) {
            this.__v_emitter.off("*", addTimelineEvent);
            delete this.__v_emitter;
          }
          const _vueI18n = this.$i18n;
          _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();
          delete this.$el.__VUE_I18N__;
        }
        delete this.$t;
        delete this.$rt;
        delete this.$tc;
        delete this.$te;
        delete this.$d;
        delete this.$n;
        delete this.$tm;
        i18n2.__deleteInstance(instance2);
        delete this.$i18n;
      }
    };
  }
  function mergeToRoot(root, options) {
    root.locale = options.locale || root.locale;
    root.fallbackLocale = options.fallbackLocale || root.fallbackLocale;
    root.missing = options.missing || root.missing;
    root.silentTranslationWarn = options.silentTranslationWarn || root.silentFallbackWarn;
    root.silentFallbackWarn = options.silentFallbackWarn || root.silentFallbackWarn;
    root.formatFallbackMessages = options.formatFallbackMessages || root.formatFallbackMessages;
    root.postTranslation = options.postTranslation || root.postTranslation;
    root.warnHtmlInMessage = options.warnHtmlInMessage || root.warnHtmlInMessage;
    root.escapeParameterHtml = options.escapeParameterHtml || root.escapeParameterHtml;
    root.sync = options.sync || root.sync;
    root.__composer[SetPluralRulesSymbol](options.pluralizationRules || root.pluralizationRules);
    const messages2 = getLocaleMessages(root.locale, {
      messages: options.messages,
      __i18n: options.__i18n
    });
    Object.keys(messages2).forEach((locale) => root.mergeLocaleMessage(locale, messages2[locale]));
    if (options.datetimeFormats) {
      Object.keys(options.datetimeFormats).forEach((locale) => root.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
    }
    if (options.numberFormats) {
      Object.keys(options.numberFormats).forEach((locale) => root.mergeNumberFormat(locale, options.numberFormats[locale]));
    }
    return root;
  }
  function createI18n(options = {}) {
    const __legacyMode = isBoolean(options.legacy) ? options.legacy : true;
    const __globalInjection = !!options.globalInjection;
    const __instances = /* @__PURE__ */ new Map();
    const __global = __legacyMode ? createVueI18n(options) : createComposer(options);
    const symbol = makeSymbol("vue-i18n");
    const i18n2 = {
      // mode
      get mode() {
        return __legacyMode ? "legacy" : "composition";
      },
      // install plugin
      async install(app, ...options2) {
        {
          app.__VUE_I18N__ = i18n2;
        }
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n2);
        if (!__legacyMode && __globalInjection) {
          injectGlobalFields(app, i18n2.global);
        }
        {
          apply(app, i18n2, ...options2);
        }
        if (__legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        {
          const ret = await enableDevTools(app, i18n2);
          if (!ret) {
            throw createI18nError(
              21
              /* CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN */
            );
          }
          const emitter = createEmitter();
          if (__legacyMode) {
            const _vueI18n = __global;
            _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          } else {
            const _composer = __global;
            _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
          }
          emitter.on("*", addTimelineEvent);
        }
      },
      // global accessor
      get global() {
        return __global;
      },
      // @internal
      __instances,
      // @internal
      __getInstance(component) {
        return __instances.get(component) || null;
      },
      // @internal
      __setInstance(component, instance2) {
        __instances.set(component, instance2);
      },
      // @internal
      __deleteInstance(component) {
        __instances.delete(component);
      }
    };
    return i18n2;
  }
  function useI18n(options = {}) {
    const instance2 = vue.getCurrentInstance();
    if (instance2 == null) {
      throw createI18nError(
        16
        /* MUST_BE_CALL_SETUP_TOP */
      );
    }
    if (!instance2.appContext.app.__VUE_I18N_SYMBOL__) {
      throw createI18nError(
        17
        /* NOT_INSLALLED */
      );
    }
    const i18n2 = vue.inject(instance2.appContext.app.__VUE_I18N_SYMBOL__);
    if (!i18n2) {
      throw createI18nError(
        22
        /* UNEXPECTED_ERROR */
      );
    }
    const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    const scope = isEmptyObject(options) ? "__i18n" in instance2.type ? "local" : "global" : !options.useScope ? "local" : options.useScope;
    if (scope === "global") {
      let messages2 = isObject$3(options.messages) ? options.messages : {};
      if ("__i18nGlobal" in instance2.type) {
        messages2 = getLocaleMessages(global2.locale.value, {
          messages: messages2,
          __i18n: instance2.type.__i18nGlobal
        });
      }
      const locales = Object.keys(messages2);
      if (locales.length) {
        locales.forEach((locale) => {
          global2.mergeLocaleMessage(locale, messages2[locale]);
        });
      }
      if (isObject$3(options.datetimeFormats)) {
        const locales2 = Object.keys(options.datetimeFormats);
        if (locales2.length) {
          locales2.forEach((locale) => {
            global2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
          });
        }
      }
      if (isObject$3(options.numberFormats)) {
        const locales2 = Object.keys(options.numberFormats);
        if (locales2.length) {
          locales2.forEach((locale) => {
            global2.mergeNumberFormat(locale, options.numberFormats[locale]);
          });
        }
      }
      return global2;
    }
    if (scope === "parent") {
      let composer2 = getComposer(i18n2, instance2, options.__useComponent);
      if (composer2 == null) {
        {
          warn(getWarnMessage(
            12
            /* NOT_FOUND_PARENT_SCOPE */
          ));
        }
        composer2 = global2;
      }
      return composer2;
    }
    if (i18n2.mode === "legacy") {
      throw createI18nError(
        18
        /* NOT_AVAILABLE_IN_LEGACY_MODE */
      );
    }
    const i18nInternal = i18n2;
    let composer = i18nInternal.__getInstance(instance2);
    if (composer == null) {
      const type = instance2.type;
      const composerOptions = assign$2({}, options);
      if (type.__i18n) {
        composerOptions.__i18n = type.__i18n;
      }
      if (global2) {
        composerOptions.__root = global2;
      }
      composer = createComposer(composerOptions);
      setupLifeCycle(i18nInternal, instance2, composer);
      i18nInternal.__setInstance(instance2, composer);
    }
    return composer;
  }
  function getComposer(i18n2, target, useComponent = false) {
    let composer = null;
    const root = target.root;
    let current2 = target.parent;
    while (current2 != null) {
      const i18nInternal = i18n2;
      if (i18n2.mode === "composition") {
        composer = i18nInternal.__getInstance(current2);
      } else {
        const vueI18n = i18nInternal.__getInstance(current2);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
        }
        if (useComponent && composer && !composer[InejctWithOption]) {
          composer = null;
        }
      }
      if (composer != null) {
        break;
      }
      if (root === current2) {
        break;
      }
      current2 = current2.parent;
    }
    return composer;
  }
  function setupLifeCycle(i18n2, target, composer) {
    let emitter = null;
    vue.onMounted(() => {
      if (target.vnode.el) {
        target.vnode.el.__VUE_I18N__ = composer;
        emitter = createEmitter();
        const _composer = composer;
        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
        emitter.on("*", addTimelineEvent);
      }
    }, target);
    vue.onUnmounted(() => {
      if (target.vnode.el && target.vnode.el.__VUE_I18N__) {
        emitter && emitter.off("*", addTimelineEvent);
        const _composer = composer;
        _composer[DisableEmitter] && _composer[DisableEmitter]();
        delete target.vnode.el.__VUE_I18N__;
      }
      i18n2.__deleteInstance(target);
    }, target);
  }
  const globalExportProps = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ];
  const globalExportMethods = ["t", "rt", "d", "n", "tm"];
  function injectGlobalFields(app, composer) {
    const i18n2 = /* @__PURE__ */ Object.create(null);
    globalExportProps.forEach((prop) => {
      const desc = Object.getOwnPropertyDescriptor(composer, prop);
      if (!desc) {
        throw createI18nError(
          22
          /* UNEXPECTED_ERROR */
        );
      }
      const wrap = vue.isRef(desc.value) ? {
        get() {
          return desc.value.value;
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        set(val) {
          desc.value.value = val;
        }
      } : {
        get() {
          return desc.get && desc.get();
        }
      };
      Object.defineProperty(i18n2, prop, wrap);
    });
    app.config.globalProperties.$i18n = i18n2;
    globalExportMethods.forEach((method) => {
      const desc = Object.getOwnPropertyDescriptor(composer, method);
      if (!desc || !desc.value) {
        throw createI18nError(
          22
          /* UNEXPECTED_ERROR */
        );
      }
      Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
    });
  }
  {
    initFeatureFlags();
  }
  {
    const target = getGlobalThis();
    target.__INTLIFY__ = true;
    setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const _imports_0$3 = "/static/icons/settingIcon.png";
  const _imports_1$b = "/static/banner.png";
  const _export_sfc = (sfc, props2) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props2) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$p = {
    __name: "index",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        t: t2
      } = useI18n();
      const listItem = vue.computed(() => {
        return [
          {
            name: "Receiving",
            url: "../home/scanCode?type=1",
            icon: "/static/l1.png"
          },
          {
            name: "Warehousing",
            url: "../home/scanCode?type=2",
            icon: "/static/l2.png"
          },
          {
            name: "Collect",
            url: "../home/scanCode?type=4",
            icon: "/static/l3.png"
          },
          {
            name: "Goods Management",
            url: "../home/goodsList",
            icon: "/static/l4.png"
          },
          {
            name: "Shelf Management",
            url: "../shelf/index",
            icon: "/static/l5.png"
          }
        ];
      });
      const listItemGD = vue.computed(() => {
        return [
          {
            name: "收货",
            url: "../home/scanCode?type=6",
            icon: "/static/ll1.png"
          },
          {
            name: "出库",
            url: "../home/scanCode?type=7",
            icon: "/static/ll2.png"
          },
          {
            name: "出库管理",
            url: "../gd/warehouseMen",
            icon: "/static/ll3.png"
          },
          {
            name: "货品管理",
            url: "../gd/goodsMen",
            icon: "/static/ll4.png"
          }
        ];
      });
      const menuList = vue.ref([]);
      if (uni.getStorageSync("staffType")) {
        menuList.value = listItem.value;
      } else {
        menuList.value = listItemGD.value;
      }
      menuList.value = listItem.value.concat(listItemGD.value);
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const username = uni.getStorageSync("username");
      vue.onMounted(() => {
        if (!uni.getStorageSync("token")) {
          uni.clearStorage();
          uni.navigateTo({
            url: "/pages/home/login"
          });
        }
      });
      const __returned__ = { t: t2, listItem, listItemGD, menuList, changePage, username, ref: vue.ref, computed: vue.computed, onMounted: vue.onMounted, get onLoad() {
        return onLoad;
      }, get useI18n() {
        return useI18n;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "" }, [
      vue.createElementVNode("view", { class: "" }, [
        vue.createElementVNode("view", { class: "between mt10 pdlr12" }, [
          vue.createElementVNode("view", { class: "ww24" }),
          vue.createElementVNode(
            "view",
            { class: "text_center text_bold f17" },
            vue.toDisplayString($setup.t("home.h_h2")),
            1
            /* TEXT */
          ),
          vue.createElementVNode("view", {
            class: "ww24",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("../setting/index"))
          }, [
            vue.createElementVNode("image", {
              src: _imports_0$3,
              class: "ww24 hh24"
            })
          ])
        ]),
        vue.createElementVNode(
          "view",
          { class: "text_center color7C f11 mt5" },
          vue.toDisplayString($setup.t("home.h_h3") + " " + $setup.username),
          1
          /* TEXT */
        ),
        vue.createElementVNode("view", { class: "pdlr12 mt17" }, [
          vue.createElementVNode("view", null, [
            vue.createElementVNode("image", {
              src: _imports_1$b,
              style: { "width": "100%", "height": "110px" }
            })
          ]),
          vue.createElementVNode(
            "view",
            { class: "hasBeforeLine mt30 text_bold f16" },
            vue.toDisplayString($setup.t("home.h_h1")),
            1
            /* TEXT */
          ),
          vue.createElementVNode("view", { class: "gridBox" }, [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.menuList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "gridItem center flex-col",
                  onClick: ($event) => $setup.changePage(item.url),
                  key: index2
                }, [
                  vue.createElementVNode("view", null, [
                    vue.createElementVNode("image", {
                      src: item.icon,
                      class: "ww50 hh48"
                    }, null, 8, ["src"])
                  ]),
                  vue.createElementVNode(
                    "view",
                    { class: "mt12 f12 word" },
                    vue.toDisplayString(item.name),
                    1
                    /* TEXT */
                  )
                ], 8, ["onClick"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ])
      ])
    ]);
  }
  const PagesTabIndex = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$o], ["__scopeId", "data-v-ae0729d5"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/tab/index.vue"]]);
  function noop$1() {
  }
  const extend = Object.assign;
  const inBrowser$1 = typeof window !== "undefined";
  const isObject$1 = (val) => val !== null && typeof val === "object";
  const isDef = (val) => val !== void 0 && val !== null;
  const isFunction = (val) => typeof val === "function";
  const isPromise$1 = (val) => isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
  const isDate = (val) => Object.prototype.toString.call(val) === "[object Date]" && !Number.isNaN(val.getTime());
  function isMobile(value) {
    value = value.replace(/[^-|\d]/g, "");
    return /^((\+86)|(86))?(1)\d{10}$/.test(value) || /^0[0-9-]{10,13}$/.test(value);
  }
  const isNumeric = (val) => typeof val === "number" || /^\d+(\.\d+)?$/.test(val);
  const isIOS$1 = () => inBrowser$1 ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : false;
  function get(object2, path) {
    const keys = path.split(".");
    let result = object2;
    keys.forEach((key) => {
      var _a;
      result = isObject$1(result) ? (_a = result[key]) != null ? _a : "" : "";
    });
    return result;
  }
  function pick(obj, keys, ignoreUndefined) {
    return keys.reduce(
      (ret, key) => {
        if (!ignoreUndefined || obj[key] !== void 0) {
          ret[key] = obj[key];
        }
        return ret;
      },
      {}
    );
  }
  const isSameValue = (newValue, oldValue) => JSON.stringify(newValue) === JSON.stringify(oldValue);
  const toArray = (item) => Array.isArray(item) ? item : [item];
  const flat = (arr) => arr.reduce((acc, val) => acc.concat(val), []);
  const unknownProp = null;
  const numericProp = [Number, String];
  const truthProp = {
    type: Boolean,
    default: true
  };
  const makeRequiredProp = (type) => ({
    type,
    required: true
  });
  const makeArrayProp = () => ({
    type: Array,
    default: () => []
  });
  const makeNumberProp = (defaultVal) => ({
    type: Number,
    default: defaultVal
  });
  const makeNumericProp = (defaultVal) => ({
    type: numericProp,
    default: defaultVal
  });
  const makeStringProp = (defaultVal) => ({
    type: String,
    default: defaultVal
  });
  var inBrowser = typeof window !== "undefined";
  function raf(fn) {
    return inBrowser ? requestAnimationFrame(fn) : -1;
  }
  function cancelRaf(id) {
    if (inBrowser) {
      cancelAnimationFrame(id);
    }
  }
  function doubleRaf(fn) {
    raf(() => raf(fn));
  }
  var isWindow = (val) => val === window;
  var makeDOMRect = (width2, height2) => ({
    top: 0,
    left: 0,
    right: width2,
    bottom: height2,
    width: width2,
    height: height2
  });
  var useRect = (elementOrRef) => {
    const element = vue.unref(elementOrRef);
    if (isWindow(element)) {
      const width2 = element.innerWidth;
      const height2 = element.innerHeight;
      return makeDOMRect(width2, height2);
    }
    if (element == null ? void 0 : element.getBoundingClientRect) {
      return element.getBoundingClientRect();
    }
    return makeDOMRect(0, 0);
  };
  function useToggle(defaultValue = false) {
    const state = vue.ref(defaultValue);
    const toggle = (value = !state.value) => {
      state.value = value;
    };
    return [state, toggle];
  }
  function useParent(key) {
    const parent = vue.inject(key, null);
    if (parent) {
      const instance2 = vue.getCurrentInstance();
      const { link, unlink, internalChildren } = parent;
      link(instance2);
      vue.onUnmounted(() => unlink(instance2));
      const index2 = vue.computed(() => internalChildren.indexOf(instance2));
      return {
        parent,
        index: index2
      };
    }
    return {
      parent: null,
      index: vue.ref(-1)
    };
  }
  function flattenVNodes(children) {
    const result = [];
    const traverse = (children2) => {
      if (Array.isArray(children2)) {
        children2.forEach((child) => {
          var _a;
          if (vue.isVNode(child)) {
            result.push(child);
            if ((_a = child.component) == null ? void 0 : _a.subTree) {
              result.push(child.component.subTree);
              traverse(child.component.subTree.children);
            }
            if (child.children) {
              traverse(child.children);
            }
          }
        });
      }
    };
    traverse(children);
    return result;
  }
  var findVNodeIndex = (vnodes, vnode) => {
    const index2 = vnodes.indexOf(vnode);
    if (index2 === -1) {
      return vnodes.findIndex(
        (item) => vnode.key !== void 0 && vnode.key !== null && item.type === vnode.type && item.key === vnode.key
      );
    }
    return index2;
  };
  function sortChildren(parent, publicChildren, internalChildren) {
    const vnodes = flattenVNodes(parent.subTree.children);
    internalChildren.sort(
      (a2, b2) => findVNodeIndex(vnodes, a2.vnode) - findVNodeIndex(vnodes, b2.vnode)
    );
    const orderedPublicChildren = internalChildren.map((item) => item.proxy);
    publicChildren.sort((a2, b2) => {
      const indexA = orderedPublicChildren.indexOf(a2);
      const indexB = orderedPublicChildren.indexOf(b2);
      return indexA - indexB;
    });
  }
  function useChildren(key) {
    const publicChildren = vue.reactive([]);
    const internalChildren = vue.reactive([]);
    const parent = vue.getCurrentInstance();
    const linkChildren = (value) => {
      const link = (child) => {
        if (child.proxy) {
          internalChildren.push(child);
          publicChildren.push(child.proxy);
          sortChildren(parent, publicChildren, internalChildren);
        }
      };
      const unlink = (child) => {
        const index2 = internalChildren.indexOf(child);
        publicChildren.splice(index2, 1);
        internalChildren.splice(index2, 1);
      };
      vue.provide(
        key,
        Object.assign(
          {
            link,
            unlink,
            children: publicChildren,
            internalChildren
          },
          value
        )
      );
    };
    return {
      children: publicChildren,
      linkChildren
    };
  }
  var SECOND = 1e3;
  var MINUTE = 60 * SECOND;
  var HOUR = 60 * MINUTE;
  var DAY = 24 * HOUR;
  function parseTime(time) {
    const days = Math.floor(time / DAY);
    const hours = Math.floor(time % DAY / HOUR);
    const minutes = Math.floor(time % HOUR / MINUTE);
    const seconds = Math.floor(time % MINUTE / SECOND);
    const milliseconds = Math.floor(time % SECOND);
    return {
      total: time,
      days,
      hours,
      minutes,
      seconds,
      milliseconds
    };
  }
  function isSameSecond(time1, time2) {
    return Math.floor(time1 / 1e3) === Math.floor(time2 / 1e3);
  }
  function useCountDown(options) {
    let rafId;
    let endTime;
    let counting;
    let deactivated;
    const remain = vue.ref(options.time);
    const current2 = vue.computed(() => parseTime(remain.value));
    const pause = () => {
      counting = false;
      cancelRaf(rafId);
    };
    const getCurrentRemain = () => Math.max(endTime - Date.now(), 0);
    const setRemain = (value) => {
      var _a, _b;
      remain.value = value;
      (_a = options.onChange) == null ? void 0 : _a.call(options, current2.value);
      if (value === 0) {
        pause();
        (_b = options.onFinish) == null ? void 0 : _b.call(options);
      }
    };
    const microTick = () => {
      rafId = raf(() => {
        if (counting) {
          setRemain(getCurrentRemain());
          if (remain.value > 0) {
            microTick();
          }
        }
      });
    };
    const macroTick = () => {
      rafId = raf(() => {
        if (counting) {
          const remainRemain = getCurrentRemain();
          if (!isSameSecond(remainRemain, remain.value) || remainRemain === 0) {
            setRemain(remainRemain);
          }
          if (remain.value > 0) {
            macroTick();
          }
        }
      });
    };
    const tick = () => {
      if (!inBrowser) {
        return;
      }
      if (options.millisecond) {
        microTick();
      } else {
        macroTick();
      }
    };
    const start2 = () => {
      if (!counting) {
        endTime = Date.now() + remain.value;
        counting = true;
        tick();
      }
    };
    const reset = (totalTime = options.time) => {
      pause();
      remain.value = totalTime;
    };
    vue.onBeforeUnmount(pause);
    vue.onActivated(() => {
      if (deactivated) {
        counting = true;
        deactivated = false;
        tick();
      }
    });
    vue.onDeactivated(() => {
      if (counting) {
        pause();
        deactivated = true;
      }
    });
    return {
      start: start2,
      pause,
      reset,
      current: current2
    };
  }
  function onMountedOrActivated(hook) {
    let mounted;
    vue.onMounted(() => {
      hook();
      vue.nextTick(() => {
        mounted = true;
      });
    });
    vue.onActivated(() => {
      if (mounted) {
        hook();
      }
    });
  }
  function useEventListener(type, listener, options = {}) {
    if (!inBrowser) {
      return;
    }
    const { target = window, passive: passive2 = false, capture = false } = options;
    let cleaned = false;
    let attached;
    const add = (target2) => {
      if (cleaned) {
        return;
      }
      const element = vue.unref(target2);
      if (element && !attached) {
        element.addEventListener(type, listener, {
          capture,
          passive: passive2
        });
        attached = true;
      }
    };
    const remove = (target2) => {
      if (cleaned) {
        return;
      }
      const element = vue.unref(target2);
      if (element && attached) {
        element.removeEventListener(type, listener, capture);
        attached = false;
      }
    };
    vue.onUnmounted(() => remove(target));
    vue.onDeactivated(() => remove(target));
    onMountedOrActivated(() => add(target));
    let stopWatch;
    if (vue.isRef(target)) {
      stopWatch = vue.watch(target, (val, oldVal) => {
        remove(oldVal);
        add(val);
      });
    }
    return () => {
      stopWatch == null ? void 0 : stopWatch();
      remove(target);
      cleaned = true;
    };
  }
  function useClickAway(target, listener, options = {}) {
    if (!inBrowser) {
      return;
    }
    const { eventName = "click" } = options;
    const onClick = (event) => {
      const targets = Array.isArray(target) ? target : [target];
      const isClickAway = targets.every((item) => {
        const element = vue.unref(item);
        return element && !element.contains(event.target);
      });
      if (isClickAway) {
        listener(event);
      }
    };
    useEventListener(eventName, onClick, { target: document });
  }
  var width;
  var height;
  function useWindowSize() {
    if (!width) {
      width = vue.ref(0);
      height = vue.ref(0);
      if (inBrowser) {
        const update = () => {
          width.value = window.innerWidth;
          height.value = window.innerHeight;
        };
        update();
        window.addEventListener("resize", update, { passive: true });
        window.addEventListener("orientationchange", update, { passive: true });
      }
    }
    return { width, height };
  }
  var overflowScrollReg = /scroll|auto|overlay/i;
  var defaultRoot = inBrowser ? window : void 0;
  function isElement$1(node) {
    const ELEMENT_NODE_TYPE = 1;
    return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
  }
  function getScrollParent$1(el, root = defaultRoot) {
    let node = el;
    while (node && node !== root && isElement$1(node)) {
      const { overflowY } = window.getComputedStyle(node);
      if (overflowScrollReg.test(overflowY)) {
        return node;
      }
      node = node.parentNode;
    }
    return root;
  }
  function useScrollParent(el, root = defaultRoot) {
    const scrollParent = vue.ref();
    vue.onMounted(() => {
      if (el.value) {
        scrollParent.value = getScrollParent$1(el.value, root);
      }
    });
    return scrollParent;
  }
  var visibility;
  function usePageVisibility() {
    if (!visibility) {
      visibility = vue.ref("visible");
      if (inBrowser) {
        const update = () => {
          visibility.value = document.hidden ? "hidden" : "visible";
        };
        update();
        window.addEventListener("visibilitychange", update);
      }
    }
    return visibility;
  }
  var CUSTOM_FIELD_INJECTION_KEY = Symbol("van-field");
  function useCustomFieldValue(customValue) {
    const field = vue.inject(CUSTOM_FIELD_INJECTION_KEY, null);
    if (field && !field.customValue.value) {
      field.customValue.value = customValue;
      vue.watch(customValue, () => {
        field.resetValidation();
        field.validateWithTrigger("onChange");
      });
    }
  }
  function getScrollTop(el) {
    const top2 = "scrollTop" in el ? el.scrollTop : el.pageYOffset;
    return Math.max(top2, 0);
  }
  function setScrollTop(el, value) {
    if ("scrollTop" in el) {
      el.scrollTop = value;
    } else {
      el.scrollTo(el.scrollX, value);
    }
  }
  function getRootScrollTop() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  }
  function setRootScrollTop(value) {
    setScrollTop(window, value);
    setScrollTop(document.body, value);
  }
  function getElementTop(el, scroller) {
    if (el === window) {
      return 0;
    }
    const scrollTop = scroller ? getScrollTop(scroller) : getRootScrollTop();
    return useRect(el).top + scrollTop;
  }
  const isIOS = isIOS$1();
  function resetScroll() {
    if (isIOS) {
      setRootScrollTop(getRootScrollTop());
    }
  }
  const stopPropagation = (event) => event.stopPropagation();
  function preventDefault(event, isStopPropagation) {
    if (typeof event.cancelable !== "boolean" || event.cancelable) {
      event.preventDefault();
    }
    if (isStopPropagation) {
      stopPropagation(event);
    }
  }
  function isHidden(elementRef) {
    const el = vue.unref(elementRef);
    if (!el) {
      return false;
    }
    const style = window.getComputedStyle(el);
    const hidden = style.display === "none";
    const parentHidden = el.offsetParent === null && style.position !== "fixed";
    return hidden || parentHidden;
  }
  const { width: windowWidth, height: windowHeight } = useWindowSize();
  function isContainingBlock(el) {
    const css = window.getComputedStyle(el);
    return css.transform !== "none" || css.perspective !== "none" || ["transform", "perspective", "filter"].some(
      (value) => (css.willChange || "").includes(value)
    );
  }
  function getContainingBlock$1(el) {
    let node = el.parentElement;
    while (node) {
      if (node && node.tagName !== "HTML" && node.tagName !== "BODY" && isContainingBlock(node)) {
        return node;
      }
      node = node.parentElement;
    }
    return null;
  }
  function addUnit$2(value) {
    if (isDef(value)) {
      return isNumeric(value) ? `${value}px` : String(value);
    }
    return void 0;
  }
  function getSizeStyle(originSize) {
    if (isDef(originSize)) {
      if (Array.isArray(originSize)) {
        return {
          width: addUnit$2(originSize[0]),
          height: addUnit$2(originSize[1])
        };
      }
      const size = addUnit$2(originSize);
      return {
        width: size,
        height: size
      };
    }
  }
  function getZIndexStyle(zIndex) {
    const style = {};
    if (zIndex !== void 0) {
      style.zIndex = +zIndex;
    }
    return style;
  }
  let rootFontSize;
  function getRootFontSize() {
    if (!rootFontSize) {
      const doc = document.documentElement;
      const fontSize = doc.style.fontSize || window.getComputedStyle(doc).fontSize;
      rootFontSize = parseFloat(fontSize);
    }
    return rootFontSize;
  }
  function convertRem(value) {
    value = value.replace(/rem/g, "");
    return +value * getRootFontSize();
  }
  function convertVw(value) {
    value = value.replace(/vw/g, "");
    return +value * windowWidth.value / 100;
  }
  function convertVh(value) {
    value = value.replace(/vh/g, "");
    return +value * windowHeight.value / 100;
  }
  function unitToPx(value) {
    if (typeof value === "number") {
      return value;
    }
    if (inBrowser$1) {
      if (value.includes("rem")) {
        return convertRem(value);
      }
      if (value.includes("vw")) {
        return convertVw(value);
      }
      if (value.includes("vh")) {
        return convertVh(value);
      }
    }
    return parseFloat(value);
  }
  const camelizeRE = /-(\w)/g;
  const camelize = (str) => str.replace(camelizeRE, (_, c2) => c2.toUpperCase());
  const kebabCase = (str) => str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
  function padZero$1(num, targetLength = 2) {
    let str = num + "";
    while (str.length < targetLength) {
      str = "0" + str;
    }
    return str;
  }
  const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
  function trimExtraChar(value, char, regExp2) {
    const index2 = value.indexOf(char);
    if (index2 === -1) {
      return value;
    }
    if (char === "-" && index2 !== 0) {
      return value.slice(0, index2);
    }
    return value.slice(0, index2 + 1) + value.slice(index2).replace(regExp2, "");
  }
  function formatNumber(value, allowDot = true, allowMinus = true) {
    if (allowDot) {
      value = trimExtraChar(value, ".", /\./g);
    } else {
      value = value.split(".")[0];
    }
    if (allowMinus) {
      value = trimExtraChar(value, "-", /-/g);
    } else {
      value = value.replace(/-/, "");
    }
    const regExp2 = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
    return value.replace(regExp2, "");
  }
  function addNumber(num1, num2) {
    const cardinal = 10 ** 10;
    return Math.round((num1 + num2) * cardinal) / cardinal;
  }
  const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
  function assignKey(to, from, key) {
    const val = from[key];
    if (!isDef(val)) {
      return;
    }
    if (!hasOwnProperty$1.call(to, key) || !isObject$1(val)) {
      to[key] = val;
    } else {
      to[key] = deepAssign(Object(to[key]), val);
    }
  }
  function deepAssign(to, from) {
    Object.keys(from).forEach((key) => {
      assignKey(to, from, key);
    });
    return to;
  }
  var stdin_default$1T = {
    name: "姓名",
    tel: "电话",
    save: "保存",
    clear: "清空",
    cancel: "取消",
    confirm: "确认",
    delete: "删除",
    loading: "加载中...",
    noCoupon: "暂无优惠券",
    nameEmpty: "请填写姓名",
    addContact: "添加联系人",
    telInvalid: "请填写正确的电话",
    vanCalendar: {
      end: "结束",
      start: "开始",
      title: "日期选择",
      weekdays: ["日", "一", "二", "三", "四", "五", "六"],
      monthTitle: (year, month) => `${year}年${month}月`,
      rangePrompt: (maxRange) => `最多选择 ${maxRange} 天`
    },
    vanCascader: {
      select: "请选择"
    },
    vanPagination: {
      prev: "上一页",
      next: "下一页"
    },
    vanPullRefresh: {
      pulling: "下拉即可刷新...",
      loosing: "释放即可刷新..."
    },
    vanSubmitBar: {
      label: "合计:"
    },
    vanCoupon: {
      unlimited: "无门槛",
      discount: (discount) => `${discount}折`,
      condition: (condition) => `满${condition}元可用`
    },
    vanCouponCell: {
      title: "优惠券",
      count: (count) => `${count}张可用`
    },
    vanCouponList: {
      exchange: "兑换",
      close: "不使用",
      enable: "可用",
      disabled: "不可用",
      placeholder: "输入优惠码"
    },
    vanAddressEdit: {
      area: "地区",
      areaEmpty: "请选择地区",
      addressEmpty: "请填写详细地址",
      addressDetail: "详细地址",
      defaultAddress: "设为默认收货地址"
    },
    vanAddressList: {
      add: "新增地址"
    }
  };
  const lang$1 = vue.ref("zh-CN");
  const messages$1 = vue.reactive({
    "zh-CN": stdin_default$1T
  });
  const Locale = {
    messages() {
      return messages$1[lang$1.value];
    },
    use(newLang, newMessages) {
      lang$1.value = newLang;
      this.add({ [newLang]: newMessages });
    },
    add(newMessages = {}) {
      deepAssign(messages$1, newMessages);
    }
  };
  var stdin_default$1S = Locale;
  function createTranslate(name2) {
    const prefix = camelize(name2) + ".";
    return (path, ...args) => {
      const messages2 = stdin_default$1S.messages();
      const message = get(messages2, prefix + path) || get(messages2, path);
      return isFunction(message) ? message(...args) : message;
    };
  }
  function genBem(name2, mods) {
    if (!mods) {
      return "";
    }
    if (typeof mods === "string") {
      return ` ${name2}--${mods}`;
    }
    if (Array.isArray(mods)) {
      return mods.reduce(
        (ret, item) => ret + genBem(name2, item),
        ""
      );
    }
    return Object.keys(mods).reduce(
      (ret, key) => ret + (mods[key] ? genBem(name2, key) : ""),
      ""
    );
  }
  function createBEM(name2) {
    return (el, mods) => {
      if (el && typeof el !== "string") {
        mods = el;
        el = "";
      }
      el = el ? `${name2}__${el}` : name2;
      return `${el}${genBem(el, mods)}`;
    };
  }
  function createNamespace(name2) {
    const prefixedName = `van-${name2}`;
    return [
      prefixedName,
      createBEM(prefixedName),
      createTranslate(prefixedName)
    ];
  }
  const BORDER = "van-hairline";
  const BORDER_TOP = `${BORDER}--top`;
  const BORDER_LEFT = `${BORDER}--left`;
  const BORDER_RIGHT = `${BORDER}--right`;
  const BORDER_BOTTOM = `${BORDER}--bottom`;
  const BORDER_SURROUND = `${BORDER}--surround`;
  const BORDER_TOP_BOTTOM = `${BORDER}--top-bottom`;
  const BORDER_UNSET_TOP_BOTTOM = `${BORDER}-unset--top-bottom`;
  const HAPTICS_FEEDBACK = "van-haptics-feedback";
  const FORM_KEY = Symbol("van-form");
  const LONG_PRESS_START_TIME = 500;
  const TAP_OFFSET = 5;
  function callInterceptor(interceptor2, {
    args = [],
    done,
    canceled,
    error: error2
  }) {
    if (interceptor2) {
      const returnVal = interceptor2.apply(null, args);
      if (isPromise$1(returnVal)) {
        returnVal.then((value) => {
          if (value) {
            done();
          } else if (canceled) {
            canceled();
          }
        }).catch(error2 || noop$1);
      } else if (returnVal) {
        done();
      } else if (canceled) {
        canceled();
      }
    } else {
      done();
    }
  }
  function withInstall(options) {
    options.install = (app) => {
      const { name: name2 } = options;
      if (name2) {
        app.component(name2, options);
        app.component(camelize(`-${name2}`), options);
      }
    };
    return options;
  }
  function closest(arr, target) {
    return arr.reduce(
      (pre, cur) => Math.abs(pre - target) < Math.abs(cur - target) ? pre : cur
    );
  }
  const POPUP_TOGGLE_KEY = Symbol();
  function onPopupReopen(callback) {
    const popupToggleStatus = vue.inject(POPUP_TOGGLE_KEY, null);
    if (popupToggleStatus) {
      vue.watch(popupToggleStatus, (show) => {
        if (show) {
          callback();
        }
      });
    }
  }
  const useHeight = (element, withSafeArea) => {
    const height2 = vue.ref();
    const setHeight = () => {
      height2.value = useRect(element).height;
    };
    vue.onMounted(() => {
      vue.nextTick(setHeight);
      if (withSafeArea) {
        for (let i2 = 1; i2 <= 3; i2++) {
          setTimeout(setHeight, 100 * i2);
        }
      }
    });
    onPopupReopen(() => vue.nextTick(setHeight));
    vue.watch([windowWidth, windowHeight], setHeight);
    return height2;
  };
  function usePlaceholder(contentRef, bem2) {
    const height2 = useHeight(contentRef, true);
    return (renderContent) => vue.createVNode("div", {
      "class": bem2("placeholder"),
      "style": {
        height: height2.value ? `${height2.value}px` : void 0
      }
    }, [renderContent()]);
  }
  const [name$1K, bem$1F] = createNamespace("action-bar");
  const ACTION_BAR_KEY = Symbol(name$1K);
  const actionBarProps = {
    placeholder: Boolean,
    safeAreaInsetBottom: truthProp
  };
  var stdin_default$1R = vue.defineComponent({
    name: name$1K,
    props: actionBarProps,
    setup(props2, {
      slots
    }) {
      const root = vue.ref();
      const renderPlaceholder = usePlaceholder(root, bem$1F);
      const {
        linkChildren
      } = useChildren(ACTION_BAR_KEY);
      linkChildren();
      const renderActionBar = () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "class": [bem$1F(), {
            "van-safe-area-bottom": props2.safeAreaInsetBottom
          }]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
      return () => {
        if (props2.placeholder) {
          return renderPlaceholder(renderActionBar);
        }
        return renderActionBar();
      };
    }
  });
  const ActionBar = withInstall(stdin_default$1R);
  function useExpose(apis) {
    const instance2 = vue.getCurrentInstance();
    if (instance2) {
      extend(instance2.proxy, apis);
    }
  }
  const routeProps = {
    to: [String, Object],
    url: String,
    replace: Boolean
  };
  function route$1({
    to,
    url: url2,
    replace,
    $router: router
  }) {
    if (to && router) {
      router[replace ? "replace" : "push"](to);
    } else if (url2) {
      replace ? location.replace(url2) : location.href = url2;
    }
  }
  function useRoute() {
    const vm = vue.getCurrentInstance().proxy;
    return () => route$1(vm);
  }
  const [name$1J, bem$1E] = createNamespace("badge");
  const badgeProps = {
    dot: Boolean,
    max: numericProp,
    tag: makeStringProp("div"),
    color: String,
    offset: Array,
    content: numericProp,
    showZero: truthProp,
    position: makeStringProp("top-right")
  };
  var stdin_default$1Q = vue.defineComponent({
    name: name$1J,
    props: badgeProps,
    setup(props2, {
      slots
    }) {
      const hasContent = () => {
        if (slots.content) {
          return true;
        }
        const {
          content,
          showZero
        } = props2;
        return isDef(content) && content !== "" && (showZero || content !== 0 && content !== "0");
      };
      const renderContent = () => {
        const {
          dot,
          max,
          content
        } = props2;
        if (!dot && hasContent()) {
          if (slots.content) {
            return slots.content();
          }
          if (isDef(max) && isNumeric(content) && +content > +max) {
            return `${max}+`;
          }
          return content;
        }
      };
      const getOffsetWithMinusString = (val) => val.startsWith("-") ? val.replace("-", "") : `-${val}`;
      const style = vue.computed(() => {
        const style2 = {
          background: props2.color
        };
        if (props2.offset) {
          const [x, y] = props2.offset;
          const {
            position
          } = props2;
          const [offsetY, offsetX] = position.split("-");
          if (slots.default) {
            if (typeof y === "number") {
              style2[offsetY] = addUnit$2(offsetY === "top" ? y : -y);
            } else {
              style2[offsetY] = offsetY === "top" ? addUnit$2(y) : getOffsetWithMinusString(y);
            }
            if (typeof x === "number") {
              style2[offsetX] = addUnit$2(offsetX === "left" ? x : -x);
            } else {
              style2[offsetX] = offsetX === "left" ? addUnit$2(x) : getOffsetWithMinusString(x);
            }
          } else {
            style2.marginTop = addUnit$2(y);
            style2.marginLeft = addUnit$2(x);
          }
        }
        return style2;
      });
      const renderBadge = () => {
        if (hasContent() || props2.dot) {
          return vue.createVNode("div", {
            "class": bem$1E([props2.position, {
              dot: props2.dot,
              fixed: !!slots.default
            }]),
            "style": style.value
          }, [renderContent()]);
        }
      };
      return () => {
        if (slots.default) {
          const {
            tag
          } = props2;
          return vue.createVNode(tag, {
            "class": bem$1E("wrapper")
          }, {
            default: () => [slots.default(), renderBadge()]
          });
        }
        return renderBadge();
      };
    }
  });
  const Badge = withInstall(stdin_default$1Q);
  let globalZIndex = 2e3;
  const useGlobalZIndex = () => ++globalZIndex;
  const setGlobalZIndex = (val) => {
    globalZIndex = val;
  };
  const [name$1I, bem$1D] = createNamespace("config-provider");
  const CONFIG_PROVIDER_KEY = Symbol(name$1I);
  const configProviderProps = {
    tag: makeStringProp("div"),
    theme: makeStringProp("light"),
    zIndex: Number,
    themeVars: Object,
    themeVarsDark: Object,
    themeVarsLight: Object,
    themeVarsScope: makeStringProp("local"),
    iconPrefix: String
  };
  function insertDash(str) {
    return str.replace(/([a-zA-Z])(\d)/g, "$1-$2");
  }
  function mapThemeVarsToCSSVars(themeVars) {
    const cssVars = {};
    Object.keys(themeVars).forEach((key) => {
      const formattedKey = insertDash(kebabCase(key));
      cssVars[`--van-${formattedKey}`] = themeVars[key];
    });
    return cssVars;
  }
  function syncThemeVarsOnRoot(newStyle = {}, oldStyle = {}) {
    Object.keys(newStyle).forEach((key) => {
      if (newStyle[key] !== oldStyle[key]) {
        document.documentElement.style.setProperty(key, newStyle[key]);
      }
    });
    Object.keys(oldStyle).forEach((key) => {
      if (!newStyle[key]) {
        document.documentElement.style.removeProperty(key);
      }
    });
  }
  var stdin_default$1P = vue.defineComponent({
    name: name$1I,
    props: configProviderProps,
    setup(props2, {
      slots
    }) {
      const style = vue.computed(() => mapThemeVarsToCSSVars(extend({}, props2.themeVars, props2.theme === "dark" ? props2.themeVarsDark : props2.themeVarsLight)));
      if (inBrowser$1) {
        const addTheme = () => {
          document.documentElement.classList.add(`van-theme-${props2.theme}`);
        };
        const removeTheme = (theme = props2.theme) => {
          document.documentElement.classList.remove(`van-theme-${theme}`);
        };
        vue.watch(() => props2.theme, (newVal, oldVal) => {
          if (oldVal) {
            removeTheme(oldVal);
          }
          addTheme();
        }, {
          immediate: true
        });
        vue.onActivated(addTheme);
        vue.onDeactivated(removeTheme);
        vue.onBeforeUnmount(removeTheme);
        vue.watch(style, (newStyle, oldStyle) => {
          if (props2.themeVarsScope === "global") {
            syncThemeVarsOnRoot(newStyle, oldStyle);
          }
        });
        vue.watch(() => props2.themeVarsScope, (newScope, oldScope) => {
          if (oldScope === "global") {
            syncThemeVarsOnRoot({}, style.value);
          }
          if (newScope === "global") {
            syncThemeVarsOnRoot(style.value, {});
          }
        });
        if (props2.themeVarsScope === "global") {
          syncThemeVarsOnRoot(style.value, {});
        }
      }
      vue.provide(CONFIG_PROVIDER_KEY, props2);
      vue.watchEffect(() => {
        if (props2.zIndex !== void 0) {
          setGlobalZIndex(props2.zIndex);
        }
      });
      return () => vue.createVNode(props2.tag, {
        "class": bem$1D(),
        "style": props2.themeVarsScope === "local" ? style.value : void 0
      }, {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      });
    }
  });
  const [name$1H, bem$1C] = createNamespace("icon");
  const isImage$1 = (name2) => name2 == null ? void 0 : name2.includes("/");
  const iconProps = {
    dot: Boolean,
    tag: makeStringProp("i"),
    name: String,
    size: numericProp,
    badge: numericProp,
    color: String,
    badgeProps: Object,
    classPrefix: String
  };
  var stdin_default$1O = vue.defineComponent({
    name: name$1H,
    props: iconProps,
    setup(props2, {
      slots
    }) {
      const config2 = vue.inject(CONFIG_PROVIDER_KEY, null);
      const classPrefix = vue.computed(() => props2.classPrefix || (config2 == null ? void 0 : config2.iconPrefix) || bem$1C());
      return () => {
        const {
          tag,
          dot,
          name: name2,
          size,
          badge,
          color
        } = props2;
        const isImageIcon = isImage$1(name2);
        return vue.createVNode(Badge, vue.mergeProps({
          "dot": dot,
          "tag": tag,
          "class": [classPrefix.value, isImageIcon ? "" : `${classPrefix.value}-${name2}`],
          "style": {
            color,
            fontSize: addUnit$2(size)
          },
          "content": badge
        }, props2.badgeProps), {
          default: () => {
            var _a;
            return [(_a = slots.default) == null ? void 0 : _a.call(slots), isImageIcon && vue.createVNode("img", {
              "class": bem$1C("image"),
              "src": name2
            }, null)];
          }
        });
      };
    }
  });
  const Icon = withInstall(stdin_default$1O);
  var stdin_default$1N = Icon;
  const [name$1G, bem$1B] = createNamespace("loading");
  const SpinIcon = Array(12).fill(null).map((_, index2) => vue.createVNode("i", {
    "class": bem$1B("line", String(index2 + 1))
  }, null));
  const CircularIcon = vue.createVNode("svg", {
    "class": bem$1B("circular"),
    "viewBox": "25 25 50 50"
  }, [vue.createVNode("circle", {
    "cx": "50",
    "cy": "50",
    "r": "20",
    "fill": "none"
  }, null)]);
  const loadingProps = {
    size: numericProp,
    type: makeStringProp("circular"),
    color: String,
    vertical: Boolean,
    textSize: numericProp,
    textColor: String
  };
  var stdin_default$1M = vue.defineComponent({
    name: name$1G,
    props: loadingProps,
    setup(props2, {
      slots
    }) {
      const spinnerStyle = vue.computed(() => extend({
        color: props2.color
      }, getSizeStyle(props2.size)));
      const renderIcon = () => {
        const DefaultIcon = props2.type === "spinner" ? SpinIcon : CircularIcon;
        return vue.createVNode("span", {
          "class": bem$1B("spinner", props2.type),
          "style": spinnerStyle.value
        }, [slots.icon ? slots.icon() : DefaultIcon]);
      };
      const renderText = () => {
        var _a;
        if (slots.default) {
          return vue.createVNode("span", {
            "class": bem$1B("text"),
            "style": {
              fontSize: addUnit$2(props2.textSize),
              color: (_a = props2.textColor) != null ? _a : props2.color
            }
          }, [slots.default()]);
        }
      };
      return () => {
        const {
          type,
          vertical
        } = props2;
        return vue.createVNode("div", {
          "class": bem$1B([type, {
            vertical
          }]),
          "aria-live": "polite",
          "aria-busy": true
        }, [renderIcon(), renderText()]);
      };
    }
  });
  const Loading = withInstall(stdin_default$1M);
  const [name$1F, bem$1A] = createNamespace("button");
  const buttonProps = extend({}, routeProps, {
    tag: makeStringProp("button"),
    text: String,
    icon: String,
    type: makeStringProp("default"),
    size: makeStringProp("normal"),
    color: String,
    block: Boolean,
    plain: Boolean,
    round: Boolean,
    square: Boolean,
    loading: Boolean,
    hairline: Boolean,
    disabled: Boolean,
    iconPrefix: String,
    nativeType: makeStringProp("button"),
    loadingSize: numericProp,
    loadingText: String,
    loadingType: String,
    iconPosition: makeStringProp("left")
  });
  var stdin_default$1L = vue.defineComponent({
    name: name$1F,
    props: buttonProps,
    emits: ["click"],
    setup(props2, {
      emit,
      slots
    }) {
      const route2 = useRoute();
      const renderLoadingIcon = () => {
        if (slots.loading) {
          return slots.loading();
        }
        return vue.createVNode(Loading, {
          "size": props2.loadingSize,
          "type": props2.loadingType,
          "class": bem$1A("loading")
        }, null);
      };
      const renderIcon = () => {
        if (props2.loading) {
          return renderLoadingIcon();
        }
        if (slots.icon) {
          return vue.createVNode("div", {
            "class": bem$1A("icon")
          }, [slots.icon()]);
        }
        if (props2.icon) {
          return vue.createVNode(Icon, {
            "name": props2.icon,
            "class": bem$1A("icon"),
            "classPrefix": props2.iconPrefix
          }, null);
        }
      };
      const renderText = () => {
        let text;
        if (props2.loading) {
          text = props2.loadingText;
        } else {
          text = slots.default ? slots.default() : props2.text;
        }
        if (text) {
          return vue.createVNode("span", {
            "class": bem$1A("text")
          }, [text]);
        }
      };
      const getStyle = () => {
        const {
          color,
          plain
        } = props2;
        if (color) {
          const style = {
            color: plain ? color : "white"
          };
          if (!plain) {
            style.background = color;
          }
          if (color.includes("gradient")) {
            style.border = 0;
          } else {
            style.borderColor = color;
          }
          return style;
        }
      };
      const onClick = (event) => {
        if (props2.loading) {
          preventDefault(event);
        } else if (!props2.disabled) {
          emit("click", event);
          route2();
        }
      };
      return () => {
        const {
          tag,
          type,
          size,
          block,
          round: round2,
          plain,
          square,
          loading,
          disabled,
          hairline,
          nativeType,
          iconPosition
        } = props2;
        const classes = [bem$1A([type, size, {
          plain,
          block,
          round: round2,
          square,
          loading,
          disabled,
          hairline
        }]), {
          [BORDER_SURROUND]: hairline
        }];
        return vue.createVNode(tag, {
          "type": nativeType,
          "class": classes,
          "style": getStyle(),
          "disabled": disabled,
          "onClick": onClick
        }, {
          default: () => [vue.createVNode("div", {
            "class": bem$1A("content")
          }, [iconPosition === "left" && renderIcon(), renderText(), iconPosition === "right" && renderIcon()])]
        });
      };
    }
  });
  const Button = withInstall(stdin_default$1L);
  const [name$1E, bem$1z] = createNamespace("action-bar-button");
  const actionBarButtonProps = extend({}, routeProps, {
    type: String,
    text: String,
    icon: String,
    color: String,
    loading: Boolean,
    disabled: Boolean
  });
  var stdin_default$1K = vue.defineComponent({
    name: name$1E,
    props: actionBarButtonProps,
    setup(props2, {
      slots
    }) {
      const route2 = useRoute();
      const {
        parent,
        index: index2
      } = useParent(ACTION_BAR_KEY);
      const isFirst = vue.computed(() => {
        if (parent) {
          const prev = parent.children[index2.value - 1];
          return !(prev && "isButton" in prev);
        }
      });
      const isLast = vue.computed(() => {
        if (parent) {
          const next = parent.children[index2.value + 1];
          return !(next && "isButton" in next);
        }
      });
      useExpose({
        isButton: true
      });
      return () => {
        const {
          type,
          icon,
          text,
          color,
          loading,
          disabled
        } = props2;
        return vue.createVNode(Button, {
          "class": bem$1z([type, {
            last: isLast.value,
            first: isFirst.value
          }]),
          "size": "large",
          "type": type,
          "icon": icon,
          "color": color,
          "loading": loading,
          "disabled": disabled,
          "onClick": route2
        }, {
          default: () => [slots.default ? slots.default() : text]
        });
      };
    }
  });
  const ActionBarButton = withInstall(stdin_default$1K);
  const [name$1D, bem$1y] = createNamespace("action-bar-icon");
  const actionBarIconProps = extend({}, routeProps, {
    dot: Boolean,
    text: String,
    icon: String,
    color: String,
    badge: numericProp,
    iconClass: unknownProp,
    badgeProps: Object,
    iconPrefix: String
  });
  var stdin_default$1J = vue.defineComponent({
    name: name$1D,
    props: actionBarIconProps,
    setup(props2, {
      slots
    }) {
      const route2 = useRoute();
      useParent(ACTION_BAR_KEY);
      const renderIcon = () => {
        const {
          dot,
          badge,
          icon,
          color,
          iconClass,
          badgeProps: badgeProps2,
          iconPrefix
        } = props2;
        if (slots.icon) {
          return vue.createVNode(Badge, vue.mergeProps({
            "dot": dot,
            "class": bem$1y("icon"),
            "content": badge
          }, badgeProps2), {
            default: slots.icon
          });
        }
        return vue.createVNode(Icon, {
          "tag": "div",
          "dot": dot,
          "name": icon,
          "badge": badge,
          "color": color,
          "class": [bem$1y("icon"), iconClass],
          "badgeProps": badgeProps2,
          "classPrefix": iconPrefix
        }, null);
      };
      return () => vue.createVNode("div", {
        "role": "button",
        "class": bem$1y(),
        "tabindex": 0,
        "onClick": route2
      }, [renderIcon(), slots.default ? slots.default() : props2.text]);
    }
  });
  const ActionBarIcon = withInstall(stdin_default$1J);
  const popupSharedProps = {
    // whether to show popup
    show: Boolean,
    // z-index
    zIndex: numericProp,
    // whether to show overlay
    overlay: truthProp,
    // transition duration
    duration: numericProp,
    // teleport
    teleport: [String, Object],
    // prevent body scroll
    lockScroll: truthProp,
    // whether to lazy render
    lazyRender: truthProp,
    // callback function before close
    beforeClose: Function,
    // overlay custom style
    overlayStyle: Object,
    // overlay custom class name
    overlayClass: unknownProp,
    // Initial rendering animation
    transitionAppear: Boolean,
    // whether to close popup when overlay is clicked
    closeOnClickOverlay: truthProp
  };
  const popupSharedPropKeys = Object.keys(
    popupSharedProps
  );
  function getDirection(x, y) {
    if (x > y) {
      return "horizontal";
    }
    if (y > x) {
      return "vertical";
    }
    return "";
  }
  function useTouch() {
    const startX = vue.ref(0);
    const startY = vue.ref(0);
    const deltaX = vue.ref(0);
    const deltaY = vue.ref(0);
    const offsetX = vue.ref(0);
    const offsetY = vue.ref(0);
    const direction = vue.ref("");
    const isTap = vue.ref(true);
    const isVertical = () => direction.value === "vertical";
    const isHorizontal = () => direction.value === "horizontal";
    const reset = () => {
      deltaX.value = 0;
      deltaY.value = 0;
      offsetX.value = 0;
      offsetY.value = 0;
      direction.value = "";
      isTap.value = true;
    };
    const start2 = (event) => {
      reset();
      startX.value = event.touches[0].clientX;
      startY.value = event.touches[0].clientY;
    };
    const move = (event) => {
      const touch = event.touches[0];
      deltaX.value = (touch.clientX < 0 ? 0 : touch.clientX) - startX.value;
      deltaY.value = touch.clientY - startY.value;
      offsetX.value = Math.abs(deltaX.value);
      offsetY.value = Math.abs(deltaY.value);
      const LOCK_DIRECTION_DISTANCE = 10;
      if (!direction.value || offsetX.value < LOCK_DIRECTION_DISTANCE && offsetY.value < LOCK_DIRECTION_DISTANCE) {
        direction.value = getDirection(offsetX.value, offsetY.value);
      }
      if (isTap.value && (offsetX.value > TAP_OFFSET || offsetY.value > TAP_OFFSET)) {
        isTap.value = false;
      }
    };
    return {
      move,
      start: start2,
      reset,
      startX,
      startY,
      deltaX,
      deltaY,
      offsetX,
      offsetY,
      direction,
      isVertical,
      isHorizontal,
      isTap
    };
  }
  let totalLockCount = 0;
  const BODY_LOCK_CLASS = "van-overflow-hidden";
  function useLockScroll(rootRef, shouldLock) {
    const touch = useTouch();
    const DIRECTION_UP = "01";
    const DIRECTION_DOWN = "10";
    const onTouchMove = (event) => {
      touch.move(event);
      const direction = touch.deltaY.value > 0 ? DIRECTION_DOWN : DIRECTION_UP;
      const el = getScrollParent$1(
        event.target,
        rootRef.value
      );
      const { scrollHeight, offsetHeight, scrollTop } = el;
      let status = "11";
      if (scrollTop === 0) {
        status = offsetHeight >= scrollHeight ? "00" : "01";
      } else if (scrollTop + offsetHeight >= scrollHeight) {
        status = "10";
      }
      if (status !== "11" && touch.isVertical() && !(parseInt(status, 2) & parseInt(direction, 2))) {
        preventDefault(event, true);
      }
    };
    const lock = () => {
      document.addEventListener("touchstart", touch.start);
      document.addEventListener("touchmove", onTouchMove, { passive: false });
      if (!totalLockCount) {
        document.body.classList.add(BODY_LOCK_CLASS);
      }
      totalLockCount++;
    };
    const unlock = () => {
      if (totalLockCount) {
        document.removeEventListener("touchstart", touch.start);
        document.removeEventListener("touchmove", onTouchMove);
        totalLockCount--;
        if (!totalLockCount) {
          document.body.classList.remove(BODY_LOCK_CLASS);
        }
      }
    };
    const init = () => shouldLock() && lock();
    const destroy = () => shouldLock() && unlock();
    onMountedOrActivated(init);
    vue.onDeactivated(destroy);
    vue.onBeforeUnmount(destroy);
    vue.watch(shouldLock, (value) => {
      value ? lock() : unlock();
    });
  }
  function useLazyRender(show) {
    const inited = vue.ref(false);
    vue.watch(
      show,
      (value) => {
        if (value) {
          inited.value = value;
        }
      },
      { immediate: true }
    );
    return (render) => () => inited.value ? render() : null;
  }
  const useScopeId = () => {
    var _a;
    const { scopeId } = ((_a = vue.getCurrentInstance()) == null ? void 0 : _a.vnode) || {};
    return scopeId ? { [scopeId]: "" } : null;
  };
  const [name$1C, bem$1x] = createNamespace("overlay");
  const overlayProps = {
    show: Boolean,
    zIndex: numericProp,
    duration: numericProp,
    className: unknownProp,
    lockScroll: truthProp,
    lazyRender: truthProp,
    customStyle: Object,
    teleport: [String, Object]
  };
  var stdin_default$1I = vue.defineComponent({
    name: name$1C,
    props: overlayProps,
    setup(props2, {
      slots
    }) {
      const root = vue.ref();
      const lazyRender = useLazyRender(() => props2.show || !props2.lazyRender);
      const onTouchMove = (event) => {
        if (props2.lockScroll) {
          preventDefault(event, true);
        }
      };
      const renderOverlay = lazyRender(() => {
        var _a;
        const style = extend(getZIndexStyle(props2.zIndex), props2.customStyle);
        if (isDef(props2.duration)) {
          style.animationDuration = `${props2.duration}s`;
        }
        return vue.withDirectives(vue.createVNode("div", {
          "ref": root,
          "style": style,
          "class": [bem$1x(), props2.className]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), [[vue.vShow, props2.show]]);
      });
      useEventListener("touchmove", onTouchMove, {
        target: root
      });
      return () => {
        const Content = vue.createVNode(vue.Transition, {
          "name": "van-fade",
          "appear": true
        }, {
          default: renderOverlay
        });
        if (props2.teleport) {
          return vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [Content]
          });
        }
        return Content;
      };
    }
  });
  const Overlay = withInstall(stdin_default$1I);
  const popupProps$2 = extend({}, popupSharedProps, {
    round: Boolean,
    position: makeStringProp("center"),
    closeIcon: makeStringProp("cross"),
    closeable: Boolean,
    transition: String,
    iconPrefix: String,
    closeOnPopstate: Boolean,
    closeIconPosition: makeStringProp("top-right"),
    safeAreaInsetTop: Boolean,
    safeAreaInsetBottom: Boolean
  });
  const [name$1B, bem$1w] = createNamespace("popup");
  var stdin_default$1H = vue.defineComponent({
    name: name$1B,
    inheritAttrs: false,
    props: popupProps$2,
    emits: ["open", "close", "opened", "closed", "keydown", "update:show", "clickOverlay", "clickCloseIcon"],
    setup(props2, {
      emit,
      attrs,
      slots
    }) {
      let opened;
      let shouldReopen;
      const zIndex = vue.ref();
      const popupRef = vue.ref();
      const lazyRender = useLazyRender(() => props2.show || !props2.lazyRender);
      const style = vue.computed(() => {
        const style2 = {
          zIndex: zIndex.value
        };
        if (isDef(props2.duration)) {
          const key = props2.position === "center" ? "animationDuration" : "transitionDuration";
          style2[key] = `${props2.duration}s`;
        }
        return style2;
      });
      const open2 = () => {
        if (!opened) {
          opened = true;
          zIndex.value = props2.zIndex !== void 0 ? +props2.zIndex : useGlobalZIndex();
          emit("open");
        }
      };
      const close = () => {
        if (opened) {
          callInterceptor(props2.beforeClose, {
            done() {
              opened = false;
              emit("close");
              emit("update:show", false);
            }
          });
        }
      };
      const onClickOverlay = (event) => {
        emit("clickOverlay", event);
        if (props2.closeOnClickOverlay) {
          close();
        }
      };
      const renderOverlay = () => {
        if (props2.overlay) {
          return vue.createVNode(Overlay, vue.mergeProps({
            "show": props2.show,
            "class": props2.overlayClass,
            "zIndex": zIndex.value,
            "duration": props2.duration,
            "customStyle": props2.overlayStyle,
            "role": props2.closeOnClickOverlay ? "button" : void 0,
            "tabindex": props2.closeOnClickOverlay ? 0 : void 0
          }, useScopeId(), {
            "onClick": onClickOverlay
          }), {
            default: slots["overlay-content"]
          });
        }
      };
      const onClickCloseIcon = (event) => {
        emit("clickCloseIcon", event);
        close();
      };
      const renderCloseIcon = () => {
        if (props2.closeable) {
          return vue.createVNode(Icon, {
            "role": "button",
            "tabindex": 0,
            "name": props2.closeIcon,
            "class": [bem$1w("close-icon", props2.closeIconPosition), HAPTICS_FEEDBACK],
            "classPrefix": props2.iconPrefix,
            "onClick": onClickCloseIcon
          }, null);
        }
      };
      let timer;
      const onOpened = () => {
        if (timer)
          clearTimeout(timer);
        timer = setTimeout(() => {
          emit("opened");
        });
      };
      const onClosed = () => emit("closed");
      const onKeydown = (event) => emit("keydown", event);
      const renderPopup = lazyRender(() => {
        var _a;
        const {
          round: round2,
          position,
          safeAreaInsetTop,
          safeAreaInsetBottom
        } = props2;
        return vue.withDirectives(vue.createVNode("div", vue.mergeProps({
          "ref": popupRef,
          "style": style.value,
          "role": "dialog",
          "tabindex": 0,
          "class": [bem$1w({
            round: round2,
            [position]: position
          }), {
            "van-safe-area-top": safeAreaInsetTop,
            "van-safe-area-bottom": safeAreaInsetBottom
          }],
          "onKeydown": onKeydown
        }, attrs, useScopeId()), [(_a = slots.default) == null ? void 0 : _a.call(slots), renderCloseIcon()]), [[vue.vShow, props2.show]]);
      });
      const renderTransition = () => {
        const {
          position,
          transition,
          transitionAppear
        } = props2;
        const name2 = position === "center" ? "van-fade" : `van-popup-slide-${position}`;
        return vue.createVNode(vue.Transition, {
          "name": transition || name2,
          "appear": transitionAppear,
          "onAfterEnter": onOpened,
          "onAfterLeave": onClosed
        }, {
          default: renderPopup
        });
      };
      vue.watch(() => props2.show, (show) => {
        if (show && !opened) {
          open2();
          if (attrs.tabindex === 0) {
            vue.nextTick(() => {
              var _a;
              (_a = popupRef.value) == null ? void 0 : _a.focus();
            });
          }
        }
        if (!show && opened) {
          opened = false;
          emit("close");
        }
      });
      useExpose({
        popupRef
      });
      useLockScroll(popupRef, () => props2.show && props2.lockScroll);
      useEventListener("popstate", () => {
        if (props2.closeOnPopstate) {
          close();
          shouldReopen = false;
        }
      });
      vue.onMounted(() => {
        if (props2.show) {
          open2();
        }
      });
      vue.onActivated(() => {
        if (shouldReopen) {
          emit("update:show", true);
          shouldReopen = false;
        }
      });
      vue.onDeactivated(() => {
        if (props2.show && props2.teleport) {
          close();
          shouldReopen = true;
        }
      });
      vue.provide(POPUP_TOGGLE_KEY, () => props2.show);
      return () => {
        if (props2.teleport) {
          return vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [renderOverlay(), renderTransition()]
          });
        }
        return vue.createVNode(vue.Fragment, null, [renderOverlay(), renderTransition()]);
      };
    }
  });
  const Popup = withInstall(stdin_default$1H);
  const [name$1A, bem$1v] = createNamespace("action-sheet");
  const actionSheetProps = extend({}, popupSharedProps, {
    title: String,
    round: truthProp,
    actions: makeArrayProp(),
    closeIcon: makeStringProp("cross"),
    closeable: truthProp,
    cancelText: String,
    description: String,
    closeOnPopstate: truthProp,
    closeOnClickAction: Boolean,
    safeAreaInsetBottom: truthProp
  });
  const popupInheritKeys$2 = [...popupSharedPropKeys, "round", "closeOnPopstate", "safeAreaInsetBottom"];
  var stdin_default$1G = vue.defineComponent({
    name: name$1A,
    props: actionSheetProps,
    emits: ["select", "cancel", "update:show"],
    setup(props2, {
      slots,
      emit
    }) {
      const updateShow = (show) => emit("update:show", show);
      const onCancel = () => {
        updateShow(false);
        emit("cancel");
      };
      const renderHeader = () => {
        if (props2.title) {
          return vue.createVNode("div", {
            "class": bem$1v("header")
          }, [props2.title, props2.closeable && vue.createVNode(Icon, {
            "name": props2.closeIcon,
            "class": [bem$1v("close"), HAPTICS_FEEDBACK],
            "onClick": onCancel
          }, null)]);
        }
      };
      const renderCancel = () => {
        if (slots.cancel || props2.cancelText) {
          return [vue.createVNode("div", {
            "class": bem$1v("gap")
          }, null), vue.createVNode("button", {
            "type": "button",
            "class": bem$1v("cancel"),
            "onClick": onCancel
          }, [slots.cancel ? slots.cancel() : props2.cancelText])];
        }
      };
      const renderIcon = (action) => {
        if (action.icon) {
          return vue.createVNode(Icon, {
            "class": bem$1v("item-icon"),
            "name": action.icon
          }, null);
        }
      };
      const renderActionContent = (action, index2) => {
        if (action.loading) {
          return vue.createVNode(Loading, {
            "class": bem$1v("loading-icon")
          }, null);
        }
        if (slots.action) {
          return slots.action({
            action,
            index: index2
          });
        }
        return [vue.createVNode("span", {
          "class": bem$1v("name")
        }, [action.name]), action.subname && vue.createVNode("div", {
          "class": bem$1v("subname")
        }, [action.subname])];
      };
      const renderAction = (action, index2) => {
        const {
          color,
          loading,
          callback,
          disabled,
          className
        } = action;
        const onClick = () => {
          if (disabled || loading) {
            return;
          }
          if (callback) {
            callback(action);
          }
          if (props2.closeOnClickAction) {
            updateShow(false);
          }
          vue.nextTick(() => emit("select", action, index2));
        };
        return vue.createVNode("button", {
          "type": "button",
          "style": {
            color
          },
          "class": [bem$1v("item", {
            loading,
            disabled
          }), className],
          "onClick": onClick
        }, [renderIcon(action), renderActionContent(action, index2)]);
      };
      const renderDescription = () => {
        if (props2.description || slots.description) {
          const content = slots.description ? slots.description() : props2.description;
          return vue.createVNode("div", {
            "class": bem$1v("description")
          }, [content]);
        }
      };
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": bem$1v(),
        "position": "bottom",
        "onUpdate:show": updateShow
      }, pick(props2, popupInheritKeys$2)), {
        default: () => {
          var _a;
          return [renderHeader(), renderDescription(), vue.createVNode("div", {
            "class": bem$1v("content")
          }, [props2.actions.map(renderAction), (_a = slots.default) == null ? void 0 : _a.call(slots)]), renderCancel()];
        }
      });
    }
  });
  const ActionSheet = withInstall(stdin_default$1G);
  const [name$1z, bem$1u, t$m] = createNamespace("picker");
  const getFirstEnabledOption = (options) => options.find((option) => !option.disabled) || options[0];
  function getColumnsType(columns, fields) {
    const firstColumn = columns[0];
    if (firstColumn) {
      if (Array.isArray(firstColumn)) {
        return "multiple";
      }
      if (fields.children in firstColumn) {
        return "cascade";
      }
    }
    return "default";
  }
  function findIndexOfEnabledOption(options, index2) {
    index2 = clamp(index2, 0, options.length);
    for (let i2 = index2; i2 < options.length; i2++) {
      if (!options[i2].disabled)
        return i2;
    }
    for (let i2 = index2 - 1; i2 >= 0; i2--) {
      if (!options[i2].disabled)
        return i2;
    }
    return 0;
  }
  const isOptionExist = (options, value, fields) => value !== void 0 && !!options.find((option) => option[fields.value] === value);
  function findOptionByValue(options, value, fields) {
    const index2 = options.findIndex((option) => option[fields.value] === value);
    const enabledIndex = findIndexOfEnabledOption(options, index2);
    return options[enabledIndex];
  }
  function formatCascadeColumns(columns, fields, selectedValues) {
    const formatted = [];
    let cursor = {
      [fields.children]: columns
    };
    let columnIndex = 0;
    while (cursor && cursor[fields.children]) {
      const options = cursor[fields.children];
      const value = selectedValues.value[columnIndex];
      cursor = isDef(value) ? findOptionByValue(options, value, fields) : void 0;
      if (!cursor && options.length) {
        const firstValue = getFirstEnabledOption(options)[fields.value];
        cursor = findOptionByValue(options, firstValue, fields);
      }
      columnIndex++;
      formatted.push(options);
    }
    return formatted;
  }
  function getElementTranslateY(element) {
    const { transform } = window.getComputedStyle(element);
    const translateY = transform.slice(7, transform.length - 1).split(", ")[5];
    return Number(translateY);
  }
  function assignDefaultFields(fields) {
    return extend(
      {
        text: "text",
        value: "value",
        children: "children"
      },
      fields
    );
  }
  const DEFAULT_DURATION = 200;
  const MOMENTUM_TIME = 300;
  const MOMENTUM_DISTANCE = 15;
  const [name$1y, bem$1t] = createNamespace("picker-column");
  const PICKER_KEY = Symbol(name$1y);
  var stdin_default$1F = vue.defineComponent({
    name: name$1y,
    props: {
      value: numericProp,
      fields: makeRequiredProp(Object),
      options: makeArrayProp(),
      readonly: Boolean,
      allowHtml: Boolean,
      optionHeight: makeRequiredProp(Number),
      swipeDuration: makeRequiredProp(numericProp),
      visibleOptionNum: makeRequiredProp(numericProp)
    },
    emits: ["change", "clickOption", "scrollInto"],
    setup(props2, {
      emit,
      slots
    }) {
      let moving;
      let startOffset;
      let touchStartTime;
      let momentumOffset;
      let transitionEndTrigger;
      const root = vue.ref();
      const wrapper = vue.ref();
      const currentOffset = vue.ref(0);
      const currentDuration = vue.ref(0);
      const touch = useTouch();
      const count = () => props2.options.length;
      const baseOffset = () => props2.optionHeight * (+props2.visibleOptionNum - 1) / 2;
      const updateValueByIndex = (index2) => {
        let enabledIndex = findIndexOfEnabledOption(props2.options, index2);
        const offset2 = -enabledIndex * props2.optionHeight;
        const trigger = () => {
          if (enabledIndex > count() - 1) {
            enabledIndex = findIndexOfEnabledOption(props2.options, index2);
          }
          const value = props2.options[enabledIndex][props2.fields.value];
          if (value !== props2.value) {
            emit("change", value);
          }
        };
        if (moving && offset2 !== currentOffset.value) {
          transitionEndTrigger = trigger;
        } else {
          trigger();
        }
        currentOffset.value = offset2;
      };
      const isReadonly = () => props2.readonly || !props2.options.length;
      const onClickOption = (index2) => {
        if (moving || isReadonly()) {
          return;
        }
        transitionEndTrigger = null;
        currentDuration.value = DEFAULT_DURATION;
        updateValueByIndex(index2);
        emit("clickOption", props2.options[index2]);
      };
      const getIndexByOffset = (offset2) => clamp(Math.round(-offset2 / props2.optionHeight), 0, count() - 1);
      const currentIndex = vue.computed(() => getIndexByOffset(currentOffset.value));
      const momentum = (distance, duration) => {
        const speed = Math.abs(distance / duration);
        distance = currentOffset.value + speed / 3e-3 * (distance < 0 ? -1 : 1);
        const index2 = getIndexByOffset(distance);
        currentDuration.value = +props2.swipeDuration;
        updateValueByIndex(index2);
      };
      const stopMomentum = () => {
        moving = false;
        currentDuration.value = 0;
        if (transitionEndTrigger) {
          transitionEndTrigger();
          transitionEndTrigger = null;
        }
      };
      const onTouchStart = (event) => {
        if (isReadonly()) {
          return;
        }
        touch.start(event);
        if (moving) {
          const translateY = getElementTranslateY(wrapper.value);
          currentOffset.value = Math.min(0, translateY - baseOffset());
        }
        currentDuration.value = 0;
        startOffset = currentOffset.value;
        touchStartTime = Date.now();
        momentumOffset = startOffset;
        transitionEndTrigger = null;
      };
      const onTouchMove = (event) => {
        if (isReadonly()) {
          return;
        }
        touch.move(event);
        if (touch.isVertical()) {
          moving = true;
          preventDefault(event, true);
        }
        const newOffset = clamp(startOffset + touch.deltaY.value, -(count() * props2.optionHeight), props2.optionHeight);
        const newIndex = getIndexByOffset(newOffset);
        if (newIndex !== currentIndex.value) {
          emit("scrollInto", props2.options[newIndex]);
        }
        currentOffset.value = newOffset;
        const now2 = Date.now();
        if (now2 - touchStartTime > MOMENTUM_TIME) {
          touchStartTime = now2;
          momentumOffset = newOffset;
        }
      };
      const onTouchEnd = () => {
        if (isReadonly()) {
          return;
        }
        const distance = currentOffset.value - momentumOffset;
        const duration = Date.now() - touchStartTime;
        const startMomentum = duration < MOMENTUM_TIME && Math.abs(distance) > MOMENTUM_DISTANCE;
        if (startMomentum) {
          momentum(distance, duration);
          return;
        }
        const index2 = getIndexByOffset(currentOffset.value);
        currentDuration.value = DEFAULT_DURATION;
        updateValueByIndex(index2);
        setTimeout(() => {
          moving = false;
        }, 0);
      };
      const renderOptions = () => {
        const optionStyle = {
          height: `${props2.optionHeight}px`
        };
        return props2.options.map((option, index2) => {
          const text = option[props2.fields.text];
          const {
            disabled
          } = option;
          const value = option[props2.fields.value];
          const data = {
            role: "button",
            style: optionStyle,
            tabindex: disabled ? -1 : 0,
            class: [bem$1t("item", {
              disabled,
              selected: value === props2.value
            }), option.className],
            onClick: () => onClickOption(index2)
          };
          const childData = {
            class: "van-ellipsis",
            [props2.allowHtml ? "innerHTML" : "textContent"]: text
          };
          return vue.createVNode("li", data, [slots.option ? slots.option(option, index2) : vue.createVNode("div", childData, null)]);
        });
      };
      useParent(PICKER_KEY);
      useExpose({
        stopMomentum
      });
      vue.watchEffect(() => {
        const index2 = moving ? Math.floor(-currentOffset.value / props2.optionHeight) : props2.options.findIndex((option) => option[props2.fields.value] === props2.value);
        const enabledIndex = findIndexOfEnabledOption(props2.options, index2);
        const offset2 = -enabledIndex * props2.optionHeight;
        if (moving && enabledIndex < index2)
          stopMomentum();
        currentOffset.value = offset2;
      });
      useEventListener("touchmove", onTouchMove, {
        target: root
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "class": bem$1t(),
        "onTouchstartPassive": onTouchStart,
        "onTouchend": onTouchEnd,
        "onTouchcancel": onTouchEnd
      }, [vue.createVNode("ul", {
        "ref": wrapper,
        "style": {
          transform: `translate3d(0, ${currentOffset.value + baseOffset()}px, 0)`,
          transitionDuration: `${currentDuration.value}ms`,
          transitionProperty: currentDuration.value ? "all" : "none"
        },
        "class": bem$1t("wrapper"),
        "onTransitionend": stopMomentum
      }, [renderOptions()])]);
    }
  });
  const [name$1x] = createNamespace("picker-toolbar");
  const pickerToolbarProps = {
    title: String,
    cancelButtonText: String,
    confirmButtonText: String
  };
  const pickerToolbarSlots = ["cancel", "confirm", "title", "toolbar"];
  const pickerToolbarPropKeys = Object.keys(pickerToolbarProps);
  var stdin_default$1E = vue.defineComponent({
    name: name$1x,
    props: pickerToolbarProps,
    emits: ["confirm", "cancel"],
    setup(props2, {
      emit,
      slots
    }) {
      const renderTitle = () => {
        if (slots.title) {
          return slots.title();
        }
        if (props2.title) {
          return vue.createVNode("div", {
            "class": [bem$1u("title"), "van-ellipsis"]
          }, [props2.title]);
        }
      };
      const onCancel = () => emit("cancel");
      const onConfirm = () => emit("confirm");
      const renderCancel = () => {
        var _a;
        const text = (_a = props2.cancelButtonText) != null ? _a : t$m("cancel");
        if (!slots.cancel && !text) {
          return;
        }
        return vue.createVNode("button", {
          "type": "button",
          "class": [bem$1u("cancel"), HAPTICS_FEEDBACK],
          "onClick": onCancel
        }, [slots.cancel ? slots.cancel() : text]);
      };
      const renderConfirm = () => {
        var _a;
        const text = (_a = props2.confirmButtonText) != null ? _a : t$m("confirm");
        if (!slots.confirm && !text) {
          return;
        }
        return vue.createVNode("button", {
          "type": "button",
          "class": [bem$1u("confirm"), HAPTICS_FEEDBACK],
          "onClick": onConfirm
        }, [slots.confirm ? slots.confirm() : text]);
      };
      return () => vue.createVNode("div", {
        "class": bem$1u("toolbar")
      }, [slots.toolbar ? slots.toolbar() : [renderCancel(), renderTitle(), renderConfirm()]]);
    }
  });
  const useSyncPropRef = (getProp, setProp) => {
    const propRef = vue.ref(getProp());
    vue.watch(getProp, (value) => {
      if (value !== propRef.value) {
        propRef.value = value;
      }
    });
    vue.watch(propRef, (value) => {
      if (value !== getProp()) {
        setProp(value);
      }
    });
    return propRef;
  };
  function scrollLeftTo(scroller, to, duration) {
    let rafId;
    let count = 0;
    const from = scroller.scrollLeft;
    const frames = duration === 0 ? 1 : Math.round(duration * 1e3 / 16);
    let scrollLeft = from;
    function cancel() {
      cancelRaf(rafId);
    }
    function animate() {
      scrollLeft += (to - from) / frames;
      scroller.scrollLeft = scrollLeft;
      if (++count < frames) {
        rafId = raf(animate);
      }
    }
    animate();
    return cancel;
  }
  function scrollTopTo(scroller, to, duration, callback) {
    let rafId;
    let current2 = getScrollTop(scroller);
    const isDown = current2 < to;
    const frames = duration === 0 ? 1 : Math.round(duration * 1e3 / 16);
    const step = (to - current2) / frames;
    function cancel() {
      cancelRaf(rafId);
    }
    function animate() {
      current2 += step;
      if (isDown && current2 > to || !isDown && current2 < to) {
        current2 = to;
      }
      setScrollTop(scroller, current2);
      if (isDown && current2 < to || !isDown && current2 > to) {
        rafId = raf(animate);
      } else if (callback) {
        rafId = raf(callback);
      }
    }
    animate();
    return cancel;
  }
  let current = 0;
  function useId() {
    const vm = vue.getCurrentInstance();
    const { name: name2 = "unknown" } = (vm == null ? void 0 : vm.type) || {};
    return `${name2}-${++current}`;
  }
  function useRefs() {
    const refs = vue.ref([]);
    const cache2 = [];
    vue.onBeforeUpdate(() => {
      refs.value = [];
    });
    const setRefs = (index2) => {
      if (!cache2[index2]) {
        cache2[index2] = (el) => {
          refs.value[index2] = el;
        };
      }
      return cache2[index2];
    };
    return [refs, setRefs];
  }
  function useVisibilityChange(target, onChange) {
    if (!inBrowser$1 || !window.IntersectionObserver) {
      return;
    }
    const observer = new IntersectionObserver(
      (entries) => {
        onChange(entries[0].intersectionRatio > 0);
      },
      { root: document.body }
    );
    const observe = () => {
      if (target.value) {
        observer.observe(target.value);
      }
    };
    const unobserve = () => {
      if (target.value) {
        observer.unobserve(target.value);
      }
    };
    vue.onDeactivated(unobserve);
    vue.onBeforeUnmount(unobserve);
    onMountedOrActivated(observe);
  }
  const [name$1w, bem$1s] = createNamespace("sticky");
  const stickyProps = {
    zIndex: numericProp,
    position: makeStringProp("top"),
    container: Object,
    offsetTop: makeNumericProp(0),
    offsetBottom: makeNumericProp(0)
  };
  var stdin_default$1D = vue.defineComponent({
    name: name$1w,
    props: stickyProps,
    emits: ["scroll", "change"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const scrollParent = useScrollParent(root);
      const state = vue.reactive({
        fixed: false,
        width: 0,
        // root width
        height: 0,
        // root height
        transform: 0
      });
      const isReset = vue.ref(false);
      const offset2 = vue.computed(() => unitToPx(props2.position === "top" ? props2.offsetTop : props2.offsetBottom));
      const rootStyle = vue.computed(() => {
        if (isReset.value) {
          return;
        }
        const {
          fixed,
          height: height2,
          width: width2
        } = state;
        if (fixed) {
          return {
            width: `${width2}px`,
            height: `${height2}px`
          };
        }
      });
      const stickyStyle = vue.computed(() => {
        if (!state.fixed || isReset.value) {
          return;
        }
        const style = extend(getZIndexStyle(props2.zIndex), {
          width: `${state.width}px`,
          height: `${state.height}px`,
          [props2.position]: `${offset2.value}px`
        });
        if (state.transform) {
          style.transform = `translate3d(0, ${state.transform}px, 0)`;
        }
        return style;
      });
      const emitScroll = (scrollTop) => emit("scroll", {
        scrollTop,
        isFixed: state.fixed
      });
      const onScroll = () => {
        if (!root.value || isHidden(root)) {
          return;
        }
        const {
          container,
          position
        } = props2;
        const rootRect = useRect(root);
        const scrollTop = getScrollTop(window);
        state.width = rootRect.width;
        state.height = rootRect.height;
        if (position === "top") {
          if (container) {
            const containerRect = useRect(container);
            const difference = containerRect.bottom - offset2.value - state.height;
            state.fixed = offset2.value > rootRect.top && containerRect.bottom > 0;
            state.transform = difference < 0 ? difference : 0;
          } else {
            state.fixed = offset2.value > rootRect.top;
          }
        } else {
          const {
            clientHeight
          } = document.documentElement;
          if (container) {
            const containerRect = useRect(container);
            const difference = clientHeight - containerRect.top - offset2.value - state.height;
            state.fixed = clientHeight - offset2.value < rootRect.bottom && clientHeight > containerRect.top;
            state.transform = difference < 0 ? -difference : 0;
          } else {
            state.fixed = clientHeight - offset2.value < rootRect.bottom;
          }
        }
        emitScroll(scrollTop);
      };
      vue.watch(() => state.fixed, (value) => emit("change", value));
      useEventListener("scroll", onScroll, {
        target: scrollParent,
        passive: true
      });
      useVisibilityChange(root, onScroll);
      vue.watch([windowWidth, windowHeight], () => {
        if (!root.value || isHidden(root) || !state.fixed) {
          return;
        }
        isReset.value = true;
        vue.nextTick(() => {
          const rootRect = useRect(root);
          state.width = rootRect.width;
          state.height = rootRect.height;
          isReset.value = false;
        });
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "style": rootStyle.value
        }, [vue.createVNode("div", {
          "class": bem$1s({
            fixed: state.fixed && !isReset.value
          }),
          "style": stickyStyle.value
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
      };
    }
  });
  const Sticky = withInstall(stdin_default$1D);
  const [name$1v, bem$1r] = createNamespace("swipe");
  const swipeProps = {
    loop: truthProp,
    width: numericProp,
    height: numericProp,
    vertical: Boolean,
    autoplay: makeNumericProp(0),
    duration: makeNumericProp(500),
    touchable: truthProp,
    lazyRender: Boolean,
    initialSwipe: makeNumericProp(0),
    indicatorColor: String,
    showIndicators: truthProp,
    stopPropagation: truthProp
  };
  const SWIPE_KEY = Symbol(name$1v);
  var stdin_default$1C = vue.defineComponent({
    name: name$1v,
    props: swipeProps,
    emits: ["change", "dragStart", "dragEnd"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const track = vue.ref();
      const state = vue.reactive({
        rect: null,
        width: 0,
        height: 0,
        offset: 0,
        active: 0,
        swiping: false
      });
      let dragging = false;
      const touch = useTouch();
      const {
        children,
        linkChildren
      } = useChildren(SWIPE_KEY);
      const count = vue.computed(() => children.length);
      const size = vue.computed(() => state[props2.vertical ? "height" : "width"]);
      const delta = vue.computed(() => props2.vertical ? touch.deltaY.value : touch.deltaX.value);
      const minOffset = vue.computed(() => {
        if (state.rect) {
          const base = props2.vertical ? state.rect.height : state.rect.width;
          return base - size.value * count.value;
        }
        return 0;
      });
      const maxCount = vue.computed(() => size.value ? Math.ceil(Math.abs(minOffset.value) / size.value) : count.value);
      const trackSize = vue.computed(() => count.value * size.value);
      const activeIndicator = vue.computed(() => (state.active + count.value) % count.value);
      const isCorrectDirection = vue.computed(() => {
        const expect = props2.vertical ? "vertical" : "horizontal";
        return touch.direction.value === expect;
      });
      const trackStyle = vue.computed(() => {
        const style = {
          transitionDuration: `${state.swiping ? 0 : props2.duration}ms`,
          transform: `translate${props2.vertical ? "Y" : "X"}(${+state.offset.toFixed(2)}px)`
        };
        if (size.value) {
          const mainAxis = props2.vertical ? "height" : "width";
          const crossAxis = props2.vertical ? "width" : "height";
          style[mainAxis] = `${trackSize.value}px`;
          style[crossAxis] = props2[crossAxis] ? `${props2[crossAxis]}px` : "";
        }
        return style;
      });
      const getTargetActive = (pace) => {
        const {
          active
        } = state;
        if (pace) {
          if (props2.loop) {
            return clamp(active + pace, -1, count.value);
          }
          return clamp(active + pace, 0, maxCount.value);
        }
        return active;
      };
      const getTargetOffset = (targetActive, offset2 = 0) => {
        let currentPosition = targetActive * size.value;
        if (!props2.loop) {
          currentPosition = Math.min(currentPosition, -minOffset.value);
        }
        let targetOffset = offset2 - currentPosition;
        if (!props2.loop) {
          targetOffset = clamp(targetOffset, minOffset.value, 0);
        }
        return targetOffset;
      };
      const move = ({
        pace = 0,
        offset: offset2 = 0,
        emitChange
      }) => {
        if (count.value <= 1) {
          return;
        }
        const {
          active
        } = state;
        const targetActive = getTargetActive(pace);
        const targetOffset = getTargetOffset(targetActive, offset2);
        if (props2.loop) {
          if (children[0] && targetOffset !== minOffset.value) {
            const outRightBound = targetOffset < minOffset.value;
            children[0].setOffset(outRightBound ? trackSize.value : 0);
          }
          if (children[count.value - 1] && targetOffset !== 0) {
            const outLeftBound = targetOffset > 0;
            children[count.value - 1].setOffset(outLeftBound ? -trackSize.value : 0);
          }
        }
        state.active = targetActive;
        state.offset = targetOffset;
        if (emitChange && targetActive !== active) {
          emit("change", activeIndicator.value);
        }
      };
      const correctPosition = () => {
        state.swiping = true;
        if (state.active <= -1) {
          move({
            pace: count.value
          });
        } else if (state.active >= count.value) {
          move({
            pace: -count.value
          });
        }
      };
      const prev = () => {
        correctPosition();
        touch.reset();
        doubleRaf(() => {
          state.swiping = false;
          move({
            pace: -1,
            emitChange: true
          });
        });
      };
      const next = () => {
        correctPosition();
        touch.reset();
        doubleRaf(() => {
          state.swiping = false;
          move({
            pace: 1,
            emitChange: true
          });
        });
      };
      let autoplayTimer;
      const stopAutoplay = () => clearTimeout(autoplayTimer);
      const autoplay = () => {
        stopAutoplay();
        if (+props2.autoplay > 0 && count.value > 1) {
          autoplayTimer = setTimeout(() => {
            next();
            autoplay();
          }, +props2.autoplay);
        }
      };
      const initialize = (active = +props2.initialSwipe) => {
        if (!root.value) {
          return;
        }
        const cb = () => {
          var _a, _b;
          if (!isHidden(root)) {
            const rect = {
              width: root.value.offsetWidth,
              height: root.value.offsetHeight
            };
            state.rect = rect;
            state.width = +((_a = props2.width) != null ? _a : rect.width);
            state.height = +((_b = props2.height) != null ? _b : rect.height);
          }
          if (count.value) {
            active = Math.min(count.value - 1, active);
            if (active === -1) {
              active = count.value - 1;
            }
          }
          state.active = active;
          state.swiping = true;
          state.offset = getTargetOffset(active);
          children.forEach((swipe) => {
            swipe.setOffset(0);
          });
          autoplay();
        };
        if (isHidden(root)) {
          vue.nextTick().then(cb);
        } else {
          cb();
        }
      };
      const resize = () => initialize(state.active);
      let touchStartTime;
      const onTouchStart = (event) => {
        if (!props2.touchable || // avoid resetting position on multi-finger touch
        event.touches.length > 1)
          return;
        touch.start(event);
        dragging = false;
        touchStartTime = Date.now();
        stopAutoplay();
        correctPosition();
      };
      const onTouchMove = (event) => {
        if (props2.touchable && state.swiping) {
          touch.move(event);
          if (isCorrectDirection.value) {
            const isEdgeTouch = !props2.loop && (state.active === 0 && delta.value > 0 || state.active === count.value - 1 && delta.value < 0);
            if (!isEdgeTouch) {
              preventDefault(event, props2.stopPropagation);
              move({
                offset: delta.value
              });
              if (!dragging) {
                emit("dragStart", {
                  index: activeIndicator.value
                });
                dragging = true;
              }
            }
          }
        }
      };
      const onTouchEnd = () => {
        if (!props2.touchable || !state.swiping) {
          return;
        }
        const duration = Date.now() - touchStartTime;
        const speed = delta.value / duration;
        const shouldSwipe = Math.abs(speed) > 0.25 || Math.abs(delta.value) > size.value / 2;
        if (shouldSwipe && isCorrectDirection.value) {
          const offset2 = props2.vertical ? touch.offsetY.value : touch.offsetX.value;
          let pace = 0;
          if (props2.loop) {
            pace = offset2 > 0 ? delta.value > 0 ? -1 : 1 : 0;
          } else {
            pace = -Math[delta.value > 0 ? "ceil" : "floor"](delta.value / size.value);
          }
          move({
            pace,
            emitChange: true
          });
        } else if (delta.value) {
          move({
            pace: 0
          });
        }
        dragging = false;
        state.swiping = false;
        emit("dragEnd", {
          index: activeIndicator.value
        });
        autoplay();
      };
      const swipeTo = (index2, options = {}) => {
        correctPosition();
        touch.reset();
        doubleRaf(() => {
          let targetIndex;
          if (props2.loop && index2 === count.value) {
            targetIndex = state.active === 0 ? 0 : index2;
          } else {
            targetIndex = index2 % count.value;
          }
          if (options.immediate) {
            doubleRaf(() => {
              state.swiping = false;
            });
          } else {
            state.swiping = false;
          }
          move({
            pace: targetIndex - state.active,
            emitChange: true
          });
        });
      };
      const renderDot = (_, index2) => {
        const active = index2 === activeIndicator.value;
        const style = active ? {
          backgroundColor: props2.indicatorColor
        } : void 0;
        return vue.createVNode("i", {
          "style": style,
          "class": bem$1r("indicator", {
            active
          })
        }, null);
      };
      const renderIndicator = () => {
        if (slots.indicator) {
          return slots.indicator({
            active: activeIndicator.value,
            total: count.value
          });
        }
        if (props2.showIndicators && count.value > 1) {
          return vue.createVNode("div", {
            "class": bem$1r("indicators", {
              vertical: props2.vertical
            })
          }, [Array(count.value).fill("").map(renderDot)]);
        }
      };
      useExpose({
        prev,
        next,
        state,
        resize,
        swipeTo
      });
      linkChildren({
        size,
        props: props2,
        count,
        activeIndicator
      });
      vue.watch(() => props2.initialSwipe, (value) => initialize(+value));
      vue.watch(count, () => initialize(state.active));
      vue.watch(() => props2.autoplay, autoplay);
      vue.watch([windowWidth, windowHeight, () => props2.width, () => props2.height], resize);
      vue.watch(usePageVisibility(), (visible) => {
        if (visible === "visible") {
          autoplay();
        } else {
          stopAutoplay();
        }
      });
      vue.onMounted(initialize);
      vue.onActivated(() => initialize(state.active));
      onPopupReopen(() => initialize(state.active));
      vue.onDeactivated(stopAutoplay);
      vue.onBeforeUnmount(stopAutoplay);
      useEventListener("touchmove", onTouchMove, {
        target: track
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$1r()
        }, [vue.createVNode("div", {
          "ref": track,
          "style": trackStyle.value,
          "class": bem$1r("track", {
            vertical: props2.vertical
          }),
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), renderIndicator()]);
      };
    }
  });
  const Swipe = withInstall(stdin_default$1C);
  const [name$1u, bem$1q] = createNamespace("tabs");
  var stdin_default$1B = vue.defineComponent({
    name: name$1u,
    props: {
      count: makeRequiredProp(Number),
      inited: Boolean,
      animated: Boolean,
      duration: makeRequiredProp(numericProp),
      swipeable: Boolean,
      lazyRender: Boolean,
      currentIndex: makeRequiredProp(Number)
    },
    emits: ["change"],
    setup(props2, {
      emit,
      slots
    }) {
      const swipeRef = vue.ref();
      const onChange = (index2) => emit("change", index2);
      const renderChildren = () => {
        var _a;
        const Content = (_a = slots.default) == null ? void 0 : _a.call(slots);
        if (props2.animated || props2.swipeable) {
          return vue.createVNode(Swipe, {
            "ref": swipeRef,
            "loop": false,
            "class": bem$1q("track"),
            "duration": +props2.duration * 1e3,
            "touchable": props2.swipeable,
            "lazyRender": props2.lazyRender,
            "showIndicators": false,
            "onChange": onChange
          }, {
            default: () => [Content]
          });
        }
        return Content;
      };
      const swipeToCurrentTab = (index2) => {
        const swipe = swipeRef.value;
        if (swipe && swipe.state.active !== index2) {
          swipe.swipeTo(index2, {
            immediate: !props2.inited
          });
        }
      };
      vue.watch(() => props2.currentIndex, swipeToCurrentTab);
      vue.onMounted(() => {
        swipeToCurrentTab(props2.currentIndex);
      });
      useExpose({
        swipeRef
      });
      return () => vue.createVNode("div", {
        "class": bem$1q("content", {
          animated: props2.animated || props2.swipeable
        })
      }, [renderChildren()]);
    }
  });
  const [name$1t, bem$1p] = createNamespace("tabs");
  const tabsProps = {
    type: makeStringProp("line"),
    color: String,
    border: Boolean,
    sticky: Boolean,
    shrink: Boolean,
    active: makeNumericProp(0),
    duration: makeNumericProp(0.3),
    animated: Boolean,
    ellipsis: truthProp,
    swipeable: Boolean,
    scrollspy: Boolean,
    offsetTop: makeNumericProp(0),
    background: String,
    lazyRender: truthProp,
    showHeader: truthProp,
    lineWidth: numericProp,
    lineHeight: numericProp,
    beforeChange: Function,
    swipeThreshold: makeNumericProp(5),
    titleActiveColor: String,
    titleInactiveColor: String
  };
  const TABS_KEY = Symbol(name$1t);
  var stdin_default$1A = vue.defineComponent({
    name: name$1t,
    props: tabsProps,
    emits: ["change", "scroll", "rendered", "clickTab", "update:active"],
    setup(props2, {
      emit,
      slots
    }) {
      let tabHeight;
      let lockScroll;
      let stickyFixed;
      let cancelScrollLeftToRaf;
      let cancelScrollTopToRaf;
      const root = vue.ref();
      const navRef = vue.ref();
      const wrapRef = vue.ref();
      const contentRef = vue.ref();
      const id = useId();
      const scroller = useScrollParent(root);
      const [titleRefs, setTitleRefs] = useRefs();
      const {
        children,
        linkChildren
      } = useChildren(TABS_KEY);
      const state = vue.reactive({
        inited: false,
        position: "",
        lineStyle: {},
        currentIndex: -1
      });
      const scrollable = vue.computed(() => children.length > +props2.swipeThreshold || !props2.ellipsis || props2.shrink);
      const navStyle = vue.computed(() => ({
        borderColor: props2.color,
        background: props2.background
      }));
      const getTabName = (tab, index2) => {
        var _a;
        return (_a = tab.name) != null ? _a : index2;
      };
      const currentName = vue.computed(() => {
        const activeTab = children[state.currentIndex];
        if (activeTab) {
          return getTabName(activeTab, state.currentIndex);
        }
      });
      const offsetTopPx = vue.computed(() => unitToPx(props2.offsetTop));
      const scrollOffset = vue.computed(() => {
        if (props2.sticky) {
          return offsetTopPx.value + tabHeight;
        }
        return 0;
      });
      const scrollIntoView = (immediate) => {
        const nav = navRef.value;
        const titles = titleRefs.value;
        if (!scrollable.value || !nav || !titles || !titles[state.currentIndex]) {
          return;
        }
        const title = titles[state.currentIndex].$el;
        const to = title.offsetLeft - (nav.offsetWidth - title.offsetWidth) / 2;
        if (cancelScrollLeftToRaf)
          cancelScrollLeftToRaf();
        cancelScrollLeftToRaf = scrollLeftTo(nav, to, immediate ? 0 : +props2.duration);
      };
      const setLine = () => {
        const shouldAnimate = state.inited;
        vue.nextTick(() => {
          const titles = titleRefs.value;
          if (!titles || !titles[state.currentIndex] || props2.type !== "line" || isHidden(root.value)) {
            return;
          }
          const title = titles[state.currentIndex].$el;
          const {
            lineWidth,
            lineHeight
          } = props2;
          const left2 = title.offsetLeft + title.offsetWidth / 2;
          const lineStyle = {
            width: addUnit$2(lineWidth),
            backgroundColor: props2.color,
            transform: `translateX(${left2}px) translateX(-50%)`
          };
          if (shouldAnimate) {
            lineStyle.transitionDuration = `${props2.duration}s`;
          }
          if (isDef(lineHeight)) {
            const height2 = addUnit$2(lineHeight);
            lineStyle.height = height2;
            lineStyle.borderRadius = height2;
          }
          state.lineStyle = lineStyle;
        });
      };
      const findAvailableTab = (index2) => {
        const diff = index2 < state.currentIndex ? -1 : 1;
        while (index2 >= 0 && index2 < children.length) {
          if (!children[index2].disabled) {
            return index2;
          }
          index2 += diff;
        }
      };
      const setCurrentIndex = (currentIndex, skipScrollIntoView) => {
        const newIndex = findAvailableTab(currentIndex);
        if (!isDef(newIndex)) {
          return;
        }
        const newTab = children[newIndex];
        const newName = getTabName(newTab, newIndex);
        const shouldEmitChange = state.currentIndex !== null;
        if (state.currentIndex !== newIndex) {
          state.currentIndex = newIndex;
          if (!skipScrollIntoView) {
            scrollIntoView();
          }
          setLine();
        }
        if (newName !== props2.active) {
          emit("update:active", newName);
          if (shouldEmitChange) {
            emit("change", newName, newTab.title);
          }
        }
        if (stickyFixed && !props2.scrollspy) {
          setRootScrollTop(Math.ceil(getElementTop(root.value) - offsetTopPx.value));
        }
      };
      const setCurrentIndexByName = (name2, skipScrollIntoView) => {
        const matched = children.find((tab, index22) => getTabName(tab, index22) === name2);
        const index2 = matched ? children.indexOf(matched) : 0;
        setCurrentIndex(index2, skipScrollIntoView);
      };
      const scrollToCurrentContent = (immediate = false) => {
        if (props2.scrollspy) {
          const target = children[state.currentIndex].$el;
          if (target && scroller.value) {
            const to = getElementTop(target, scroller.value) - scrollOffset.value;
            lockScroll = true;
            if (cancelScrollTopToRaf)
              cancelScrollTopToRaf();
            cancelScrollTopToRaf = scrollTopTo(scroller.value, to, immediate ? 0 : +props2.duration, () => {
              lockScroll = false;
            });
          }
        }
      };
      const onClickTab = (item, index2, event) => {
        const {
          title,
          disabled
        } = children[index2];
        const name2 = getTabName(children[index2], index2);
        if (!disabled) {
          callInterceptor(props2.beforeChange, {
            args: [name2],
            done: () => {
              setCurrentIndex(index2);
              scrollToCurrentContent();
            }
          });
          route$1(item);
        }
        emit("clickTab", {
          name: name2,
          title,
          event,
          disabled
        });
      };
      const onStickyScroll = (params) => {
        stickyFixed = params.isFixed;
        emit("scroll", params);
      };
      const scrollTo = (name2) => {
        vue.nextTick(() => {
          setCurrentIndexByName(name2);
          scrollToCurrentContent(true);
        });
      };
      const getCurrentIndexOnScroll = () => {
        for (let index2 = 0; index2 < children.length; index2++) {
          const {
            top: top2
          } = useRect(children[index2].$el);
          if (top2 > scrollOffset.value) {
            return index2 === 0 ? 0 : index2 - 1;
          }
        }
        return children.length - 1;
      };
      const onScroll = () => {
        if (props2.scrollspy && !lockScroll) {
          const index2 = getCurrentIndexOnScroll();
          setCurrentIndex(index2);
        }
      };
      const renderLine = () => {
        if (props2.type === "line" && children.length) {
          return vue.createVNode("div", {
            "class": bem$1p("line"),
            "style": state.lineStyle
          }, null);
        }
      };
      const renderHeader = () => {
        var _a, _b, _c;
        const {
          type,
          border,
          sticky
        } = props2;
        const Header = [vue.createVNode("div", {
          "ref": sticky ? void 0 : wrapRef,
          "class": [bem$1p("wrap"), {
            [BORDER_TOP_BOTTOM]: type === "line" && border
          }]
        }, [vue.createVNode("div", {
          "ref": navRef,
          "role": "tablist",
          "class": bem$1p("nav", [type, {
            shrink: props2.shrink,
            complete: scrollable.value
          }]),
          "style": navStyle.value,
          "aria-orientation": "horizontal"
        }, [(_a = slots["nav-left"]) == null ? void 0 : _a.call(slots), children.map((item) => item.renderTitle(onClickTab)), renderLine(), (_b = slots["nav-right"]) == null ? void 0 : _b.call(slots)])]), (_c = slots["nav-bottom"]) == null ? void 0 : _c.call(slots)];
        if (sticky) {
          return vue.createVNode("div", {
            "ref": wrapRef
          }, [Header]);
        }
        return Header;
      };
      const resize = () => {
        setLine();
        vue.nextTick(() => {
          var _a, _b;
          scrollIntoView(true);
          (_b = (_a = contentRef.value) == null ? void 0 : _a.swipeRef.value) == null ? void 0 : _b.resize();
        });
      };
      vue.watch(() => [props2.color, props2.duration, props2.lineWidth, props2.lineHeight], setLine);
      vue.watch(windowWidth, resize);
      vue.watch(() => props2.active, (value) => {
        if (value !== currentName.value) {
          setCurrentIndexByName(value);
        }
      });
      vue.watch(() => children.length, () => {
        if (state.inited) {
          setCurrentIndexByName(props2.active);
          setLine();
          vue.nextTick(() => {
            scrollIntoView(true);
          });
        }
      });
      const init = () => {
        setCurrentIndexByName(props2.active, true);
        vue.nextTick(() => {
          state.inited = true;
          if (wrapRef.value) {
            tabHeight = useRect(wrapRef.value).height;
          }
          scrollIntoView(true);
        });
      };
      const onRendered = (name2, title) => emit("rendered", name2, title);
      useExpose({
        resize,
        scrollTo
      });
      vue.onActivated(setLine);
      onPopupReopen(setLine);
      onMountedOrActivated(init);
      useVisibilityChange(root, setLine);
      useEventListener("scroll", onScroll, {
        target: scroller,
        passive: true
      });
      linkChildren({
        id,
        props: props2,
        setLine,
        scrollable,
        onRendered,
        currentName,
        setTitleRefs,
        scrollIntoView
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "class": bem$1p([props2.type])
      }, [props2.showHeader ? props2.sticky ? vue.createVNode(Sticky, {
        "container": root.value,
        "offsetTop": offsetTopPx.value,
        "onScroll": onStickyScroll
      }, {
        default: () => [renderHeader()]
      }) : renderHeader() : null, vue.createVNode(stdin_default$1B, {
        "ref": contentRef,
        "count": children.length,
        "inited": state.inited,
        "animated": props2.animated,
        "duration": props2.duration,
        "swipeable": props2.swipeable,
        "lazyRender": props2.lazyRender,
        "currentIndex": state.currentIndex,
        "onChange": setCurrentIndex
      }, {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      })]);
    }
  });
  const TAB_STATUS_KEY = Symbol();
  const useTabStatus = () => vue.inject(TAB_STATUS_KEY, null);
  const [name$1s, bem$1o] = createNamespace("tab");
  const TabTitle = vue.defineComponent({
    name: name$1s,
    props: {
      id: String,
      dot: Boolean,
      type: String,
      color: String,
      title: String,
      badge: numericProp,
      shrink: Boolean,
      isActive: Boolean,
      disabled: Boolean,
      controls: String,
      scrollable: Boolean,
      activeColor: String,
      inactiveColor: String,
      showZeroBadge: truthProp
    },
    setup(props2, {
      slots
    }) {
      const style = vue.computed(() => {
        const style2 = {};
        const {
          type,
          color,
          disabled,
          isActive,
          activeColor,
          inactiveColor
        } = props2;
        const isCard = type === "card";
        if (color && isCard) {
          style2.borderColor = color;
          if (!disabled) {
            if (isActive) {
              style2.backgroundColor = color;
            } else {
              style2.color = color;
            }
          }
        }
        const titleColor = isActive ? activeColor : inactiveColor;
        if (titleColor) {
          style2.color = titleColor;
        }
        return style2;
      });
      const renderText = () => {
        const Text = vue.createVNode("span", {
          "class": bem$1o("text", {
            ellipsis: !props2.scrollable
          })
        }, [slots.title ? slots.title() : props2.title]);
        if (props2.dot || isDef(props2.badge) && props2.badge !== "") {
          return vue.createVNode(Badge, {
            "dot": props2.dot,
            "content": props2.badge,
            "showZero": props2.showZeroBadge
          }, {
            default: () => [Text]
          });
        }
        return Text;
      };
      return () => vue.createVNode("div", {
        "id": props2.id,
        "role": "tab",
        "class": [bem$1o([props2.type, {
          grow: props2.scrollable && !props2.shrink,
          shrink: props2.shrink,
          active: props2.isActive,
          disabled: props2.disabled
        }])],
        "style": style.value,
        "tabindex": props2.disabled ? void 0 : props2.isActive ? 0 : -1,
        "aria-selected": props2.isActive,
        "aria-disabled": props2.disabled || void 0,
        "aria-controls": props2.controls,
        "data-allow-mismatch": "attribute"
      }, [renderText()]);
    }
  });
  const [name$1r, bem$1n] = createNamespace("swipe-item");
  var stdin_default$1z = vue.defineComponent({
    name: name$1r,
    setup(props2, {
      slots
    }) {
      let rendered;
      const state = vue.reactive({
        offset: 0,
        inited: false,
        mounted: false
      });
      const {
        parent,
        index: index2
      } = useParent(SWIPE_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/swipe-item/SwipeItem.mjs:24", "[Vant] <SwipeItem> must be a child component of <Swipe>.");
        }
        return;
      }
      const style = vue.computed(() => {
        const style2 = {};
        const {
          vertical
        } = parent.props;
        if (parent.size.value) {
          style2[vertical ? "height" : "width"] = `${parent.size.value}px`;
        }
        if (state.offset) {
          style2.transform = `translate${vertical ? "Y" : "X"}(${state.offset}px)`;
        }
        return style2;
      });
      const shouldRender = vue.computed(() => {
        const {
          loop,
          lazyRender
        } = parent.props;
        if (!lazyRender || rendered) {
          return true;
        }
        if (!state.mounted) {
          return false;
        }
        const active = parent.activeIndicator.value;
        const maxActive = parent.count.value - 1;
        const prevActive = active === 0 && loop ? maxActive : active - 1;
        const nextActive = active === maxActive && loop ? 0 : active + 1;
        rendered = index2.value === active || index2.value === prevActive || index2.value === nextActive;
        return rendered;
      });
      const setOffset = (offset2) => {
        state.offset = offset2;
      };
      vue.onMounted(() => {
        vue.nextTick(() => {
          state.mounted = true;
        });
      });
      useExpose({
        setOffset
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$1n(),
          "style": style.value
        }, [shouldRender.value ? (_a = slots.default) == null ? void 0 : _a.call(slots) : null]);
      };
    }
  });
  const SwipeItem = withInstall(stdin_default$1z);
  const [name$1q, bem$1m] = createNamespace("tab");
  const tabProps = extend({}, routeProps, {
    dot: Boolean,
    name: numericProp,
    badge: numericProp,
    title: String,
    disabled: Boolean,
    titleClass: unknownProp,
    titleStyle: [String, Object],
    showZeroBadge: truthProp
  });
  var stdin_default$1y = vue.defineComponent({
    name: name$1q,
    props: tabProps,
    setup(props2, {
      slots
    }) {
      const id = useId();
      const inited = vue.ref(false);
      const instance2 = vue.getCurrentInstance();
      const {
        parent,
        index: index2
      } = useParent(TABS_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/tab/Tab.mjs:38", "[Vant] <Tab> must be a child component of <Tabs>.");
        }
        return;
      }
      const getName = () => {
        var _a;
        return (_a = props2.name) != null ? _a : index2.value;
      };
      const init = () => {
        inited.value = true;
        if (parent.props.lazyRender) {
          vue.nextTick(() => {
            parent.onRendered(getName(), props2.title);
          });
        }
      };
      const active = vue.computed(() => {
        const isActive = getName() === parent.currentName.value;
        if (isActive && !inited.value) {
          init();
        }
        return isActive;
      });
      const parsedClass = vue.ref("");
      const parsedStyle = vue.ref("");
      vue.watchEffect(() => {
        const {
          titleClass,
          titleStyle
        } = props2;
        parsedClass.value = titleClass ? shared.normalizeClass(titleClass) : "";
        parsedStyle.value = titleStyle && typeof titleStyle !== "string" ? shared.stringifyStyle(shared.normalizeStyle(titleStyle)) : titleStyle;
      });
      const renderTitle = (onClickTab) => vue.createVNode(TabTitle, vue.mergeProps({
        "key": id,
        "id": `${parent.id}-${index2.value}`,
        "ref": parent.setTitleRefs(index2.value),
        "style": parsedStyle.value,
        "class": parsedClass.value,
        "isActive": active.value,
        "controls": id,
        "scrollable": parent.scrollable.value,
        "activeColor": parent.props.titleActiveColor,
        "inactiveColor": parent.props.titleInactiveColor,
        "onClick": (event) => onClickTab(instance2.proxy, index2.value, event)
      }, pick(parent.props, ["type", "color", "shrink"]), pick(props2, ["dot", "badge", "title", "disabled", "showZeroBadge"])), {
        title: slots.title
      });
      const hasInactiveClass = vue.ref(!active.value);
      vue.watch(active, (val) => {
        if (val) {
          hasInactiveClass.value = false;
        } else {
          doubleRaf(() => {
            hasInactiveClass.value = true;
          });
        }
      });
      vue.watch(() => props2.title, () => {
        parent.setLine();
        parent.scrollIntoView();
      });
      vue.provide(TAB_STATUS_KEY, active);
      useExpose({
        id,
        renderTitle
      });
      return () => {
        var _a;
        const label = `${parent.id}-${index2.value}`;
        const {
          animated,
          swipeable,
          scrollspy,
          lazyRender
        } = parent.props;
        if (!slots.default && !animated) {
          return;
        }
        const show = scrollspy || active.value;
        if (animated || swipeable) {
          return vue.createVNode(SwipeItem, {
            "id": id,
            "role": "tabpanel",
            "class": bem$1m("panel-wrapper", {
              inactive: hasInactiveClass.value
            }),
            "tabindex": active.value ? 0 : -1,
            "aria-hidden": !active.value,
            "aria-labelledby": label,
            "data-allow-mismatch": "attribute"
          }, {
            default: () => {
              var _a2;
              return [vue.createVNode("div", {
                "class": bem$1m("panel")
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])];
            }
          });
        }
        const shouldRender = inited.value || scrollspy || !lazyRender;
        const Content = shouldRender ? (_a = slots.default) == null ? void 0 : _a.call(slots) : null;
        return vue.withDirectives(vue.createVNode("div", {
          "id": id,
          "role": "tabpanel",
          "class": bem$1m("panel"),
          "tabindex": show ? 0 : -1,
          "aria-labelledby": label,
          "data-allow-mismatch": "attribute"
        }, [Content]), [[vue.vShow, show]]);
      };
    }
  });
  const Tab = withInstall(stdin_default$1y);
  const Tabs = withInstall(stdin_default$1A);
  const [name$1p, bem$1l] = createNamespace("picker-group");
  const PICKER_GROUP_KEY = Symbol(name$1p);
  const pickerGroupProps = extend({
    tabs: makeArrayProp(),
    activeTab: makeNumericProp(0),
    nextStepText: String,
    showToolbar: truthProp
  }, pickerToolbarProps);
  var stdin_default$1x = vue.defineComponent({
    name: name$1p,
    props: pickerGroupProps,
    emits: ["confirm", "cancel", "update:activeTab"],
    setup(props2, {
      emit,
      slots
    }) {
      const activeTab = useSyncPropRef(() => props2.activeTab, (value) => emit("update:activeTab", value));
      const {
        children,
        linkChildren
      } = useChildren(PICKER_GROUP_KEY);
      linkChildren();
      const showNextButton = () => +activeTab.value < props2.tabs.length - 1 && props2.nextStepText;
      const onConfirm = () => {
        if (showNextButton()) {
          activeTab.value = +activeTab.value + 1;
        } else {
          emit("confirm", children.map((item) => item.confirm()));
        }
      };
      const onCancel = () => emit("cancel");
      return () => {
        var _a, _b;
        let childNodes = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) == null ? void 0 : _b.filter((node) => node.type !== vue.Comment).map((node) => {
          if (node.type === vue.Fragment) {
            return node.children;
          }
          return node;
        });
        if (childNodes) {
          childNodes = flat(childNodes);
        }
        const confirmButtonText = showNextButton() ? props2.nextStepText : props2.confirmButtonText;
        return vue.createVNode("div", {
          "class": bem$1l()
        }, [props2.showToolbar ? vue.createVNode(stdin_default$1E, {
          "title": props2.title,
          "cancelButtonText": props2.cancelButtonText,
          "confirmButtonText": confirmButtonText,
          "onConfirm": onConfirm,
          "onCancel": onCancel
        }, pick(slots, pickerToolbarSlots)) : null, vue.createVNode(Tabs, {
          "active": activeTab.value,
          "onUpdate:active": ($event) => activeTab.value = $event,
          "class": bem$1l("tabs"),
          "shrink": true,
          "animated": true,
          "lazyRender": false
        }, {
          default: () => [props2.tabs.map((title, index2) => vue.createVNode(Tab, {
            "title": title,
            "titleClass": bem$1l("tab-title")
          }, {
            default: () => [childNodes == null ? void 0 : childNodes[index2]]
          }))]
        })]);
      };
    }
  });
  const pickerSharedProps = extend({
    loading: Boolean,
    readonly: Boolean,
    allowHtml: Boolean,
    optionHeight: makeNumericProp(44),
    showToolbar: truthProp,
    swipeDuration: makeNumericProp(1e3),
    visibleOptionNum: makeNumericProp(6)
  }, pickerToolbarProps);
  const pickerProps = extend({}, pickerSharedProps, {
    columns: makeArrayProp(),
    modelValue: makeArrayProp(),
    toolbarPosition: makeStringProp("top"),
    columnsFieldNames: Object
  });
  var stdin_default$1w = vue.defineComponent({
    name: name$1z,
    props: pickerProps,
    emits: ["confirm", "cancel", "change", "scrollInto", "clickOption", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const columnsRef = vue.ref();
      const selectedValues = vue.ref(props2.modelValue.slice(0));
      const {
        parent
      } = useParent(PICKER_GROUP_KEY);
      const {
        children,
        linkChildren
      } = useChildren(PICKER_KEY);
      linkChildren();
      const fields = vue.computed(() => assignDefaultFields(props2.columnsFieldNames));
      const optionHeight = vue.computed(() => unitToPx(props2.optionHeight));
      const columnsType = vue.computed(() => getColumnsType(props2.columns, fields.value));
      const currentColumns = vue.computed(() => {
        const {
          columns
        } = props2;
        switch (columnsType.value) {
          case "multiple":
            return columns;
          case "cascade":
            return formatCascadeColumns(columns, fields.value, selectedValues);
          default:
            return [columns];
        }
      });
      const hasOptions = vue.computed(() => currentColumns.value.some((options) => options.length));
      const selectedOptions = vue.computed(() => currentColumns.value.map((options, index2) => findOptionByValue(options, selectedValues.value[index2], fields.value)));
      const selectedIndexes = vue.computed(() => currentColumns.value.map((options, index2) => options.findIndex((option) => option[fields.value.value] === selectedValues.value[index2])));
      const setValue = (index2, value) => {
        if (selectedValues.value[index2] !== value) {
          const newValues = selectedValues.value.slice(0);
          newValues[index2] = value;
          selectedValues.value = newValues;
        }
      };
      const getEventParams = () => ({
        selectedValues: selectedValues.value.slice(0),
        selectedOptions: selectedOptions.value,
        selectedIndexes: selectedIndexes.value
      });
      const onChange = (value, columnIndex) => {
        setValue(columnIndex, value);
        if (columnsType.value === "cascade") {
          selectedValues.value.forEach((value2, index2) => {
            const options = currentColumns.value[index2];
            if (!isOptionExist(options, value2, fields.value)) {
              setValue(index2, options.length ? options[0][fields.value.value] : void 0);
            }
          });
        }
        vue.nextTick(() => {
          emit("change", extend({
            columnIndex
          }, getEventParams()));
        });
      };
      const onClickOption = (currentOption, columnIndex) => {
        const params = {
          columnIndex,
          currentOption
        };
        emit("clickOption", extend(getEventParams(), params));
        emit("scrollInto", params);
      };
      const confirm = () => {
        children.forEach((child) => child.stopMomentum());
        const params = getEventParams();
        vue.nextTick(() => {
          emit("confirm", params);
        });
        return params;
      };
      const cancel = () => emit("cancel", getEventParams());
      const renderColumnItems = () => currentColumns.value.map((options, columnIndex) => vue.createVNode(stdin_default$1F, {
        "value": selectedValues.value[columnIndex],
        "fields": fields.value,
        "options": options,
        "readonly": props2.readonly,
        "allowHtml": props2.allowHtml,
        "optionHeight": optionHeight.value,
        "swipeDuration": props2.swipeDuration,
        "visibleOptionNum": props2.visibleOptionNum,
        "onChange": (value) => onChange(value, columnIndex),
        "onClickOption": (option) => onClickOption(option, columnIndex),
        "onScrollInto": (option) => {
          emit("scrollInto", {
            currentOption: option,
            columnIndex
          });
        }
      }, {
        option: slots.option
      }));
      const renderMask = (wrapHeight) => {
        if (hasOptions.value) {
          const frameStyle = {
            height: `${optionHeight.value}px`
          };
          const maskStyle = {
            backgroundSize: `100% ${(wrapHeight - optionHeight.value) / 2}px`
          };
          return [vue.createVNode("div", {
            "class": bem$1u("mask"),
            "style": maskStyle
          }, null), vue.createVNode("div", {
            "class": [BORDER_UNSET_TOP_BOTTOM, bem$1u("frame")],
            "style": frameStyle
          }, null)];
        }
      };
      const renderColumns = () => {
        const wrapHeight = optionHeight.value * +props2.visibleOptionNum;
        const columnsStyle = {
          height: `${wrapHeight}px`
        };
        return vue.createVNode("div", {
          "ref": columnsRef,
          "class": bem$1u("columns"),
          "style": columnsStyle
        }, [renderColumnItems(), renderMask(wrapHeight)]);
      };
      const renderToolbar = () => {
        if (props2.showToolbar && !parent) {
          return vue.createVNode(stdin_default$1E, vue.mergeProps(pick(props2, pickerToolbarPropKeys), {
            "onConfirm": confirm,
            "onCancel": cancel
          }), pick(slots, pickerToolbarSlots));
        }
      };
      vue.watch(currentColumns, (columns) => {
        columns.forEach((options, index2) => {
          if (options.length && !isOptionExist(options, selectedValues.value[index2], fields.value)) {
            setValue(index2, getFirstEnabledOption(options)[fields.value.value]);
          }
        });
      }, {
        immediate: true
      });
      let lastEmittedModelValue;
      vue.watch(() => props2.modelValue, (newValues) => {
        if (!isSameValue(newValues, selectedValues.value) && !isSameValue(newValues, lastEmittedModelValue)) {
          selectedValues.value = newValues.slice(0);
          lastEmittedModelValue = newValues.slice(0);
        }
      }, {
        deep: true
      });
      vue.watch(selectedValues, (newValues) => {
        if (!isSameValue(newValues, props2.modelValue)) {
          lastEmittedModelValue = newValues.slice(0);
          emit("update:modelValue", lastEmittedModelValue);
        }
      }, {
        immediate: true
      });
      useEventListener("touchmove", preventDefault, {
        target: columnsRef
      });
      const getSelectedOptions = () => selectedOptions.value;
      useExpose({
        confirm,
        getSelectedOptions
      });
      return () => {
        var _a, _b;
        return vue.createVNode("div", {
          "class": bem$1u()
        }, [props2.toolbarPosition === "top" ? renderToolbar() : null, props2.loading ? vue.createVNode(Loading, {
          "class": bem$1u("loading")
        }, null) : null, (_a = slots["columns-top"]) == null ? void 0 : _a.call(slots), renderColumns(), (_b = slots["columns-bottom"]) == null ? void 0 : _b.call(slots), props2.toolbarPosition === "bottom" ? renderToolbar() : null]);
      };
    }
  });
  const AREA_EMPTY_CODE = "000000";
  const INHERIT_SLOTS = [
    "title",
    "cancel",
    "confirm",
    "toolbar",
    "columns-top",
    "columns-bottom"
  ];
  const INHERIT_PROPS = [
    "title",
    "loading",
    "readonly",
    "optionHeight",
    "swipeDuration",
    "visibleOptionNum",
    "cancelButtonText",
    "confirmButtonText"
  ];
  const makeOption = (text = "", value = AREA_EMPTY_CODE, children = void 0) => ({
    text,
    value,
    children
  });
  function formatDataForCascade({
    areaList,
    columnsNum,
    columnsPlaceholder: placeholder
  }) {
    const {
      city_list: city = {},
      county_list: county = {},
      province_list: province = {}
    } = areaList;
    const showCity = +columnsNum > 1;
    const showCounty = +columnsNum > 2;
    const getProvinceChildren = () => {
      if (showCity) {
        return placeholder.length > 1 ? [
          makeOption(
            placeholder[1],
            AREA_EMPTY_CODE,
            showCounty ? [] : void 0
          )
        ] : [];
      }
    };
    const provinceMap = /* @__PURE__ */ new Map();
    Object.keys(province).forEach((code2) => {
      provinceMap.set(
        code2.slice(0, 2),
        makeOption(province[code2], code2, getProvinceChildren())
      );
    });
    const cityMap = /* @__PURE__ */ new Map();
    if (showCity) {
      const getCityChildren = () => {
        if (showCounty) {
          return placeholder.length > 2 ? [makeOption(placeholder[2])] : [];
        }
      };
      Object.keys(city).forEach((code2) => {
        const option = makeOption(city[code2], code2, getCityChildren());
        cityMap.set(code2.slice(0, 4), option);
        const province2 = provinceMap.get(code2.slice(0, 2));
        if (province2) {
          province2.children.push(option);
        }
      });
    }
    if (showCounty) {
      Object.keys(county).forEach((code2) => {
        const city2 = cityMap.get(code2.slice(0, 4));
        if (city2) {
          city2.children.push(makeOption(county[code2], code2));
        }
      });
    }
    const options = Array.from(provinceMap.values());
    if (placeholder.length) {
      const county2 = showCounty ? [makeOption(placeholder[2])] : void 0;
      const city2 = showCity ? [makeOption(placeholder[1], AREA_EMPTY_CODE, county2)] : void 0;
      options.unshift(makeOption(placeholder[0], AREA_EMPTY_CODE, city2));
    }
    return options;
  }
  const Picker = withInstall(stdin_default$1w);
  const [name$1o, bem$1k] = createNamespace("area");
  const areaProps = extend({}, pick(pickerSharedProps, INHERIT_PROPS), {
    modelValue: String,
    columnsNum: makeNumericProp(3),
    columnsPlaceholder: makeArrayProp(),
    areaList: {
      type: Object,
      default: () => ({})
    }
  });
  var stdin_default$1v = vue.defineComponent({
    name: name$1o,
    props: areaProps,
    emits: ["change", "confirm", "cancel", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const codes = vue.ref([]);
      const picker = vue.ref();
      const columns = vue.computed(() => formatDataForCascade(props2));
      const onChange = (...args) => emit("change", ...args);
      const onCancel = (...args) => emit("cancel", ...args);
      const onConfirm = (...args) => emit("confirm", ...args);
      vue.watch(codes, (newCodes) => {
        const lastCode = newCodes.length ? newCodes[newCodes.length - 1] : "";
        if (lastCode && lastCode !== props2.modelValue) {
          emit("update:modelValue", lastCode);
        }
      }, {
        deep: true
      });
      vue.watch(() => props2.modelValue, (newCode) => {
        if (newCode) {
          const lastCode = codes.value.length ? codes.value[codes.value.length - 1] : "";
          if (newCode !== lastCode) {
            codes.value = [`${newCode.slice(0, 2)}0000`, `${newCode.slice(0, 4)}00`, newCode].slice(0, +props2.columnsNum);
          }
        } else {
          codes.value = [];
        }
      }, {
        immediate: true
      });
      useExpose({
        confirm: () => {
          var _a;
          return (_a = picker.value) == null ? void 0 : _a.confirm();
        },
        getSelectedOptions: () => {
          var _a;
          return ((_a = picker.value) == null ? void 0 : _a.getSelectedOptions()) || [];
        }
      });
      return () => vue.createVNode(Picker, vue.mergeProps({
        "ref": picker,
        "modelValue": codes.value,
        "onUpdate:modelValue": ($event) => codes.value = $event,
        "class": bem$1k(),
        "columns": columns.value,
        "onChange": onChange,
        "onCancel": onCancel,
        "onConfirm": onConfirm
      }, pick(props2, INHERIT_PROPS)), pick(slots, INHERIT_SLOTS));
    }
  });
  const Area = withInstall(stdin_default$1v);
  const [name$1n, bem$1j] = createNamespace("cell");
  const cellSharedProps = {
    tag: makeStringProp("div"),
    icon: String,
    size: String,
    title: numericProp,
    value: numericProp,
    label: numericProp,
    center: Boolean,
    isLink: Boolean,
    border: truthProp,
    iconPrefix: String,
    valueClass: unknownProp,
    labelClass: unknownProp,
    titleClass: unknownProp,
    titleStyle: null,
    arrowDirection: String,
    required: {
      type: [Boolean, String],
      default: null
    },
    clickable: {
      type: Boolean,
      default: null
    }
  };
  const cellProps = extend({}, cellSharedProps, routeProps);
  var stdin_default$1u = vue.defineComponent({
    name: name$1n,
    props: cellProps,
    setup(props2, {
      slots
    }) {
      const route2 = useRoute();
      const renderLabel = () => {
        const showLabel = slots.label || isDef(props2.label);
        if (showLabel) {
          return vue.createVNode("div", {
            "class": [bem$1j("label"), props2.labelClass]
          }, [slots.label ? slots.label() : props2.label]);
        }
      };
      const renderTitle = () => {
        var _a;
        if (slots.title || isDef(props2.title)) {
          const titleSlot = (_a = slots.title) == null ? void 0 : _a.call(slots);
          if (Array.isArray(titleSlot) && titleSlot.length === 0) {
            return;
          }
          return vue.createVNode("div", {
            "class": [bem$1j("title"), props2.titleClass],
            "style": props2.titleStyle
          }, [titleSlot || vue.createVNode("span", null, [props2.title]), renderLabel()]);
        }
      };
      const renderValue = () => {
        const slot = slots.value || slots.default;
        const hasValue = slot || isDef(props2.value);
        if (hasValue) {
          return vue.createVNode("div", {
            "class": [bem$1j("value"), props2.valueClass]
          }, [slot ? slot() : vue.createVNode("span", null, [props2.value])]);
        }
      };
      const renderLeftIcon = () => {
        if (slots.icon) {
          return slots.icon();
        }
        if (props2.icon) {
          return vue.createVNode(Icon, {
            "name": props2.icon,
            "class": bem$1j("left-icon"),
            "classPrefix": props2.iconPrefix
          }, null);
        }
      };
      const renderRightIcon = () => {
        if (slots["right-icon"]) {
          return slots["right-icon"]();
        }
        if (props2.isLink) {
          const name2 = props2.arrowDirection && props2.arrowDirection !== "right" ? `arrow-${props2.arrowDirection}` : "arrow";
          return vue.createVNode(Icon, {
            "name": name2,
            "class": bem$1j("right-icon")
          }, null);
        }
      };
      return () => {
        var _a;
        const {
          tag,
          size,
          center,
          border,
          isLink,
          required
        } = props2;
        const clickable = (_a = props2.clickable) != null ? _a : isLink;
        const classes = {
          center,
          required: !!required,
          clickable,
          borderless: !border
        };
        if (size) {
          classes[size] = !!size;
        }
        return vue.createVNode(tag, {
          "class": bem$1j(classes),
          "role": clickable ? "button" : void 0,
          "tabindex": clickable ? 0 : void 0,
          "onClick": route2
        }, {
          default: () => {
            var _a2;
            return [renderLeftIcon(), renderTitle(), renderValue(), renderRightIcon(), (_a2 = slots.extra) == null ? void 0 : _a2.call(slots)];
          }
        });
      };
    }
  });
  const Cell = withInstall(stdin_default$1u);
  const [name$1m, bem$1i] = createNamespace("form");
  const formProps = {
    colon: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    required: [Boolean, String],
    showError: Boolean,
    labelWidth: numericProp,
    labelAlign: String,
    inputAlign: String,
    scrollToError: Boolean,
    scrollToErrorPosition: String,
    validateFirst: Boolean,
    submitOnEnter: truthProp,
    showErrorMessage: truthProp,
    errorMessageAlign: String,
    validateTrigger: {
      type: [String, Array],
      default: "onBlur"
    }
  };
  var stdin_default$1t = vue.defineComponent({
    name: name$1m,
    props: formProps,
    emits: ["submit", "failed"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        children,
        linkChildren
      } = useChildren(FORM_KEY);
      const getFieldsByNames = (names) => {
        if (names) {
          return children.filter((field) => names.includes(field.name));
        }
        return children;
      };
      const validateSeq = (names) => new Promise((resolve, reject) => {
        const errors = [];
        const fields = getFieldsByNames(names);
        fields.reduce((promise2, field) => promise2.then(() => {
          if (!errors.length) {
            return field.validate().then((error2) => {
              if (error2) {
                errors.push(error2);
              }
            });
          }
        }), Promise.resolve()).then(() => {
          if (errors.length) {
            reject(errors);
          } else {
            resolve();
          }
        });
      });
      const validateAll = (names) => new Promise((resolve, reject) => {
        const fields = getFieldsByNames(names);
        Promise.all(fields.map((item) => item.validate())).then((errors) => {
          errors = errors.filter(Boolean);
          if (errors.length) {
            reject(errors);
          } else {
            resolve();
          }
        });
      });
      const validateField = (name2) => {
        const matched = children.find((item) => item.name === name2);
        if (matched) {
          return new Promise((resolve, reject) => {
            matched.validate().then((error2) => {
              if (error2) {
                reject(error2);
              } else {
                resolve();
              }
            });
          });
        }
        return Promise.reject();
      };
      const validate = (name2) => {
        if (typeof name2 === "string") {
          return validateField(name2);
        }
        return props2.validateFirst ? validateSeq(name2) : validateAll(name2);
      };
      const resetValidation = (name2) => {
        if (typeof name2 === "string") {
          name2 = [name2];
        }
        const fields = getFieldsByNames(name2);
        fields.forEach((item) => {
          item.resetValidation();
        });
      };
      const getValidationStatus = () => children.reduce((form, field) => {
        form[field.name] = field.getValidationStatus();
        return form;
      }, {});
      const scrollToField = (name2, options) => {
        children.some((item) => {
          if (item.name === name2) {
            item.$el.scrollIntoView(options);
            return true;
          }
          return false;
        });
      };
      const getValues = () => children.reduce((form, field) => {
        if (field.name !== void 0) {
          form[field.name] = field.formValue.value;
        }
        return form;
      }, {});
      const submit = () => {
        const values = getValues();
        validate().then(() => emit("submit", values)).catch((errors) => {
          emit("failed", {
            values,
            errors
          });
          const {
            scrollToError,
            scrollToErrorPosition
          } = props2;
          if (scrollToError && errors[0].name) {
            scrollToField(errors[0].name, scrollToErrorPosition ? {
              block: scrollToErrorPosition
            } : void 0);
          }
        });
      };
      const onSubmit = (event) => {
        preventDefault(event);
        submit();
      };
      linkChildren({
        props: props2
      });
      useExpose({
        submit,
        validate,
        getValues,
        scrollToField,
        resetValidation,
        getValidationStatus
      });
      return () => {
        var _a;
        return vue.createVNode("form", {
          "class": bem$1i(),
          "onSubmit": onSubmit
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Form = withInstall(stdin_default$1t);
  function isEmptyValue(value) {
    if (Array.isArray(value)) {
      return !value.length;
    }
    if (value === 0) {
      return false;
    }
    return !value;
  }
  function runSyncRule(value, rule) {
    if (isEmptyValue(value)) {
      if (rule.required) {
        return false;
      }
      if (rule.validateEmpty === false) {
        return true;
      }
    }
    if (rule.pattern && !rule.pattern.test(String(value))) {
      return false;
    }
    return true;
  }
  function runRuleValidator(value, rule) {
    return new Promise((resolve) => {
      const returnVal = rule.validator(value, rule);
      if (isPromise$1(returnVal)) {
        returnVal.then(resolve);
        return;
      }
      resolve(returnVal);
    });
  }
  function getRuleMessage(value, rule) {
    const { message } = rule;
    if (isFunction(message)) {
      return message(value, rule);
    }
    return message || "";
  }
  function startComposing({ target }) {
    target.composing = true;
  }
  function endComposing({ target }) {
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  function resizeTextarea(input, autosize) {
    const scrollTop = getRootScrollTop();
    input.style.height = "auto";
    let height2 = input.scrollHeight;
    if (isObject$1(autosize)) {
      const { maxHeight, minHeight } = autosize;
      if (maxHeight !== void 0) {
        height2 = Math.min(height2, maxHeight);
      }
      if (minHeight !== void 0) {
        height2 = Math.max(height2, minHeight);
      }
    }
    if (height2) {
      input.style.height = `${height2}px`;
      setRootScrollTop(scrollTop);
    }
  }
  function mapInputType(type, inputmode) {
    if (type === "number") {
      type = "text";
      inputmode != null ? inputmode : inputmode = "decimal";
    }
    if (type === "digit") {
      type = "tel";
      inputmode != null ? inputmode : inputmode = "numeric";
    }
    return { type, inputmode };
  }
  function getStringLength(str) {
    return [...str].length;
  }
  function cutString(str, maxlength) {
    return [...str].slice(0, maxlength).join("");
  }
  const [name$1l, bem$1h] = createNamespace("field");
  const fieldSharedProps = {
    id: String,
    name: String,
    leftIcon: String,
    rightIcon: String,
    autofocus: Boolean,
    clearable: Boolean,
    maxlength: numericProp,
    max: Number,
    min: Number,
    formatter: Function,
    clearIcon: makeStringProp("clear"),
    modelValue: makeNumericProp(""),
    inputAlign: String,
    placeholder: String,
    autocomplete: String,
    autocapitalize: String,
    autocorrect: String,
    errorMessage: String,
    enterkeyhint: String,
    clearTrigger: makeStringProp("focus"),
    formatTrigger: makeStringProp("onChange"),
    spellcheck: {
      type: Boolean,
      default: null
    },
    error: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    inputmode: String
  };
  const fieldProps = extend({}, cellSharedProps, fieldSharedProps, {
    rows: numericProp,
    type: makeStringProp("text"),
    rules: Array,
    autosize: [Boolean, Object],
    labelWidth: numericProp,
    labelClass: unknownProp,
    labelAlign: String,
    showWordLimit: Boolean,
    errorMessageAlign: String,
    colon: {
      type: Boolean,
      default: null
    }
  });
  var stdin_default$1s = vue.defineComponent({
    name: name$1l,
    props: fieldProps,
    emits: ["blur", "focus", "clear", "keypress", "clickInput", "endValidate", "startValidate", "clickLeftIcon", "clickRightIcon", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const id = useId();
      const state = vue.reactive({
        status: "unvalidated",
        focused: false,
        validateMessage: ""
      });
      const inputRef = vue.ref();
      const clearIconRef = vue.ref();
      const customValue = vue.ref();
      const {
        parent: form
      } = useParent(FORM_KEY);
      const getModelValue = () => {
        var _a;
        return String((_a = props2.modelValue) != null ? _a : "");
      };
      const getProp = (key) => {
        if (isDef(props2[key])) {
          return props2[key];
        }
        if (form && isDef(form.props[key])) {
          return form.props[key];
        }
      };
      const showClear = vue.computed(() => {
        const readonly = getProp("readonly");
        if (props2.clearable && !readonly) {
          const hasValue = getModelValue() !== "";
          const trigger = props2.clearTrigger === "always" || props2.clearTrigger === "focus" && state.focused;
          return hasValue && trigger;
        }
        return false;
      });
      const formValue = vue.computed(() => {
        if (customValue.value && slots.input) {
          return customValue.value();
        }
        return props2.modelValue;
      });
      const showRequiredMark = vue.computed(() => {
        var _a;
        const required = getProp("required");
        if (required === "auto") {
          return (_a = props2.rules) == null ? void 0 : _a.some((rule) => rule.required);
        }
        return required;
      });
      const runRules = (rules) => rules.reduce((promise2, rule) => promise2.then(() => {
        if (state.status === "failed") {
          return;
        }
        let {
          value
        } = formValue;
        if (rule.formatter) {
          value = rule.formatter(value, rule);
        }
        if (!runSyncRule(value, rule)) {
          state.status = "failed";
          state.validateMessage = getRuleMessage(value, rule);
          return;
        }
        if (rule.validator) {
          if (isEmptyValue(value) && rule.validateEmpty === false) {
            return;
          }
          return runRuleValidator(value, rule).then((result) => {
            if (result && typeof result === "string") {
              state.status = "failed";
              state.validateMessage = result;
            } else if (result === false) {
              state.status = "failed";
              state.validateMessage = getRuleMessage(value, rule);
            }
          });
        }
      }), Promise.resolve());
      const resetValidation = () => {
        state.status = "unvalidated";
        state.validateMessage = "";
      };
      const endValidate = () => emit("endValidate", {
        status: state.status,
        message: state.validateMessage
      });
      const validate = (rules = props2.rules) => new Promise((resolve) => {
        resetValidation();
        if (rules) {
          emit("startValidate");
          runRules(rules).then(() => {
            if (state.status === "failed") {
              resolve({
                name: props2.name,
                message: state.validateMessage
              });
              endValidate();
            } else {
              state.status = "passed";
              resolve();
              endValidate();
            }
          });
        } else {
          resolve();
        }
      });
      const validateWithTrigger = (trigger) => {
        if (form && props2.rules) {
          const {
            validateTrigger
          } = form.props;
          const defaultTrigger = toArray(validateTrigger).includes(trigger);
          const rules = props2.rules.filter((rule) => {
            if (rule.trigger) {
              return toArray(rule.trigger).includes(trigger);
            }
            return defaultTrigger;
          });
          if (rules.length) {
            validate(rules);
          }
        }
      };
      const limitValueLength = (value) => {
        var _a;
        const {
          maxlength
        } = props2;
        if (isDef(maxlength) && getStringLength(value) > +maxlength) {
          const modelValue = getModelValue();
          if (modelValue && getStringLength(modelValue) === +maxlength) {
            return modelValue;
          }
          const selectionEnd = (_a = inputRef.value) == null ? void 0 : _a.selectionEnd;
          if (state.focused && selectionEnd) {
            const valueArr = [...value];
            const exceededLength = valueArr.length - +maxlength;
            valueArr.splice(selectionEnd - exceededLength, exceededLength);
            return valueArr.join("");
          }
          return cutString(value, +maxlength);
        }
        return value;
      };
      const updateValue = (value, trigger = "onChange") => {
        var _a, _b;
        const originalValue = value;
        value = limitValueLength(value);
        const limitDiffLen = getStringLength(originalValue) - getStringLength(value);
        if (props2.type === "number" || props2.type === "digit") {
          const isNumber2 = props2.type === "number";
          value = formatNumber(value, isNumber2, isNumber2);
          if (trigger === "onBlur" && value !== "" && (props2.min !== void 0 || props2.max !== void 0)) {
            const adjustedValue = clamp(+value, (_a = props2.min) != null ? _a : -Infinity, (_b = props2.max) != null ? _b : Infinity);
            value = adjustedValue.toString();
          }
        }
        let formatterDiffLen = 0;
        if (props2.formatter && trigger === props2.formatTrigger) {
          const {
            formatter,
            maxlength
          } = props2;
          value = formatter(value);
          if (isDef(maxlength) && getStringLength(value) > +maxlength) {
            value = cutString(value, +maxlength);
          }
          if (inputRef.value && state.focused) {
            const {
              selectionEnd
            } = inputRef.value;
            const bcoVal = cutString(originalValue, selectionEnd);
            formatterDiffLen = getStringLength(formatter(bcoVal)) - getStringLength(bcoVal);
          }
        }
        if (inputRef.value && inputRef.value.value !== value) {
          if (state.focused) {
            let {
              selectionStart,
              selectionEnd
            } = inputRef.value;
            inputRef.value.value = value;
            if (isDef(selectionStart) && isDef(selectionEnd)) {
              const valueLen = getStringLength(value);
              if (limitDiffLen) {
                selectionStart -= limitDiffLen;
                selectionEnd -= limitDiffLen;
              } else if (formatterDiffLen) {
                selectionStart += formatterDiffLen;
                selectionEnd += formatterDiffLen;
              }
              inputRef.value.setSelectionRange(Math.min(selectionStart, valueLen), Math.min(selectionEnd, valueLen));
            }
          } else {
            inputRef.value.value = value;
          }
        }
        if (value !== props2.modelValue) {
          emit("update:modelValue", value);
        }
      };
      const onInput = (event) => {
        if (!event.target.composing) {
          updateValue(event.target.value);
        }
      };
      const blur = () => {
        var _a;
        return (_a = inputRef.value) == null ? void 0 : _a.blur();
      };
      const focus = () => {
        var _a;
        return (_a = inputRef.value) == null ? void 0 : _a.focus();
      };
      const adjustTextareaSize = () => {
        const input = inputRef.value;
        if (props2.type === "textarea" && props2.autosize && input) {
          resizeTextarea(input, props2.autosize);
        }
      };
      const onFocus = (event) => {
        state.focused = true;
        emit("focus", event);
        vue.nextTick(adjustTextareaSize);
        if (getProp("readonly")) {
          blur();
        }
      };
      const onBlur = (event) => {
        state.focused = false;
        updateValue(getModelValue(), "onBlur");
        emit("blur", event);
        if (getProp("readonly")) {
          return;
        }
        validateWithTrigger("onBlur");
        vue.nextTick(adjustTextareaSize);
        resetScroll();
      };
      const onClickInput = (event) => emit("clickInput", event);
      const onClickLeftIcon = (event) => emit("clickLeftIcon", event);
      const onClickRightIcon = (event) => emit("clickRightIcon", event);
      const onClear = (event) => {
        preventDefault(event);
        emit("update:modelValue", "");
        emit("clear", event);
      };
      const showError = vue.computed(() => {
        if (typeof props2.error === "boolean") {
          return props2.error;
        }
        if (form && form.props.showError && state.status === "failed") {
          return true;
        }
      });
      const labelStyle = vue.computed(() => {
        const labelWidth = getProp("labelWidth");
        const labelAlign = getProp("labelAlign");
        if (labelWidth && labelAlign !== "top") {
          return {
            width: addUnit$2(labelWidth)
          };
        }
      });
      const onKeypress = (event) => {
        const ENTER_CODE = 13;
        if (event.keyCode === ENTER_CODE) {
          const submitOnEnter = form && form.props.submitOnEnter;
          if (!submitOnEnter && props2.type !== "textarea") {
            preventDefault(event);
          }
          if (props2.type === "search") {
            blur();
          }
        }
        emit("keypress", event);
      };
      const getInputId = () => props2.id || `${id}-input`;
      const getValidationStatus = () => state.status;
      const renderInput = () => {
        const controlClass = bem$1h("control", [getProp("inputAlign"), {
          error: showError.value,
          custom: !!slots.input,
          "min-height": props2.type === "textarea" && !props2.autosize
        }]);
        if (slots.input) {
          return vue.createVNode("div", {
            "class": controlClass,
            "onClick": onClickInput
          }, [slots.input()]);
        }
        const inputAttrs = {
          id: getInputId(),
          ref: inputRef,
          name: props2.name,
          rows: props2.rows !== void 0 ? +props2.rows : void 0,
          class: controlClass,
          disabled: getProp("disabled"),
          readonly: getProp("readonly"),
          autofocus: props2.autofocus,
          placeholder: props2.placeholder,
          autocomplete: props2.autocomplete,
          autocapitalize: props2.autocapitalize,
          autocorrect: props2.autocorrect,
          enterkeyhint: props2.enterkeyhint,
          spellcheck: props2.spellcheck,
          "aria-labelledby": props2.label ? `${id}-label` : void 0,
          "data-allow-mismatch": "attribute",
          onBlur,
          onFocus,
          onInput,
          onClick: onClickInput,
          onChange: endComposing,
          onKeypress,
          onCompositionend: endComposing,
          onCompositionstart: startComposing
        };
        if (props2.type === "textarea") {
          return vue.createVNode("textarea", vue.mergeProps(inputAttrs, {
            "inputmode": props2.inputmode
          }), null);
        }
        return vue.createVNode("input", vue.mergeProps(mapInputType(props2.type, props2.inputmode), inputAttrs), null);
      };
      const renderLeftIcon = () => {
        const leftIconSlot = slots["left-icon"];
        if (props2.leftIcon || leftIconSlot) {
          return vue.createVNode("div", {
            "class": bem$1h("left-icon"),
            "onClick": onClickLeftIcon
          }, [leftIconSlot ? leftIconSlot() : vue.createVNode(Icon, {
            "name": props2.leftIcon,
            "classPrefix": props2.iconPrefix
          }, null)]);
        }
      };
      const renderRightIcon = () => {
        const rightIconSlot = slots["right-icon"];
        if (props2.rightIcon || rightIconSlot) {
          return vue.createVNode("div", {
            "class": bem$1h("right-icon"),
            "onClick": onClickRightIcon
          }, [rightIconSlot ? rightIconSlot() : vue.createVNode(Icon, {
            "name": props2.rightIcon,
            "classPrefix": props2.iconPrefix
          }, null)]);
        }
      };
      const renderWordLimit = () => {
        if (props2.showWordLimit && props2.maxlength) {
          const count = getStringLength(getModelValue());
          return vue.createVNode("div", {
            "class": bem$1h("word-limit")
          }, [vue.createVNode("span", {
            "class": bem$1h("word-num")
          }, [count]), vue.createTextVNode("/"), props2.maxlength]);
        }
      };
      const renderMessage = () => {
        if (form && form.props.showErrorMessage === false) {
          return;
        }
        const message = props2.errorMessage || state.validateMessage;
        if (message) {
          const slot = slots["error-message"];
          const errorMessageAlign = getProp("errorMessageAlign");
          return vue.createVNode("div", {
            "class": bem$1h("error-message", errorMessageAlign)
          }, [slot ? slot({
            message
          }) : message]);
        }
      };
      const renderLabel = () => {
        const labelWidth = getProp("labelWidth");
        const labelAlign = getProp("labelAlign");
        const colon = getProp("colon") ? ":" : "";
        if (slots.label) {
          return [slots.label(), colon];
        }
        if (props2.label) {
          return vue.createVNode("label", {
            "id": `${id}-label`,
            "for": slots.input ? void 0 : getInputId(),
            "data-allow-mismatch": "attribute",
            "onClick": (event) => {
              preventDefault(event);
              focus();
            },
            "style": labelAlign === "top" && labelWidth ? {
              width: addUnit$2(labelWidth)
            } : void 0
          }, [props2.label + colon]);
        }
      };
      const renderFieldBody = () => [vue.createVNode("div", {
        "class": bem$1h("body")
      }, [renderInput(), showClear.value && vue.createVNode(Icon, {
        "ref": clearIconRef,
        "name": props2.clearIcon,
        "class": bem$1h("clear")
      }, null), renderRightIcon(), slots.button && vue.createVNode("div", {
        "class": bem$1h("button")
      }, [slots.button()])]), renderWordLimit(), renderMessage()];
      useExpose({
        blur,
        focus,
        validate,
        formValue,
        resetValidation,
        getValidationStatus
      });
      vue.provide(CUSTOM_FIELD_INJECTION_KEY, {
        customValue,
        resetValidation,
        validateWithTrigger
      });
      vue.watch(() => props2.modelValue, () => {
        updateValue(getModelValue());
        resetValidation();
        validateWithTrigger("onChange");
        vue.nextTick(adjustTextareaSize);
      });
      vue.onMounted(() => {
        updateValue(getModelValue(), props2.formatTrigger);
        vue.nextTick(adjustTextareaSize);
      });
      useEventListener("touchstart", onClear, {
        target: vue.computed(() => {
          var _a;
          return (_a = clearIconRef.value) == null ? void 0 : _a.$el;
        })
      });
      return () => {
        const disabled = getProp("disabled");
        const labelAlign = getProp("labelAlign");
        const LeftIcon = renderLeftIcon();
        const renderTitle = () => {
          const Label = renderLabel();
          if (labelAlign === "top") {
            return [LeftIcon, Label].filter(Boolean);
          }
          return Label || [];
        };
        return vue.createVNode(Cell, {
          "size": props2.size,
          "class": bem$1h({
            error: showError.value,
            disabled,
            [`label-${labelAlign}`]: labelAlign
          }),
          "center": props2.center,
          "border": props2.border,
          "isLink": props2.isLink,
          "clickable": props2.clickable,
          "titleStyle": labelStyle.value,
          "valueClass": bem$1h("value"),
          "titleClass": [bem$1h("label", [labelAlign, {
            required: showRequiredMark.value
          }]), props2.labelClass],
          "arrowDirection": props2.arrowDirection
        }, {
          icon: LeftIcon && labelAlign !== "top" ? () => LeftIcon : null,
          title: renderTitle,
          value: renderFieldBody,
          extra: slots.extra
        });
      };
    }
  });
  const Field = withInstall(stdin_default$1s);
  let lockCount = 0;
  function lockClick(lock) {
    if (lock) {
      if (!lockCount) {
        document.body.classList.add("van-toast--unclickable");
      }
      lockCount++;
    } else if (lockCount) {
      lockCount--;
      if (!lockCount) {
        document.body.classList.remove("van-toast--unclickable");
      }
    }
  }
  const [name$1k, bem$1g] = createNamespace("toast");
  const popupInheritProps$1 = ["show", "overlay", "teleport", "transition", "overlayClass", "overlayStyle", "closeOnClickOverlay", "zIndex"];
  const toastProps = {
    icon: String,
    show: Boolean,
    type: makeStringProp("text"),
    overlay: Boolean,
    message: numericProp,
    iconSize: numericProp,
    duration: makeNumberProp(2e3),
    position: makeStringProp("middle"),
    teleport: [String, Object],
    wordBreak: String,
    className: unknownProp,
    iconPrefix: String,
    transition: makeStringProp("van-fade"),
    loadingType: String,
    forbidClick: Boolean,
    overlayClass: unknownProp,
    overlayStyle: Object,
    closeOnClick: Boolean,
    closeOnClickOverlay: Boolean,
    zIndex: numericProp
  };
  var stdin_default$1r = vue.defineComponent({
    name: name$1k,
    props: toastProps,
    emits: ["update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      let timer;
      let clickable = false;
      const toggleClickable = () => {
        const newValue = props2.show && props2.forbidClick;
        if (clickable !== newValue) {
          clickable = newValue;
          lockClick(clickable);
        }
      };
      const updateShow = (show) => emit("update:show", show);
      const onClick = () => {
        if (props2.closeOnClick) {
          updateShow(false);
        }
      };
      const clearTimer = () => clearTimeout(timer);
      const renderIcon = () => {
        const {
          icon,
          type,
          iconSize,
          iconPrefix,
          loadingType
        } = props2;
        const hasIcon = icon || type === "success" || type === "fail";
        if (hasIcon) {
          return vue.createVNode(Icon, {
            "name": icon || type,
            "size": iconSize,
            "class": bem$1g("icon"),
            "classPrefix": iconPrefix
          }, null);
        }
        if (type === "loading") {
          return vue.createVNode(Loading, {
            "class": bem$1g("loading"),
            "size": iconSize,
            "type": loadingType
          }, null);
        }
      };
      const renderMessage = () => {
        const {
          type,
          message
        } = props2;
        if (slots.message) {
          return vue.createVNode("div", {
            "class": bem$1g("text")
          }, [slots.message()]);
        }
        if (isDef(message) && message !== "") {
          return type === "html" ? vue.createVNode("div", {
            "key": 0,
            "class": bem$1g("text"),
            "innerHTML": String(message)
          }, null) : vue.createVNode("div", {
            "class": bem$1g("text")
          }, [message]);
        }
      };
      vue.watch(() => [props2.show, props2.forbidClick], toggleClickable);
      vue.watch(() => [props2.show, props2.type, props2.message, props2.duration], () => {
        clearTimer();
        if (props2.show && props2.duration > 0) {
          timer = setTimeout(() => {
            updateShow(false);
          }, props2.duration);
        }
      });
      vue.onMounted(toggleClickable);
      vue.onUnmounted(toggleClickable);
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": [bem$1g([props2.position, props2.wordBreak === "normal" ? "break-normal" : props2.wordBreak, {
          [props2.type]: !props2.icon
        }]), props2.className],
        "lockScroll": false,
        "onClick": onClick,
        "onClosed": clearTimer,
        "onUpdate:show": updateShow
      }, pick(props2, popupInheritProps$1)), {
        default: () => [renderIcon(), renderMessage()]
      });
    }
  });
  function usePopupState() {
    const state = vue.reactive({
      show: false
    });
    const toggle = (show) => {
      state.show = show;
    };
    const open2 = (props2) => {
      extend(state, props2, { transitionAppear: true });
      toggle(true);
    };
    const close = () => toggle(false);
    useExpose({ open: open2, close, toggle });
    return {
      open: open2,
      close,
      state,
      toggle
    };
  }
  function mountComponent(RootComponent) {
    const app = vue.createApp(RootComponent);
    const root = document.createElement("div");
    document.body.appendChild(root);
    return {
      instance: app.mount(root),
      unmount() {
        app.unmount();
        document.body.removeChild(root);
      }
    };
  }
  const defaultOptions = {
    icon: "",
    type: "text",
    message: "",
    className: "",
    overlay: false,
    onClose: void 0,
    onOpened: void 0,
    duration: 2e3,
    teleport: "body",
    iconSize: void 0,
    iconPrefix: void 0,
    position: "middle",
    transition: "van-fade",
    forbidClick: false,
    loadingType: void 0,
    overlayClass: "",
    overlayStyle: void 0,
    closeOnClick: false,
    closeOnClickOverlay: false
  };
  let queue = [];
  let allowMultiple = false;
  let currentOptions = extend({}, defaultOptions);
  const defaultOptionsMap = /* @__PURE__ */ new Map();
  function parseOptions(message) {
    if (isObject$1(message)) {
      return message;
    }
    return {
      message
    };
  }
  function createInstance() {
    const {
      instance: instance2,
      unmount
    } = mountComponent({
      setup() {
        const message = vue.ref("");
        const {
          open: open2,
          state,
          close,
          toggle
        } = usePopupState();
        const onClosed = () => {
        };
        const render = () => {
          const attrs = {
            onClosed,
            "onUpdate:show": toggle
          };
          return vue.createVNode(stdin_default$1r, vue.mergeProps(state, attrs), null);
        };
        vue.watch(message, (val) => {
          state.message = val;
        });
        vue.getCurrentInstance().render = render;
        return {
          open: open2,
          close,
          message
        };
      }
    });
    return instance2;
  }
  function getInstance() {
    if (!queue.length || allowMultiple) {
      const instance2 = createInstance();
      queue.push(instance2);
    }
    return queue[queue.length - 1];
  }
  function showToast(options = {}) {
    if (!inBrowser$1) {
      return {};
    }
    const toast2 = getInstance();
    const parsedOptions = parseOptions(options);
    toast2.open(extend({}, currentOptions, defaultOptionsMap.get(parsedOptions.type || currentOptions.type), parsedOptions));
    return toast2;
  }
  const Toast = withInstall(stdin_default$1r);
  const [name$1j, bem$1f] = createNamespace("switch");
  const switchProps = {
    size: numericProp,
    loading: Boolean,
    disabled: Boolean,
    modelValue: unknownProp,
    activeColor: String,
    inactiveColor: String,
    activeValue: {
      type: unknownProp,
      default: true
    },
    inactiveValue: {
      type: unknownProp,
      default: false
    }
  };
  var stdin_default$1q = vue.defineComponent({
    name: name$1j,
    props: switchProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const isChecked = () => props2.modelValue === props2.activeValue;
      const onClick = () => {
        if (!props2.disabled && !props2.loading) {
          const newValue = isChecked() ? props2.inactiveValue : props2.activeValue;
          emit("update:modelValue", newValue);
          emit("change", newValue);
        }
      };
      const renderLoading = () => {
        if (props2.loading) {
          const color = isChecked() ? props2.activeColor : props2.inactiveColor;
          return vue.createVNode(Loading, {
            "class": bem$1f("loading"),
            "color": color
          }, null);
        }
        if (slots.node) {
          return slots.node();
        }
      };
      useCustomFieldValue(() => props2.modelValue);
      return () => {
        var _a;
        const {
          size,
          loading,
          disabled,
          activeColor,
          inactiveColor
        } = props2;
        const checked = isChecked();
        const style = {
          fontSize: addUnit$2(size),
          backgroundColor: checked ? activeColor : inactiveColor
        };
        return vue.createVNode("div", {
          "role": "switch",
          "class": bem$1f({
            on: checked,
            loading,
            disabled
          }),
          "style": style,
          "tabindex": disabled ? void 0 : 0,
          "aria-checked": checked,
          "onClick": onClick
        }, [vue.createVNode("div", {
          "class": bem$1f("node")
        }, [renderLoading()]), (_a = slots.background) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Switch = withInstall(stdin_default$1q);
  const [name$1i, bem$1e] = createNamespace("address-edit-detail");
  const t$l = createNamespace("address-edit")[2];
  var stdin_default$1p = vue.defineComponent({
    name: name$1i,
    props: {
      show: Boolean,
      rows: numericProp,
      value: String,
      rules: Array,
      focused: Boolean,
      maxlength: numericProp,
      searchResult: Array,
      showSearchResult: Boolean
    },
    emits: ["blur", "focus", "input", "selectSearch"],
    setup(props2, {
      emit
    }) {
      const field = vue.ref();
      const showSearchResult = () => props2.focused && props2.searchResult && props2.showSearchResult;
      const onSelect = (express) => {
        emit("selectSearch", express);
        emit("input", `${express.address || ""} ${express.name || ""}`.trim());
      };
      const renderSearchResult = () => {
        if (!showSearchResult()) {
          return;
        }
        const {
          searchResult
        } = props2;
        return searchResult.map((express) => vue.createVNode(Cell, {
          "clickable": true,
          "key": (express.name || "") + (express.address || ""),
          "icon": "location-o",
          "title": express.name,
          "label": express.address,
          "class": bem$1e("search-item"),
          "border": false,
          "onClick": () => onSelect(express)
        }, null));
      };
      const onBlur = (event) => emit("blur", event);
      const onFocus = (event) => emit("focus", event);
      const onInput = (value) => emit("input", value);
      return () => {
        if (props2.show) {
          return vue.createVNode(vue.Fragment, null, [vue.createVNode(Field, {
            "autosize": true,
            "clearable": true,
            "ref": field,
            "class": bem$1e(),
            "rows": props2.rows,
            "type": "textarea",
            "rules": props2.rules,
            "label": t$l("addressDetail"),
            "border": !showSearchResult(),
            "maxlength": props2.maxlength,
            "modelValue": props2.value,
            "placeholder": t$l("addressDetail"),
            "onBlur": onBlur,
            "onFocus": onFocus,
            "onUpdate:modelValue": onInput
          }, null), renderSearchResult()]);
        }
      };
    }
  });
  const [name$1h, bem$1d, t$k] = createNamespace("address-edit");
  const DEFAULT_DATA = {
    name: "",
    tel: "",
    city: "",
    county: "",
    country: "",
    province: "",
    areaCode: "",
    isDefault: false,
    addressDetail: ""
  };
  const addressEditProps = {
    areaList: Object,
    isSaving: Boolean,
    isDeleting: Boolean,
    validator: Function,
    showArea: truthProp,
    showDetail: truthProp,
    showDelete: Boolean,
    disableArea: Boolean,
    searchResult: Array,
    telMaxlength: numericProp,
    showSetDefault: Boolean,
    saveButtonText: String,
    areaPlaceholder: String,
    deleteButtonText: String,
    showSearchResult: Boolean,
    detailRows: makeNumericProp(1),
    detailMaxlength: makeNumericProp(200),
    areaColumnsPlaceholder: makeArrayProp(),
    addressInfo: {
      type: Object,
      default: () => extend({}, DEFAULT_DATA)
    },
    telValidator: {
      type: Function,
      default: isMobile
    }
  };
  var stdin_default$1o = vue.defineComponent({
    name: name$1h,
    props: addressEditProps,
    emits: ["save", "focus", "change", "delete", "clickArea", "changeArea", "changeDetail", "selectSearch", "changeDefault"],
    setup(props2, {
      emit,
      slots
    }) {
      const areaRef = vue.ref();
      const data = vue.reactive({});
      const showAreaPopup = vue.ref(false);
      const detailFocused = vue.ref(false);
      const areaListLoaded = vue.computed(() => isObject$1(props2.areaList) && Object.keys(props2.areaList).length);
      const areaText = vue.computed(() => {
        const {
          province,
          city,
          county,
          areaCode
        } = data;
        if (areaCode) {
          const arr = [province, city, county];
          if (province && province === city) {
            arr.splice(1, 1);
          }
          return arr.filter(Boolean).join("/");
        }
        return "";
      });
      const hideBottomFields = vue.computed(() => {
        var _a;
        return ((_a = props2.searchResult) == null ? void 0 : _a.length) && detailFocused.value;
      });
      const onFocus = (key) => {
        detailFocused.value = key === "addressDetail";
        emit("focus", key);
      };
      const onChange = (key, value) => {
        emit("change", {
          key,
          value
        });
      };
      const rules = vue.computed(() => {
        const {
          validator,
          telValidator
        } = props2;
        const makeRule = (name2, emptyMessage) => ({
          validator: (value) => {
            if (validator) {
              const message = validator(name2, value);
              if (message) {
                return message;
              }
            }
            if (!value) {
              return emptyMessage;
            }
            return true;
          }
        });
        return {
          name: [makeRule("name", t$k("nameEmpty"))],
          tel: [makeRule("tel", t$k("telInvalid")), {
            validator: telValidator,
            message: t$k("telInvalid")
          }],
          areaCode: [makeRule("areaCode", t$k("areaEmpty"))],
          addressDetail: [makeRule("addressDetail", t$k("addressEmpty"))]
        };
      });
      const onSave = () => emit("save", data);
      const onChangeDetail = (val) => {
        data.addressDetail = val;
        emit("changeDetail", val);
      };
      const assignAreaText = (options) => {
        data.province = options[0].text;
        data.city = options[1].text;
        data.county = options[2].text;
      };
      const onAreaConfirm = ({
        selectedValues,
        selectedOptions
      }) => {
        if (selectedValues.some((value) => value === AREA_EMPTY_CODE)) {
          showToast(t$k("areaEmpty"));
        } else {
          showAreaPopup.value = false;
          assignAreaText(selectedOptions);
          emit("changeArea", selectedOptions);
        }
      };
      const onDelete = () => emit("delete", data);
      const setAreaCode = (code2) => {
        data.areaCode = code2 || "";
      };
      const onDetailBlur = () => {
        setTimeout(() => {
          detailFocused.value = false;
        });
      };
      const setAddressDetail = (value) => {
        data.addressDetail = value;
      };
      const renderSetDefaultCell = () => {
        if (props2.showSetDefault) {
          const slots2 = {
            "right-icon": () => vue.createVNode(Switch, {
              "modelValue": data.isDefault,
              "onUpdate:modelValue": ($event) => data.isDefault = $event,
              "onChange": (event) => emit("changeDefault", event)
            }, null)
          };
          return vue.withDirectives(vue.createVNode(Cell, {
            "center": true,
            "border": false,
            "title": t$k("defaultAddress"),
            "class": bem$1d("default")
          }, slots2), [[vue.vShow, !hideBottomFields.value]]);
        }
      };
      useExpose({
        setAreaCode,
        setAddressDetail
      });
      vue.watch(() => props2.addressInfo, (value) => {
        extend(data, DEFAULT_DATA, value);
        vue.nextTick(() => {
          var _a;
          const options = (_a = areaRef.value) == null ? void 0 : _a.getSelectedOptions();
          if (options && options.every((option) => option && option.value !== AREA_EMPTY_CODE)) {
            assignAreaText(options);
          }
        });
      }, {
        deep: true,
        immediate: true
      });
      return () => {
        const {
          disableArea
        } = props2;
        return vue.createVNode(Form, {
          "class": bem$1d(),
          "onSubmit": onSave
        }, {
          default: () => {
            var _a;
            return [vue.createVNode("div", {
              "class": bem$1d("fields")
            }, [vue.createVNode(Field, {
              "modelValue": data.name,
              "onUpdate:modelValue": [($event) => data.name = $event, (val) => onChange("name", val)],
              "clearable": true,
              "label": t$k("name"),
              "rules": rules.value.name,
              "placeholder": t$k("name"),
              "onFocus": () => onFocus("name")
            }, null), vue.createVNode(Field, {
              "modelValue": data.tel,
              "onUpdate:modelValue": [($event) => data.tel = $event, (val) => onChange("tel", val)],
              "clearable": true,
              "type": "tel",
              "label": t$k("tel"),
              "rules": rules.value.tel,
              "maxlength": props2.telMaxlength,
              "placeholder": t$k("tel"),
              "onFocus": () => onFocus("tel")
            }, null), vue.withDirectives(vue.createVNode(Field, {
              "readonly": true,
              "label": t$k("area"),
              "is-link": !disableArea,
              "modelValue": areaText.value,
              "rules": props2.showArea ? rules.value.areaCode : void 0,
              "placeholder": props2.areaPlaceholder || t$k("area"),
              "onFocus": () => onFocus("areaCode"),
              "onClick": () => {
                emit("clickArea");
                showAreaPopup.value = !disableArea;
              }
            }, null), [[vue.vShow, props2.showArea]]), vue.createVNode(stdin_default$1p, {
              "show": props2.showDetail,
              "rows": props2.detailRows,
              "rules": rules.value.addressDetail,
              "value": data.addressDetail,
              "focused": detailFocused.value,
              "maxlength": props2.detailMaxlength,
              "searchResult": props2.searchResult,
              "showSearchResult": props2.showSearchResult,
              "onBlur": onDetailBlur,
              "onFocus": () => onFocus("addressDetail"),
              "onInput": onChangeDetail,
              "onSelectSearch": (event) => emit("selectSearch", event)
            }, null), (_a = slots.default) == null ? void 0 : _a.call(slots)]), renderSetDefaultCell(), vue.withDirectives(vue.createVNode("div", {
              "class": bem$1d("buttons")
            }, [vue.createVNode(Button, {
              "block": true,
              "round": true,
              "type": "primary",
              "text": props2.saveButtonText || t$k("save"),
              "class": bem$1d("button"),
              "loading": props2.isSaving,
              "nativeType": "submit"
            }, null), props2.showDelete && vue.createVNode(Button, {
              "block": true,
              "round": true,
              "class": bem$1d("button"),
              "loading": props2.isDeleting,
              "text": props2.deleteButtonText || t$k("delete"),
              "onClick": onDelete
            }, null)]), [[vue.vShow, !hideBottomFields.value]]), vue.createVNode(Popup, {
              "show": showAreaPopup.value,
              "onUpdate:show": ($event) => showAreaPopup.value = $event,
              "round": true,
              "teleport": "body",
              "position": "bottom",
              "lazyRender": false
            }, {
              default: () => [vue.createVNode(Area, {
                "modelValue": data.areaCode,
                "onUpdate:modelValue": ($event) => data.areaCode = $event,
                "ref": areaRef,
                "loading": !areaListLoaded.value,
                "areaList": props2.areaList,
                "columnsPlaceholder": props2.areaColumnsPlaceholder,
                "onConfirm": onAreaConfirm,
                "onCancel": () => {
                  showAreaPopup.value = false;
                }
              }, null)]
            })];
          }
        });
      };
    }
  });
  const AddressEdit = withInstall(stdin_default$1o);
  const [name$1g, bem$1c] = createNamespace("radio-group");
  const radioGroupProps = {
    shape: String,
    disabled: Boolean,
    iconSize: numericProp,
    direction: String,
    modelValue: unknownProp,
    checkedColor: String
  };
  const RADIO_KEY = Symbol(name$1g);
  var stdin_default$1n = vue.defineComponent({
    name: name$1g,
    props: radioGroupProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        linkChildren
      } = useChildren(RADIO_KEY);
      const updateValue = (value) => emit("update:modelValue", value);
      vue.watch(() => props2.modelValue, (value) => emit("change", value));
      linkChildren({
        props: props2,
        updateValue
      });
      useCustomFieldValue(() => props2.modelValue);
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$1c([props2.direction]),
          "role": "radiogroup"
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const RadioGroup = withInstall(stdin_default$1n);
  const [name$1f, bem$1b] = createNamespace("checkbox-group");
  const checkboxGroupProps = {
    max: numericProp,
    shape: makeStringProp("round"),
    disabled: Boolean,
    iconSize: numericProp,
    direction: String,
    modelValue: makeArrayProp(),
    checkedColor: String
  };
  const CHECKBOX_GROUP_KEY = Symbol(name$1f);
  var stdin_default$1m = vue.defineComponent({
    name: name$1f,
    props: checkboxGroupProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        children,
        linkChildren
      } = useChildren(CHECKBOX_GROUP_KEY);
      const updateValue = (value) => emit("update:modelValue", value);
      const toggleAll = (options = {}) => {
        if (typeof options === "boolean") {
          options = {
            checked: options
          };
        }
        const {
          checked,
          skipDisabled
        } = options;
        const checkedChildren = children.filter((item) => {
          if (!item.props.bindGroup) {
            return false;
          }
          if (item.props.disabled && skipDisabled) {
            return item.checked.value;
          }
          return checked != null ? checked : !item.checked.value;
        });
        const names = checkedChildren.map((item) => item.name);
        updateValue(names);
      };
      vue.watch(() => props2.modelValue, (value) => emit("change", value));
      useExpose({
        toggleAll
      });
      useCustomFieldValue(() => props2.modelValue);
      linkChildren({
        props: props2,
        updateValue
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$1b([props2.direction])
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const CheckboxGroup = withInstall(stdin_default$1m);
  const [name$1e, bem$1a] = createNamespace("tag");
  const tagProps = {
    size: String,
    mark: Boolean,
    show: truthProp,
    type: makeStringProp("default"),
    color: String,
    plain: Boolean,
    round: Boolean,
    textColor: String,
    closeable: Boolean
  };
  var stdin_default$1l = vue.defineComponent({
    name: name$1e,
    props: tagProps,
    emits: ["close"],
    setup(props2, {
      slots,
      emit
    }) {
      const onClose = (event) => {
        event.stopPropagation();
        emit("close", event);
      };
      const getStyle = () => {
        if (props2.plain) {
          return {
            color: props2.textColor || props2.color,
            borderColor: props2.color
          };
        }
        return {
          color: props2.textColor,
          background: props2.color
        };
      };
      const renderTag = () => {
        var _a;
        const {
          type,
          mark: mark2,
          plain,
          round: round2,
          size,
          closeable
        } = props2;
        const classes = {
          mark: mark2,
          plain,
          round: round2
        };
        if (size) {
          classes[size] = size;
        }
        const CloseIcon = closeable && vue.createVNode(Icon, {
          "name": "cross",
          "class": [bem$1a("close"), HAPTICS_FEEDBACK],
          "onClick": onClose
        }, null);
        return vue.createVNode("span", {
          "style": getStyle(),
          "class": bem$1a([classes, type])
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots), CloseIcon]);
      };
      return () => vue.createVNode(vue.Transition, {
        "name": props2.closeable ? "van-fade" : void 0
      }, {
        default: () => [props2.show ? renderTag() : null]
      });
    }
  });
  const Tag = withInstall(stdin_default$1l);
  const checkerProps = {
    name: unknownProp,
    disabled: Boolean,
    iconSize: numericProp,
    modelValue: unknownProp,
    checkedColor: String,
    labelPosition: String,
    labelDisabled: Boolean
  };
  var stdin_default$1k = vue.defineComponent({
    props: extend({}, checkerProps, {
      bem: makeRequiredProp(Function),
      role: String,
      shape: String,
      parent: Object,
      checked: Boolean,
      bindGroup: truthProp,
      indeterminate: {
        type: Boolean,
        default: null
      }
    }),
    emits: ["click", "toggle"],
    setup(props2, {
      emit,
      slots
    }) {
      const iconRef = vue.ref();
      const getParentProp = (name2) => {
        if (props2.parent && props2.bindGroup) {
          return props2.parent.props[name2];
        }
      };
      const disabled = vue.computed(() => {
        if (props2.parent && props2.bindGroup) {
          const disabled2 = getParentProp("disabled") || props2.disabled;
          if (props2.role === "checkbox") {
            const checkedCount = getParentProp("modelValue").length;
            const max = getParentProp("max");
            const overlimit = max && checkedCount >= +max;
            return disabled2 || overlimit && !props2.checked;
          }
          return disabled2;
        }
        return props2.disabled;
      });
      const direction = vue.computed(() => getParentProp("direction"));
      const iconStyle = vue.computed(() => {
        const checkedColor = props2.checkedColor || getParentProp("checkedColor");
        if (checkedColor && props2.checked && !disabled.value) {
          return {
            borderColor: checkedColor,
            backgroundColor: checkedColor
          };
        }
      });
      const shape = vue.computed(() => {
        return props2.shape || getParentProp("shape") || "round";
      });
      const onClick = (event) => {
        const {
          target
        } = event;
        const icon = iconRef.value;
        const iconClicked = icon === target || (icon == null ? void 0 : icon.contains(target));
        if (!disabled.value && (iconClicked || !props2.labelDisabled)) {
          emit("toggle");
        }
        emit("click", event);
      };
      const renderIcon = () => {
        var _a, _b;
        const {
          bem: bem2,
          checked,
          indeterminate
        } = props2;
        const iconSize = props2.iconSize || getParentProp("iconSize");
        return vue.createVNode("div", {
          "ref": iconRef,
          "class": bem2("icon", [shape.value, {
            disabled: disabled.value,
            checked,
            indeterminate
          }]),
          "style": shape.value !== "dot" ? {
            fontSize: addUnit$2(iconSize)
          } : {
            width: addUnit$2(iconSize),
            height: addUnit$2(iconSize),
            borderColor: (_a = iconStyle.value) == null ? void 0 : _a.borderColor
          }
        }, [slots.icon ? slots.icon({
          checked,
          disabled: disabled.value
        }) : shape.value !== "dot" ? vue.createVNode(Icon, {
          "name": indeterminate ? "minus" : "success",
          "style": iconStyle.value
        }, null) : vue.createVNode("div", {
          "class": bem2("icon--dot__icon"),
          "style": {
            backgroundColor: (_b = iconStyle.value) == null ? void 0 : _b.backgroundColor
          }
        }, null)]);
      };
      const renderLabel = () => {
        const {
          checked
        } = props2;
        if (slots.default) {
          return vue.createVNode("span", {
            "class": props2.bem("label", [props2.labelPosition, {
              disabled: disabled.value
            }])
          }, [slots.default({
            checked,
            disabled: disabled.value
          })]);
        }
      };
      return () => {
        const nodes = props2.labelPosition === "left" ? [renderLabel(), renderIcon()] : [renderIcon(), renderLabel()];
        return vue.createVNode("div", {
          "role": props2.role,
          "class": props2.bem([{
            disabled: disabled.value,
            "label-disabled": props2.labelDisabled
          }, direction.value]),
          "tabindex": disabled.value ? void 0 : 0,
          "aria-checked": props2.checked,
          "onClick": onClick
        }, [nodes]);
      };
    }
  });
  const radioProps = extend({}, checkerProps, {
    shape: String
  });
  const [name$1d, bem$19] = createNamespace("radio");
  var stdin_default$1j = vue.defineComponent({
    name: name$1d,
    props: radioProps,
    emits: ["update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        parent
      } = useParent(RADIO_KEY);
      const checked = () => {
        const value = parent ? parent.props.modelValue : props2.modelValue;
        return value === props2.name;
      };
      const toggle = () => {
        if (parent) {
          parent.updateValue(props2.name);
        } else {
          emit("update:modelValue", props2.name);
        }
      };
      return () => vue.createVNode(stdin_default$1k, vue.mergeProps({
        "bem": bem$19,
        "role": "radio",
        "parent": parent,
        "checked": checked(),
        "onToggle": toggle
      }, props2), pick(slots, ["default", "icon"]));
    }
  });
  const Radio = withInstall(stdin_default$1j);
  const [name$1c, bem$18] = createNamespace("checkbox");
  const checkboxProps = extend({}, checkerProps, {
    shape: String,
    bindGroup: truthProp,
    indeterminate: {
      type: Boolean,
      default: null
    }
  });
  var stdin_default$1i = vue.defineComponent({
    name: name$1c,
    props: checkboxProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        parent
      } = useParent(CHECKBOX_GROUP_KEY);
      const setParentValue = (checked2) => {
        const {
          name: name2
        } = props2;
        const {
          max,
          modelValue
        } = parent.props;
        const value = modelValue.slice();
        if (checked2) {
          const overlimit = max && value.length >= +max;
          if (!overlimit && !value.includes(name2)) {
            value.push(name2);
            if (props2.bindGroup) {
              parent.updateValue(value);
            }
          }
        } else {
          const index2 = value.indexOf(name2);
          if (index2 !== -1) {
            value.splice(index2, 1);
            if (props2.bindGroup) {
              parent.updateValue(value);
            }
          }
        }
      };
      const checked = vue.computed(() => {
        if (parent && props2.bindGroup) {
          return parent.props.modelValue.indexOf(props2.name) !== -1;
        }
        return !!props2.modelValue;
      });
      const toggle = (newValue = !checked.value) => {
        if (parent && props2.bindGroup) {
          setParentValue(newValue);
        } else {
          emit("update:modelValue", newValue);
        }
        if (props2.indeterminate !== null)
          emit("change", newValue);
      };
      vue.watch(() => props2.modelValue, (value) => {
        if (props2.indeterminate === null)
          emit("change", value);
      });
      useExpose({
        toggle,
        props: props2,
        checked
      });
      useCustomFieldValue(() => props2.modelValue);
      return () => vue.createVNode(stdin_default$1k, vue.mergeProps({
        "bem": bem$18,
        "role": "checkbox",
        "parent": parent,
        "checked": checked.value,
        "onToggle": toggle
      }, props2), pick(slots, ["default", "icon"]));
    }
  });
  const Checkbox = withInstall(stdin_default$1i);
  const [name$1b, bem$17] = createNamespace("address-item");
  var stdin_default$1h = vue.defineComponent({
    name: name$1b,
    props: {
      address: makeRequiredProp(Object),
      disabled: Boolean,
      switchable: Boolean,
      singleChoice: Boolean,
      defaultTagText: String,
      rightIcon: makeStringProp("edit")
    },
    emits: ["edit", "click", "select"],
    setup(props2, {
      slots,
      emit
    }) {
      const onClick = (event) => {
        if (props2.switchable) {
          emit("select");
        }
        emit("click", event);
      };
      const renderRightIcon = () => vue.createVNode(Icon, {
        "name": props2.rightIcon,
        "class": bem$17("edit"),
        "onClick": (event) => {
          event.stopPropagation();
          emit("edit");
          emit("click", event);
        }
      }, null);
      const renderTag = () => {
        if (slots.tag) {
          return slots.tag(props2.address);
        }
        if (props2.address.isDefault && props2.defaultTagText) {
          return vue.createVNode(Tag, {
            "type": "primary",
            "round": true,
            "class": bem$17("tag")
          }, {
            default: () => [props2.defaultTagText]
          });
        }
      };
      const renderContent = () => {
        const {
          address,
          disabled,
          switchable,
          singleChoice
        } = props2;
        const Info = [vue.createVNode("div", {
          "class": bem$17("name")
        }, [`${address.name} ${address.tel}`, renderTag()]), vue.createVNode("div", {
          "class": bem$17("address")
        }, [address.address])];
        if (switchable && !disabled) {
          if (singleChoice) {
            return vue.createVNode(Radio, {
              "name": address.id,
              "iconSize": 18
            }, {
              default: () => [Info]
            });
          } else {
            return vue.createVNode(Checkbox, {
              "name": address.id,
              "iconSize": 18
            }, {
              default: () => [Info]
            });
          }
        }
        return Info;
      };
      return () => {
        var _a;
        const {
          disabled
        } = props2;
        return vue.createVNode("div", {
          "class": bem$17({
            disabled
          }),
          "onClick": onClick
        }, [vue.createVNode(Cell, {
          "border": false,
          "titleClass": bem$17("title")
        }, {
          title: renderContent,
          "right-icon": renderRightIcon
        }), (_a = slots.bottom) == null ? void 0 : _a.call(slots, extend({}, props2.address, {
          disabled
        }))]);
      };
    }
  });
  const [name$1a, bem$16, t$j] = createNamespace("address-list");
  const addressListProps = {
    list: makeArrayProp(),
    modelValue: [...numericProp, Array],
    switchable: truthProp,
    disabledText: String,
    disabledList: makeArrayProp(),
    showAddButton: truthProp,
    addButtonText: String,
    defaultTagText: String,
    rightIcon: makeStringProp("edit")
  };
  var stdin_default$1g = vue.defineComponent({
    name: name$1a,
    props: addressListProps,
    emits: ["add", "edit", "select", "clickItem", "editDisabled", "selectDisabled", "update:modelValue"],
    setup(props2, {
      slots,
      emit
    }) {
      const singleChoice = vue.computed(() => !Array.isArray(props2.modelValue));
      const renderItem = (item, index2, disabled) => {
        const onEdit = () => emit(disabled ? "editDisabled" : "edit", item, index2);
        const onClick = (event) => emit("clickItem", item, index2, {
          event
        });
        const onSelect = () => {
          emit(disabled ? "selectDisabled" : "select", item, index2);
          if (!disabled) {
            if (singleChoice.value) {
              emit("update:modelValue", item.id);
            } else {
              const value = props2.modelValue;
              if (value.includes(item.id)) {
                emit("update:modelValue", value.filter((id) => id !== item.id));
              } else {
                emit("update:modelValue", [...value, item.id]);
              }
            }
          }
        };
        return vue.createVNode(stdin_default$1h, {
          "key": item.id,
          "address": item,
          "disabled": disabled,
          "switchable": props2.switchable,
          "singleChoice": singleChoice.value,
          "defaultTagText": props2.defaultTagText,
          "rightIcon": props2.rightIcon,
          "onEdit": onEdit,
          "onClick": onClick,
          "onSelect": onSelect
        }, {
          bottom: slots["item-bottom"],
          tag: slots.tag
        });
      };
      const renderList = (list, disabled) => {
        if (list) {
          return list.map((item, index2) => renderItem(item, index2, disabled));
        }
      };
      const renderBottom = () => props2.showAddButton ? vue.createVNode("div", {
        "class": [bem$16("bottom"), "van-safe-area-bottom"]
      }, [vue.createVNode(Button, {
        "round": true,
        "block": true,
        "type": "primary",
        "text": props2.addButtonText || t$j("add"),
        "class": bem$16("add"),
        "onClick": () => emit("add")
      }, null)]) : void 0;
      return () => {
        var _a, _b;
        const List2 = renderList(props2.list);
        const DisabledList = renderList(props2.disabledList, true);
        const DisabledText = props2.disabledText && vue.createVNode("div", {
          "class": bem$16("disabled-text")
        }, [props2.disabledText]);
        return vue.createVNode("div", {
          "class": bem$16()
        }, [(_a = slots.top) == null ? void 0 : _a.call(slots), !singleChoice.value && Array.isArray(props2.modelValue) ? vue.createVNode(CheckboxGroup, {
          "modelValue": props2.modelValue
        }, {
          default: () => [List2]
        }) : vue.createVNode(RadioGroup, {
          "modelValue": props2.modelValue
        }, {
          default: () => [List2]
        }), DisabledText, DisabledList, (_b = slots.default) == null ? void 0 : _b.call(slots), renderBottom()]);
      };
    }
  });
  const AddressList = withInstall(stdin_default$1g);
  function throttle$1(action, delay2) {
    let timeout2 = null;
    let lastRun = 0;
    return function(...args) {
      if (timeout2) {
        return;
      }
      const elapsed = Date.now() - lastRun;
      const runCallback = () => {
        lastRun = Date.now();
        timeout2 = false;
        action.apply(this, args);
      };
      if (elapsed >= delay2) {
        runCallback();
      } else {
        timeout2 = setTimeout(runCallback, delay2);
      }
    };
  }
  const [name$19, bem$15] = createNamespace("back-top");
  const backTopProps = {
    right: numericProp,
    bottom: numericProp,
    zIndex: numericProp,
    target: [String, Object],
    offset: makeNumericProp(200),
    immediate: Boolean,
    teleport: {
      type: [String, Object],
      default: "body"
    }
  };
  var stdin_default$1f = vue.defineComponent({
    name: name$19,
    inheritAttrs: false,
    props: backTopProps,
    emits: ["click"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      let shouldReshow = false;
      const show = vue.ref(false);
      const root = vue.ref();
      const scrollParent = vue.ref();
      const style = vue.computed(() => extend(getZIndexStyle(props2.zIndex), {
        right: addUnit$2(props2.right),
        bottom: addUnit$2(props2.bottom)
      }));
      const onClick = (event) => {
        var _a;
        emit("click", event);
        (_a = scrollParent.value) == null ? void 0 : _a.scrollTo({
          top: 0,
          behavior: props2.immediate ? "auto" : "smooth"
        });
      };
      const scroll = () => {
        show.value = scrollParent.value ? getScrollTop(scrollParent.value) >= +props2.offset : false;
      };
      const getTarget2 = () => {
        const {
          target
        } = props2;
        if (typeof target === "string") {
          const el = document.querySelector(target);
          if (el) {
            return el;
          }
          {
            formatAppLog("error", "at node_modules/vant/es/back-top/BackTop.mjs:58", `[Vant] BackTop: target element "${target}" was not found, the BackTop component will not be rendered.`);
          }
        } else {
          return target;
        }
      };
      const updateTarget = () => {
        if (inBrowser$1) {
          vue.nextTick(() => {
            scrollParent.value = props2.target ? getTarget2() : getScrollParent$1(root.value);
            scroll();
          });
        }
      };
      useEventListener("scroll", throttle$1(scroll, 100), {
        target: scrollParent
      });
      vue.onMounted(updateTarget);
      vue.onActivated(() => {
        if (shouldReshow) {
          show.value = true;
          shouldReshow = false;
        }
      });
      vue.onDeactivated(() => {
        if (show.value && props2.teleport) {
          show.value = false;
          shouldReshow = true;
        }
      });
      vue.watch(() => props2.target, updateTarget);
      return () => {
        const Content = vue.createVNode("div", vue.mergeProps({
          "ref": !props2.teleport ? root : void 0,
          "class": bem$15({
            active: show.value
          }),
          "style": style.value,
          "onClick": onClick
        }, attrs), [slots.default ? slots.default() : vue.createVNode(Icon, {
          "name": "back-top",
          "class": bem$15("icon")
        }, null)]);
        if (props2.teleport) {
          return [vue.createVNode("div", {
            "ref": root,
            "class": bem$15("placeholder")
          }, null), vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [Content]
          })];
        }
        return Content;
      };
    }
  });
  const BackTop = withInstall(stdin_default$1f);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const barrageProps = {
    top: makeNumericProp(10),
    rows: makeNumericProp(4),
    duration: makeNumericProp(4e3),
    autoPlay: truthProp,
    delay: makeNumberProp(300),
    modelValue: makeArrayProp()
  };
  const [name$18, bem$14] = createNamespace("barrage");
  var stdin_default$1e = vue.defineComponent({
    name: name$18,
    props: barrageProps,
    emits: ["update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const barrageWrapper = vue.ref();
      const className = bem$14("item");
      const total = vue.ref(0);
      const barrageItems = [];
      const createBarrageItem = (text, delay2 = props2.delay) => {
        const item = document.createElement("span");
        item.className = className;
        item.innerText = String(text);
        item.style.animationDuration = `${props2.duration}ms`;
        item.style.animationDelay = `${delay2}ms`;
        item.style.animationName = "van-barrage";
        item.style.animationTimingFunction = "linear";
        return item;
      };
      const isInitBarrage = vue.ref(true);
      const isPlay = vue.ref(props2.autoPlay);
      const appendBarrageItem = ({
        id,
        text
      }, i2) => {
        var _a;
        const item = createBarrageItem(text, isInitBarrage.value ? i2 * props2.delay : void 0);
        if (!props2.autoPlay && isPlay.value === false) {
          item.style.animationPlayState = "paused";
        }
        (_a = barrageWrapper.value) == null ? void 0 : _a.append(item);
        total.value++;
        const top2 = (total.value - 1) % +props2.rows * item.offsetHeight + +props2.top;
        item.style.top = `${top2}px`;
        item.dataset.id = String(id);
        barrageItems.push(item);
        item.addEventListener("animationend", () => {
          emit("update:modelValue", [...props2.modelValue].filter((v2) => String(v2.id) !== item.dataset.id));
        });
      };
      const updateBarrages = (newValue, oldValue) => {
        const map = new Map(oldValue.map((item) => [item.id, item]));
        newValue.forEach((item, i2) => {
          if (map.has(item.id)) {
            map.delete(item.id);
          } else {
            appendBarrageItem(item, i2);
          }
        });
        map.forEach((item) => {
          const index2 = barrageItems.findIndex((span) => span.dataset.id === String(item.id));
          if (index2 > -1) {
            barrageItems[index2].remove();
            barrageItems.splice(index2, 1);
          }
        });
        isInitBarrage.value = false;
      };
      vue.watch(() => props2.modelValue.slice(), (newValue, oldValue) => updateBarrages(newValue != null ? newValue : [], oldValue != null ? oldValue : []), {
        deep: true
      });
      const rootStyle = vue.ref({});
      vue.onMounted(() => __async(this, null, function* () {
        var _a;
        rootStyle.value["--move-distance"] = `-${(_a = barrageWrapper.value) == null ? void 0 : _a.offsetWidth}px`;
        yield vue.nextTick();
        updateBarrages(props2.modelValue, []);
      }));
      const play = () => {
        isPlay.value = true;
        barrageItems.forEach((item) => {
          item.style.animationPlayState = "running";
        });
      };
      const pause = () => {
        isPlay.value = false;
        barrageItems.forEach((item) => {
          item.style.animationPlayState = "paused";
        });
      };
      useExpose({
        play,
        pause
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$14(),
          "ref": barrageWrapper,
          "style": rootStyle.value
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Barrage = withInstall(stdin_default$1e);
  const [name$17, bem$13, t$i] = createNamespace("calendar");
  const formatMonthTitle = (date2) => t$i("monthTitle", date2.getFullYear(), date2.getMonth() + 1);
  function compareMonth(date1, date2) {
    const year1 = date1.getFullYear();
    const year2 = date2.getFullYear();
    if (year1 === year2) {
      const month1 = date1.getMonth();
      const month2 = date2.getMonth();
      return month1 === month2 ? 0 : month1 > month2 ? 1 : -1;
    }
    return year1 > year2 ? 1 : -1;
  }
  function compareDay(day1, day2) {
    const compareMonthResult = compareMonth(day1, day2);
    if (compareMonthResult === 0) {
      const date1 = day1.getDate();
      const date2 = day2.getDate();
      return date1 === date2 ? 0 : date1 > date2 ? 1 : -1;
    }
    return compareMonthResult;
  }
  const cloneDate = (date2) => new Date(date2);
  const cloneDates = (dates) => Array.isArray(dates) ? dates.map(cloneDate) : cloneDate(dates);
  function getDayByOffset(date2, offset2) {
    const cloned = cloneDate(date2);
    cloned.setDate(cloned.getDate() + offset2);
    return cloned;
  }
  function getMonthByOffset(date2, offset2) {
    const cloned = cloneDate(date2);
    cloned.setMonth(cloned.getMonth() + offset2);
    if (cloned.getDate() !== date2.getDate()) {
      cloned.setDate(0);
    }
    return cloned;
  }
  function getYearByOffset(date2, offset2) {
    const cloned = cloneDate(date2);
    cloned.setFullYear(cloned.getFullYear() + offset2);
    if (cloned.getDate() !== date2.getDate()) {
      cloned.setDate(0);
    }
    return cloned;
  }
  const getPrevDay = (date2) => getDayByOffset(date2, -1);
  const getNextDay = (date2) => getDayByOffset(date2, 1);
  const getPrevMonth = (date2) => getMonthByOffset(date2, -1);
  const getNextMonth = (date2) => getMonthByOffset(date2, 1);
  const getPrevYear = (date2) => getYearByOffset(date2, -1);
  const getNextYear = (date2) => getYearByOffset(date2, 1);
  const getToday = () => {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    return today;
  };
  function calcDateNum(date2) {
    const day1 = date2[0].getTime();
    const day2 = date2[1].getTime();
    return (day2 - day1) / (1e3 * 60 * 60 * 24) + 1;
  }
  const sharedProps = extend({}, pickerSharedProps, {
    modelValue: makeArrayProp(),
    filter: Function,
    formatter: {
      type: Function,
      default: (type, option) => option
    }
  });
  const pickerInheritKeys = Object.keys(pickerSharedProps);
  function times$1(n2, iteratee) {
    if (n2 < 0) {
      return [];
    }
    const result = Array(n2);
    let index2 = -1;
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  const getMonthEndDay = (year, month) => 32 - new Date(year, month - 1, 32).getDate();
  const genOptions = (min, max, type, formatter, filter, values) => {
    const options = times$1(max - min + 1, (index2) => {
      const value = padZero$1(min + index2);
      return formatter(type, {
        text: value,
        value
      });
    });
    return filter ? filter(type, options, values) : options;
  };
  const formatValueRange = (values, columns) => values.map((value, index2) => {
    const column = columns[index2];
    if (column.length) {
      const minValue = +column[0].value;
      const maxValue = +column[column.length - 1].value;
      return padZero$1(clamp(+value, minValue, maxValue));
    }
    return value;
  });
  const [name$16] = createNamespace("calendar-day");
  var stdin_default$1d = vue.defineComponent({
    name: name$16,
    props: {
      item: makeRequiredProp(Object),
      color: String,
      index: Number,
      offset: makeNumberProp(0),
      rowHeight: String
    },
    emits: ["click", "clickDisabledDate"],
    setup(props2, {
      emit,
      slots
    }) {
      const style = vue.computed(() => {
        var _a;
        const {
          item,
          index: index2,
          color,
          offset: offset2,
          rowHeight
        } = props2;
        const style2 = {
          height: rowHeight
        };
        if (item.type === "placeholder") {
          style2.width = "100%";
          return style2;
        }
        if (index2 === 0) {
          style2.marginLeft = `${100 * offset2 / 7}%`;
        }
        if (color) {
          switch (item.type) {
            case "end":
            case "start":
            case "start-end":
            case "multiple-middle":
            case "multiple-selected":
              style2.background = color;
              break;
            case "middle":
              style2.color = color;
              break;
          }
        }
        if (offset2 + (((_a = item.date) == null ? void 0 : _a.getDate()) || 1) > 28) {
          style2.marginBottom = 0;
        }
        return style2;
      });
      const onClick = () => {
        if (props2.item.type !== "disabled") {
          emit("click", props2.item);
        } else {
          emit("clickDisabledDate", props2.item);
        }
      };
      const renderTopInfo = () => {
        const {
          topInfo
        } = props2.item;
        if (topInfo || slots["top-info"]) {
          return vue.createVNode("div", {
            "class": bem$13("top-info")
          }, [slots["top-info"] ? slots["top-info"](props2.item) : topInfo]);
        }
      };
      const renderBottomInfo = () => {
        const {
          bottomInfo
        } = props2.item;
        if (bottomInfo || slots["bottom-info"]) {
          return vue.createVNode("div", {
            "class": bem$13("bottom-info")
          }, [slots["bottom-info"] ? slots["bottom-info"](props2.item) : bottomInfo]);
        }
      };
      const renderText = () => {
        return slots.text ? slots.text(props2.item) : props2.item.text;
      };
      const renderContent = () => {
        const {
          item,
          color,
          rowHeight
        } = props2;
        const {
          type
        } = item;
        const Nodes = [renderTopInfo(), renderText(), renderBottomInfo()];
        if (type === "selected") {
          return vue.createVNode("div", {
            "class": bem$13("selected-day"),
            "style": {
              width: rowHeight,
              height: rowHeight,
              background: color
            }
          }, [Nodes]);
        }
        return Nodes;
      };
      return () => {
        const {
          type,
          className
        } = props2.item;
        if (type === "placeholder") {
          return vue.createVNode("div", {
            "class": bem$13("day"),
            "style": style.value
          }, null);
        }
        return vue.createVNode("div", {
          "role": "gridcell",
          "style": style.value,
          "class": [bem$13("day", type), className],
          "tabindex": type === "disabled" ? void 0 : -1,
          "onClick": onClick
        }, [renderContent()]);
      };
    }
  });
  const [name$15] = createNamespace("calendar-month");
  const calendarMonthProps = {
    date: makeRequiredProp(Date),
    type: String,
    color: String,
    minDate: Date,
    maxDate: Date,
    showMark: Boolean,
    rowHeight: numericProp,
    formatter: Function,
    lazyRender: Boolean,
    currentDate: [Date, Array],
    allowSameDay: Boolean,
    showSubtitle: Boolean,
    showMonthTitle: Boolean,
    firstDayOfWeek: Number
  };
  var stdin_default$1c = vue.defineComponent({
    name: name$15,
    props: calendarMonthProps,
    emits: ["click", "clickDisabledDate"],
    setup(props2, {
      emit,
      slots
    }) {
      const [visible, setVisible] = useToggle();
      const daysRef = vue.ref();
      const monthRef = vue.ref();
      const height2 = useHeight(monthRef);
      const title = vue.computed(() => formatMonthTitle(props2.date));
      const rowHeight = vue.computed(() => addUnit$2(props2.rowHeight));
      const offset2 = vue.computed(() => {
        const date2 = props2.date.getDate();
        const day = props2.date.getDay();
        const realDay = (day - date2 % 7 + 8) % 7;
        if (props2.firstDayOfWeek) {
          return (realDay + 7 - props2.firstDayOfWeek) % 7;
        }
        return realDay;
      });
      const totalDay = vue.computed(() => getMonthEndDay(props2.date.getFullYear(), props2.date.getMonth() + 1));
      const shouldRender = vue.computed(() => visible.value || !props2.lazyRender);
      const getTitle = () => title.value;
      const getMultipleDayType = (day) => {
        const isSelected = (date2) => props2.currentDate.some((item) => compareDay(item, date2) === 0);
        if (isSelected(day)) {
          const prevDay = getPrevDay(day);
          const nextDay = getNextDay(day);
          const prevSelected = isSelected(prevDay);
          const nextSelected = isSelected(nextDay);
          if (prevSelected && nextSelected) {
            return "multiple-middle";
          }
          if (prevSelected) {
            return "end";
          }
          if (nextSelected) {
            return "start";
          }
          return "multiple-selected";
        }
        return "";
      };
      const getRangeDayType = (day) => {
        const [startDay, endDay] = props2.currentDate;
        if (!startDay) {
          return "";
        }
        const compareToStart = compareDay(day, startDay);
        if (!endDay) {
          return compareToStart === 0 ? "start" : "";
        }
        const compareToEnd = compareDay(day, endDay);
        if (props2.allowSameDay && compareToStart === 0 && compareToEnd === 0) {
          return "start-end";
        }
        if (compareToStart === 0) {
          return "start";
        }
        if (compareToEnd === 0) {
          return "end";
        }
        if (compareToStart > 0 && compareToEnd < 0) {
          return "middle";
        }
        return "";
      };
      const getDayType = (day) => {
        const {
          type,
          minDate,
          maxDate,
          currentDate
        } = props2;
        if (minDate && compareDay(day, minDate) < 0 || maxDate && compareDay(day, maxDate) > 0) {
          return "disabled";
        }
        if (currentDate === null) {
          return "";
        }
        if (Array.isArray(currentDate)) {
          if (type === "multiple") {
            return getMultipleDayType(day);
          }
          if (type === "range") {
            return getRangeDayType(day);
          }
        } else if (type === "single") {
          return compareDay(day, currentDate) === 0 ? "selected" : "";
        }
        return "";
      };
      const getBottomInfo = (dayType) => {
        if (props2.type === "range") {
          if (dayType === "start" || dayType === "end") {
            return t$i(dayType);
          }
          if (dayType === "start-end") {
            return `${t$i("start")}/${t$i("end")}`;
          }
        }
      };
      const renderTitle = () => {
        if (props2.showMonthTitle) {
          return vue.createVNode("div", {
            "class": bem$13("month-title")
          }, [slots["month-title"] ? slots["month-title"]({
            date: props2.date,
            text: title.value
          }) : title.value]);
        }
      };
      const renderMark = () => {
        if (props2.showMark && shouldRender.value) {
          return vue.createVNode("div", {
            "class": bem$13("month-mark")
          }, [props2.date.getMonth() + 1]);
        }
      };
      const placeholders = vue.computed(() => {
        const count = Math.ceil((totalDay.value + offset2.value) / 7);
        return Array(count).fill({
          type: "placeholder"
        });
      });
      const days = vue.computed(() => {
        const days2 = [];
        const year = props2.date.getFullYear();
        const month = props2.date.getMonth();
        for (let day = 1; day <= totalDay.value; day++) {
          const date2 = new Date(year, month, day);
          const type = getDayType(date2);
          let config2 = {
            date: date2,
            type,
            text: day,
            bottomInfo: getBottomInfo(type)
          };
          if (props2.formatter) {
            config2 = props2.formatter(config2);
          }
          days2.push(config2);
        }
        return days2;
      });
      const disabledDays = vue.computed(() => days.value.filter((day) => day.type === "disabled"));
      const scrollToDate = (body, targetDate) => {
        if (daysRef.value) {
          const daysRect = useRect(daysRef.value);
          const totalRows = placeholders.value.length;
          const currentRow = Math.ceil((targetDate.getDate() + offset2.value) / 7);
          const rowOffset = (currentRow - 1) * daysRect.height / totalRows;
          setScrollTop(body, daysRect.top + rowOffset + body.scrollTop - useRect(body).top);
        }
      };
      const renderDay = (item, index2) => vue.createVNode(stdin_default$1d, {
        "item": item,
        "index": index2,
        "color": props2.color,
        "offset": offset2.value,
        "rowHeight": rowHeight.value,
        "onClick": (item2) => emit("click", item2),
        "onClickDisabledDate": (item2) => emit("clickDisabledDate", item2)
      }, pick(slots, ["top-info", "bottom-info", "text"]));
      const renderDays = () => vue.createVNode("div", {
        "ref": daysRef,
        "role": "grid",
        "class": bem$13("days")
      }, [renderMark(), (shouldRender.value ? days : placeholders).value.map(renderDay)]);
      useExpose({
        getTitle,
        getHeight: () => height2.value,
        setVisible,
        scrollToDate,
        disabledDays
      });
      return () => vue.createVNode("div", {
        "class": bem$13("month"),
        "ref": monthRef
      }, [renderTitle(), renderDays()]);
    }
  });
  const [name$14] = createNamespace("calendar-header");
  var stdin_default$1b = vue.defineComponent({
    name: name$14,
    props: {
      date: Date,
      minDate: Date,
      maxDate: Date,
      title: String,
      subtitle: String,
      showTitle: Boolean,
      showSubtitle: Boolean,
      firstDayOfWeek: Number,
      switchMode: makeStringProp("none")
    },
    emits: ["clickSubtitle", "panelChange"],
    setup(props2, {
      slots,
      emit
    }) {
      const prevMonthDisabled = vue.computed(() => props2.date && props2.minDate && compareMonth(getPrevMonth(props2.date), props2.minDate) < 0);
      const prevYearDisabled = vue.computed(() => props2.date && props2.minDate && compareMonth(getPrevYear(props2.date), props2.minDate) < 0);
      const nextMonthDisabled = vue.computed(() => props2.date && props2.maxDate && compareMonth(getNextMonth(props2.date), props2.maxDate) > 0);
      const nextYearDisabled = vue.computed(() => props2.date && props2.maxDate && compareMonth(getNextYear(props2.date), props2.maxDate) > 0);
      const renderTitle = () => {
        if (props2.showTitle) {
          const text = props2.title || t$i("title");
          const title = slots.title ? slots.title() : text;
          return vue.createVNode("div", {
            "class": bem$13("header-title")
          }, [title]);
        }
      };
      const onClickSubtitle = (event) => emit("clickSubtitle", event);
      const onPanelChange = (date2) => emit("panelChange", date2);
      const renderAction = (isNext) => {
        const showYearAction = props2.switchMode === "year-month";
        const monthSlot = slots[isNext ? "next-month" : "prev-month"];
        const yearSlot = slots[isNext ? "next-year" : "prev-year"];
        const monthDisabled = isNext ? nextMonthDisabled.value : prevMonthDisabled.value;
        const yearDisabled = isNext ? nextYearDisabled.value : prevYearDisabled.value;
        const monthIconName = isNext ? "arrow" : "arrow-left";
        const yearIconName = isNext ? "arrow-double-right" : "arrow-double-left";
        const onMonthChange = () => onPanelChange((isNext ? getNextMonth : getPrevMonth)(props2.date));
        const onYearChange = () => onPanelChange((isNext ? getNextYear : getPrevYear)(props2.date));
        const MonthAction = vue.createVNode("view", {
          "class": bem$13("header-action", {
            disabled: monthDisabled
          }),
          "onClick": monthDisabled ? void 0 : onMonthChange
        }, [monthSlot ? monthSlot({
          disabled: monthDisabled
        }) : vue.createVNode(Icon, {
          "class": {
            [HAPTICS_FEEDBACK]: !monthDisabled
          },
          "name": monthIconName
        }, null)]);
        const YearAction = showYearAction && vue.createVNode("view", {
          "class": bem$13("header-action", {
            disabled: yearDisabled
          }),
          "onClick": yearDisabled ? void 0 : onYearChange
        }, [yearSlot ? yearSlot({
          disabled: yearDisabled
        }) : vue.createVNode(Icon, {
          "class": {
            [HAPTICS_FEEDBACK]: !yearDisabled
          },
          "name": yearIconName
        }, null)]);
        return isNext ? [MonthAction, YearAction] : [YearAction, MonthAction];
      };
      const renderSubtitle = () => {
        if (props2.showSubtitle) {
          const title = slots.subtitle ? slots.subtitle({
            date: props2.date,
            text: props2.subtitle
          }) : props2.subtitle;
          const canSwitch = props2.switchMode !== "none";
          return vue.createVNode("div", {
            "class": bem$13("header-subtitle", {
              "with-switch": canSwitch
            }),
            "onClick": onClickSubtitle
          }, [canSwitch ? [renderAction(), vue.createVNode("div", {
            "class": bem$13("header-subtitle-text")
          }, [title]), renderAction(true)] : title]);
        }
      };
      const renderWeekDays = () => {
        const {
          firstDayOfWeek
        } = props2;
        const weekdays = t$i("weekdays");
        const renderWeekDays2 = [...weekdays.slice(firstDayOfWeek, 7), ...weekdays.slice(0, firstDayOfWeek)];
        return vue.createVNode("div", {
          "class": bem$13("weekdays")
        }, [renderWeekDays2.map((text) => vue.createVNode("span", {
          "class": bem$13("weekday")
        }, [text]))]);
      };
      return () => vue.createVNode("div", {
        "class": bem$13("header")
      }, [renderTitle(), renderSubtitle(), renderWeekDays()]);
    }
  });
  const calendarProps = {
    show: Boolean,
    type: makeStringProp("single"),
    switchMode: makeStringProp("none"),
    title: String,
    color: String,
    round: truthProp,
    readonly: Boolean,
    poppable: truthProp,
    maxRange: makeNumericProp(null),
    position: makeStringProp("bottom"),
    teleport: [String, Object],
    showMark: truthProp,
    showTitle: truthProp,
    formatter: Function,
    rowHeight: numericProp,
    confirmText: String,
    rangePrompt: String,
    lazyRender: truthProp,
    showConfirm: truthProp,
    defaultDate: [Date, Array],
    allowSameDay: Boolean,
    showSubtitle: truthProp,
    closeOnPopstate: truthProp,
    showRangePrompt: truthProp,
    confirmDisabledText: String,
    closeOnClickOverlay: truthProp,
    safeAreaInsetTop: Boolean,
    safeAreaInsetBottom: truthProp,
    minDate: {
      type: Date,
      validator: isDate
    },
    maxDate: {
      type: Date,
      validator: isDate
    },
    firstDayOfWeek: {
      type: numericProp,
      default: 0,
      validator: (val) => val >= 0 && val <= 6
    }
  };
  var stdin_default$1a = vue.defineComponent({
    name: name$17,
    props: calendarProps,
    emits: ["select", "confirm", "unselect", "monthShow", "overRange", "update:show", "clickSubtitle", "clickDisabledDate", "panelChange"],
    setup(props2, {
      emit,
      slots
    }) {
      const canSwitch = vue.computed(() => props2.switchMode !== "none");
      const minDate = vue.computed(() => {
        if (!props2.minDate && !canSwitch.value) {
          return getToday();
        }
        return props2.minDate;
      });
      const maxDate = vue.computed(() => {
        if (!props2.maxDate && !canSwitch.value) {
          return getMonthByOffset(getToday(), 6);
        }
        return props2.maxDate;
      });
      const limitDateRange = (date2, min = minDate.value, max = maxDate.value) => {
        if (min && compareDay(date2, min) === -1) {
          return min;
        }
        if (max && compareDay(date2, max) === 1) {
          return max;
        }
        return date2;
      };
      const getInitialDate = (defaultDate = props2.defaultDate) => {
        const {
          type,
          allowSameDay
        } = props2;
        if (defaultDate === null) {
          return defaultDate;
        }
        const now2 = getToday();
        if (type === "range") {
          if (!Array.isArray(defaultDate)) {
            defaultDate = [];
          }
          if (defaultDate.length === 1 && compareDay(defaultDate[0], now2) === 1) {
            defaultDate = [];
          }
          const min = minDate.value;
          const max = maxDate.value;
          const start2 = limitDateRange(defaultDate[0] || now2, min, max ? allowSameDay ? max : getPrevDay(max) : void 0);
          const end2 = limitDateRange(defaultDate[1] || (allowSameDay ? now2 : getNextDay(now2)), min ? allowSameDay ? min : getNextDay(min) : void 0);
          return [start2, end2];
        }
        if (type === "multiple") {
          if (Array.isArray(defaultDate)) {
            return defaultDate.map((date2) => limitDateRange(date2));
          }
          return [limitDateRange(now2)];
        }
        if (!defaultDate || Array.isArray(defaultDate)) {
          defaultDate = now2;
        }
        return limitDateRange(defaultDate);
      };
      const getInitialPanelDate = () => {
        const date2 = Array.isArray(currentDate.value) ? currentDate.value[0] : currentDate.value;
        return date2 ? date2 : limitDateRange(getToday());
      };
      let bodyHeight;
      const bodyRef = vue.ref();
      const currentDate = vue.ref(getInitialDate());
      const currentPanelDate = vue.ref(getInitialPanelDate());
      const currentMonthRef = vue.ref();
      const [monthRefs, setMonthRefs] = useRefs();
      const dayOffset = vue.computed(() => props2.firstDayOfWeek ? +props2.firstDayOfWeek % 7 : 0);
      const months = vue.computed(() => {
        const months2 = [];
        if (!minDate.value || !maxDate.value) {
          return months2;
        }
        const cursor = new Date(minDate.value);
        cursor.setDate(1);
        do {
          months2.push(new Date(cursor));
          cursor.setMonth(cursor.getMonth() + 1);
        } while (compareMonth(cursor, maxDate.value) !== 1);
        return months2;
      });
      const buttonDisabled = vue.computed(() => {
        if (currentDate.value) {
          if (props2.type === "range") {
            return !currentDate.value[0] || !currentDate.value[1];
          }
          if (props2.type === "multiple") {
            return !currentDate.value.length;
          }
        }
        return !currentDate.value;
      });
      const getSelectedDate = () => currentDate.value;
      const onScroll = () => {
        const top2 = getScrollTop(bodyRef.value);
        const bottom2 = top2 + bodyHeight;
        const heights = months.value.map((item, index2) => monthRefs.value[index2].getHeight());
        const heightSum = heights.reduce((a2, b2) => a2 + b2, 0);
        if (bottom2 > heightSum && top2 > 0) {
          return;
        }
        let height2 = 0;
        let currentMonth;
        const visibleRange = [-1, -1];
        for (let i2 = 0; i2 < months.value.length; i2++) {
          const month = monthRefs.value[i2];
          const visible = height2 <= bottom2 && height2 + heights[i2] >= top2;
          if (visible) {
            visibleRange[1] = i2;
            if (!currentMonth) {
              currentMonth = month;
              visibleRange[0] = i2;
            }
            if (!monthRefs.value[i2].showed) {
              monthRefs.value[i2].showed = true;
              emit("monthShow", {
                date: month.date,
                title: month.getTitle()
              });
            }
          }
          height2 += heights[i2];
        }
        months.value.forEach((month, index2) => {
          const visible = index2 >= visibleRange[0] - 1 && index2 <= visibleRange[1] + 1;
          monthRefs.value[index2].setVisible(visible);
        });
        if (currentMonth) {
          currentMonthRef.value = currentMonth;
        }
      };
      const scrollToDate = (targetDate) => {
        if (canSwitch.value) {
          currentPanelDate.value = targetDate;
        } else {
          raf(() => {
            months.value.some((month, index2) => {
              if (compareMonth(month, targetDate) === 0) {
                if (bodyRef.value) {
                  monthRefs.value[index2].scrollToDate(bodyRef.value, targetDate);
                }
                return true;
              }
              return false;
            });
            onScroll();
          });
        }
      };
      const scrollToCurrentDate = () => {
        if (props2.poppable && !props2.show) {
          return;
        }
        if (currentDate.value) {
          const targetDate = props2.type === "single" ? currentDate.value : currentDate.value[0];
          if (isDate(targetDate)) {
            scrollToDate(targetDate);
          }
        } else if (!canSwitch.value) {
          raf(onScroll);
        }
      };
      const init = () => {
        if (props2.poppable && !props2.show) {
          return;
        }
        if (!canSwitch.value) {
          raf(() => {
            bodyHeight = Math.floor(useRect(bodyRef).height);
          });
        }
        scrollToCurrentDate();
      };
      const reset = (date2 = getInitialDate()) => {
        currentDate.value = date2;
        scrollToCurrentDate();
      };
      const checkRange = (date2) => {
        const {
          maxRange,
          rangePrompt,
          showRangePrompt
        } = props2;
        if (maxRange && calcDateNum(date2) > +maxRange) {
          if (showRangePrompt) {
            showToast(rangePrompt || t$i("rangePrompt", maxRange));
          }
          emit("overRange");
          return false;
        }
        return true;
      };
      const onPanelChange = (date2) => {
        currentPanelDate.value = date2;
        emit("panelChange", {
          date: date2
        });
      };
      const onConfirm = () => {
        var _a;
        return emit("confirm", (_a = currentDate.value) != null ? _a : cloneDates(currentDate.value));
      };
      const select = (date2, complete) => {
        const setCurrentDate = (date22) => {
          currentDate.value = date22;
          emit("select", cloneDates(date22));
        };
        if (complete && props2.type === "range") {
          const valid = checkRange(date2);
          if (!valid) {
            setCurrentDate([date2[0], getDayByOffset(date2[0], +props2.maxRange - 1)]);
            return;
          }
        }
        setCurrentDate(date2);
        if (complete && !props2.showConfirm) {
          onConfirm();
        }
      };
      const getDisabledDate = (disabledDays2, startDay, date2) => {
        var _a;
        return (_a = disabledDays2.find((day) => compareDay(startDay, day.date) === -1 && compareDay(day.date, date2) === -1)) == null ? void 0 : _a.date;
      };
      const disabledDays = vue.computed(() => monthRefs.value.reduce((arr, ref2) => {
        var _a, _b;
        arr.push(...(_b = (_a = ref2.disabledDays) == null ? void 0 : _a.value) != null ? _b : []);
        return arr;
      }, []));
      const onClickDay = (item) => {
        if (props2.readonly || !item.date) {
          return;
        }
        const {
          date: date2
        } = item;
        const {
          type
        } = props2;
        if (type === "range") {
          if (!currentDate.value) {
            select([date2]);
            return;
          }
          const [startDay, endDay] = currentDate.value;
          if (startDay && !endDay) {
            const compareToStart = compareDay(date2, startDay);
            if (compareToStart === 1) {
              const disabledDay = getDisabledDate(disabledDays.value, startDay, date2);
              if (disabledDay) {
                const endDay2 = getPrevDay(disabledDay);
                if (compareDay(startDay, endDay2) === -1) {
                  select([startDay, endDay2]);
                } else {
                  select([date2]);
                }
              } else {
                select([startDay, date2], true);
              }
            } else if (compareToStart === -1) {
              select([date2]);
            } else if (props2.allowSameDay) {
              select([date2, date2], true);
            }
          } else {
            select([date2]);
          }
        } else if (type === "multiple") {
          if (!currentDate.value) {
            select([date2]);
            return;
          }
          const dates = currentDate.value;
          const selectedIndex = dates.findIndex((dateItem) => compareDay(dateItem, date2) === 0);
          if (selectedIndex !== -1) {
            const [unselectedDate] = dates.splice(selectedIndex, 1);
            emit("unselect", cloneDate(unselectedDate));
          } else if (props2.maxRange && dates.length >= +props2.maxRange) {
            showToast(props2.rangePrompt || t$i("rangePrompt", props2.maxRange));
          } else {
            select([...dates, date2]);
          }
        } else {
          select(date2, true);
        }
      };
      const updateShow = (value) => emit("update:show", value);
      const renderMonth = (date2, index2) => {
        const showMonthTitle = index2 !== 0 || !props2.showSubtitle;
        return vue.createVNode(stdin_default$1c, vue.mergeProps({
          "ref": canSwitch.value ? currentMonthRef : setMonthRefs(index2),
          "date": date2,
          "currentDate": currentDate.value,
          "showMonthTitle": showMonthTitle,
          "firstDayOfWeek": dayOffset.value,
          "lazyRender": canSwitch.value ? false : props2.lazyRender,
          "maxDate": maxDate.value,
          "minDate": minDate.value
        }, pick(props2, ["type", "color", "showMark", "formatter", "rowHeight", "showSubtitle", "allowSameDay"]), {
          "onClick": onClickDay,
          "onClickDisabledDate": (item) => emit("clickDisabledDate", item)
        }), pick(slots, ["top-info", "bottom-info", "month-title", "text"]));
      };
      const renderFooterButton = () => {
        if (slots.footer) {
          return slots.footer();
        }
        if (props2.showConfirm) {
          const slot = slots["confirm-text"];
          const disabled = buttonDisabled.value;
          const text = disabled ? props2.confirmDisabledText : props2.confirmText;
          return vue.createVNode(Button, {
            "round": true,
            "block": true,
            "type": "primary",
            "color": props2.color,
            "class": bem$13("confirm"),
            "disabled": disabled,
            "nativeType": "button",
            "onClick": onConfirm
          }, {
            default: () => [slot ? slot({
              disabled
            }) : text || t$i("confirm")]
          });
        }
      };
      const renderFooter = () => vue.createVNode("div", {
        "class": [bem$13("footer"), {
          "van-safe-area-bottom": props2.safeAreaInsetBottom
        }]
      }, [renderFooterButton()]);
      const renderCalendar = () => {
        var _a, _b;
        return vue.createVNode("div", {
          "class": bem$13()
        }, [vue.createVNode(stdin_default$1b, {
          "date": (_a = currentMonthRef.value) == null ? void 0 : _a.date,
          "maxDate": maxDate.value,
          "minDate": minDate.value,
          "title": props2.title,
          "subtitle": (_b = currentMonthRef.value) == null ? void 0 : _b.getTitle(),
          "showTitle": props2.showTitle,
          "showSubtitle": props2.showSubtitle,
          "switchMode": props2.switchMode,
          "firstDayOfWeek": dayOffset.value,
          "onClickSubtitle": (event) => emit("clickSubtitle", event),
          "onPanelChange": onPanelChange
        }, pick(slots, ["title", "subtitle", "prev-month", "prev-year", "next-month", "next-year"])), vue.createVNode("div", {
          "ref": bodyRef,
          "class": bem$13("body"),
          "onScroll": canSwitch.value ? void 0 : onScroll
        }, [canSwitch.value ? renderMonth(currentPanelDate.value, 0) : months.value.map(renderMonth)]), renderFooter()]);
      };
      vue.watch(() => props2.show, init);
      vue.watch(() => [props2.type, props2.minDate, props2.maxDate, props2.switchMode], () => reset(getInitialDate(currentDate.value)));
      vue.watch(() => props2.defaultDate, (value) => {
        reset(value);
      });
      useExpose({
        reset,
        scrollToDate,
        getSelectedDate
      });
      onMountedOrActivated(init);
      return () => {
        if (props2.poppable) {
          return vue.createVNode(Popup, {
            "show": props2.show,
            "class": bem$13("popup"),
            "round": props2.round,
            "position": props2.position,
            "closeable": props2.showTitle || props2.showSubtitle,
            "teleport": props2.teleport,
            "closeOnPopstate": props2.closeOnPopstate,
            "safeAreaInsetTop": props2.safeAreaInsetTop,
            "closeOnClickOverlay": props2.closeOnClickOverlay,
            "onUpdate:show": updateShow
          }, {
            default: renderCalendar
          });
        }
        return renderCalendar();
      };
    }
  });
  const Calendar = withInstall(stdin_default$1a);
  const [name$13, bem$12] = createNamespace("image");
  const imageProps = {
    src: String,
    alt: String,
    fit: String,
    position: String,
    round: Boolean,
    block: Boolean,
    width: numericProp,
    height: numericProp,
    radius: numericProp,
    lazyLoad: Boolean,
    iconSize: numericProp,
    showError: truthProp,
    errorIcon: makeStringProp("photo-fail"),
    iconPrefix: String,
    showLoading: truthProp,
    loadingIcon: makeStringProp("photo"),
    crossorigin: String,
    referrerpolicy: String
  };
  var stdin_default$19 = vue.defineComponent({
    name: name$13,
    props: imageProps,
    emits: ["load", "error"],
    setup(props2, {
      emit,
      slots
    }) {
      const error2 = vue.ref(false);
      const loading = vue.ref(true);
      const imageRef = vue.ref();
      const {
        $Lazyload
      } = vue.getCurrentInstance().proxy;
      const style = vue.computed(() => {
        const style2 = {
          width: addUnit$2(props2.width),
          height: addUnit$2(props2.height)
        };
        if (isDef(props2.radius)) {
          style2.overflow = "hidden";
          style2.borderRadius = addUnit$2(props2.radius);
        }
        return style2;
      });
      vue.watch(() => props2.src, () => {
        error2.value = false;
        loading.value = true;
      });
      const onLoad2 = (event) => {
        if (loading.value) {
          loading.value = false;
          emit("load", event);
        }
      };
      const triggerLoad = () => {
        const loadEvent = new Event("load");
        Object.defineProperty(loadEvent, "target", {
          value: imageRef.value,
          enumerable: true
        });
        onLoad2(loadEvent);
      };
      const onError = (event) => {
        error2.value = true;
        loading.value = false;
        emit("error", event);
      };
      const renderIcon = (name2, className, slot) => {
        if (slot) {
          return slot();
        }
        return vue.createVNode(Icon, {
          "name": name2,
          "size": props2.iconSize,
          "class": className,
          "classPrefix": props2.iconPrefix
        }, null);
      };
      const renderPlaceholder = () => {
        if (loading.value && props2.showLoading) {
          return vue.createVNode("div", {
            "class": bem$12("loading")
          }, [renderIcon(props2.loadingIcon, bem$12("loading-icon"), slots.loading)]);
        }
        if (error2.value && props2.showError) {
          return vue.createVNode("div", {
            "class": bem$12("error")
          }, [renderIcon(props2.errorIcon, bem$12("error-icon"), slots.error)]);
        }
      };
      const renderImage = () => {
        if (error2.value || !props2.src) {
          return;
        }
        const attrs = {
          alt: props2.alt,
          class: bem$12("img"),
          style: {
            objectFit: props2.fit,
            objectPosition: props2.position
          },
          crossorigin: props2.crossorigin,
          referrerpolicy: props2.referrerpolicy
        };
        if (props2.lazyLoad) {
          return vue.withDirectives(vue.createVNode("img", vue.mergeProps({
            "ref": imageRef
          }, attrs), null), [[vue.resolveDirective("lazy"), props2.src]]);
        }
        return vue.createVNode("img", vue.mergeProps({
          "ref": imageRef,
          "src": props2.src,
          "onLoad": onLoad2,
          "onError": onError
        }, attrs), null);
      };
      const onLazyLoaded = ({
        el
      }) => {
        const check = () => {
          if (el === imageRef.value && loading.value) {
            triggerLoad();
          }
        };
        if (imageRef.value) {
          check();
        } else {
          vue.nextTick(check);
        }
      };
      const onLazyLoadError = ({
        el
      }) => {
        if (el === imageRef.value && !error2.value) {
          onError();
        }
      };
      if ($Lazyload && inBrowser$1) {
        $Lazyload.$on("loaded", onLazyLoaded);
        $Lazyload.$on("error", onLazyLoadError);
        vue.onBeforeUnmount(() => {
          $Lazyload.$off("loaded", onLazyLoaded);
          $Lazyload.$off("error", onLazyLoadError);
        });
      }
      vue.onMounted(() => {
        vue.nextTick(() => {
          var _a;
          if (((_a = imageRef.value) == null ? void 0 : _a.complete) && !props2.lazyLoad) {
            triggerLoad();
          }
        });
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$12({
            round: props2.round,
            block: props2.block
          }),
          "style": style.value
        }, [renderImage(), renderPlaceholder(), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Image$1 = withInstall(stdin_default$19);
  const [name$12, bem$11] = createNamespace("card");
  const cardProps = {
    tag: String,
    num: numericProp,
    desc: String,
    thumb: String,
    title: String,
    price: numericProp,
    centered: Boolean,
    lazyLoad: Boolean,
    currency: makeStringProp("¥"),
    thumbLink: String,
    originPrice: numericProp
  };
  var stdin_default$18 = vue.defineComponent({
    name: name$12,
    props: cardProps,
    emits: ["clickThumb"],
    setup(props2, {
      slots,
      emit
    }) {
      const renderTitle = () => {
        if (slots.title) {
          return slots.title();
        }
        if (props2.title) {
          return vue.createVNode("div", {
            "class": [bem$11("title"), "van-multi-ellipsis--l2"]
          }, [props2.title]);
        }
      };
      const renderThumbTag = () => {
        if (slots.tag || props2.tag) {
          return vue.createVNode("div", {
            "class": bem$11("tag")
          }, [slots.tag ? slots.tag() : vue.createVNode(Tag, {
            "mark": true,
            "type": "primary"
          }, {
            default: () => [props2.tag]
          })]);
        }
      };
      const renderThumbImage = () => {
        if (slots.thumb) {
          return slots.thumb();
        }
        return vue.createVNode(Image$1, {
          "src": props2.thumb,
          "fit": "cover",
          "width": "100%",
          "height": "100%",
          "lazyLoad": props2.lazyLoad
        }, null);
      };
      const renderThumb = () => {
        if (slots.thumb || props2.thumb) {
          return vue.createVNode("a", {
            "href": props2.thumbLink,
            "class": bem$11("thumb"),
            "onClick": (event) => emit("clickThumb", event)
          }, [renderThumbImage(), renderThumbTag()]);
        }
      };
      const renderDesc = () => {
        if (slots.desc) {
          return slots.desc();
        }
        if (props2.desc) {
          return vue.createVNode("div", {
            "class": [bem$11("desc"), "van-ellipsis"]
          }, [props2.desc]);
        }
      };
      const renderPriceText = () => {
        const priceArr = props2.price.toString().split(".");
        return vue.createVNode("div", null, [vue.createVNode("span", {
          "class": bem$11("price-currency")
        }, [props2.currency]), vue.createVNode("span", {
          "class": bem$11("price-integer")
        }, [priceArr[0]]), priceArr.length > 1 && vue.createVNode(vue.Fragment, null, [vue.createTextVNode("."), vue.createVNode("span", {
          "class": bem$11("price-decimal")
        }, [priceArr[1]])])]);
      };
      return () => {
        var _a, _b, _c;
        const showNum = slots.num || isDef(props2.num);
        const showPrice = slots.price || isDef(props2.price);
        const showOriginPrice = slots["origin-price"] || isDef(props2.originPrice);
        const showBottom = showNum || showPrice || showOriginPrice || slots.bottom;
        const Price = showPrice && vue.createVNode("div", {
          "class": bem$11("price")
        }, [slots.price ? slots.price() : renderPriceText()]);
        const OriginPrice = showOriginPrice && vue.createVNode("div", {
          "class": bem$11("origin-price")
        }, [slots["origin-price"] ? slots["origin-price"]() : `${props2.currency} ${props2.originPrice}`]);
        const Num = showNum && vue.createVNode("div", {
          "class": bem$11("num")
        }, [slots.num ? slots.num() : `x${props2.num}`]);
        const Footer = slots.footer && vue.createVNode("div", {
          "class": bem$11("footer")
        }, [slots.footer()]);
        const Bottom = showBottom && vue.createVNode("div", {
          "class": bem$11("bottom")
        }, [(_a = slots["price-top"]) == null ? void 0 : _a.call(slots), Price, OriginPrice, Num, (_b = slots.bottom) == null ? void 0 : _b.call(slots)]);
        return vue.createVNode("div", {
          "class": bem$11()
        }, [vue.createVNode("div", {
          "class": bem$11("header")
        }, [renderThumb(), vue.createVNode("div", {
          "class": bem$11("content", {
            centered: props2.centered
          })
        }, [vue.createVNode("div", null, [renderTitle(), renderDesc(), (_c = slots.tags) == null ? void 0 : _c.call(slots)]), Bottom])]), Footer]);
      };
    }
  });
  const Card = withInstall(stdin_default$18);
  const [name$11, bem$10, t$h] = createNamespace("cascader");
  const cascaderProps = {
    title: String,
    options: makeArrayProp(),
    closeable: truthProp,
    swipeable: truthProp,
    closeIcon: makeStringProp("cross"),
    showHeader: truthProp,
    modelValue: numericProp,
    fieldNames: Object,
    placeholder: String,
    activeColor: String
  };
  var stdin_default$17 = vue.defineComponent({
    name: name$11,
    props: cascaderProps,
    emits: ["close", "change", "finish", "clickTab", "update:modelValue"],
    setup(props2, {
      slots,
      emit
    }) {
      const tabs = vue.ref([]);
      const activeTab = vue.ref(0);
      const [selectedElementRefs, setSelectedElementRefs] = useRefs();
      const {
        text: textKey,
        value: valueKey,
        children: childrenKey
      } = extend({
        text: "text",
        value: "value",
        children: "children"
      }, props2.fieldNames);
      const getSelectedOptionsByValue = (options, value) => {
        for (const option of options) {
          if (option[valueKey] === value) {
            return [option];
          }
          if (option[childrenKey]) {
            const selectedOptions = getSelectedOptionsByValue(option[childrenKey], value);
            if (selectedOptions) {
              return [option, ...selectedOptions];
            }
          }
        }
      };
      const updateTabs = () => {
        const {
          options,
          modelValue
        } = props2;
        if (modelValue !== void 0) {
          const selectedOptions = getSelectedOptionsByValue(options, modelValue);
          if (selectedOptions) {
            let optionsCursor = options;
            tabs.value = selectedOptions.map((option) => {
              const tab = {
                options: optionsCursor,
                selected: option
              };
              const next = optionsCursor.find((item) => item[valueKey] === option[valueKey]);
              if (next) {
                optionsCursor = next[childrenKey];
              }
              return tab;
            });
            if (optionsCursor) {
              tabs.value.push({
                options: optionsCursor,
                selected: null
              });
            }
            vue.nextTick(() => {
              activeTab.value = tabs.value.length - 1;
            });
            return;
          }
        }
        tabs.value = [{
          options,
          selected: null
        }];
      };
      const onSelect = (option, tabIndex) => {
        if (option.disabled) {
          return;
        }
        tabs.value[tabIndex].selected = option;
        if (tabs.value.length > tabIndex + 1) {
          tabs.value = tabs.value.slice(0, tabIndex + 1);
        }
        if (option[childrenKey]) {
          const nextTab = {
            options: option[childrenKey],
            selected: null
          };
          if (tabs.value[tabIndex + 1]) {
            tabs.value[tabIndex + 1] = nextTab;
          } else {
            tabs.value.push(nextTab);
          }
          vue.nextTick(() => {
            activeTab.value++;
          });
        }
        const selectedOptions = tabs.value.map((tab) => tab.selected).filter(Boolean);
        emit("update:modelValue", option[valueKey]);
        const params = {
          value: option[valueKey],
          tabIndex,
          selectedOptions
        };
        emit("change", params);
        if (!option[childrenKey]) {
          emit("finish", params);
        }
      };
      const onClose = () => emit("close");
      const onClickTab = ({
        name: name2,
        title
      }) => emit("clickTab", name2, title);
      const renderHeader = () => props2.showHeader ? vue.createVNode("div", {
        "class": bem$10("header")
      }, [vue.createVNode("h2", {
        "class": bem$10("title")
      }, [slots.title ? slots.title() : props2.title]), props2.closeable ? vue.createVNode(Icon, {
        "name": props2.closeIcon,
        "class": [bem$10("close-icon"), HAPTICS_FEEDBACK],
        "onClick": onClose
      }, null) : null]) : null;
      const renderOption = (option, selectedOption, tabIndex) => {
        const {
          disabled
        } = option;
        const selected = !!(selectedOption && option[valueKey] === selectedOption[valueKey]);
        const color = option.color || (selected ? props2.activeColor : void 0);
        const Text = slots.option ? slots.option({
          option,
          selected
        }) : vue.createVNode("span", null, [option[textKey]]);
        return vue.createVNode("li", {
          "ref": selected ? setSelectedElementRefs(tabIndex) : void 0,
          "role": "menuitemradio",
          "class": [bem$10("option", {
            selected,
            disabled
          }), option.className],
          "style": {
            color
          },
          "tabindex": disabled ? void 0 : selected ? 0 : -1,
          "aria-checked": selected,
          "aria-disabled": disabled || void 0,
          "onClick": () => onSelect(option, tabIndex)
        }, [Text, selected ? vue.createVNode(Icon, {
          "name": "success",
          "class": bem$10("selected-icon")
        }, null) : null]);
      };
      const renderOptions = (options, selectedOption, tabIndex) => vue.createVNode("ul", {
        "role": "menu",
        "class": bem$10("options")
      }, [options.map((option) => renderOption(option, selectedOption, tabIndex))]);
      const renderTab = (tab, tabIndex) => {
        const {
          options,
          selected
        } = tab;
        const placeholder = props2.placeholder || t$h("select");
        const title = selected ? selected[textKey] : placeholder;
        return vue.createVNode(Tab, {
          "title": title,
          "titleClass": bem$10("tab", {
            unselected: !selected
          })
        }, {
          default: () => {
            var _a, _b;
            return [(_a = slots["options-top"]) == null ? void 0 : _a.call(slots, {
              tabIndex
            }), renderOptions(options, selected, tabIndex), (_b = slots["options-bottom"]) == null ? void 0 : _b.call(slots, {
              tabIndex
            })];
          }
        });
      };
      const renderTabs = () => vue.createVNode(Tabs, {
        "active": activeTab.value,
        "onUpdate:active": ($event) => activeTab.value = $event,
        "shrink": true,
        "animated": true,
        "class": bem$10("tabs"),
        "color": props2.activeColor,
        "swipeable": props2.swipeable,
        "onClickTab": onClickTab
      }, {
        default: () => [tabs.value.map(renderTab)]
      });
      const scrollIntoView = (el) => {
        const scrollParent = el.parentElement;
        if (scrollParent) {
          scrollParent.scrollTop = el.offsetTop - (scrollParent.offsetHeight - el.offsetHeight) / 2;
        }
      };
      updateTabs();
      vue.watch(activeTab, (value) => {
        const el = selectedElementRefs.value[value];
        if (el)
          scrollIntoView(el);
      });
      vue.watch(() => props2.options, updateTabs, {
        deep: true
      });
      vue.watch(() => props2.modelValue, (value) => {
        if (value !== void 0) {
          const values = tabs.value.map((tab) => {
            var _a;
            return (_a = tab.selected) == null ? void 0 : _a[valueKey];
          });
          if (values.includes(value)) {
            return;
          }
        }
        updateTabs();
      });
      return () => vue.createVNode("div", {
        "class": bem$10()
      }, [renderHeader(), renderTabs()]);
    }
  });
  const Cascader = withInstall(stdin_default$17);
  const [name$10, bem$$] = createNamespace("cell-group");
  const cellGroupProps = {
    title: String,
    inset: Boolean,
    border: truthProp
  };
  var stdin_default$16 = vue.defineComponent({
    name: name$10,
    inheritAttrs: false,
    props: cellGroupProps,
    setup(props2, {
      slots,
      attrs
    }) {
      const renderGroup = () => {
        var _a;
        return vue.createVNode("div", vue.mergeProps({
          "class": [bem$$({
            inset: props2.inset
          }), {
            [BORDER_TOP_BOTTOM]: props2.border && !props2.inset
          }]
        }, attrs, useScopeId()), [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
      const renderTitle = () => vue.createVNode("div", {
        "class": bem$$("title", {
          inset: props2.inset
        })
      }, [slots.title ? slots.title() : props2.title]);
      return () => {
        if (props2.title || slots.title) {
          return vue.createVNode(vue.Fragment, null, [renderTitle(), renderGroup()]);
        }
        return renderGroup();
      };
    }
  });
  const CellGroup = withInstall(stdin_default$16);
  const [name$$, bem$_] = createNamespace("circle");
  let uid = 0;
  const format$1 = (rate) => Math.min(Math.max(+rate, 0), 100);
  function getPath(clockwise, viewBoxSize) {
    const sweepFlag = clockwise ? 1 : 0;
    return `M ${viewBoxSize / 2} ${viewBoxSize / 2} m 0, -500 a 500, 500 0 1, ${sweepFlag} 0, 1000 a 500, 500 0 1, ${sweepFlag} 0, -1000`;
  }
  const circleProps = {
    text: String,
    size: numericProp,
    fill: makeStringProp("none"),
    rate: makeNumericProp(100),
    speed: makeNumericProp(0),
    color: [String, Object],
    clockwise: truthProp,
    layerColor: String,
    currentRate: makeNumberProp(0),
    strokeWidth: makeNumericProp(40),
    strokeLinecap: String,
    startPosition: makeStringProp("top")
  };
  var stdin_default$15 = vue.defineComponent({
    name: name$$,
    props: circleProps,
    emits: ["update:currentRate"],
    setup(props2, {
      emit,
      slots
    }) {
      const id = `van-circle-${uid++}`;
      const viewBoxSize = vue.computed(() => +props2.strokeWidth + 1e3);
      const path = vue.computed(() => getPath(props2.clockwise, viewBoxSize.value));
      const svgStyle = vue.computed(() => {
        const ROTATE_ANGLE_MAP = {
          top: 0,
          right: 90,
          bottom: 180,
          left: 270
        };
        const angleValue = ROTATE_ANGLE_MAP[props2.startPosition];
        if (angleValue) {
          return {
            transform: `rotate(${angleValue}deg)`
          };
        }
      });
      vue.watch(() => props2.rate, (rate) => {
        let rafId;
        const startTime = Date.now();
        const startRate = props2.currentRate;
        const endRate = format$1(rate);
        const duration = Math.abs((startRate - endRate) * 1e3 / +props2.speed);
        const animate = () => {
          const now2 = Date.now();
          const progress = Math.min((now2 - startTime) / duration, 1);
          const rate2 = progress * (endRate - startRate) + startRate;
          emit("update:currentRate", format$1(parseFloat(rate2.toFixed(1))));
          if (endRate > startRate ? rate2 < endRate : rate2 > endRate) {
            rafId = raf(animate);
          }
        };
        if (props2.speed) {
          if (rafId) {
            cancelRaf(rafId);
          }
          rafId = raf(animate);
        } else {
          emit("update:currentRate", endRate);
        }
      }, {
        immediate: true
      });
      const renderHover = () => {
        const PERIMETER = 3140;
        const {
          strokeWidth,
          currentRate,
          strokeLinecap
        } = props2;
        const offset2 = PERIMETER * currentRate / 100;
        const color = isObject$1(props2.color) ? `url(#${id})` : props2.color;
        const style = {
          stroke: color,
          strokeWidth: `${+strokeWidth + 1}px`,
          strokeLinecap,
          strokeDasharray: `${offset2}px ${PERIMETER}px`
        };
        return vue.createVNode("path", {
          "d": path.value,
          "style": style,
          "class": bem$_("hover"),
          "stroke": color
        }, null);
      };
      const renderLayer = () => {
        const style = {
          fill: props2.fill,
          stroke: props2.layerColor,
          strokeWidth: `${props2.strokeWidth}px`
        };
        return vue.createVNode("path", {
          "class": bem$_("layer"),
          "style": style,
          "d": path.value
        }, null);
      };
      const renderGradient = () => {
        const {
          color
        } = props2;
        if (!isObject$1(color)) {
          return;
        }
        const Stops = Object.keys(color).sort((a2, b2) => parseFloat(a2) - parseFloat(b2)).map((key, index2) => vue.createVNode("stop", {
          "key": index2,
          "offset": key,
          "stop-color": color[key]
        }, null));
        return vue.createVNode("defs", null, [vue.createVNode("linearGradient", {
          "id": id,
          "x1": "100%",
          "y1": "0%",
          "x2": "0%",
          "y2": "0%"
        }, [Stops])]);
      };
      const renderText = () => {
        if (slots.default) {
          return slots.default();
        }
        if (props2.text) {
          return vue.createVNode("div", {
            "class": bem$_("text")
          }, [props2.text]);
        }
      };
      return () => vue.createVNode("div", {
        "class": bem$_(),
        "style": getSizeStyle(props2.size)
      }, [vue.createVNode("svg", {
        "viewBox": `0 0 ${viewBoxSize.value} ${viewBoxSize.value}`,
        "style": svgStyle.value
      }, [renderGradient(), renderLayer(), renderHover()]), renderText()]);
    }
  });
  const Circle = withInstall(stdin_default$15);
  const [name$_, bem$Z] = createNamespace("row");
  const ROW_KEY = Symbol(name$_);
  const rowProps = {
    tag: makeStringProp("div"),
    wrap: truthProp,
    align: String,
    gutter: {
      type: [String, Number, Array],
      default: 0
    },
    justify: String
  };
  var stdin_default$14 = vue.defineComponent({
    name: name$_,
    props: rowProps,
    setup(props2, {
      slots
    }) {
      const {
        children,
        linkChildren
      } = useChildren(ROW_KEY);
      const groups = vue.computed(() => {
        const groups2 = [[]];
        let totalSpan = 0;
        children.forEach((child, index2) => {
          totalSpan += Number(child.span);
          if (totalSpan > 24) {
            groups2.push([index2]);
            totalSpan -= 24;
          } else {
            groups2[groups2.length - 1].push(index2);
          }
        });
        return groups2;
      });
      const spaces = vue.computed(() => {
        let gutter = 0;
        if (Array.isArray(props2.gutter)) {
          gutter = Number(props2.gutter[0]) || 0;
        } else {
          gutter = Number(props2.gutter);
        }
        const spaces2 = [];
        if (!gutter) {
          return spaces2;
        }
        groups.value.forEach((group) => {
          const averagePadding = gutter * (group.length - 1) / group.length;
          group.forEach((item, index2) => {
            if (index2 === 0) {
              spaces2.push({
                right: averagePadding
              });
            } else {
              const left2 = gutter - spaces2[item - 1].right;
              const right2 = averagePadding - left2;
              spaces2.push({
                left: left2,
                right: right2
              });
            }
          });
        });
        return spaces2;
      });
      const verticalSpaces = vue.computed(() => {
        const {
          gutter
        } = props2;
        const spaces2 = [];
        if (Array.isArray(gutter) && gutter.length > 1) {
          const bottom2 = Number(gutter[1]) || 0;
          if (bottom2 <= 0) {
            return spaces2;
          }
          groups.value.forEach((group, index2) => {
            if (index2 === groups.value.length - 1)
              return;
            group.forEach(() => {
              spaces2.push({
                bottom: bottom2
              });
            });
          });
        }
        return spaces2;
      });
      linkChildren({
        spaces,
        verticalSpaces
      });
      return () => {
        const {
          tag,
          wrap,
          align,
          justify
        } = props2;
        return vue.createVNode(tag, {
          "class": bem$Z({
            [`align-${align}`]: align,
            [`justify-${justify}`]: justify,
            nowrap: !wrap
          })
        }, {
          default: () => {
            var _a;
            return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
          }
        });
      };
    }
  });
  const [name$Z, bem$Y] = createNamespace("col");
  const colProps = {
    tag: makeStringProp("div"),
    span: makeNumericProp(0),
    offset: numericProp
  };
  var stdin_default$13 = vue.defineComponent({
    name: name$Z,
    props: colProps,
    setup(props2, {
      slots
    }) {
      const {
        parent,
        index: index2
      } = useParent(ROW_KEY);
      const style = vue.computed(() => {
        if (!parent) {
          return;
        }
        const {
          spaces,
          verticalSpaces
        } = parent;
        let styles = {};
        if (spaces && spaces.value && spaces.value[index2.value]) {
          const {
            left: left2,
            right: right2
          } = spaces.value[index2.value];
          styles = {
            paddingLeft: left2 ? `${left2}px` : null,
            paddingRight: right2 ? `${right2}px` : null
          };
        }
        const {
          bottom: bottom2
        } = verticalSpaces.value[index2.value] || {};
        return extend(styles, {
          marginBottom: bottom2 ? `${bottom2}px` : null
        });
      });
      return () => {
        const {
          tag,
          span,
          offset: offset2
        } = props2;
        return vue.createVNode(tag, {
          "style": style.value,
          "class": bem$Y({
            [span]: span,
            [`offset-${offset2}`]: offset2
          })
        }, {
          default: () => {
            var _a;
            return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
          }
        });
      };
    }
  });
  const Col = withInstall(stdin_default$13);
  const [name$Y, bem$X] = createNamespace("collapse");
  const COLLAPSE_KEY = Symbol(name$Y);
  const collapseProps = {
    border: truthProp,
    accordion: Boolean,
    modelValue: {
      type: [String, Number, Array],
      default: ""
    }
  };
  function validateModelValue(modelValue, accordion) {
    if (accordion && Array.isArray(modelValue)) {
      formatAppLog("error", "at node_modules/vant/es/collapse/Collapse.mjs:17", '[Vant] Collapse: "v-model" should not be Array in accordion mode');
      return false;
    }
    if (!accordion && !Array.isArray(modelValue)) {
      formatAppLog("error", "at node_modules/vant/es/collapse/Collapse.mjs:21", '[Vant] Collapse: "v-model" should be Array in non-accordion mode');
      return false;
    }
    return true;
  }
  var stdin_default$12 = vue.defineComponent({
    name: name$Y,
    props: collapseProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        linkChildren,
        children
      } = useChildren(COLLAPSE_KEY);
      const updateName = (name2) => {
        emit("change", name2);
        emit("update:modelValue", name2);
      };
      const toggle = (name2, expanded) => {
        const {
          accordion,
          modelValue
        } = props2;
        if (accordion) {
          updateName(name2 === modelValue ? "" : name2);
        } else if (expanded) {
          updateName(modelValue.concat(name2));
        } else {
          updateName(modelValue.filter((activeName) => activeName !== name2));
        }
      };
      const toggleAll = (options = {}) => {
        if (props2.accordion) {
          return;
        }
        if (typeof options === "boolean") {
          options = {
            expanded: options
          };
        }
        const {
          expanded,
          skipDisabled
        } = options;
        const expandedChildren = children.filter((item) => {
          if (item.disabled && skipDisabled) {
            return item.expanded.value;
          }
          return expanded != null ? expanded : !item.expanded.value;
        });
        const names = expandedChildren.map((item) => item.itemName.value);
        updateName(names);
      };
      const isExpanded = (name2) => {
        const {
          accordion,
          modelValue
        } = props2;
        if (!validateModelValue(modelValue, accordion)) {
          return false;
        }
        return accordion ? modelValue === name2 : modelValue.includes(name2);
      };
      useExpose({
        toggleAll
      });
      linkChildren({
        toggle,
        isExpanded
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": [bem$X(), {
            [BORDER_TOP_BOTTOM]: props2.border
          }]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Collapse = withInstall(stdin_default$12);
  const [name$X, bem$W] = createNamespace("collapse-item");
  const CELL_SLOTS = ["icon", "title", "value", "label", "right-icon"];
  const collapseItemProps = extend({}, cellSharedProps, {
    name: numericProp,
    isLink: truthProp,
    disabled: Boolean,
    readonly: Boolean,
    lazyRender: truthProp
  });
  var stdin_default$11 = vue.defineComponent({
    name: name$X,
    props: collapseItemProps,
    setup(props2, {
      slots
    }) {
      const wrapperRef = vue.ref();
      const contentRef = vue.ref();
      const {
        parent,
        index: index2
      } = useParent(COLLAPSE_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/collapse-item/CollapseItem.mjs:32", "[Vant] <CollapseItem> must be a child component of <Collapse>.");
        }
        return;
      }
      const name2 = vue.computed(() => {
        var _a;
        return (_a = props2.name) != null ? _a : index2.value;
      });
      const expanded = vue.computed(() => parent.isExpanded(name2.value));
      const show = vue.ref(expanded.value);
      const lazyRender = useLazyRender(() => show.value || !props2.lazyRender);
      const onTransitionEnd = () => {
        if (!expanded.value) {
          show.value = false;
        } else if (wrapperRef.value) {
          wrapperRef.value.style.height = "";
        }
      };
      vue.watch(expanded, (value, oldValue) => {
        if (oldValue === null) {
          return;
        }
        if (value) {
          show.value = true;
        }
        const tick = value ? vue.nextTick : raf;
        tick(() => {
          if (!contentRef.value || !wrapperRef.value) {
            return;
          }
          const {
            offsetHeight
          } = contentRef.value;
          if (offsetHeight) {
            const contentHeight = `${offsetHeight}px`;
            wrapperRef.value.style.height = value ? "0" : contentHeight;
            doubleRaf(() => {
              if (wrapperRef.value) {
                wrapperRef.value.style.height = value ? contentHeight : "0";
              }
            });
          } else {
            onTransitionEnd();
          }
        });
      });
      const toggle = (newValue = !expanded.value) => {
        parent.toggle(name2.value, newValue);
      };
      const onClickTitle = () => {
        if (!props2.disabled && !props2.readonly) {
          toggle();
        }
      };
      const renderTitle = () => {
        const {
          border,
          disabled,
          readonly
        } = props2;
        const attrs = pick(props2, Object.keys(cellSharedProps));
        if (readonly) {
          attrs.isLink = false;
        }
        if (disabled || readonly) {
          attrs.clickable = false;
        }
        return vue.createVNode(Cell, vue.mergeProps({
          "role": "button",
          "class": bem$W("title", {
            disabled,
            expanded: expanded.value,
            borderless: !border
          }),
          "aria-expanded": String(expanded.value),
          "onClick": onClickTitle
        }, attrs), pick(slots, CELL_SLOTS));
      };
      const renderContent = lazyRender(() => {
        var _a;
        return vue.withDirectives(vue.createVNode("div", {
          "ref": wrapperRef,
          "class": bem$W("wrapper"),
          "onTransitionend": onTransitionEnd
        }, [vue.createVNode("div", {
          "ref": contentRef,
          "class": bem$W("content")
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]), [[vue.vShow, show.value]]);
      });
      useExpose({
        toggle,
        expanded,
        itemName: name2
      });
      return () => vue.createVNode("div", {
        "class": [bem$W({
          border: index2.value && props2.border
        })]
      }, [renderTitle(), renderContent()]);
    }
  });
  const CollapseItem = withInstall(stdin_default$11);
  const ConfigProvider = withInstall(stdin_default$1P);
  const [name$W, bem$V, t$g] = createNamespace("contact-card");
  const contactCardProps = {
    tel: String,
    name: String,
    type: makeStringProp("add"),
    addText: String,
    editable: truthProp
  };
  var stdin_default$10 = vue.defineComponent({
    name: name$W,
    props: contactCardProps,
    emits: ["click"],
    setup(props2, {
      emit
    }) {
      const onClick = (event) => {
        if (props2.editable) {
          emit("click", event);
        }
      };
      const renderContent = () => {
        if (props2.type === "add") {
          return props2.addText || t$g("addContact");
        }
        return [vue.createVNode("div", null, [`${t$g("name")}：${props2.name}`]), vue.createVNode("div", null, [`${t$g("tel")}：${props2.tel}`])];
      };
      return () => vue.createVNode(Cell, {
        "center": true,
        "icon": props2.type === "edit" ? "contact" : "add-square",
        "class": bem$V([props2.type]),
        "border": false,
        "isLink": props2.editable,
        "titleClass": bem$V("title"),
        "onClick": onClick
      }, {
        title: renderContent
      });
    }
  });
  const ContactCard = withInstall(stdin_default$10);
  const [name$V, bem$U, t$f] = createNamespace("contact-edit");
  const DEFAULT_CONTACT = {
    tel: "",
    name: ""
  };
  const contactEditProps = {
    isEdit: Boolean,
    isSaving: Boolean,
    isDeleting: Boolean,
    showSetDefault: Boolean,
    setDefaultLabel: String,
    contactInfo: {
      type: Object,
      default: () => extend({}, DEFAULT_CONTACT)
    },
    telValidator: {
      type: Function,
      default: isMobile
    }
  };
  var stdin_default$$ = vue.defineComponent({
    name: name$V,
    props: contactEditProps,
    emits: ["save", "delete", "changeDefault"],
    setup(props2, {
      emit
    }) {
      const contact = vue.reactive(extend({}, DEFAULT_CONTACT, props2.contactInfo));
      const onSave = () => {
        if (!props2.isSaving) {
          emit("save", contact);
        }
      };
      const onDelete = () => emit("delete", contact);
      const renderButtons = () => vue.createVNode("div", {
        "class": bem$U("buttons")
      }, [vue.createVNode(Button, {
        "block": true,
        "round": true,
        "type": "primary",
        "text": t$f("save"),
        "class": bem$U("button"),
        "loading": props2.isSaving,
        "nativeType": "submit"
      }, null), props2.isEdit && vue.createVNode(Button, {
        "block": true,
        "round": true,
        "text": t$f("delete"),
        "class": bem$U("button"),
        "loading": props2.isDeleting,
        "onClick": onDelete
      }, null)]);
      const renderSwitch = () => vue.createVNode(Switch, {
        "modelValue": contact.isDefault,
        "onUpdate:modelValue": ($event) => contact.isDefault = $event,
        "onChange": (checked) => emit("changeDefault", checked)
      }, null);
      const renderSetDefault = () => {
        if (props2.showSetDefault) {
          return vue.createVNode(Cell, {
            "title": props2.setDefaultLabel,
            "class": bem$U("switch-cell"),
            "border": false
          }, {
            "right-icon": renderSwitch
          });
        }
      };
      vue.watch(() => props2.contactInfo, (value) => extend(contact, DEFAULT_CONTACT, value));
      return () => vue.createVNode(Form, {
        "class": bem$U(),
        "onSubmit": onSave
      }, {
        default: () => [vue.createVNode("div", {
          "class": bem$U("fields")
        }, [vue.createVNode(Field, {
          "modelValue": contact.name,
          "onUpdate:modelValue": ($event) => contact.name = $event,
          "clearable": true,
          "label": t$f("name"),
          "rules": [{
            required: true,
            message: t$f("nameEmpty")
          }],
          "maxlength": "30",
          "placeholder": t$f("name")
        }, null), vue.createVNode(Field, {
          "modelValue": contact.tel,
          "onUpdate:modelValue": ($event) => contact.tel = $event,
          "clearable": true,
          "type": "tel",
          "label": t$f("tel"),
          "rules": [{
            validator: props2.telValidator,
            message: t$f("telInvalid")
          }],
          "placeholder": t$f("tel")
        }, null)]), renderSetDefault(), renderButtons()]
      });
    }
  });
  const ContactEdit = withInstall(stdin_default$$);
  const [name$U, bem$T, t$e] = createNamespace("contact-list");
  const contactListProps = {
    list: Array,
    addText: String,
    modelValue: unknownProp,
    defaultTagText: String
  };
  var stdin_default$_ = vue.defineComponent({
    name: name$U,
    props: contactListProps,
    emits: ["add", "edit", "select", "update:modelValue"],
    setup(props2, {
      emit
    }) {
      const renderItem = (item, index2) => {
        const onClick = () => {
          emit("update:modelValue", item.id);
          emit("select", item, index2);
        };
        const renderRightIcon = () => vue.createVNode(Radio, {
          "class": bem$T("radio"),
          "name": item.id,
          "iconSize": 18
        }, null);
        const renderEditIcon = () => vue.createVNode(Icon, {
          "name": "edit",
          "class": bem$T("edit"),
          "onClick": (event) => {
            event.stopPropagation();
            emit("edit", item, index2);
          }
        }, null);
        const renderContent = () => {
          const nodes = [`${item.name}，${item.tel}`];
          if (item.isDefault && props2.defaultTagText) {
            nodes.push(vue.createVNode(Tag, {
              "type": "primary",
              "round": true,
              "class": bem$T("item-tag")
            }, {
              default: () => [props2.defaultTagText]
            }));
          }
          return nodes;
        };
        return vue.createVNode(Cell, {
          "key": item.id,
          "isLink": true,
          "center": true,
          "class": bem$T("item"),
          "titleClass": bem$T("item-title"),
          "onClick": onClick
        }, {
          icon: renderEditIcon,
          title: renderContent,
          "right-icon": renderRightIcon
        });
      };
      return () => vue.createVNode("div", {
        "class": bem$T()
      }, [vue.createVNode(RadioGroup, {
        "modelValue": props2.modelValue,
        "class": bem$T("group")
      }, {
        default: () => [props2.list && props2.list.map(renderItem)]
      }), vue.createVNode("div", {
        "class": [bem$T("bottom"), "van-safe-area-bottom"]
      }, [vue.createVNode(Button, {
        "round": true,
        "block": true,
        "type": "primary",
        "class": bem$T("add"),
        "text": props2.addText || t$e("addContact"),
        "onClick": () => emit("add")
      }, null)])]);
    }
  });
  const ContactList = withInstall(stdin_default$_);
  function parseFormat(format2, currentTime) {
    const { days } = currentTime;
    let { hours, minutes, seconds, milliseconds } = currentTime;
    if (format2.includes("DD")) {
      format2 = format2.replace("DD", padZero$1(days));
    } else {
      hours += days * 24;
    }
    if (format2.includes("HH")) {
      format2 = format2.replace("HH", padZero$1(hours));
    } else {
      minutes += hours * 60;
    }
    if (format2.includes("mm")) {
      format2 = format2.replace("mm", padZero$1(minutes));
    } else {
      seconds += minutes * 60;
    }
    if (format2.includes("ss")) {
      format2 = format2.replace("ss", padZero$1(seconds));
    } else {
      milliseconds += seconds * 1e3;
    }
    if (format2.includes("S")) {
      const ms = padZero$1(milliseconds, 3);
      if (format2.includes("SSS")) {
        format2 = format2.replace("SSS", ms);
      } else if (format2.includes("SS")) {
        format2 = format2.replace("SS", ms.slice(0, 2));
      } else {
        format2 = format2.replace("S", ms.charAt(0));
      }
    }
    return format2;
  }
  const [name$T, bem$S] = createNamespace("count-down");
  const countDownProps = {
    time: makeNumericProp(0),
    format: makeStringProp("HH:mm:ss"),
    autoStart: truthProp,
    millisecond: Boolean
  };
  var stdin_default$Z = vue.defineComponent({
    name: name$T,
    props: countDownProps,
    emits: ["change", "finish"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        start: start2,
        pause,
        reset,
        current: current2
      } = useCountDown({
        time: +props2.time,
        millisecond: props2.millisecond,
        onChange: (current22) => emit("change", current22),
        onFinish: () => emit("finish")
      });
      const timeText = vue.computed(() => parseFormat(props2.format, current2.value));
      const resetTime = () => {
        reset(+props2.time);
        if (props2.autoStart) {
          start2();
        }
      };
      vue.watch(() => props2.time, resetTime, {
        immediate: true
      });
      useExpose({
        start: start2,
        pause,
        reset: resetTime
      });
      return () => vue.createVNode("div", {
        "role": "timer",
        "class": bem$S()
      }, [slots.default ? slots.default(current2.value) : timeText.value]);
    }
  });
  const CountDown = withInstall(stdin_default$Z);
  function getDate(timeStamp) {
    const date2 = new Date(timeStamp * 1e3);
    return `${date2.getFullYear()}.${padZero$1(date2.getMonth() + 1)}.${padZero$1(
      date2.getDate()
    )}`;
  }
  const formatDiscount = (discount) => (discount / 10).toFixed(discount % 10 === 0 ? 0 : 1);
  const formatAmount = (amount2) => (amount2 / 100).toFixed(amount2 % 100 === 0 ? 0 : amount2 % 10 === 0 ? 1 : 2);
  const [name$S, bem$R, t$d] = createNamespace("coupon");
  var stdin_default$Y = vue.defineComponent({
    name: name$S,
    props: {
      chosen: Boolean,
      coupon: makeRequiredProp(Object),
      disabled: Boolean,
      currency: makeStringProp("¥")
    },
    setup(props2) {
      const validPeriod = vue.computed(() => {
        const {
          startAt,
          endAt
        } = props2.coupon;
        return `${getDate(startAt)} - ${getDate(endAt)}`;
      });
      const faceAmount = vue.computed(() => {
        const {
          coupon,
          currency
        } = props2;
        if (coupon.valueDesc) {
          return [coupon.valueDesc, vue.createVNode("span", null, [coupon.unitDesc || ""])];
        }
        if (coupon.denominations) {
          const denominations = formatAmount(coupon.denominations);
          return [vue.createVNode("span", null, [currency]), ` ${denominations}`];
        }
        if (coupon.discount) {
          return t$d("discount", formatDiscount(coupon.discount));
        }
        return "";
      });
      const conditionMessage = vue.computed(() => {
        const condition = formatAmount(props2.coupon.originCondition || 0);
        return condition === "0" ? t$d("unlimited") : t$d("condition", condition);
      });
      return () => {
        const {
          chosen,
          coupon,
          disabled
        } = props2;
        const description = disabled && coupon.reason || coupon.description;
        return vue.createVNode("div", {
          "class": bem$R({
            disabled
          })
        }, [vue.createVNode("div", {
          "class": bem$R("content")
        }, [vue.createVNode("div", {
          "class": bem$R("head")
        }, [vue.createVNode("h2", {
          "class": bem$R("amount")
        }, [faceAmount.value]), vue.createVNode("p", {
          "class": bem$R("condition")
        }, [coupon.condition || conditionMessage.value])]), vue.createVNode("div", {
          "class": bem$R("body")
        }, [vue.createVNode("p", {
          "class": bem$R("name")
        }, [coupon.name]), vue.createVNode("p", {
          "class": bem$R("valid")
        }, [validPeriod.value]), !disabled && vue.createVNode(Checkbox, {
          "class": bem$R("corner"),
          "modelValue": chosen
        }, null)])]), description && vue.createVNode("p", {
          "class": bem$R("description")
        }, [description])]);
      };
    }
  });
  const Coupon = withInstall(stdin_default$Y);
  const [name$R, bem$Q, t$c] = createNamespace("coupon-cell");
  const couponCellProps = {
    title: String,
    border: truthProp,
    editable: truthProp,
    coupons: makeArrayProp(),
    currency: makeStringProp("¥"),
    chosenCoupon: {
      type: [Number, Array],
      default: -1
    }
  };
  const getValue = (coupon) => {
    const {
      value,
      denominations
    } = coupon;
    if (isDef(value)) {
      return value;
    }
    if (isDef(denominations)) {
      return denominations;
    }
    return 0;
  };
  function formatValue({
    coupons,
    chosenCoupon,
    currency
  }) {
    let value = 0;
    let isExist = false;
    (Array.isArray(chosenCoupon) ? chosenCoupon : [chosenCoupon]).forEach((i2) => {
      const coupon = coupons[+i2];
      if (coupon) {
        isExist = true;
        value += getValue(coupon);
      }
    });
    if (isExist) {
      return `-${currency} ${(value / 100).toFixed(2)}`;
    }
    return coupons.length === 0 ? t$c("noCoupon") : t$c("count", coupons.length);
  }
  var stdin_default$X = vue.defineComponent({
    name: name$R,
    props: couponCellProps,
    setup(props2) {
      return () => {
        const selected = Array.isArray(props2.chosenCoupon) ? props2.chosenCoupon.length : props2.coupons[+props2.chosenCoupon];
        return vue.createVNode(Cell, {
          "class": bem$Q(),
          "value": formatValue(props2),
          "title": props2.title || t$c("title"),
          "border": props2.border,
          "isLink": props2.editable,
          "valueClass": bem$Q("value", {
            selected
          })
        }, null);
      };
    }
  });
  const CouponCell = withInstall(stdin_default$X);
  const [name$Q, bem$P] = createNamespace("empty");
  const emptyProps = {
    image: makeStringProp("default"),
    imageSize: [Number, String, Array],
    description: String
  };
  var stdin_default$W = vue.defineComponent({
    name: name$Q,
    props: emptyProps,
    setup(props2, {
      slots
    }) {
      const renderDescription = () => {
        const description = slots.description ? slots.description() : props2.description;
        if (description) {
          return vue.createVNode("p", {
            "class": bem$P("description")
          }, [description]);
        }
      };
      const renderBottom = () => {
        if (slots.default) {
          return vue.createVNode("div", {
            "class": bem$P("bottom")
          }, [slots.default()]);
        }
      };
      const baseId = useId();
      const getId = (num) => `${baseId}-${num}`;
      const getUrlById = (num) => `url(#${getId(num)})`;
      const renderStop = (color, offset2, opacity) => vue.createVNode("stop", {
        "stop-color": color,
        "offset": `${offset2}%`,
        "stop-opacity": opacity
      }, null);
      const renderStops = (fromColor, toColor) => [renderStop(fromColor, 0), renderStop(toColor, 100)];
      const renderShadow = (id) => [vue.createVNode("defs", null, [vue.createVNode("radialGradient", {
        "id": getId(id),
        "cx": "50%",
        "cy": "54%",
        "fx": "50%",
        "fy": "54%",
        "r": "297%",
        "gradientTransform": "matrix(-.16 0 0 -.33 .58 .72)",
        "data-allow-mismatch": "attribute"
      }, [renderStop("#EBEDF0", 0), renderStop("#F2F3F5", 100, 0.3)])]), vue.createVNode("ellipse", {
        "fill": getUrlById(id),
        "opacity": ".8",
        "cx": "80",
        "cy": "140",
        "rx": "46",
        "ry": "8",
        "data-allow-mismatch": "attribute"
      }, null)];
      const renderBuilding = () => [vue.createVNode("defs", null, [vue.createVNode("linearGradient", {
        "id": getId("a"),
        "x1": "64%",
        "y1": "100%",
        "x2": "64%",
        "data-allow-mismatch": "attribute"
      }, [renderStop("#FFF", 0, 0.5), renderStop("#F2F3F5", 100)])]), vue.createVNode("g", {
        "opacity": ".8",
        "data-allow-mismatch": "children"
      }, [vue.createVNode("path", {
        "d": "M36 131V53H16v20H2v58h34z",
        "fill": getUrlById("a")
      }, null), vue.createVNode("path", {
        "d": "M123 15h22v14h9v77h-31V15z",
        "fill": getUrlById("a")
      }, null)])];
      const renderCloud = () => [vue.createVNode("defs", null, [vue.createVNode("linearGradient", {
        "id": getId("b"),
        "x1": "64%",
        "y1": "97%",
        "x2": "64%",
        "y2": "0%",
        "data-allow-mismatch": "attribute"
      }, [renderStop("#F2F3F5", 0, 0.3), renderStop("#F2F3F5", 100)])]), vue.createVNode("g", {
        "opacity": ".8",
        "data-allow-mismatch": "children"
      }, [vue.createVNode("path", {
        "d": "M87 6c3 0 7 3 8 6a8 8 0 1 1-1 16H80a7 7 0 0 1-8-6c0-4 3-7 6-7 0-5 4-9 9-9Z",
        "fill": getUrlById("b")
      }, null), vue.createVNode("path", {
        "d": "M19 23c2 0 3 1 4 3 2 0 4 2 4 4a4 4 0 0 1-4 3v1h-7v-1l-1 1c-2 0-3-2-3-4 0-1 1-3 3-3 0-2 2-4 4-4Z",
        "fill": getUrlById("b")
      }, null)])];
      const renderNetwork = () => vue.createVNode("svg", {
        "viewBox": "0 0 160 160"
      }, [vue.createVNode("defs", {
        "data-allow-mismatch": "children"
      }, [vue.createVNode("linearGradient", {
        "id": getId(1),
        "x1": "64%",
        "y1": "100%",
        "x2": "64%"
      }, [renderStop("#FFF", 0, 0.5), renderStop("#F2F3F5", 100)]), vue.createVNode("linearGradient", {
        "id": getId(2),
        "x1": "50%",
        "x2": "50%",
        "y2": "84%"
      }, [renderStop("#EBEDF0", 0), renderStop("#DCDEE0", 100, 0)]), vue.createVNode("linearGradient", {
        "id": getId(3),
        "x1": "100%",
        "x2": "100%",
        "y2": "100%"
      }, [renderStops("#EAEDF0", "#DCDEE0")]), vue.createVNode("radialGradient", {
        "id": getId(4),
        "cx": "50%",
        "cy": "0%",
        "fx": "50%",
        "fy": "0%",
        "r": "100%",
        "gradientTransform": "matrix(0 1 -.54 0 .5 -.5)"
      }, [renderStop("#EBEDF0", 0), renderStop("#FFF", 100, 0)])]), vue.createVNode("g", {
        "fill": "none"
      }, [renderBuilding(), vue.createVNode("path", {
        "fill": getUrlById(4),
        "d": "M0 139h160v21H0z",
        "data-allow-mismatch": "attribute"
      }, null), vue.createVNode("path", {
        "d": "M80 54a7 7 0 0 1 3 13v27l-2 2h-2a2 2 0 0 1-2-2V67a7 7 0 0 1 3-13z",
        "fill": getUrlById(2),
        "data-allow-mismatch": "attribute"
      }, null), vue.createVNode("g", {
        "opacity": ".6",
        "stroke-linecap": "round",
        "stroke-width": "7",
        "data-allow-mismatch": "children"
      }, [vue.createVNode("path", {
        "d": "M64 47a19 19 0 0 0-5 13c0 5 2 10 5 13",
        "stroke": getUrlById(3)
      }, null), vue.createVNode("path", {
        "d": "M53 36a34 34 0 0 0 0 48",
        "stroke": getUrlById(3)
      }, null), vue.createVNode("path", {
        "d": "M95 73a19 19 0 0 0 6-13c0-5-2-9-6-13",
        "stroke": getUrlById(3)
      }, null), vue.createVNode("path", {
        "d": "M106 84a34 34 0 0 0 0-48",
        "stroke": getUrlById(3)
      }, null)]), vue.createVNode("g", {
        "transform": "translate(31 105)"
      }, [vue.createVNode("rect", {
        "fill": "#EBEDF0",
        "width": "98",
        "height": "34",
        "rx": "2"
      }, null), vue.createVNode("rect", {
        "fill": "#FFF",
        "x": "9",
        "y": "8",
        "width": "80",
        "height": "18",
        "rx": "1.1"
      }, null), vue.createVNode("rect", {
        "fill": "#EBEDF0",
        "x": "15",
        "y": "12",
        "width": "18",
        "height": "6",
        "rx": "1.1"
      }, null)])])]);
      const renderMaterial = () => vue.createVNode("svg", {
        "viewBox": "0 0 160 160"
      }, [vue.createVNode("defs", {
        "data-allow-mismatch": "children"
      }, [vue.createVNode("linearGradient", {
        "x1": "50%",
        "x2": "50%",
        "y2": "100%",
        "id": getId(5)
      }, [renderStops("#F2F3F5", "#DCDEE0")]), vue.createVNode("linearGradient", {
        "x1": "95%",
        "y1": "48%",
        "x2": "5.5%",
        "y2": "51%",
        "id": getId(6)
      }, [renderStops("#EAEDF1", "#DCDEE0")]), vue.createVNode("linearGradient", {
        "y1": "45%",
        "x2": "100%",
        "y2": "54%",
        "id": getId(7)
      }, [renderStops("#EAEDF1", "#DCDEE0")])]), renderBuilding(), renderCloud(), vue.createVNode("g", {
        "transform": "translate(36 50)",
        "fill": "none"
      }, [vue.createVNode("g", {
        "transform": "translate(8)"
      }, [vue.createVNode("rect", {
        "fill": "#EBEDF0",
        "opacity": ".6",
        "x": "38",
        "y": "13",
        "width": "36",
        "height": "53",
        "rx": "2"
      }, null), vue.createVNode("rect", {
        "fill": getUrlById(5),
        "width": "64",
        "height": "66",
        "rx": "2",
        "data-allow-mismatch": "attribute"
      }, null), vue.createVNode("rect", {
        "fill": "#FFF",
        "x": "6",
        "y": "6",
        "width": "52",
        "height": "55",
        "rx": "1"
      }, null), vue.createVNode("g", {
        "transform": "translate(15 17)",
        "fill": getUrlById(6),
        "data-allow-mismatch": "attribute"
      }, [vue.createVNode("rect", {
        "width": "34",
        "height": "6",
        "rx": "1"
      }, null), vue.createVNode("path", {
        "d": "M0 14h34v6H0z"
      }, null), vue.createVNode("rect", {
        "y": "28",
        "width": "34",
        "height": "6",
        "rx": "1"
      }, null)])]), vue.createVNode("rect", {
        "fill": getUrlById(7),
        "y": "61",
        "width": "88",
        "height": "28",
        "rx": "1",
        "data-allow-mismatch": "attribute"
      }, null), vue.createVNode("rect", {
        "fill": "#F7F8FA",
        "x": "29",
        "y": "72",
        "width": "30",
        "height": "6",
        "rx": "1"
      }, null)])]);
      const renderError = () => vue.createVNode("svg", {
        "viewBox": "0 0 160 160"
      }, [vue.createVNode("defs", null, [vue.createVNode("linearGradient", {
        "x1": "50%",
        "x2": "50%",
        "y2": "100%",
        "id": getId(8),
        "data-allow-mismatch": "attribute"
      }, [renderStops("#EAEDF1", "#DCDEE0")])]), renderBuilding(), renderCloud(), renderShadow("c"), vue.createVNode("path", {
        "d": "m59 60 21 21 21-21h3l9 9v3L92 93l21 21v3l-9 9h-3l-21-21-21 21h-3l-9-9v-3l21-21-21-21v-3l9-9h3Z",
        "fill": getUrlById(8),
        "data-allow-mismatch": "attribute"
      }, null)]);
      const renderSearch = () => vue.createVNode("svg", {
        "viewBox": "0 0 160 160"
      }, [vue.createVNode("defs", {
        "data-allow-mismatch": "children"
      }, [vue.createVNode("linearGradient", {
        "x1": "50%",
        "y1": "100%",
        "x2": "50%",
        "id": getId(9)
      }, [renderStops("#EEE", "#D8D8D8")]), vue.createVNode("linearGradient", {
        "x1": "100%",
        "y1": "50%",
        "y2": "50%",
        "id": getId(10)
      }, [renderStops("#F2F3F5", "#DCDEE0")]), vue.createVNode("linearGradient", {
        "x1": "50%",
        "x2": "50%",
        "y2": "100%",
        "id": getId(11)
      }, [renderStops("#F2F3F5", "#DCDEE0")]), vue.createVNode("linearGradient", {
        "x1": "50%",
        "x2": "50%",
        "y2": "100%",
        "id": getId(12)
      }, [renderStops("#FFF", "#F7F8FA")])]), renderBuilding(), renderCloud(), renderShadow("d"), vue.createVNode("g", {
        "transform": "rotate(-45 113 -4)",
        "fill": "none",
        "data-allow-mismatch": "children"
      }, [vue.createVNode("rect", {
        "fill": getUrlById(9),
        "x": "24",
        "y": "52.8",
        "width": "5.8",
        "height": "19",
        "rx": "1"
      }, null), vue.createVNode("rect", {
        "fill": getUrlById(10),
        "x": "22.1",
        "y": "67.3",
        "width": "9.9",
        "height": "28",
        "rx": "1"
      }, null), vue.createVNode("circle", {
        "stroke": getUrlById(11),
        "stroke-width": "8",
        "cx": "27",
        "cy": "27",
        "r": "27"
      }, null), vue.createVNode("circle", {
        "fill": getUrlById(12),
        "cx": "27",
        "cy": "27",
        "r": "16"
      }, null), vue.createVNode("path", {
        "d": "M37 7c-8 0-15 5-16 12",
        "stroke": getUrlById(11),
        "stroke-width": "3",
        "opacity": ".5",
        "stroke-linecap": "round",
        "transform": "rotate(45 29 13)"
      }, null)])]);
      const renderImage = () => {
        var _a;
        if (slots.image) {
          return slots.image();
        }
        const PRESET_IMAGES = {
          error: renderError,
          search: renderSearch,
          network: renderNetwork,
          default: renderMaterial
        };
        return ((_a = PRESET_IMAGES[props2.image]) == null ? void 0 : _a.call(PRESET_IMAGES)) || vue.createVNode("img", {
          "src": props2.image
        }, null);
      };
      return () => vue.createVNode("div", {
        "class": bem$P()
      }, [vue.createVNode("div", {
        "class": bem$P("image"),
        "style": getSizeStyle(props2.imageSize)
      }, [renderImage()]), renderDescription(), renderBottom()]);
    }
  });
  const Empty = withInstall(stdin_default$W);
  const [name$P, bem$O, t$b] = createNamespace("coupon-list");
  const couponListProps = {
    code: makeStringProp(""),
    coupons: makeArrayProp(),
    currency: makeStringProp("¥"),
    showCount: truthProp,
    emptyImage: String,
    enabledTitle: String,
    disabledTitle: String,
    disabledCoupons: makeArrayProp(),
    showExchangeBar: truthProp,
    showCloseButton: truthProp,
    closeButtonText: String,
    inputPlaceholder: String,
    exchangeMinLength: makeNumberProp(1),
    exchangeButtonText: String,
    displayedCouponIndex: makeNumberProp(-1),
    exchangeButtonLoading: Boolean,
    exchangeButtonDisabled: Boolean,
    chosenCoupon: {
      type: [Number, Array],
      default: -1
    }
  };
  var stdin_default$V = vue.defineComponent({
    name: name$P,
    props: couponListProps,
    emits: ["change", "exchange", "update:code"],
    setup(props2, {
      emit,
      slots
    }) {
      const [couponRefs, setCouponRefs] = useRefs();
      const root = vue.ref();
      const barRef = vue.ref();
      const activeTab = vue.ref(0);
      const listHeight = vue.ref(0);
      const currentCode = vue.ref(props2.code);
      const buttonDisabled = vue.computed(() => !props2.exchangeButtonLoading && (props2.exchangeButtonDisabled || !currentCode.value || currentCode.value.length < props2.exchangeMinLength));
      const updateListHeight = () => {
        const TABS_HEIGHT = 44;
        const rootHeight = useRect(root).height;
        const headerHeight = useRect(barRef).height + TABS_HEIGHT;
        listHeight.value = (rootHeight > headerHeight ? rootHeight : windowHeight.value) - headerHeight;
      };
      const onExchange = () => {
        emit("exchange", currentCode.value);
        if (!props2.code) {
          currentCode.value = "";
        }
      };
      const scrollToCoupon = (index2) => {
        vue.nextTick(() => {
          var _a;
          return (_a = couponRefs.value[index2]) == null ? void 0 : _a.scrollIntoView();
        });
      };
      const renderEmpty = () => vue.createVNode(Empty, {
        "image": props2.emptyImage
      }, {
        default: () => [vue.createVNode("p", {
          "class": bem$O("empty-tip")
        }, [t$b("noCoupon")])]
      });
      const renderExchangeBar = () => {
        if (props2.showExchangeBar) {
          return vue.createVNode("div", {
            "ref": barRef,
            "class": bem$O("exchange-bar")
          }, [vue.createVNode(Field, {
            "modelValue": currentCode.value,
            "onUpdate:modelValue": ($event) => currentCode.value = $event,
            "clearable": true,
            "border": false,
            "class": bem$O("field"),
            "placeholder": props2.inputPlaceholder || t$b("placeholder"),
            "maxlength": "20"
          }, null), vue.createVNode(Button, {
            "plain": true,
            "type": "primary",
            "class": bem$O("exchange"),
            "text": props2.exchangeButtonText || t$b("exchange"),
            "loading": props2.exchangeButtonLoading,
            "disabled": buttonDisabled.value,
            "onClick": onExchange
          }, null)]);
        }
      };
      const renderCouponTab = () => {
        const {
          coupons,
          chosenCoupon
        } = props2;
        const count = props2.showCount ? ` (${coupons.length})` : "";
        const title = (props2.enabledTitle || t$b("enable")) + count;
        const updateChosenCoupon = (currentValues = [], value = 0) => {
          if (currentValues.includes(value)) {
            return currentValues.filter((item) => item !== value);
          }
          return [...currentValues, value];
        };
        return vue.createVNode(Tab, {
          "title": title
        }, {
          default: () => {
            var _a;
            return [vue.createVNode("div", {
              "class": bem$O("list", {
                "with-bottom": props2.showCloseButton
              }),
              "style": {
                height: `${listHeight.value}px`
              }
            }, [coupons.map((coupon, index2) => vue.createVNode(Coupon, {
              "key": coupon.id,
              "ref": setCouponRefs(index2),
              "coupon": coupon,
              "chosen": Array.isArray(chosenCoupon) ? chosenCoupon.includes(index2) : index2 === chosenCoupon,
              "currency": props2.currency,
              "onClick": () => emit("change", Array.isArray(chosenCoupon) ? updateChosenCoupon(chosenCoupon, index2) : index2)
            }, null)), !coupons.length && renderEmpty(), (_a = slots["list-footer"]) == null ? void 0 : _a.call(slots)])];
          }
        });
      };
      const renderDisabledTab = () => {
        const {
          disabledCoupons
        } = props2;
        const count = props2.showCount ? ` (${disabledCoupons.length})` : "";
        const title = (props2.disabledTitle || t$b("disabled")) + count;
        return vue.createVNode(Tab, {
          "title": title
        }, {
          default: () => {
            var _a;
            return [vue.createVNode("div", {
              "class": bem$O("list", {
                "with-bottom": props2.showCloseButton
              }),
              "style": {
                height: `${listHeight.value}px`
              }
            }, [disabledCoupons.map((coupon) => vue.createVNode(Coupon, {
              "disabled": true,
              "key": coupon.id,
              "coupon": coupon,
              "currency": props2.currency
            }, null)), !disabledCoupons.length && renderEmpty(), (_a = slots["disabled-list-footer"]) == null ? void 0 : _a.call(slots)])];
          }
        });
      };
      vue.watch(() => props2.code, (value) => {
        currentCode.value = value;
      });
      vue.watch(windowHeight, updateListHeight);
      vue.watch(currentCode, (value) => emit("update:code", value));
      vue.watch(() => props2.displayedCouponIndex, scrollToCoupon);
      vue.onMounted(() => {
        updateListHeight();
        scrollToCoupon(props2.displayedCouponIndex);
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "class": bem$O()
      }, [renderExchangeBar(), vue.createVNode(Tabs, {
        "active": activeTab.value,
        "onUpdate:active": ($event) => activeTab.value = $event,
        "class": bem$O("tab")
      }, {
        default: () => [renderCouponTab(), renderDisabledTab()]
      }), vue.createVNode("div", {
        "class": bem$O("bottom")
      }, [slots["list-button"] ? slots["list-button"]() : vue.withDirectives(vue.createVNode(Button, {
        "round": true,
        "block": true,
        "type": "primary",
        "class": bem$O("close"),
        "text": props2.closeButtonText || t$b("close"),
        "onClick": () => emit("change", Array.isArray(props2.chosenCoupon) ? [] : -1)
      }, null), [[vue.vShow, props2.showCloseButton]])])]);
    }
  });
  const CouponList = withInstall(stdin_default$V);
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const [name$O] = createNamespace("date-picker");
  const datePickerProps = extend({}, sharedProps, {
    columnsType: {
      type: Array,
      default: () => ["year", "month", "day"]
    },
    minDate: {
      type: Date,
      default: () => new Date(currentYear - 10, 0, 1),
      validator: isDate
    },
    maxDate: {
      type: Date,
      default: () => new Date(currentYear + 10, 11, 31),
      validator: isDate
    }
  });
  var stdin_default$U = vue.defineComponent({
    name: name$O,
    props: datePickerProps,
    emits: ["confirm", "cancel", "change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const currentValues = vue.ref(props2.modelValue);
      const updatedByExternalSources = vue.ref(false);
      const pickerRef = vue.ref();
      const computedValues = vue.computed(() => updatedByExternalSources.value ? props2.modelValue : currentValues.value);
      const isMinYear = (year) => year === props2.minDate.getFullYear();
      const isMaxYear = (year) => year === props2.maxDate.getFullYear();
      const isMinMonth = (month) => month === props2.minDate.getMonth() + 1;
      const isMaxMonth = (month) => month === props2.maxDate.getMonth() + 1;
      const getValue2 = (type) => {
        const {
          minDate,
          columnsType
        } = props2;
        const index2 = columnsType.indexOf(type);
        const value = computedValues.value[index2];
        if (value) {
          return +value;
        }
        switch (type) {
          case "year":
            return minDate.getFullYear();
          case "month":
            return minDate.getMonth() + 1;
          case "day":
            return minDate.getDate();
        }
      };
      const genYearOptions = () => {
        const minYear = props2.minDate.getFullYear();
        const maxYear = props2.maxDate.getFullYear();
        return genOptions(minYear, maxYear, "year", props2.formatter, props2.filter, computedValues.value);
      };
      const genMonthOptions = () => {
        const year = getValue2("year");
        const minMonth = isMinYear(year) ? props2.minDate.getMonth() + 1 : 1;
        const maxMonth = isMaxYear(year) ? props2.maxDate.getMonth() + 1 : 12;
        return genOptions(minMonth, maxMonth, "month", props2.formatter, props2.filter, computedValues.value);
      };
      const genDayOptions = () => {
        const year = getValue2("year");
        const month = getValue2("month");
        const minDate = isMinYear(year) && isMinMonth(month) ? props2.minDate.getDate() : 1;
        const maxDate = isMaxYear(year) && isMaxMonth(month) ? props2.maxDate.getDate() : getMonthEndDay(year, month);
        return genOptions(minDate, maxDate, "day", props2.formatter, props2.filter, computedValues.value);
      };
      const confirm = () => {
        var _a;
        return (_a = pickerRef.value) == null ? void 0 : _a.confirm();
      };
      const getSelectedDate = () => currentValues.value;
      const columns = vue.computed(() => props2.columnsType.map((type) => {
        switch (type) {
          case "year":
            return genYearOptions();
          case "month":
            return genMonthOptions();
          case "day":
            return genDayOptions();
          default: {
            throw new Error(`[Vant] DatePicker: unsupported columns type: ${type}`);
          }
        }
      }));
      vue.watch(currentValues, (newValues) => {
        if (!isSameValue(newValues, props2.modelValue)) {
          emit("update:modelValue", newValues);
        }
      });
      vue.watch(() => props2.modelValue, (newValues, oldValues) => {
        updatedByExternalSources.value = isSameValue(oldValues, currentValues.value);
        newValues = formatValueRange(newValues, columns.value);
        if (!isSameValue(newValues, currentValues.value)) {
          currentValues.value = newValues;
        }
        updatedByExternalSources.value = false;
      }, {
        immediate: true
      });
      const onChange = (...args) => emit("change", ...args);
      const onCancel = (...args) => emit("cancel", ...args);
      const onConfirm = (...args) => emit("confirm", ...args);
      useExpose({
        confirm,
        getSelectedDate
      });
      return () => vue.createVNode(Picker, vue.mergeProps({
        "ref": pickerRef,
        "modelValue": currentValues.value,
        "onUpdate:modelValue": ($event) => currentValues.value = $event,
        "columns": columns.value,
        "onChange": onChange,
        "onCancel": onCancel,
        "onConfirm": onConfirm
      }, pick(props2, pickerInheritKeys)), slots);
    }
  });
  const DatePicker = withInstall(stdin_default$U);
  const [name$N, bem$N, t$a] = createNamespace("dialog");
  const dialogProps = extend({}, popupSharedProps, {
    title: String,
    theme: String,
    width: numericProp,
    message: [String, Function],
    callback: Function,
    allowHtml: Boolean,
    className: unknownProp,
    transition: makeStringProp("van-dialog-bounce"),
    messageAlign: String,
    closeOnPopstate: truthProp,
    showCancelButton: Boolean,
    cancelButtonText: String,
    cancelButtonColor: String,
    cancelButtonDisabled: Boolean,
    confirmButtonText: String,
    confirmButtonColor: String,
    confirmButtonDisabled: Boolean,
    showConfirmButton: truthProp,
    closeOnClickOverlay: Boolean,
    keyboardEnabled: truthProp
  });
  const popupInheritKeys$1 = [...popupSharedPropKeys, "transition", "closeOnPopstate"];
  var stdin_default$T = vue.defineComponent({
    name: name$N,
    props: dialogProps,
    emits: ["confirm", "cancel", "keydown", "update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const loading = vue.reactive({
        confirm: false,
        cancel: false
      });
      const updateShow = (value) => emit("update:show", value);
      const close = (action) => {
        var _a;
        updateShow(false);
        (_a = props2.callback) == null ? void 0 : _a.call(props2, action);
      };
      const getActionHandler = (action) => () => {
        if (!props2.show) {
          return;
        }
        emit(action);
        if (props2.beforeClose) {
          loading[action] = true;
          callInterceptor(props2.beforeClose, {
            args: [action],
            done() {
              close(action);
              loading[action] = false;
            },
            canceled() {
              loading[action] = false;
            }
          });
        } else {
          close(action);
        }
      };
      const onCancel = getActionHandler("cancel");
      const onConfirm = getActionHandler("confirm");
      const onKeydown = vue.withKeys((event) => {
        var _a, _b;
        if (!props2.keyboardEnabled) {
          return;
        }
        if (event.target !== ((_b = (_a = root.value) == null ? void 0 : _a.popupRef) == null ? void 0 : _b.value)) {
          return;
        }
        const onEventType = {
          Enter: props2.showConfirmButton ? onConfirm : noop$1,
          Escape: props2.showCancelButton ? onCancel : noop$1
        };
        onEventType[event.key]();
        emit("keydown", event);
      }, ["enter", "esc"]);
      const renderTitle = () => {
        const title = slots.title ? slots.title() : props2.title;
        if (title) {
          return vue.createVNode("div", {
            "class": bem$N("header", {
              isolated: !props2.message && !slots.default
            })
          }, [title]);
        }
      };
      const renderMessage = (hasTitle) => {
        const {
          message,
          allowHtml,
          messageAlign
        } = props2;
        const classNames = bem$N("message", {
          "has-title": hasTitle,
          [messageAlign]: messageAlign
        });
        const content = isFunction(message) ? message() : message;
        if (allowHtml && typeof content === "string") {
          return vue.createVNode("div", {
            "class": classNames,
            "innerHTML": content
          }, null);
        }
        return vue.createVNode("div", {
          "class": classNames
        }, [content]);
      };
      const renderContent = () => {
        if (slots.default) {
          return vue.createVNode("div", {
            "class": bem$N("content")
          }, [slots.default()]);
        }
        const {
          title,
          message,
          allowHtml
        } = props2;
        if (message) {
          const hasTitle = !!(title || slots.title);
          return vue.createVNode("div", {
            "key": allowHtml ? 1 : 0,
            "class": bem$N("content", {
              isolated: !hasTitle
            })
          }, [renderMessage(hasTitle)]);
        }
      };
      const renderButtons = () => vue.createVNode("div", {
        "class": [BORDER_TOP, bem$N("footer")]
      }, [props2.showCancelButton && vue.createVNode(Button, {
        "size": "large",
        "text": props2.cancelButtonText || t$a("cancel"),
        "class": bem$N("cancel"),
        "style": {
          color: props2.cancelButtonColor
        },
        "loading": loading.cancel,
        "disabled": props2.cancelButtonDisabled,
        "onClick": onCancel
      }, null), props2.showConfirmButton && vue.createVNode(Button, {
        "size": "large",
        "text": props2.confirmButtonText || t$a("confirm"),
        "class": [bem$N("confirm"), {
          [BORDER_LEFT]: props2.showCancelButton
        }],
        "style": {
          color: props2.confirmButtonColor
        },
        "loading": loading.confirm,
        "disabled": props2.confirmButtonDisabled,
        "onClick": onConfirm
      }, null)]);
      const renderRoundButtons = () => vue.createVNode(ActionBar, {
        "class": bem$N("footer")
      }, {
        default: () => [props2.showCancelButton && vue.createVNode(ActionBarButton, {
          "type": "warning",
          "text": props2.cancelButtonText || t$a("cancel"),
          "class": bem$N("cancel"),
          "color": props2.cancelButtonColor,
          "loading": loading.cancel,
          "disabled": props2.cancelButtonDisabled,
          "onClick": onCancel
        }, null), props2.showConfirmButton && vue.createVNode(ActionBarButton, {
          "type": "danger",
          "text": props2.confirmButtonText || t$a("confirm"),
          "class": bem$N("confirm"),
          "color": props2.confirmButtonColor,
          "loading": loading.confirm,
          "disabled": props2.confirmButtonDisabled,
          "onClick": onConfirm
        }, null)]
      });
      const renderFooter = () => {
        if (slots.footer) {
          return slots.footer();
        }
        return props2.theme === "round-button" ? renderRoundButtons() : renderButtons();
      };
      return () => {
        const {
          width: width2,
          title,
          theme,
          message,
          className
        } = props2;
        return vue.createVNode(Popup, vue.mergeProps({
          "ref": root,
          "role": "dialog",
          "class": [bem$N([theme]), className],
          "style": {
            width: addUnit$2(width2)
          },
          "tabindex": 0,
          "aria-labelledby": title || message,
          "onKeydown": onKeydown,
          "onUpdate:show": updateShow
        }, pick(props2, popupInheritKeys$1)), {
          default: () => [renderTitle(), renderContent(), renderFooter()]
        });
      };
    }
  });
  const Dialog = withInstall(stdin_default$T);
  const [name$M, bem$M] = createNamespace("divider");
  const dividerProps = {
    dashed: Boolean,
    hairline: truthProp,
    vertical: Boolean,
    contentPosition: makeStringProp("center")
  };
  var stdin_default$S = vue.defineComponent({
    name: name$M,
    props: dividerProps,
    setup(props2, {
      slots
    }) {
      return () => {
        var _a;
        return vue.createVNode("div", {
          "role": "separator",
          "class": bem$M({
            dashed: props2.dashed,
            hairline: props2.hairline,
            vertical: props2.vertical,
            [`content-${props2.contentPosition}`]: !!slots.default && !props2.vertical
          })
        }, [!props2.vertical && ((_a = slots.default) == null ? void 0 : _a.call(slots))]);
      };
    }
  });
  const Divider = withInstall(stdin_default$S);
  const [name$L, bem$L] = createNamespace("dropdown-menu");
  const dropdownMenuProps = {
    overlay: truthProp,
    zIndex: numericProp,
    duration: makeNumericProp(0.2),
    direction: makeStringProp("down"),
    activeColor: String,
    autoLocate: Boolean,
    closeOnClickOutside: truthProp,
    closeOnClickOverlay: truthProp,
    swipeThreshold: numericProp
  };
  const DROPDOWN_KEY = Symbol(name$L);
  var stdin_default$R = vue.defineComponent({
    name: name$L,
    props: dropdownMenuProps,
    setup(props2, {
      slots
    }) {
      const id = useId();
      const root = vue.ref();
      const barRef = vue.ref();
      const offset2 = vue.ref(0);
      const {
        children,
        linkChildren
      } = useChildren(DROPDOWN_KEY);
      const scrollParent = useScrollParent(root);
      const opened = vue.computed(() => children.some((item) => item.state.showWrapper));
      const scrollable = vue.computed(() => props2.swipeThreshold && children.length > +props2.swipeThreshold);
      const barStyle = vue.computed(() => {
        if (opened.value && isDef(props2.zIndex)) {
          return {
            zIndex: +props2.zIndex + 1
          };
        }
      });
      const close = () => {
        children.forEach((item) => {
          item.toggle(false);
        });
      };
      const onClickAway = () => {
        if (props2.closeOnClickOutside) {
          close();
        }
      };
      const updateOffset = () => {
        if (barRef.value) {
          const rect = useRect(barRef);
          if (props2.direction === "down") {
            offset2.value = rect.bottom;
          } else {
            offset2.value = windowHeight.value - rect.top;
          }
        }
      };
      const onScroll = () => {
        if (opened.value) {
          updateOffset();
        }
      };
      const toggleItem = (active) => {
        children.forEach((item, index2) => {
          if (index2 === active) {
            item.toggle();
          } else if (item.state.showPopup) {
            item.toggle(false, {
              immediate: true
            });
          }
        });
      };
      const renderTitle = (item, index2) => {
        const {
          showPopup
        } = item.state;
        const {
          disabled,
          titleClass
        } = item;
        return vue.createVNode("div", {
          "id": `${id}-${index2}`,
          "role": "button",
          "tabindex": disabled ? void 0 : 0,
          "data-allow-mismatch": "attribute",
          "class": [bem$L("item", {
            disabled,
            grow: scrollable.value
          }), {
            [HAPTICS_FEEDBACK]: !disabled
          }],
          "onClick": () => {
            if (!disabled) {
              toggleItem(index2);
            }
          }
        }, [vue.createVNode("span", {
          "class": [bem$L("title", {
            down: showPopup === (props2.direction === "down"),
            active: showPopup
          }), titleClass],
          "style": {
            color: showPopup ? props2.activeColor : ""
          }
        }, [vue.createVNode("div", {
          "class": "van-ellipsis"
        }, [item.renderTitle()])])]);
      };
      useExpose({
        close
      });
      linkChildren({
        id,
        props: props2,
        offset: offset2,
        updateOffset
      });
      useClickAway(root, onClickAway);
      useEventListener("scroll", onScroll, {
        target: scrollParent,
        passive: true
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$L()
        }, [vue.createVNode("div", {
          "ref": barRef,
          "style": barStyle.value,
          "class": bem$L("bar", {
            opened: opened.value,
            scrollable: scrollable.value
          })
        }, [children.map(renderTitle)]), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const [name$K, bem$K] = createNamespace("dropdown-item");
  const dropdownItemProps = {
    title: String,
    options: makeArrayProp(),
    disabled: Boolean,
    teleport: [String, Object],
    lazyRender: truthProp,
    modelValue: unknownProp,
    titleClass: unknownProp
  };
  var stdin_default$Q = vue.defineComponent({
    name: name$K,
    inheritAttrs: false,
    props: dropdownItemProps,
    emits: ["open", "opened", "close", "closed", "change", "update:modelValue"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      const state = vue.reactive({
        showPopup: false,
        transition: true,
        showWrapper: false
      });
      const wrapperRef = vue.ref();
      const {
        parent,
        index: index2
      } = useParent(DROPDOWN_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/dropdown-item/DropdownItem.mjs:41", "[Vant] <DropdownItem> must be a child component of <DropdownMenu>.");
        }
        return;
      }
      const getEmitter = (name2) => () => emit(name2);
      const onOpen = getEmitter("open");
      const onClose = getEmitter("close");
      const onOpened = getEmitter("opened");
      const onClosed = () => {
        state.showWrapper = false;
        emit("closed");
      };
      const onClickWrapper = (event) => {
        if (props2.teleport) {
          event.stopPropagation();
        }
      };
      const toggle = (show = !state.showPopup, options = {}) => {
        if (show === state.showPopup) {
          return;
        }
        state.showPopup = show;
        state.transition = !options.immediate;
        if (show) {
          parent.updateOffset();
          state.showWrapper = true;
        }
      };
      const renderTitle = () => {
        if (slots.title) {
          return slots.title();
        }
        if (props2.title) {
          return props2.title;
        }
        const match = props2.options.find((option) => option.value === props2.modelValue);
        return match ? match.text : "";
      };
      const renderOption = (option) => {
        const {
          activeColor
        } = parent.props;
        const {
          disabled
        } = option;
        const active = option.value === props2.modelValue;
        const onClick = () => {
          if (disabled) {
            return;
          }
          state.showPopup = false;
          if (option.value !== props2.modelValue) {
            emit("update:modelValue", option.value);
            emit("change", option.value);
          }
        };
        const renderIcon = () => {
          if (active) {
            return vue.createVNode(Icon, {
              "class": bem$K("icon"),
              "color": disabled ? void 0 : activeColor,
              "name": "success"
            }, null);
          }
        };
        return vue.createVNode(Cell, {
          "role": "menuitem",
          "key": String(option.value),
          "icon": option.icon,
          "title": option.text,
          "class": bem$K("option", {
            active,
            disabled
          }),
          "style": {
            color: active ? activeColor : ""
          },
          "tabindex": active ? 0 : -1,
          "clickable": !disabled,
          "onClick": onClick
        }, {
          value: renderIcon
        });
      };
      const renderContent = () => {
        const {
          offset: offset2
        } = parent;
        const {
          autoLocate,
          zIndex,
          overlay,
          duration,
          direction,
          closeOnClickOverlay
        } = parent.props;
        const style = getZIndexStyle(zIndex);
        let offsetValue = offset2.value;
        if (autoLocate && wrapperRef.value) {
          const offsetParent = getContainingBlock$1(wrapperRef.value);
          if (offsetParent) {
            offsetValue -= useRect(offsetParent).top;
          }
        }
        if (direction === "down") {
          style.top = `${offsetValue}px`;
        } else {
          style.bottom = `${offsetValue}px`;
        }
        return vue.withDirectives(vue.createVNode("div", vue.mergeProps({
          "ref": wrapperRef,
          "style": style,
          "class": bem$K([direction]),
          "onClick": onClickWrapper
        }, attrs), [vue.createVNode(Popup, {
          "show": state.showPopup,
          "onUpdate:show": ($event) => state.showPopup = $event,
          "role": "menu",
          "class": bem$K("content"),
          "overlay": overlay,
          "position": direction === "down" ? "top" : "bottom",
          "duration": state.transition ? duration : 0,
          "lazyRender": props2.lazyRender,
          "overlayStyle": {
            position: "absolute"
          },
          "aria-labelledby": `${parent.id}-${index2.value}`,
          "data-allow-mismatch": "attribute",
          "closeOnClickOverlay": closeOnClickOverlay,
          "onOpen": onOpen,
          "onClose": onClose,
          "onOpened": onOpened,
          "onClosed": onClosed
        }, {
          default: () => {
            var _a;
            return [props2.options.map(renderOption), (_a = slots.default) == null ? void 0 : _a.call(slots)];
          }
        })]), [[vue.vShow, state.showWrapper]]);
      };
      useExpose({
        state,
        toggle,
        renderTitle
      });
      return () => {
        if (props2.teleport) {
          return vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [renderContent()]
          });
        }
        return renderContent();
      };
    }
  });
  const DropdownItem = withInstall(stdin_default$Q);
  const DropdownMenu = withInstall(stdin_default$R);
  const floatingBubbleProps = {
    gap: makeNumberProp(24),
    icon: String,
    axis: makeStringProp("y"),
    magnetic: String,
    offset: {
      type: Object,
      default: () => ({
        x: -1,
        y: -1
      })
    },
    teleport: {
      type: [String, Object],
      default: "body"
    }
  };
  const [name$J, bem$J] = createNamespace("floating-bubble");
  var stdin_default$P = vue.defineComponent({
    name: name$J,
    inheritAttrs: false,
    props: floatingBubbleProps,
    emits: ["click", "update:offset", "offsetChange"],
    setup(props2, {
      slots,
      emit,
      attrs
    }) {
      const rootRef = vue.ref();
      const state = vue.ref({
        x: 0,
        y: 0,
        width: 0,
        height: 0
      });
      const boundary = vue.computed(() => ({
        top: props2.gap,
        right: windowWidth.value - state.value.width - props2.gap,
        bottom: windowHeight.value - state.value.height - props2.gap,
        left: props2.gap
      }));
      const dragging = vue.ref(false);
      let initialized = false;
      const rootStyle = vue.computed(() => {
        const style = {};
        const x = addUnit$2(state.value.x);
        const y = addUnit$2(state.value.y);
        style.transform = `translate3d(${x}, ${y}, 0)`;
        if (dragging.value || !initialized) {
          style.transition = "none";
        }
        return style;
      });
      const updateState = () => {
        if (!show.value)
          return;
        const {
          width: width2,
          height: height2
        } = useRect(rootRef.value);
        const {
          offset: offset2
        } = props2;
        state.value = {
          x: offset2.x > -1 ? offset2.x : windowWidth.value - width2 - props2.gap,
          y: offset2.y > -1 ? offset2.y : windowHeight.value - height2 - props2.gap,
          width: width2,
          height: height2
        };
      };
      const touch = useTouch();
      let prevX = 0;
      let prevY = 0;
      const onTouchStart = (e2) => {
        touch.start(e2);
        dragging.value = true;
        prevX = state.value.x;
        prevY = state.value.y;
      };
      const onTouchMove = (e2) => {
        e2.preventDefault();
        touch.move(e2);
        if (props2.axis === "lock")
          return;
        if (!touch.isTap.value) {
          if (props2.axis === "x" || props2.axis === "xy") {
            let nextX = prevX + touch.deltaX.value;
            if (nextX < boundary.value.left)
              nextX = boundary.value.left;
            if (nextX > boundary.value.right)
              nextX = boundary.value.right;
            state.value.x = nextX;
          }
          if (props2.axis === "y" || props2.axis === "xy") {
            let nextY = prevY + touch.deltaY.value;
            if (nextY < boundary.value.top)
              nextY = boundary.value.top;
            if (nextY > boundary.value.bottom)
              nextY = boundary.value.bottom;
            state.value.y = nextY;
          }
          const offset2 = pick(state.value, ["x", "y"]);
          emit("update:offset", offset2);
        }
      };
      useEventListener("touchmove", onTouchMove, {
        target: rootRef
      });
      const onTouchEnd = () => {
        dragging.value = false;
        vue.nextTick(() => {
          if (props2.magnetic === "x") {
            const nextX = closest([boundary.value.left, boundary.value.right], state.value.x);
            state.value.x = nextX;
          }
          if (props2.magnetic === "y") {
            const nextY = closest([boundary.value.top, boundary.value.bottom], state.value.y);
            state.value.y = nextY;
          }
          if (!touch.isTap.value) {
            const offset2 = pick(state.value, ["x", "y"]);
            emit("update:offset", offset2);
            if (prevX !== offset2.x || prevY !== offset2.y) {
              emit("offsetChange", offset2);
            }
          }
        });
      };
      const onClick = (e2) => {
        if (touch.isTap.value)
          emit("click", e2);
        else
          e2.stopPropagation();
      };
      vue.onMounted(() => {
        updateState();
        vue.nextTick(() => {
          initialized = true;
        });
      });
      vue.watch([windowWidth, windowHeight, () => props2.gap, () => props2.offset], updateState, {
        deep: true
      });
      const show = vue.ref(true);
      vue.onActivated(() => {
        show.value = true;
      });
      vue.onDeactivated(() => {
        if (props2.teleport) {
          show.value = false;
        }
      });
      return () => {
        const Content = vue.withDirectives(vue.createVNode("div", vue.mergeProps({
          "class": bem$J(),
          "ref": rootRef,
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd,
          "onClickCapture": onClick,
          "style": rootStyle.value
        }, attrs), [slots.default ? slots.default() : vue.createVNode(stdin_default$1N, {
          "name": props2.icon,
          "class": bem$J("icon")
        }, null)]), [[vue.vShow, show.value]]);
        return props2.teleport ? vue.createVNode(vue.Teleport, {
          "to": props2.teleport
        }, {
          default: () => [Content]
        }) : Content;
      };
    }
  });
  const FloatingBubble = withInstall(stdin_default$P);
  const floatingPanelProps = {
    height: makeNumericProp(0),
    anchors: makeArrayProp(),
    duration: makeNumericProp(0.3),
    contentDraggable: truthProp,
    lockScroll: Boolean,
    safeAreaInsetBottom: truthProp
  };
  const [name$I, bem$I] = createNamespace("floating-panel");
  var stdin_default$O = vue.defineComponent({
    name: name$I,
    props: floatingPanelProps,
    emits: ["heightChange", "update:height"],
    setup(props2, {
      emit,
      slots
    }) {
      const DAMP = 0.2;
      const rootRef = vue.ref();
      const contentRef = vue.ref();
      const height2 = useSyncPropRef(() => +props2.height, (value) => emit("update:height", value));
      const boundary = vue.computed(() => {
        var _a, _b;
        return {
          min: (_a = props2.anchors[0]) != null ? _a : 100,
          max: (_b = props2.anchors[props2.anchors.length - 1]) != null ? _b : Math.round(windowHeight.value * 0.6)
        };
      });
      const anchors = vue.computed(() => props2.anchors.length >= 2 ? props2.anchors : [boundary.value.min, boundary.value.max]);
      const dragging = vue.ref(false);
      const rootStyle = vue.computed(() => ({
        height: addUnit$2(boundary.value.max),
        transform: `translateY(calc(100% + ${addUnit$2(-height2.value)}))`,
        transition: !dragging.value ? `transform ${props2.duration}s cubic-bezier(0.18, 0.89, 0.32, 1.28)` : "none"
      }));
      const ease = (moveY) => {
        const absDistance = Math.abs(moveY);
        const {
          min,
          max
        } = boundary.value;
        if (absDistance > max) {
          return -(max + (absDistance - max) * DAMP);
        }
        if (absDistance < min) {
          return -(min - (min - absDistance) * DAMP);
        }
        return moveY;
      };
      let startY;
      let maxScroll = -1;
      const touch = useTouch();
      const onTouchstart = (e2) => {
        touch.start(e2);
        dragging.value = true;
        startY = -height2.value;
        maxScroll = -1;
      };
      const onTouchmove = (e2) => {
        var _a;
        touch.move(e2);
        const target = e2.target;
        if (contentRef.value === target || ((_a = contentRef.value) == null ? void 0 : _a.contains(target))) {
          const {
            scrollTop
          } = contentRef.value;
          maxScroll = Math.max(maxScroll, scrollTop);
          if (!props2.contentDraggable)
            return;
          if (-startY < boundary.value.max) {
            preventDefault(e2, true);
          } else if (!(scrollTop <= 0 && touch.deltaY.value > 0) || maxScroll > 0) {
            return;
          }
        }
        const moveY = touch.deltaY.value + startY;
        height2.value = -ease(moveY);
      };
      const onTouchend = () => {
        maxScroll = -1;
        dragging.value = false;
        height2.value = closest(anchors.value, height2.value);
        if (height2.value !== -startY) {
          emit("heightChange", {
            height: height2.value
          });
        }
      };
      vue.watch(boundary, () => {
        height2.value = closest(anchors.value, height2.value);
      }, {
        immediate: true
      });
      useLockScroll(rootRef, () => props2.lockScroll || dragging.value);
      useEventListener("touchmove", onTouchmove, {
        target: rootRef
      });
      const renderHeader = () => {
        if (slots.header) {
          return slots.header();
        }
        return vue.createVNode("div", {
          "class": bem$I("header")
        }, [vue.createVNode("div", {
          "class": bem$I("header-bar")
        }, null)]);
      };
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": [bem$I(), {
            "van-safe-area-bottom": props2.safeAreaInsetBottom
          }],
          "ref": rootRef,
          "style": rootStyle.value,
          "onTouchstartPassive": onTouchstart,
          "onTouchend": onTouchend,
          "onTouchcancel": onTouchend
        }, [renderHeader(), vue.createVNode("div", {
          "class": bem$I("content"),
          "ref": contentRef
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
      };
    }
  });
  const FloatingPanel = withInstall(stdin_default$O);
  const [name$H, bem$H] = createNamespace("grid");
  const gridProps = {
    square: Boolean,
    center: truthProp,
    border: truthProp,
    gutter: numericProp,
    reverse: Boolean,
    iconSize: numericProp,
    direction: String,
    clickable: Boolean,
    columnNum: makeNumericProp(4)
  };
  const GRID_KEY = Symbol(name$H);
  var stdin_default$N = vue.defineComponent({
    name: name$H,
    props: gridProps,
    setup(props2, {
      slots
    }) {
      const {
        linkChildren
      } = useChildren(GRID_KEY);
      linkChildren({
        props: props2
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "style": {
            paddingLeft: addUnit$2(props2.gutter)
          },
          "class": [bem$H(), {
            [BORDER_TOP]: props2.border && !props2.gutter
          }]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Grid = withInstall(stdin_default$N);
  const [name$G, bem$G] = createNamespace("grid-item");
  const gridItemProps = extend({}, routeProps, {
    dot: Boolean,
    text: String,
    icon: String,
    badge: numericProp,
    iconColor: String,
    iconPrefix: String,
    badgeProps: Object
  });
  var stdin_default$M = vue.defineComponent({
    name: name$G,
    props: gridItemProps,
    setup(props2, {
      slots
    }) {
      const {
        parent,
        index: index2
      } = useParent(GRID_KEY);
      const route2 = useRoute();
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/grid-item/GridItem.mjs:31", "[Vant] <GridItem> must be a child component of <Grid>.");
        }
        return;
      }
      const rootStyle = vue.computed(() => {
        const {
          square,
          gutter,
          columnNum
        } = parent.props;
        const percent = `${100 / +columnNum}%`;
        const style = {
          flexBasis: percent
        };
        if (square) {
          style.paddingTop = percent;
        } else if (gutter) {
          const gutterValue = addUnit$2(gutter);
          style.paddingRight = gutterValue;
          if (index2.value >= +columnNum) {
            style.marginTop = gutterValue;
          }
        }
        return style;
      });
      const contentStyle = vue.computed(() => {
        const {
          square,
          gutter
        } = parent.props;
        if (square && gutter) {
          const gutterValue = addUnit$2(gutter);
          return {
            right: gutterValue,
            bottom: gutterValue,
            height: "auto"
          };
        }
      });
      const renderIcon = () => {
        if (slots.icon) {
          return vue.createVNode(Badge, vue.mergeProps({
            "dot": props2.dot,
            "content": props2.badge
          }, props2.badgeProps), {
            default: slots.icon
          });
        }
        if (props2.icon) {
          return vue.createVNode(Icon, {
            "dot": props2.dot,
            "name": props2.icon,
            "size": parent.props.iconSize,
            "badge": props2.badge,
            "class": bem$G("icon"),
            "color": props2.iconColor,
            "badgeProps": props2.badgeProps,
            "classPrefix": props2.iconPrefix
          }, null);
        }
      };
      const renderText = () => {
        if (slots.text) {
          return slots.text();
        }
        if (props2.text) {
          return vue.createVNode("span", {
            "class": bem$G("text")
          }, [props2.text]);
        }
      };
      const renderContent = () => {
        if (slots.default) {
          return slots.default();
        }
        return [renderIcon(), renderText()];
      };
      return () => {
        const {
          center,
          border,
          square,
          gutter,
          reverse,
          direction,
          clickable
        } = parent.props;
        const classes = [bem$G("content", [direction, {
          center,
          square,
          reverse,
          clickable,
          surround: border && gutter
        }]), {
          [BORDER]: border
        }];
        return vue.createVNode("div", {
          "class": [bem$G({
            square
          })],
          "style": rootStyle.value
        }, [vue.createVNode("div", {
          "role": clickable ? "button" : void 0,
          "class": classes,
          "style": contentStyle.value,
          "tabindex": clickable ? 0 : void 0,
          "onClick": route2
        }, [renderContent()])]);
      };
    }
  });
  const GridItem = withInstall(stdin_default$M);
  const [name$F, bem$F] = createNamespace("highlight");
  const highlightProps = {
    autoEscape: truthProp,
    caseSensitive: Boolean,
    highlightClass: String,
    highlightTag: makeStringProp("span"),
    keywords: makeRequiredProp([String, Array]),
    sourceString: makeStringProp(""),
    tag: makeStringProp("div"),
    unhighlightClass: String,
    unhighlightTag: makeStringProp("span")
  };
  var stdin_default$L = vue.defineComponent({
    name: name$F,
    props: highlightProps,
    setup(props2) {
      const highlightChunks = vue.computed(() => {
        const {
          autoEscape,
          caseSensitive,
          keywords,
          sourceString
        } = props2;
        const flags = caseSensitive ? "g" : "gi";
        const _keywords = Array.isArray(keywords) ? keywords : [keywords];
        let chunks = _keywords.filter((keyword) => keyword).reduce((chunks2, keyword) => {
          if (autoEscape) {
            keyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          const regex = new RegExp(keyword, flags);
          let match;
          while (match = regex.exec(sourceString)) {
            const start2 = match.index;
            const end2 = regex.lastIndex;
            if (start2 >= end2) {
              regex.lastIndex++;
              continue;
            }
            chunks2.push({
              start: start2,
              end: end2,
              highlight: true
            });
          }
          return chunks2;
        }, []);
        chunks = chunks.sort((a2, b2) => a2.start - b2.start).reduce((chunks2, currentChunk) => {
          const prevChunk = chunks2[chunks2.length - 1];
          if (!prevChunk || currentChunk.start > prevChunk.end) {
            const unhighlightStart = prevChunk ? prevChunk.end : 0;
            const unhighlightEnd = currentChunk.start;
            if (unhighlightStart !== unhighlightEnd) {
              chunks2.push({
                start: unhighlightStart,
                end: unhighlightEnd,
                highlight: false
              });
            }
            chunks2.push(currentChunk);
          } else {
            prevChunk.end = Math.max(prevChunk.end, currentChunk.end);
          }
          return chunks2;
        }, []);
        const lastChunk = chunks[chunks.length - 1];
        if (!lastChunk) {
          chunks.push({
            start: 0,
            end: sourceString.length,
            highlight: false
          });
        }
        if (lastChunk && lastChunk.end < sourceString.length) {
          chunks.push({
            start: lastChunk.end,
            end: sourceString.length,
            highlight: false
          });
        }
        return chunks;
      });
      const renderContent = () => {
        const {
          sourceString,
          highlightClass,
          unhighlightClass,
          highlightTag,
          unhighlightTag
        } = props2;
        return highlightChunks.value.map((chunk) => {
          const {
            start: start2,
            end: end2,
            highlight
          } = chunk;
          const text = sourceString.slice(start2, end2);
          if (highlight) {
            return vue.createVNode(highlightTag, {
              "class": [bem$F("tag"), highlightClass]
            }, {
              default: () => [text]
            });
          }
          return vue.createVNode(unhighlightTag, {
            "class": unhighlightClass
          }, {
            default: () => [text]
          });
        });
      };
      return () => {
        const {
          tag
        } = props2;
        return vue.createVNode(tag, {
          "class": bem$F()
        }, {
          default: () => [renderContent()]
        });
      };
    }
  });
  const Highlight = withInstall(stdin_default$L);
  const getDistance = (touches) => Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);
  const getCenter = (touches) => ({
    x: (touches[0].clientX + touches[1].clientX) / 2,
    y: (touches[0].clientY + touches[1].clientY) / 2
  });
  const bem$E = createNamespace("image-preview")[1];
  const longImageRatio = 2.6;
  const imagePreviewItemProps = {
    src: String,
    show: Boolean,
    active: Number,
    minZoom: makeRequiredProp(numericProp),
    maxZoom: makeRequiredProp(numericProp),
    rootWidth: makeRequiredProp(Number),
    rootHeight: makeRequiredProp(Number),
    disableZoom: Boolean,
    doubleScale: Boolean,
    closeOnClickImage: Boolean,
    closeOnClickOverlay: Boolean,
    vertical: Boolean
  };
  var stdin_default$K = vue.defineComponent({
    props: imagePreviewItemProps,
    emits: ["scale", "close", "longPress"],
    setup(props2, {
      emit,
      slots
    }) {
      const state = vue.reactive({
        scale: 1,
        moveX: 0,
        moveY: 0,
        moving: false,
        zooming: false,
        initializing: false,
        imageRatio: 0
      });
      const touch = useTouch();
      const imageRef = vue.ref();
      const swipeItem = vue.ref();
      const vertical = vue.ref(false);
      const isLongImage = vue.ref(false);
      let initialMoveY = 0;
      const imageStyle = vue.computed(() => {
        const {
          scale,
          moveX,
          moveY,
          moving,
          zooming,
          initializing
        } = state;
        const style = {
          transitionDuration: zooming || moving || initializing ? "0s" : ".3s"
        };
        if (scale !== 1 || isLongImage.value) {
          style.transform = `matrix(${scale}, 0, 0, ${scale}, ${moveX}, ${moveY})`;
        }
        return style;
      });
      const maxMoveX = vue.computed(() => {
        if (state.imageRatio) {
          const {
            rootWidth,
            rootHeight
          } = props2;
          const displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;
          return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);
        }
        return 0;
      });
      const maxMoveY = vue.computed(() => {
        if (state.imageRatio) {
          const {
            rootWidth,
            rootHeight
          } = props2;
          const displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;
          return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);
        }
        return 0;
      });
      const setScale = (scale, center) => {
        var _a;
        scale = clamp(scale, +props2.minZoom, +props2.maxZoom + 1);
        if (scale !== state.scale) {
          const ratio = scale / state.scale;
          state.scale = scale;
          if (center) {
            const imageRect = useRect((_a = imageRef.value) == null ? void 0 : _a.$el);
            const origin = {
              x: imageRect.width * 0.5,
              y: imageRect.height * 0.5
            };
            const moveX = state.moveX - (center.x - imageRect.left - origin.x) * (ratio - 1);
            const moveY = state.moveY - (center.y - imageRect.top - origin.y) * (ratio - 1);
            state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);
            state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);
          } else {
            state.moveX = 0;
            state.moveY = isLongImage.value ? initialMoveY : 0;
          }
          emit("scale", {
            scale,
            index: props2.active
          });
        }
      };
      const resetScale = () => {
        setScale(1);
      };
      const toggleScale = () => {
        const scale = state.scale > 1 ? 1 : 2;
        setScale(scale, scale === 2 || isLongImage.value ? {
          x: touch.startX.value,
          y: touch.startY.value
        } : void 0);
      };
      let fingerNum;
      let startMoveX;
      let startMoveY;
      let startScale;
      let startDistance;
      let lastCenter;
      let doubleTapTimer;
      let touchStartTime;
      let isImageMoved = false;
      const onTouchStart = (event) => {
        const {
          touches
        } = event;
        fingerNum = touches.length;
        if (fingerNum === 2 && props2.disableZoom) {
          return;
        }
        const {
          offsetX
        } = touch;
        touch.start(event);
        startMoveX = state.moveX;
        startMoveY = state.moveY;
        touchStartTime = Date.now();
        isImageMoved = false;
        state.moving = fingerNum === 1 && (state.scale !== 1 || isLongImage.value);
        state.zooming = fingerNum === 2 && !offsetX.value;
        if (state.zooming) {
          startScale = state.scale;
          startDistance = getDistance(touches);
        }
      };
      const onTouchMove = (event) => {
        const {
          touches
        } = event;
        touch.move(event);
        if (state.moving) {
          const {
            deltaX,
            deltaY
          } = touch;
          const moveX = deltaX.value + startMoveX;
          const moveY = deltaY.value + startMoveY;
          if ((props2.vertical ? touch.isVertical() && Math.abs(moveY) > maxMoveY.value : touch.isHorizontal() && Math.abs(moveX) > maxMoveX.value) && !isImageMoved) {
            state.moving = false;
            return;
          }
          isImageMoved = true;
          preventDefault(event, true);
          state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);
          state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);
        }
        if (state.zooming) {
          preventDefault(event, true);
          if (touches.length === 2) {
            const distance = getDistance(touches);
            const scale = startScale * distance / startDistance;
            lastCenter = getCenter(touches);
            setScale(scale, lastCenter);
          }
        }
      };
      const checkClose = (event) => {
        var _a;
        const swipeItemEl = (_a = swipeItem.value) == null ? void 0 : _a.$el;
        if (!swipeItemEl)
          return;
        const imageEl = swipeItemEl.firstElementChild;
        const isClickOverlay = event.target === swipeItemEl;
        const isClickImage = imageEl == null ? void 0 : imageEl.contains(event.target);
        if (!props2.closeOnClickImage && isClickImage)
          return;
        if (!props2.closeOnClickOverlay && isClickOverlay)
          return;
        emit("close");
      };
      const checkTap = (event) => {
        if (fingerNum > 1) {
          return;
        }
        const deltaTime = Date.now() - touchStartTime;
        const TAP_TIME = 250;
        if (touch.isTap.value) {
          if (deltaTime < TAP_TIME) {
            if (props2.doubleScale) {
              if (doubleTapTimer) {
                clearTimeout(doubleTapTimer);
                doubleTapTimer = null;
                toggleScale();
              } else {
                doubleTapTimer = setTimeout(() => {
                  checkClose(event);
                  doubleTapTimer = null;
                }, TAP_TIME);
              }
            } else {
              checkClose(event);
            }
          } else if (deltaTime > LONG_PRESS_START_TIME) {
            emit("longPress");
          }
        }
      };
      const onTouchEnd = (event) => {
        let stopPropagation2 = false;
        if (state.moving || state.zooming) {
          stopPropagation2 = true;
          if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {
            stopPropagation2 = false;
          }
          if (!event.touches.length) {
            if (state.zooming) {
              state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);
              state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);
              state.zooming = false;
            }
            state.moving = false;
            startMoveX = 0;
            startMoveY = 0;
            startScale = 1;
            if (state.scale < 1) {
              resetScale();
            }
            const maxZoom = +props2.maxZoom;
            if (state.scale > maxZoom) {
              setScale(maxZoom, lastCenter);
            }
          }
        }
        preventDefault(event, stopPropagation2);
        checkTap(event);
        touch.reset();
      };
      const resize = () => {
        const {
          rootWidth,
          rootHeight
        } = props2;
        const rootRatio = rootHeight / rootWidth;
        const {
          imageRatio
        } = state;
        vertical.value = state.imageRatio > rootRatio && imageRatio < longImageRatio;
        isLongImage.value = state.imageRatio > rootRatio && imageRatio >= longImageRatio;
        if (isLongImage.value) {
          initialMoveY = (imageRatio * rootWidth - rootHeight) / 2;
          state.moveY = initialMoveY;
          state.initializing = true;
          raf(() => {
            state.initializing = false;
          });
        }
        resetScale();
      };
      const onLoad2 = (event) => {
        const {
          naturalWidth,
          naturalHeight
        } = event.target;
        state.imageRatio = naturalHeight / naturalWidth;
        resize();
      };
      vue.watch(() => props2.active, resetScale);
      vue.watch(() => props2.show, (value) => {
        if (!value) {
          resetScale();
        }
      });
      vue.watch(() => [props2.rootWidth, props2.rootHeight], resize);
      useEventListener("touchmove", onTouchMove, {
        target: vue.computed(() => {
          var _a;
          return (_a = swipeItem.value) == null ? void 0 : _a.$el;
        })
      });
      useExpose({
        resetScale
      });
      return () => {
        const imageSlots = {
          loading: () => vue.createVNode(Loading, {
            "type": "spinner"
          }, null)
        };
        return vue.createVNode(SwipeItem, {
          "ref": swipeItem,
          "class": bem$E("swipe-item"),
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd
        }, {
          default: () => [slots.image ? vue.createVNode("div", {
            "class": bem$E("image-wrap")
          }, [slots.image({
            src: props2.src,
            onLoad: onLoad2,
            style: imageStyle.value
          })]) : vue.createVNode(Image$1, {
            "ref": imageRef,
            "src": props2.src,
            "fit": "contain",
            "class": bem$E("image", {
              vertical: vertical.value
            }),
            "style": imageStyle.value,
            "onLoad": onLoad2
          }, imageSlots)]
        });
      };
    }
  });
  const [name$E, bem$D] = createNamespace("image-preview");
  const popupProps$1 = ["show", "teleport", "transition", "overlayStyle", "closeOnPopstate"];
  const imagePreviewProps = {
    show: Boolean,
    loop: truthProp,
    images: makeArrayProp(),
    minZoom: makeNumericProp(1 / 3),
    maxZoom: makeNumericProp(3),
    overlay: truthProp,
    vertical: Boolean,
    closeable: Boolean,
    showIndex: truthProp,
    className: unknownProp,
    closeIcon: makeStringProp("clear"),
    transition: String,
    beforeClose: Function,
    doubleScale: truthProp,
    overlayClass: unknownProp,
    overlayStyle: Object,
    swipeDuration: makeNumericProp(300),
    startPosition: makeNumericProp(0),
    showIndicators: Boolean,
    closeOnPopstate: truthProp,
    closeOnClickImage: truthProp,
    closeOnClickOverlay: truthProp,
    closeIconPosition: makeStringProp("top-right"),
    teleport: [String, Object]
  };
  var stdin_default$J = vue.defineComponent({
    name: name$E,
    props: imagePreviewProps,
    emits: ["scale", "close", "closed", "change", "longPress", "update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      const swipeRef = vue.ref();
      const activedPreviewItemRef = vue.ref();
      const state = vue.reactive({
        active: 0,
        rootWidth: 0,
        rootHeight: 0,
        disableZoom: false
      });
      const resize = () => {
        if (swipeRef.value) {
          const rect = useRect(swipeRef.value.$el);
          state.rootWidth = rect.width;
          state.rootHeight = rect.height;
          swipeRef.value.resize();
        }
      };
      const emitScale = (args) => emit("scale", args);
      const updateShow = (show) => emit("update:show", show);
      const emitClose = () => {
        callInterceptor(props2.beforeClose, {
          args: [state.active],
          done: () => updateShow(false)
        });
      };
      const setActive = (active) => {
        if (active !== state.active) {
          state.active = active;
          emit("change", active);
        }
      };
      const renderIndex = () => {
        if (props2.showIndex) {
          return vue.createVNode("div", {
            "class": bem$D("index")
          }, [slots.index ? slots.index({
            index: state.active
          }) : `${state.active + 1} / ${props2.images.length}`]);
        }
      };
      const renderCover = () => {
        if (slots.cover) {
          return vue.createVNode("div", {
            "class": bem$D("cover")
          }, [slots.cover()]);
        }
      };
      const onDragStart = () => {
        state.disableZoom = true;
      };
      const onDragEnd = () => {
        state.disableZoom = false;
      };
      const renderImages = () => vue.createVNode(Swipe, {
        "ref": swipeRef,
        "lazyRender": true,
        "loop": props2.loop,
        "class": bem$D("swipe"),
        "vertical": props2.vertical,
        "duration": props2.swipeDuration,
        "initialSwipe": props2.startPosition,
        "showIndicators": props2.showIndicators,
        "indicatorColor": "white",
        "onChange": setActive,
        "onDragEnd": onDragEnd,
        "onDragStart": onDragStart
      }, {
        default: () => [props2.images.map((image2, index2) => vue.createVNode(stdin_default$K, {
          "ref": (item) => {
            if (index2 === state.active) {
              activedPreviewItemRef.value = item;
            }
          },
          "src": image2,
          "show": props2.show,
          "active": state.active,
          "maxZoom": props2.maxZoom,
          "minZoom": props2.minZoom,
          "rootWidth": state.rootWidth,
          "rootHeight": state.rootHeight,
          "disableZoom": state.disableZoom,
          "doubleScale": props2.doubleScale,
          "closeOnClickImage": props2.closeOnClickImage,
          "closeOnClickOverlay": props2.closeOnClickOverlay,
          "vertical": props2.vertical,
          "onScale": emitScale,
          "onClose": emitClose,
          "onLongPress": () => emit("longPress", {
            index: index2
          })
        }, {
          image: slots.image
        }))]
      });
      const renderClose = () => {
        if (props2.closeable) {
          return vue.createVNode(Icon, {
            "role": "button",
            "name": props2.closeIcon,
            "class": [bem$D("close-icon", props2.closeIconPosition), HAPTICS_FEEDBACK],
            "onClick": emitClose
          }, null);
        }
      };
      const onClosed = () => emit("closed");
      const swipeTo = (index2, options) => {
        var _a;
        return (_a = swipeRef.value) == null ? void 0 : _a.swipeTo(index2, options);
      };
      useExpose({
        resetScale: () => {
          var _a;
          (_a = activedPreviewItemRef.value) == null ? void 0 : _a.resetScale();
        },
        swipeTo
      });
      vue.onMounted(resize);
      vue.watch([windowWidth, windowHeight], resize);
      vue.watch(() => props2.startPosition, (value) => setActive(+value));
      vue.watch(() => props2.show, (value) => {
        const {
          images,
          startPosition
        } = props2;
        if (value) {
          setActive(+startPosition);
          vue.nextTick(() => {
            resize();
            swipeTo(+startPosition, {
              immediate: true
            });
          });
        } else {
          emit("close", {
            index: state.active,
            url: images[state.active]
          });
        }
      });
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": [bem$D(), props2.className],
        "overlayClass": [bem$D("overlay"), props2.overlayClass],
        "onClosed": onClosed,
        "onUpdate:show": updateShow
      }, pick(props2, popupProps$1)), {
        default: () => [renderClose(), renderImages(), renderIndex(), renderCover()]
      });
    }
  });
  let instance$1;
  const defaultConfig = {
    loop: true,
    images: [],
    maxZoom: 3,
    minZoom: 1 / 3,
    onScale: void 0,
    onClose: void 0,
    onChange: void 0,
    vertical: false,
    teleport: "body",
    className: "",
    showIndex: true,
    closeable: false,
    closeIcon: "clear",
    transition: void 0,
    beforeClose: void 0,
    doubleScale: true,
    overlayStyle: void 0,
    overlayClass: void 0,
    startPosition: 0,
    swipeDuration: 300,
    showIndicators: false,
    closeOnPopstate: true,
    closeOnClickOverlay: true,
    closeIconPosition: "top-right"
  };
  function initInstance() {
    ({
      instance: instance$1
    } = mountComponent({
      setup() {
        const {
          state,
          toggle
        } = usePopupState();
        const onClosed = () => {
          state.images = [];
        };
        return () => vue.createVNode(stdin_default$J, vue.mergeProps(state, {
          "onClosed": onClosed,
          "onUpdate:show": toggle
        }), null);
      }
    }));
  }
  const showImagePreview = (options, startPosition = 0) => {
    if (!inBrowser$1) {
      return;
    }
    if (!instance$1) {
      initInstance();
    }
    options = Array.isArray(options) ? {
      images: options,
      startPosition
    } : options;
    instance$1.open(extend({}, defaultConfig, options));
    return instance$1;
  };
  const ImagePreview = withInstall(stdin_default$J);
  function genAlphabet() {
    const charCodeOfA = "A".charCodeAt(0);
    const indexList = Array(26).fill("").map((_, i2) => String.fromCharCode(charCodeOfA + i2));
    return indexList;
  }
  const [name$D, bem$C] = createNamespace("index-bar");
  const indexBarProps = {
    sticky: truthProp,
    zIndex: numericProp,
    teleport: [String, Object],
    highlightColor: String,
    stickyOffsetTop: makeNumberProp(0),
    indexList: {
      type: Array,
      default: genAlphabet
    }
  };
  const INDEX_BAR_KEY = Symbol(name$D);
  var stdin_default$I = vue.defineComponent({
    name: name$D,
    props: indexBarProps,
    emits: ["select", "change"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const sidebar = vue.ref();
      const activeAnchor = vue.ref("");
      const touch = useTouch();
      const scrollParent = useScrollParent(root);
      const {
        children,
        linkChildren
      } = useChildren(INDEX_BAR_KEY);
      let selectActiveIndex;
      linkChildren({
        props: props2
      });
      const sidebarStyle = vue.computed(() => {
        if (isDef(props2.zIndex)) {
          return {
            zIndex: +props2.zIndex + 1
          };
        }
      });
      const highlightStyle = vue.computed(() => {
        if (props2.highlightColor) {
          return {
            color: props2.highlightColor
          };
        }
      });
      const getActiveAnchor = (scrollTop, rects) => {
        for (let i2 = children.length - 1; i2 >= 0; i2--) {
          const prevHeight = i2 > 0 ? rects[i2 - 1].height : 0;
          const reachTop = props2.sticky ? prevHeight + props2.stickyOffsetTop : 0;
          if (scrollTop + reachTop >= rects[i2].top) {
            return i2;
          }
        }
        return -1;
      };
      const getMatchAnchor = (index2) => children.find((item) => String(item.index) === index2);
      const onScroll = () => {
        if (isHidden(root)) {
          return;
        }
        const {
          sticky,
          indexList
        } = props2;
        const scrollTop = getScrollTop(scrollParent.value);
        const scrollParentRect = useRect(scrollParent);
        const rects = children.map((item) => item.getRect(scrollParent.value, scrollParentRect));
        let active = -1;
        if (selectActiveIndex) {
          const match = getMatchAnchor(selectActiveIndex);
          if (match) {
            const rect = match.getRect(scrollParent.value, scrollParentRect);
            if (props2.sticky && props2.stickyOffsetTop) {
              active = getActiveAnchor(rect.top - props2.stickyOffsetTop, rects);
            } else {
              active = getActiveAnchor(rect.top, rects);
            }
          }
        } else {
          active = getActiveAnchor(scrollTop, rects);
        }
        activeAnchor.value = indexList[active];
        if (sticky) {
          children.forEach((item, index2) => {
            const {
              state,
              $el
            } = item;
            if (index2 === active || index2 === active - 1) {
              const rect = $el.getBoundingClientRect();
              state.left = rect.left;
              state.width = rect.width;
            } else {
              state.left = null;
              state.width = null;
            }
            if (index2 === active) {
              state.active = true;
              state.top = Math.max(props2.stickyOffsetTop, rects[index2].top - scrollTop) + scrollParentRect.top;
            } else if (index2 === active - 1 && selectActiveIndex === "") {
              const activeItemTop = rects[active].top - scrollTop;
              state.active = activeItemTop > 0;
              state.top = activeItemTop + scrollParentRect.top - rects[index2].height;
            } else {
              state.active = false;
            }
          });
        }
        selectActiveIndex = "";
      };
      const init = () => {
        vue.nextTick(onScroll);
      };
      useEventListener("scroll", onScroll, {
        target: scrollParent,
        passive: true
      });
      vue.onMounted(init);
      vue.watch(() => props2.indexList, init);
      vue.watch(activeAnchor, (value) => {
        if (value) {
          emit("change", value);
        }
      });
      const renderIndexes = () => props2.indexList.map((index2) => {
        const active = index2 === activeAnchor.value;
        return vue.createVNode("span", {
          "class": bem$C("index", {
            active
          }),
          "style": active ? highlightStyle.value : void 0,
          "data-index": index2
        }, [index2]);
      });
      const scrollTo = (index2) => {
        selectActiveIndex = String(index2);
        const match = getMatchAnchor(selectActiveIndex);
        if (match) {
          const scrollTop = getScrollTop(scrollParent.value);
          const scrollParentRect = useRect(scrollParent);
          const {
            offsetHeight
          } = document.documentElement;
          match.$el.scrollIntoView();
          if (scrollTop === offsetHeight - scrollParentRect.height) {
            onScroll();
            return;
          }
          if (props2.sticky && props2.stickyOffsetTop) {
            if (getRootScrollTop() === offsetHeight - scrollParentRect.height) {
              setRootScrollTop(getRootScrollTop());
            } else {
              setRootScrollTop(getRootScrollTop() - props2.stickyOffsetTop);
            }
          }
          emit("select", match.index);
        }
      };
      const scrollToElement = (element) => {
        const {
          index: index2
        } = element.dataset;
        if (index2) {
          scrollTo(index2);
        }
      };
      const onClickSidebar = (event) => {
        scrollToElement(event.target);
      };
      let touchActiveIndex;
      const onTouchMove = (event) => {
        touch.move(event);
        if (touch.isVertical()) {
          preventDefault(event);
          const {
            clientX,
            clientY
          } = event.touches[0];
          const target = document.elementFromPoint(clientX, clientY);
          if (target) {
            const {
              index: index2
            } = target.dataset;
            if (index2 && touchActiveIndex !== index2) {
              touchActiveIndex = index2;
              scrollToElement(target);
            }
          }
        }
      };
      const renderSidebar = () => vue.createVNode("div", {
        "ref": sidebar,
        "class": bem$C("sidebar"),
        "style": sidebarStyle.value,
        "onClick": onClickSidebar,
        "onTouchstartPassive": touch.start
      }, [renderIndexes()]);
      useExpose({
        scrollTo
      });
      useEventListener("touchmove", onTouchMove, {
        target: sidebar
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$C()
        }, [props2.teleport ? vue.createVNode(vue.Teleport, {
          "to": props2.teleport
        }, {
          default: () => [renderSidebar()]
        }) : renderSidebar(), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const [name$C, bem$B] = createNamespace("index-anchor");
  const indexAnchorProps = {
    index: numericProp
  };
  var stdin_default$H = vue.defineComponent({
    name: name$C,
    props: indexAnchorProps,
    setup(props2, {
      slots
    }) {
      const state = vue.reactive({
        top: 0,
        left: null,
        rect: {
          top: 0,
          height: 0
        },
        width: null,
        active: false
      });
      const root = vue.ref();
      const {
        parent
      } = useParent(INDEX_BAR_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/index-anchor/IndexAnchor.mjs:33", "[Vant] <IndexAnchor> must be a child component of <IndexBar>.");
        }
        return;
      }
      const isSticky = () => state.active && parent.props.sticky;
      const anchorStyle = vue.computed(() => {
        const {
          zIndex,
          highlightColor
        } = parent.props;
        if (isSticky()) {
          return extend(getZIndexStyle(zIndex), {
            left: state.left ? `${state.left}px` : void 0,
            width: state.width ? `${state.width}px` : void 0,
            transform: state.top ? `translate3d(0, ${state.top}px, 0)` : void 0,
            color: highlightColor
          });
        }
      });
      const getRect = (scrollParent, scrollParentRect) => {
        const rootRect = useRect(root);
        state.rect.height = rootRect.height;
        if (scrollParent === window || scrollParent === document.body) {
          state.rect.top = rootRect.top + getRootScrollTop();
        } else {
          state.rect.top = rootRect.top + getScrollTop(scrollParent) - scrollParentRect.top;
        }
        return state.rect;
      };
      useExpose({
        state,
        getRect
      });
      return () => {
        const sticky = isSticky();
        return vue.createVNode("div", {
          "ref": root,
          "style": {
            height: sticky ? `${state.rect.height}px` : void 0
          }
        }, [vue.createVNode("div", {
          "style": anchorStyle.value,
          "class": [bem$B({
            sticky
          }), {
            [BORDER_BOTTOM]: sticky
          }]
        }, [slots.default ? slots.default() : props2.index])]);
      };
    }
  });
  const IndexAnchor = withInstall(stdin_default$H);
  const IndexBar = withInstall(stdin_default$I);
  const [name$B, bem$A, t$9] = createNamespace("list");
  const listProps = {
    error: Boolean,
    offset: makeNumericProp(300),
    loading: Boolean,
    disabled: Boolean,
    finished: Boolean,
    scroller: Object,
    errorText: String,
    direction: makeStringProp("down"),
    loadingText: String,
    finishedText: String,
    immediateCheck: truthProp
  };
  var stdin_default$G = vue.defineComponent({
    name: name$B,
    props: listProps,
    emits: ["load", "update:error", "update:loading"],
    setup(props2, {
      emit,
      slots
    }) {
      const loading = vue.ref(props2.loading);
      const root = vue.ref();
      const placeholder = vue.ref();
      const tabStatus = useTabStatus();
      const scrollParent = useScrollParent(root);
      const scroller = vue.computed(() => props2.scroller || scrollParent.value);
      const check = () => {
        vue.nextTick(() => {
          if (loading.value || props2.finished || props2.disabled || props2.error || // skip check when inside an inactive tab
          (tabStatus == null ? void 0 : tabStatus.value) === false) {
            return;
          }
          const {
            direction
          } = props2;
          const offset2 = +props2.offset;
          const scrollParentRect = useRect(scroller);
          if (!scrollParentRect.height || isHidden(root)) {
            return;
          }
          let isReachEdge = false;
          const placeholderRect = useRect(placeholder);
          if (direction === "up") {
            isReachEdge = scrollParentRect.top - placeholderRect.top <= offset2;
          } else {
            isReachEdge = placeholderRect.bottom - scrollParentRect.bottom <= offset2;
          }
          if (isReachEdge) {
            loading.value = true;
            emit("update:loading", true);
            emit("load");
          }
        });
      };
      const renderFinishedText = () => {
        if (props2.finished) {
          const text = slots.finished ? slots.finished() : props2.finishedText;
          if (text) {
            return vue.createVNode("div", {
              "class": bem$A("finished-text")
            }, [text]);
          }
        }
      };
      const clickErrorText = () => {
        emit("update:error", false);
        check();
      };
      const renderErrorText = () => {
        if (props2.error) {
          const text = slots.error ? slots.error() : props2.errorText;
          if (text) {
            return vue.createVNode("div", {
              "role": "button",
              "class": bem$A("error-text"),
              "tabindex": 0,
              "onClick": clickErrorText
            }, [text]);
          }
        }
      };
      const renderLoading = () => {
        if (loading.value && !props2.finished && !props2.disabled) {
          return vue.createVNode("div", {
            "class": bem$A("loading")
          }, [slots.loading ? slots.loading() : vue.createVNode(Loading, {
            "class": bem$A("loading-icon")
          }, {
            default: () => [props2.loadingText || t$9("loading")]
          })]);
        }
      };
      vue.watch(() => [props2.loading, props2.finished, props2.error], check);
      if (tabStatus) {
        vue.watch(tabStatus, (tabActive) => {
          if (tabActive) {
            check();
          }
        });
      }
      vue.onUpdated(() => {
        loading.value = props2.loading;
      });
      vue.onMounted(() => {
        if (props2.immediateCheck) {
          check();
        }
      });
      useExpose({
        check
      });
      useEventListener("scroll", check, {
        target: scroller,
        passive: true
      });
      return () => {
        var _a;
        const Content = (_a = slots.default) == null ? void 0 : _a.call(slots);
        const Placeholder = vue.createVNode("div", {
          "ref": placeholder,
          "class": bem$A("placeholder")
        }, null);
        return vue.createVNode("div", {
          "ref": root,
          "role": "feed",
          "class": bem$A(),
          "aria-busy": loading.value
        }, [props2.direction === "down" ? Content : Placeholder, renderLoading(), renderFinishedText(), renderErrorText(), props2.direction === "up" ? Content : Placeholder]);
      };
    }
  });
  const List = withInstall(stdin_default$G);
  const [name$A, bem$z] = createNamespace("nav-bar");
  const navBarProps = {
    title: String,
    fixed: Boolean,
    zIndex: numericProp,
    border: truthProp,
    leftText: String,
    rightText: String,
    leftDisabled: Boolean,
    rightDisabled: Boolean,
    leftArrow: Boolean,
    placeholder: Boolean,
    safeAreaInsetTop: Boolean,
    clickable: truthProp
  };
  var stdin_default$F = vue.defineComponent({
    name: name$A,
    props: navBarProps,
    emits: ["clickLeft", "clickRight"],
    setup(props2, {
      emit,
      slots
    }) {
      const navBarRef = vue.ref();
      const renderPlaceholder = usePlaceholder(navBarRef, bem$z);
      const onClickLeft = (event) => {
        if (!props2.leftDisabled) {
          emit("clickLeft", event);
        }
      };
      const onClickRight = (event) => {
        if (!props2.rightDisabled) {
          emit("clickRight", event);
        }
      };
      const renderLeft = () => {
        if (slots.left) {
          return slots.left();
        }
        return [props2.leftArrow && vue.createVNode(Icon, {
          "class": bem$z("arrow"),
          "name": "arrow-left"
        }, null), props2.leftText && vue.createVNode("span", {
          "class": bem$z("text")
        }, [props2.leftText])];
      };
      const renderRight = () => {
        if (slots.right) {
          return slots.right();
        }
        return vue.createVNode("span", {
          "class": bem$z("text")
        }, [props2.rightText]);
      };
      const renderNavBar = () => {
        const {
          title,
          fixed,
          border,
          zIndex
        } = props2;
        const style = getZIndexStyle(zIndex);
        const hasLeft = props2.leftArrow || props2.leftText || slots.left;
        const hasRight = props2.rightText || slots.right;
        return vue.createVNode("div", {
          "ref": navBarRef,
          "style": style,
          "class": [bem$z({
            fixed
          }), {
            [BORDER_BOTTOM]: border,
            "van-safe-area-top": props2.safeAreaInsetTop
          }]
        }, [vue.createVNode("div", {
          "class": bem$z("content")
        }, [hasLeft && vue.createVNode("div", {
          "class": [bem$z("left", {
            disabled: props2.leftDisabled
          }), props2.clickable && !props2.leftDisabled ? HAPTICS_FEEDBACK : ""],
          "onClick": onClickLeft
        }, [renderLeft()]), vue.createVNode("div", {
          "class": [bem$z("title"), "van-ellipsis"]
        }, [slots.title ? slots.title() : title]), hasRight && vue.createVNode("div", {
          "class": [bem$z("right", {
            disabled: props2.rightDisabled
          }), props2.clickable && !props2.rightDisabled ? HAPTICS_FEEDBACK : ""],
          "onClick": onClickRight
        }, [renderRight()])])]);
      };
      return () => {
        if (props2.fixed && props2.placeholder) {
          return renderPlaceholder(renderNavBar);
        }
        return renderNavBar();
      };
    }
  });
  const NavBar = withInstall(stdin_default$F);
  const [name$z, bem$y] = createNamespace("notice-bar");
  const noticeBarProps = {
    text: String,
    mode: String,
    color: String,
    delay: makeNumericProp(1),
    speed: makeNumericProp(60),
    leftIcon: String,
    wrapable: Boolean,
    background: String,
    scrollable: {
      type: Boolean,
      default: null
    }
  };
  var stdin_default$E = vue.defineComponent({
    name: name$z,
    props: noticeBarProps,
    emits: ["close", "replay"],
    setup(props2, {
      emit,
      slots
    }) {
      let wrapWidth = 0;
      let contentWidth = 0;
      let startTimer;
      const wrapRef = vue.ref();
      const contentRef = vue.ref();
      const state = vue.reactive({
        show: true,
        offset: 0,
        duration: 0
      });
      const renderLeftIcon = () => {
        if (slots["left-icon"]) {
          return slots["left-icon"]();
        }
        if (props2.leftIcon) {
          return vue.createVNode(Icon, {
            "class": bem$y("left-icon"),
            "name": props2.leftIcon
          }, null);
        }
      };
      const getRightIconName = () => {
        if (props2.mode === "closeable") {
          return "cross";
        }
        if (props2.mode === "link") {
          return "arrow";
        }
      };
      const onClickRightIcon = (event) => {
        if (props2.mode === "closeable") {
          state.show = false;
          emit("close", event);
        }
      };
      const renderRightIcon = () => {
        if (slots["right-icon"]) {
          return slots["right-icon"]();
        }
        const name2 = getRightIconName();
        if (name2) {
          return vue.createVNode(Icon, {
            "name": name2,
            "class": bem$y("right-icon"),
            "onClick": onClickRightIcon
          }, null);
        }
      };
      const onTransitionEnd = () => {
        state.offset = wrapWidth;
        state.duration = 0;
        raf(() => {
          doubleRaf(() => {
            state.offset = -contentWidth;
            state.duration = (contentWidth + wrapWidth) / +props2.speed;
            emit("replay");
          });
        });
      };
      const renderMarquee = () => {
        const ellipsis = props2.scrollable === false && !props2.wrapable;
        const style = {
          transform: state.offset ? `translateX(${state.offset}px)` : "",
          transitionDuration: `${state.duration}s`
        };
        return vue.createVNode("div", {
          "ref": wrapRef,
          "role": "marquee",
          "class": bem$y("wrap")
        }, [vue.createVNode("div", {
          "ref": contentRef,
          "style": style,
          "class": [bem$y("content"), {
            "van-ellipsis": ellipsis
          }],
          "onTransitionend": onTransitionEnd
        }, [slots.default ? slots.default() : props2.text])]);
      };
      const reset = () => {
        const {
          delay: delay2,
          speed,
          scrollable
        } = props2;
        const ms = isDef(delay2) ? +delay2 * 1e3 : 0;
        wrapWidth = 0;
        contentWidth = 0;
        state.offset = 0;
        state.duration = 0;
        clearTimeout(startTimer);
        startTimer = setTimeout(() => {
          if (!wrapRef.value || !contentRef.value || scrollable === false) {
            return;
          }
          const wrapRefWidth = useRect(wrapRef).width;
          const contentRefWidth = useRect(contentRef).width;
          if (scrollable || contentRefWidth > wrapRefWidth) {
            doubleRaf(() => {
              wrapWidth = wrapRefWidth;
              contentWidth = contentRefWidth;
              state.offset = -contentWidth;
              state.duration = contentWidth / +speed;
            });
          }
        }, ms);
      };
      onPopupReopen(reset);
      onMountedOrActivated(reset);
      useEventListener("pageshow", reset);
      useExpose({
        reset
      });
      vue.watch(() => [props2.text, props2.scrollable], reset);
      return () => {
        const {
          color,
          wrapable,
          background
        } = props2;
        return vue.withDirectives(vue.createVNode("div", {
          "role": "alert",
          "class": bem$y({
            wrapable
          }),
          "style": {
            color,
            background
          }
        }, [renderLeftIcon(), renderMarquee(), renderRightIcon()]), [[vue.vShow, state.show]]);
      };
    }
  });
  const NoticeBar = withInstall(stdin_default$E);
  const [name$y, bem$x] = createNamespace("notify");
  const popupInheritProps = ["lockScroll", "position", "show", "teleport", "zIndex"];
  const notifyProps = extend({}, popupSharedProps, {
    type: makeStringProp("danger"),
    color: String,
    message: numericProp,
    position: makeStringProp("top"),
    className: unknownProp,
    background: String,
    lockScroll: Boolean
  });
  var stdin_default$D = vue.defineComponent({
    name: name$y,
    props: notifyProps,
    emits: ["update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      const updateShow = (show) => emit("update:show", show);
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": [bem$x([props2.type]), props2.className],
        "style": {
          color: props2.color,
          background: props2.background
        },
        "overlay": false,
        "duration": 0.2,
        "onUpdate:show": updateShow
      }, pick(props2, popupInheritProps)), {
        default: () => [slots.default ? slots.default() : props2.message]
      });
    }
  });
  const Notify = withInstall(stdin_default$D);
  const [name$x, bem$w] = createNamespace("key");
  const CollapseIcon = vue.createVNode("svg", {
    "class": bem$w("collapse-icon"),
    "viewBox": "0 0 30 24"
  }, [vue.createVNode("path", {
    "d": "M26 13h-2v2h2v-2zm-8-3h2V8h-2v2zm2-4h2V4h-2v2zm2 4h4V4h-2v4h-2v2zm-7 14 3-3h-6l3 3zM6 13H4v2h2v-2zm16 0H8v2h14v-2zm-12-3h2V8h-2v2zM28 0l1 1 1 1v15l-1 2H1l-1-2V2l1-1 1-1zm0 2H2v15h26V2zM6 4v2H4V4zm10 2h2V4h-2v2zM8 9v1H4V8zm8 0v1h-2V8zm-6-5v2H8V4zm4 0v2h-2V4z",
    "fill": "currentColor"
  }, null)]);
  const DeleteIcon = vue.createVNode("svg", {
    "class": bem$w("delete-icon"),
    "viewBox": "0 0 32 22"
  }, [vue.createVNode("path", {
    "d": "M28 0a4 4 0 0 1 4 4v14a4 4 0 0 1-4 4H10.4a2 2 0 0 1-1.4-.6L1 13.1c-.6-.5-.9-1.3-.9-2 0-1 .3-1.7.9-2.2L9 .6a2 2 0 0 1 1.4-.6zm0 2H10.4l-8.2 8.3a1 1 0 0 0-.3.7c0 .3.1.5.3.7l8.2 8.4H28a2 2 0 0 0 2-2V4c0-1.1-.9-2-2-2zm-5 4a1 1 0 0 1 .7.3 1 1 0 0 1 0 1.4L20.4 11l3.3 3.3c.2.2.3.5.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3L19 12.4l-3.4 3.3a1 1 0 0 1-.6.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.2.1-.5.3-.7l3.3-3.3-3.3-3.3A1 1 0 0 1 14 7c0-.3.1-.5.3-.7A1 1 0 0 1 15 6a1 1 0 0 1 .6.3L19 9.6l3.3-3.3A1 1 0 0 1 23 6z",
    "fill": "currentColor"
  }, null)]);
  var stdin_default$C = vue.defineComponent({
    name: name$x,
    props: {
      type: String,
      text: numericProp,
      color: String,
      wider: Boolean,
      large: Boolean,
      loading: Boolean
    },
    emits: ["press"],
    setup(props2, {
      emit,
      slots
    }) {
      const active = vue.ref(false);
      const touch = useTouch();
      const onTouchStart = (event) => {
        touch.start(event);
        active.value = true;
      };
      const onTouchMove = (event) => {
        touch.move(event);
        if (touch.direction.value) {
          active.value = false;
        }
      };
      const onTouchEnd = (event) => {
        if (active.value) {
          if (!slots.default) {
            preventDefault(event);
          }
          active.value = false;
          emit("press", props2.text, props2.type);
        }
      };
      const renderContent = () => {
        if (props2.loading) {
          return vue.createVNode(Loading, {
            "class": bem$w("loading-icon")
          }, null);
        }
        const text = slots.default ? slots.default() : props2.text;
        switch (props2.type) {
          case "delete":
            return text || DeleteIcon;
          case "extra":
            return text || CollapseIcon;
          default:
            return text;
        }
      };
      return () => vue.createVNode("div", {
        "class": bem$w("wrapper", {
          wider: props2.wider
        }),
        "onTouchstartPassive": onTouchStart,
        "onTouchmovePassive": onTouchMove,
        "onTouchend": onTouchEnd,
        "onTouchcancel": onTouchEnd
      }, [vue.createVNode("div", {
        "role": "button",
        "tabindex": 0,
        "class": bem$w([props2.color, {
          large: props2.large,
          active: active.value,
          delete: props2.type === "delete"
        }])
      }, [renderContent()])]);
    }
  });
  const [name$w, bem$v] = createNamespace("number-keyboard");
  const numberKeyboardProps = {
    show: Boolean,
    title: String,
    theme: makeStringProp("default"),
    zIndex: numericProp,
    teleport: [String, Object],
    maxlength: makeNumericProp(Infinity),
    modelValue: makeStringProp(""),
    transition: truthProp,
    blurOnClose: truthProp,
    showDeleteKey: truthProp,
    randomKeyOrder: Boolean,
    closeButtonText: String,
    deleteButtonText: String,
    closeButtonLoading: Boolean,
    hideOnClickOutside: truthProp,
    safeAreaInsetBottom: truthProp,
    extraKey: {
      type: [String, Array],
      default: ""
    }
  };
  function shuffle(array2) {
    for (let i2 = array2.length - 1; i2 > 0; i2--) {
      const j = Math.floor(Math.random() * (i2 + 1));
      const temp = array2[i2];
      array2[i2] = array2[j];
      array2[j] = temp;
    }
    return array2;
  }
  var stdin_default$B = vue.defineComponent({
    name: name$w,
    inheritAttrs: false,
    props: numberKeyboardProps,
    emits: ["show", "hide", "blur", "input", "close", "delete", "update:modelValue"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      const root = vue.ref();
      const genBasicKeys = () => {
        const keys2 = Array(9).fill("").map((_, i2) => ({
          text: i2 + 1
        }));
        if (props2.randomKeyOrder) {
          shuffle(keys2);
        }
        return keys2;
      };
      const genDefaultKeys = () => [...genBasicKeys(), {
        text: props2.extraKey,
        type: "extra"
      }, {
        text: 0
      }, {
        text: props2.showDeleteKey ? props2.deleteButtonText : "",
        type: props2.showDeleteKey ? "delete" : ""
      }];
      const genCustomKeys = () => {
        const keys2 = genBasicKeys();
        const {
          extraKey
        } = props2;
        const extraKeys = Array.isArray(extraKey) ? extraKey : [extraKey];
        if (extraKeys.length === 0) {
          keys2.push({
            text: 0,
            wider: true
          });
        } else if (extraKeys.length === 1) {
          keys2.push({
            text: 0,
            wider: true
          }, {
            text: extraKeys[0],
            type: "extra"
          });
        } else if (extraKeys.length === 2) {
          keys2.push({
            text: extraKeys[0],
            type: "extra"
          }, {
            text: 0
          }, {
            text: extraKeys[1],
            type: "extra"
          });
        }
        return keys2;
      };
      const keys = vue.computed(() => props2.theme === "custom" ? genCustomKeys() : genDefaultKeys());
      const onBlur = () => {
        if (props2.show) {
          emit("blur");
        }
      };
      const onClose = () => {
        emit("close");
        if (props2.blurOnClose) {
          onBlur();
        }
      };
      const onAnimationEnd = () => emit(props2.show ? "show" : "hide");
      const onPress = (text, type) => {
        if (text === "") {
          if (type === "extra") {
            onBlur();
          }
          return;
        }
        const value = props2.modelValue;
        if (type === "delete") {
          emit("delete");
          emit("update:modelValue", value.slice(0, value.length - 1));
        } else if (type === "close") {
          onClose();
        } else if (value.length < +props2.maxlength) {
          emit("input", text);
          emit("update:modelValue", value + text);
        }
      };
      const renderTitle = () => {
        const {
          title,
          theme,
          closeButtonText
        } = props2;
        const leftSlot = slots["title-left"];
        const showClose = closeButtonText && theme === "default";
        const showTitle = title || showClose || leftSlot;
        if (!showTitle) {
          return;
        }
        return vue.createVNode("div", {
          "class": bem$v("header")
        }, [leftSlot && vue.createVNode("span", {
          "class": bem$v("title-left")
        }, [leftSlot()]), title && vue.createVNode("h2", {
          "class": bem$v("title")
        }, [title]), showClose && vue.createVNode("button", {
          "type": "button",
          "class": [bem$v("close"), HAPTICS_FEEDBACK],
          "onClick": onClose
        }, [closeButtonText])]);
      };
      const renderKeys = () => keys.value.map((key) => {
        const keySlots = {};
        if (key.type === "delete") {
          keySlots.default = slots.delete;
        }
        if (key.type === "extra") {
          keySlots.default = slots["extra-key"];
        }
        return vue.createVNode(stdin_default$C, {
          "key": key.text,
          "text": key.text,
          "type": key.type,
          "wider": key.wider,
          "color": key.color,
          "onPress": onPress
        }, keySlots);
      });
      const renderSidebar = () => {
        if (props2.theme === "custom") {
          return vue.createVNode("div", {
            "class": bem$v("sidebar")
          }, [props2.showDeleteKey && vue.createVNode(stdin_default$C, {
            "large": true,
            "text": props2.deleteButtonText,
            "type": "delete",
            "onPress": onPress
          }, {
            default: slots.delete
          }), vue.createVNode(stdin_default$C, {
            "large": true,
            "text": props2.closeButtonText,
            "type": "close",
            "color": "blue",
            "loading": props2.closeButtonLoading,
            "onPress": onPress
          }, null)]);
        }
      };
      vue.watch(() => props2.show, (value) => {
        if (!props2.transition) {
          emit(value ? "show" : "hide");
        }
      });
      if (props2.hideOnClickOutside) {
        useClickAway(root, onBlur, {
          eventName: "touchstart"
        });
      }
      return () => {
        const Title = renderTitle();
        const Content = vue.createVNode(vue.Transition, {
          "name": props2.transition ? "van-slide-up" : ""
        }, {
          default: () => [vue.withDirectives(vue.createVNode("div", vue.mergeProps({
            "ref": root,
            "style": getZIndexStyle(props2.zIndex),
            "class": bem$v({
              unfit: !props2.safeAreaInsetBottom,
              "with-title": !!Title
            }),
            "onAnimationend": onAnimationEnd,
            "onTouchstartPassive": stopPropagation
          }, attrs), [Title, vue.createVNode("div", {
            "class": bem$v("body")
          }, [vue.createVNode("div", {
            "class": bem$v("keys")
          }, [renderKeys()]), renderSidebar()])]), [[vue.vShow, props2.show]])]
        });
        if (props2.teleport) {
          return vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [Content]
          });
        }
        return Content;
      };
    }
  });
  const NumberKeyboard = withInstall(stdin_default$B);
  const [name$v, bem$u, t$8] = createNamespace("pagination");
  const makePage = (number2, text, active) => ({
    number: number2,
    text,
    active
  });
  const paginationProps = {
    mode: makeStringProp("multi"),
    prevText: String,
    nextText: String,
    pageCount: makeNumericProp(0),
    modelValue: makeNumberProp(0),
    totalItems: makeNumericProp(0),
    showPageSize: makeNumericProp(5),
    itemsPerPage: makeNumericProp(10),
    forceEllipses: Boolean,
    showPrevButton: truthProp,
    showNextButton: truthProp
  };
  var stdin_default$A = vue.defineComponent({
    name: name$v,
    props: paginationProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const count = vue.computed(() => {
        const {
          pageCount,
          totalItems,
          itemsPerPage
        } = props2;
        const count2 = +pageCount || Math.ceil(+totalItems / +itemsPerPage);
        return Math.max(1, count2);
      });
      const pages2 = vue.computed(() => {
        const items = [];
        const pageCount = count.value;
        const showPageSize = +props2.showPageSize;
        const {
          modelValue,
          forceEllipses
        } = props2;
        let startPage = 1;
        let endPage = pageCount;
        const isMaxSized = showPageSize < pageCount;
        if (isMaxSized) {
          startPage = Math.max(modelValue - Math.floor(showPageSize / 2), 1);
          endPage = startPage + showPageSize - 1;
          if (endPage > pageCount) {
            endPage = pageCount;
            startPage = endPage - showPageSize + 1;
          }
        }
        for (let number2 = startPage; number2 <= endPage; number2++) {
          const page2 = makePage(number2, number2, number2 === modelValue);
          items.push(page2);
        }
        if (isMaxSized && showPageSize > 0 && forceEllipses) {
          if (startPage > 1) {
            const prevPages = makePage(startPage - 1, "...");
            items.unshift(prevPages);
          }
          if (endPage < pageCount) {
            const nextPages = makePage(endPage + 1, "...");
            items.push(nextPages);
          }
        }
        return items;
      });
      const updateModelValue = (value, emitChange) => {
        value = clamp(value, 1, count.value);
        if (props2.modelValue !== value) {
          emit("update:modelValue", value);
          if (emitChange) {
            emit("change", value);
          }
        }
      };
      vue.watchEffect(() => updateModelValue(props2.modelValue));
      const renderDesc = () => vue.createVNode("li", {
        "class": bem$u("page-desc")
      }, [slots.pageDesc ? slots.pageDesc() : `${props2.modelValue}/${count.value}`]);
      const renderPrevButton = () => {
        const {
          mode,
          modelValue,
          showPrevButton
        } = props2;
        if (!showPrevButton) {
          return;
        }
        const slot = slots["prev-text"];
        const disabled = modelValue === 1;
        return vue.createVNode("li", {
          "class": [bem$u("item", {
            disabled,
            border: mode === "simple",
            prev: true
          }), BORDER_SURROUND]
        }, [vue.createVNode("button", {
          "type": "button",
          "disabled": disabled,
          "onClick": () => updateModelValue(modelValue - 1, true)
        }, [slot ? slot() : props2.prevText || t$8("prev")])]);
      };
      const renderNextButton = () => {
        const {
          mode,
          modelValue,
          showNextButton
        } = props2;
        if (!showNextButton) {
          return;
        }
        const slot = slots["next-text"];
        const disabled = modelValue === count.value;
        return vue.createVNode("li", {
          "class": [bem$u("item", {
            disabled,
            border: mode === "simple",
            next: true
          }), BORDER_SURROUND]
        }, [vue.createVNode("button", {
          "type": "button",
          "disabled": disabled,
          "onClick": () => updateModelValue(modelValue + 1, true)
        }, [slot ? slot() : props2.nextText || t$8("next")])]);
      };
      const renderPages = () => pages2.value.map((page2) => vue.createVNode("li", {
        "class": [bem$u("item", {
          active: page2.active,
          page: true
        }), BORDER_SURROUND]
      }, [vue.createVNode("button", {
        "type": "button",
        "aria-current": page2.active || void 0,
        "onClick": () => updateModelValue(page2.number, true)
      }, [slots.page ? slots.page(page2) : page2.text])]));
      return () => vue.createVNode("nav", {
        "role": "navigation",
        "class": bem$u()
      }, [vue.createVNode("ul", {
        "class": bem$u("items")
      }, [renderPrevButton(), props2.mode === "simple" ? renderDesc() : renderPages(), renderNextButton()])]);
    }
  });
  const Pagination = withInstall(stdin_default$A);
  const [name$u, bem$t] = createNamespace("password-input");
  const passwordInputProps = {
    info: String,
    mask: truthProp,
    value: makeStringProp(""),
    gutter: numericProp,
    length: makeNumericProp(6),
    focused: Boolean,
    errorInfo: String
  };
  var stdin_default$z = vue.defineComponent({
    name: name$u,
    props: passwordInputProps,
    emits: ["focus"],
    setup(props2, {
      emit
    }) {
      const onTouchStart = (event) => {
        event.stopPropagation();
        emit("focus", event);
      };
      const renderPoints = () => {
        const Points = [];
        const {
          mask,
          value,
          gutter,
          focused
        } = props2;
        const length = +props2.length;
        for (let i2 = 0; i2 < length; i2++) {
          const char = value[i2];
          const showBorder = i2 !== 0 && !gutter;
          const showCursor = focused && i2 === value.length;
          let style;
          if (i2 !== 0 && gutter) {
            style = {
              marginLeft: addUnit$2(gutter)
            };
          }
          Points.push(vue.createVNode("li", {
            "class": [{
              [BORDER_LEFT]: showBorder
            }, bem$t("item", {
              focus: showCursor
            })],
            "style": style
          }, [mask ? vue.createVNode("i", {
            "style": {
              visibility: char ? "visible" : "hidden"
            }
          }, null) : char, showCursor && vue.createVNode("div", {
            "class": bem$t("cursor")
          }, null)]));
        }
        return Points;
      };
      return () => {
        const info = props2.errorInfo || props2.info;
        return vue.createVNode("div", {
          "class": bem$t()
        }, [vue.createVNode("ul", {
          "class": [bem$t("security"), {
            [BORDER_SURROUND]: !props2.gutter
          }],
          "onTouchstartPassive": onTouchStart
        }, [renderPoints()]), info && vue.createVNode("div", {
          "class": bem$t(props2.errorInfo ? "error-info" : "info")
        }, [info])]);
      };
    }
  });
  const PasswordInput = withInstall(stdin_default$z);
  const PickerGroup = withInstall(stdin_default$1x);
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  var round$1 = Math.round;
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width2 = clientRect.width / scaleX;
    var height2 = clientRect.height / scaleY;
    return {
      width: width2,
      height: height2,
      top: y,
      right: x + width2,
      bottom: y + height2,
      left: x,
      x,
      y
    };
  }
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round$1(rect.width) / element.offsetWidth || 1;
    var scaleY = round$1(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width2 = element.offsetWidth;
    var height2 = element.offsetHeight;
    if (Math.abs(clientRect.width - width2) <= 1) {
      width2 = clientRect.width;
    }
    if (Math.abs(clientRect.height - height2) <= 1) {
      height2 = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width2,
      height: height2
    };
  }
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
  }
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce$1(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p2, c2) {
      return p2.replace(/%s/, c2);
    }, str);
  }
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index2, self2) {
        return self2.indexOf(value) === index2;
      }).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:376", format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:381", format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:386", format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:391", format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:396", format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:401", format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:406", format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:413", 'PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s2) {
              return '"' + s2 + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:421", format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current2) {
      var existing = merged2[current2.name];
      merged2[current2.name] = existing ? Object.assign({}, existing, current2, {
        options: Object.assign({}, existing.options, current2.options),
        data: Object.assign({}, existing.data, current2.data)
      }) : current2;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function computeOffsets(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }
    return offsets;
  }
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions2;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
        modifiersData: {},
        elements: {
          reference,
          popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance2 = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions2, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m2) {
            return m2.enabled;
          });
          {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name2 = _ref.name;
              return name2;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name2 = _ref2.name;
                return name2 === "flip";
              });
              if (!flipModifier) {
                formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:590", ['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle(popper), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              formatAppLog("warn", "at node_modules/@vant/popperjs/dist/index.esm.mjs:597", ['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance2.update();
        },
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference2 = _state$elements.reference, popper2 = _state$elements.popper;
          if (!areValidElements(reference2, popper2)) {
            {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:610", INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference2, getOffsetParent(popper2), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper2)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
            {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:628", INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index2 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name: name2,
                instance: instance2
              }) || state;
            }
          }
        },
        update: debounce$1(function() {
          return new Promise(function(resolve) {
            instance2.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference, popper)) {
        {
          formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:661", INVALID_ELEMENT_ERROR);
        }
        return instance2;
      }
      instance2.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name2 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
          if (typeof effect3 === "function") {
            var cleanupFn = effect3({
              state,
              name: name2,
              instance: instance2,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance2;
    };
  }
  var passive = {
    passive: true
  };
  function effect(_ref) {
    var state = _ref.state, instance2 = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance2.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance2.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance2.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance2.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect,
    data: {}
  };
  function popperOffsets(_ref) {
    var state = _ref.state, name2 = _ref.name;
    state.modifiersData[name2] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round$1(x * dpr) / dpr || 0,
      y: round$1(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);
        if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    {
      var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        formatAppLog("warn", "at node_modules/@vant/popperjs/dist/index.esm.mjs:837", ["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name2) {
      var style = state.styles[name2] || {};
      var attributes = state.attributes[name2] || {};
      var element = state.elements[name2];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name22) {
        var value = attributes[name22];
        if (value === false) {
          element.removeAttribute(name22);
        } else {
          element.setAttribute(name22, value === true ? "" : value);
        }
      });
    });
  }
  function effect2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name2) {
        var element = state.elements[name2];
        var attributes = state.attributes[name2] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect2,
    requires: ["computeStyles"]
  };
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name2] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };
  const [name$t, bem$s] = createNamespace("popover");
  const popupProps = ["overlay", "duration", "teleport", "overlayStyle", "overlayClass", "closeOnClickOverlay"];
  const popoverProps = {
    show: Boolean,
    theme: makeStringProp("light"),
    overlay: Boolean,
    actions: makeArrayProp(),
    actionsDirection: makeStringProp("vertical"),
    trigger: makeStringProp("click"),
    duration: numericProp,
    showArrow: truthProp,
    placement: makeStringProp("bottom"),
    iconPrefix: String,
    overlayClass: unknownProp,
    overlayStyle: Object,
    closeOnClickAction: truthProp,
    closeOnClickOverlay: truthProp,
    closeOnClickOutside: truthProp,
    offset: {
      type: Array,
      default: () => [0, 8]
    },
    teleport: {
      type: [String, Object],
      default: "body"
    }
  };
  var stdin_default$y = vue.defineComponent({
    name: name$t,
    props: popoverProps,
    emits: ["select", "touchstart", "update:show"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      let popper;
      const popupRef = vue.ref();
      const wrapperRef = vue.ref();
      const popoverRef = vue.ref();
      const show = useSyncPropRef(() => props2.show, (value) => emit("update:show", value));
      const getPopoverOptions = () => ({
        placement: props2.placement,
        modifiers: [{
          name: "computeStyles",
          options: {
            adaptive: false,
            gpuAcceleration: false
          }
        }, extend({}, offset_default, {
          options: {
            offset: props2.offset
          }
        })]
      });
      const createPopperInstance = () => {
        if (wrapperRef.value && popoverRef.value) {
          return createPopper(wrapperRef.value, popoverRef.value.popupRef.value, getPopoverOptions());
        }
        return null;
      };
      const updateLocation = () => {
        vue.nextTick(() => {
          if (!show.value) {
            return;
          }
          if (!popper) {
            popper = createPopperInstance();
            if (inBrowser$1) {
              window.addEventListener("animationend", updateLocation);
              window.addEventListener("transitionend", updateLocation);
            }
          } else {
            popper.setOptions(getPopoverOptions());
          }
        });
      };
      const updateShow = (value) => {
        show.value = value;
      };
      const onClickWrapper = () => {
        if (props2.trigger === "click") {
          show.value = !show.value;
        }
      };
      const onClickAction = (action, index2) => {
        if (action.disabled) {
          return;
        }
        emit("select", action, index2);
        if (props2.closeOnClickAction) {
          show.value = false;
        }
      };
      const onClickAway = () => {
        if (show.value && props2.closeOnClickOutside && (!props2.overlay || props2.closeOnClickOverlay)) {
          show.value = false;
        }
      };
      const renderActionContent = (action, index2) => {
        if (slots.action) {
          return slots.action({
            action,
            index: index2
          });
        }
        return [action.icon && vue.createVNode(Icon, {
          "name": action.icon,
          "classPrefix": props2.iconPrefix,
          "class": bem$s("action-icon")
        }, null), vue.createVNode("div", {
          "class": [bem$s("action-text"), {
            [BORDER_BOTTOM]: props2.actionsDirection === "vertical"
          }]
        }, [action.text])];
      };
      const renderAction = (action, index2) => {
        const {
          icon,
          color,
          disabled,
          className
        } = action;
        return vue.createVNode("div", {
          "role": "menuitem",
          "class": [bem$s("action", {
            disabled,
            "with-icon": icon
          }), {
            [BORDER_RIGHT]: props2.actionsDirection === "horizontal"
          }, className],
          "style": {
            color
          },
          "tabindex": disabled ? void 0 : 0,
          "aria-disabled": disabled || void 0,
          "onClick": () => onClickAction(action, index2)
        }, [renderActionContent(action, index2)]);
      };
      vue.onMounted(() => {
        updateLocation();
        vue.watchEffect(() => {
          var _a;
          popupRef.value = (_a = popoverRef.value) == null ? void 0 : _a.popupRef.value;
        });
      });
      vue.onBeforeUnmount(() => {
        if (popper) {
          if (inBrowser$1) {
            window.removeEventListener("animationend", updateLocation);
            window.removeEventListener("transitionend", updateLocation);
          }
          popper.destroy();
          popper = null;
        }
      });
      vue.watch(() => [show.value, props2.offset, props2.placement], updateLocation);
      useClickAway([wrapperRef, popupRef], onClickAway, {
        eventName: "touchstart"
      });
      return () => {
        var _a;
        return vue.createVNode(vue.Fragment, null, [vue.createVNode("span", {
          "ref": wrapperRef,
          "class": bem$s("wrapper"),
          "onClick": onClickWrapper
        }, [(_a = slots.reference) == null ? void 0 : _a.call(slots)]), vue.createVNode(Popup, vue.mergeProps({
          "ref": popoverRef,
          "show": show.value,
          "class": bem$s([props2.theme]),
          "position": "",
          "transition": "van-popover-zoom",
          "lockScroll": false,
          "onUpdate:show": updateShow
        }, attrs, useScopeId(), pick(props2, popupProps)), {
          default: () => [props2.showArrow && vue.createVNode("div", {
            "class": bem$s("arrow")
          }, null), vue.createVNode("div", {
            "role": "menu",
            "class": bem$s("content", props2.actionsDirection)
          }, [slots.default ? slots.default() : props2.actions.map(renderAction)])]
        })]);
      };
    }
  });
  const Popover = withInstall(stdin_default$y);
  const [name$s, bem$r] = createNamespace("progress");
  const progressProps = {
    color: String,
    inactive: Boolean,
    pivotText: String,
    textColor: String,
    showPivot: truthProp,
    pivotColor: String,
    trackColor: String,
    strokeWidth: numericProp,
    percentage: {
      type: numericProp,
      default: 0,
      validator: (value) => +value >= 0 && +value <= 100
    }
  };
  var stdin_default$x = vue.defineComponent({
    name: name$s,
    props: progressProps,
    setup(props2) {
      const background = vue.computed(() => props2.inactive ? void 0 : props2.color);
      const renderPivot = () => {
        const {
          textColor,
          pivotText,
          pivotColor,
          percentage
        } = props2;
        const text = pivotText != null ? pivotText : `${percentage}%`;
        if (props2.showPivot && text) {
          const style = {
            color: textColor,
            left: `${+percentage}%`,
            transform: `translate(-${+percentage}%,-50%)`,
            background: pivotColor || background.value
          };
          return vue.createVNode("span", {
            "style": style,
            "class": bem$r("pivot", {
              inactive: props2.inactive
            })
          }, [text]);
        }
      };
      return () => {
        const {
          trackColor,
          percentage,
          strokeWidth
        } = props2;
        const rootStyle = {
          background: trackColor,
          height: addUnit$2(strokeWidth)
        };
        const portionStyle = {
          width: `${percentage}%`,
          background: background.value
        };
        return vue.createVNode("div", {
          "class": bem$r(),
          "style": rootStyle
        }, [vue.createVNode("span", {
          "class": bem$r("portion", {
            inactive: props2.inactive
          }),
          "style": portionStyle
        }, null), renderPivot()]);
      };
    }
  });
  const Progress = withInstall(stdin_default$x);
  const [name$r, bem$q, t$7] = createNamespace("pull-refresh");
  const DEFAULT_HEAD_HEIGHT = 50;
  const TEXT_STATUS = ["pulling", "loosing", "success"];
  const pullRefreshProps = {
    disabled: Boolean,
    modelValue: Boolean,
    headHeight: makeNumericProp(DEFAULT_HEAD_HEIGHT),
    successText: String,
    pullingText: String,
    loosingText: String,
    loadingText: String,
    pullDistance: numericProp,
    successDuration: makeNumericProp(500),
    animationDuration: makeNumericProp(300)
  };
  var stdin_default$w = vue.defineComponent({
    name: name$r,
    props: pullRefreshProps,
    emits: ["change", "refresh", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      let reachTop;
      const root = vue.ref();
      const track = vue.ref();
      const scrollParent = useScrollParent(root);
      const state = vue.reactive({
        status: "normal",
        distance: 0,
        duration: 0
      });
      const touch = useTouch();
      const getHeadStyle = () => {
        if (props2.headHeight !== DEFAULT_HEAD_HEIGHT) {
          return {
            height: `${props2.headHeight}px`
          };
        }
      };
      const isTouchable = () => state.status !== "loading" && state.status !== "success" && !props2.disabled;
      const ease = (distance) => {
        const pullDistance = +(props2.pullDistance || props2.headHeight);
        if (distance > pullDistance) {
          if (distance < pullDistance * 2) {
            distance = pullDistance + (distance - pullDistance) / 2;
          } else {
            distance = pullDistance * 1.5 + (distance - pullDistance * 2) / 4;
          }
        }
        return Math.round(distance);
      };
      const setStatus = (distance, isLoading) => {
        const pullDistance = +(props2.pullDistance || props2.headHeight);
        state.distance = distance;
        if (isLoading) {
          state.status = "loading";
        } else if (distance === 0) {
          state.status = "normal";
        } else if (distance < pullDistance) {
          state.status = "pulling";
        } else {
          state.status = "loosing";
        }
        emit("change", {
          status: state.status,
          distance
        });
      };
      const getStatusText = () => {
        const {
          status
        } = state;
        if (status === "normal") {
          return "";
        }
        return props2[`${status}Text`] || t$7(status);
      };
      const renderStatus = () => {
        const {
          status,
          distance
        } = state;
        if (slots[status]) {
          return slots[status]({
            distance
          });
        }
        const nodes = [];
        if (TEXT_STATUS.includes(status)) {
          nodes.push(vue.createVNode("div", {
            "class": bem$q("text")
          }, [getStatusText()]));
        }
        if (status === "loading") {
          nodes.push(vue.createVNode(Loading, {
            "class": bem$q("loading")
          }, {
            default: getStatusText
          }));
        }
        return nodes;
      };
      const showSuccessTip = () => {
        state.status = "success";
        setTimeout(() => {
          setStatus(0);
        }, +props2.successDuration);
      };
      const checkPosition = (event) => {
        reachTop = getScrollTop(scrollParent.value) === 0;
        if (reachTop) {
          state.duration = 0;
          touch.start(event);
        }
      };
      const onTouchStart = (event) => {
        if (isTouchable()) {
          checkPosition(event);
        }
      };
      const onTouchMove = (event) => {
        if (isTouchable()) {
          if (!reachTop) {
            checkPosition(event);
          }
          const {
            deltaY
          } = touch;
          touch.move(event);
          if (reachTop && deltaY.value >= 0 && touch.isVertical()) {
            preventDefault(event);
            setStatus(ease(deltaY.value));
          }
        }
      };
      const onTouchEnd = () => {
        if (reachTop && touch.deltaY.value && isTouchable()) {
          state.duration = +props2.animationDuration;
          if (state.status === "loosing") {
            setStatus(+props2.headHeight, true);
            emit("update:modelValue", true);
            vue.nextTick(() => emit("refresh"));
          } else {
            setStatus(0);
          }
        }
      };
      vue.watch(() => props2.modelValue, (value) => {
        state.duration = +props2.animationDuration;
        if (value) {
          setStatus(+props2.headHeight, true);
        } else if (slots.success || props2.successText) {
          showSuccessTip();
        } else {
          setStatus(0, false);
        }
      });
      useEventListener("touchmove", onTouchMove, {
        target: track
      });
      return () => {
        var _a;
        const trackStyle = {
          transitionDuration: `${state.duration}ms`,
          transform: state.distance ? `translate3d(0,${state.distance}px, 0)` : ""
        };
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$q()
        }, [vue.createVNode("div", {
          "ref": track,
          "class": bem$q("track"),
          "style": trackStyle,
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd
        }, [vue.createVNode("div", {
          "class": bem$q("head"),
          "style": getHeadStyle()
        }, [renderStatus()]), (_a = slots.default) == null ? void 0 : _a.call(slots)])]);
      };
    }
  });
  const PullRefresh = withInstall(stdin_default$w);
  const [name$q, bem$p] = createNamespace("rate");
  function getRateStatus(value, index2, allowHalf, readonly) {
    if (value >= index2) {
      return {
        status: "full",
        value: 1
      };
    }
    if (value + 0.5 >= index2 && allowHalf && !readonly) {
      return {
        status: "half",
        value: 0.5
      };
    }
    if (value + 1 >= index2 && allowHalf && readonly) {
      const cardinal = 10 ** 10;
      return {
        status: "half",
        value: Math.round((value - index2 + 1) * cardinal) / cardinal
      };
    }
    return {
      status: "void",
      value: 0
    };
  }
  const rateProps = {
    size: numericProp,
    icon: makeStringProp("star"),
    color: String,
    count: makeNumericProp(5),
    gutter: numericProp,
    clearable: Boolean,
    readonly: Boolean,
    disabled: Boolean,
    voidIcon: makeStringProp("star-o"),
    allowHalf: Boolean,
    voidColor: String,
    touchable: truthProp,
    iconPrefix: String,
    modelValue: makeNumberProp(0),
    disabledColor: String
  };
  var stdin_default$v = vue.defineComponent({
    name: name$q,
    props: rateProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit
    }) {
      const touch = useTouch();
      const [itemRefs, setItemRefs] = useRefs();
      const groupRef = vue.ref();
      const unselectable = vue.computed(() => props2.readonly || props2.disabled);
      const untouchable = vue.computed(() => unselectable.value || !props2.touchable);
      const list = vue.computed(() => Array(+props2.count).fill("").map((_, i2) => getRateStatus(props2.modelValue, i2 + 1, props2.allowHalf, props2.readonly)));
      let ranges;
      let groupRefRect;
      let minRectTop = Number.MAX_SAFE_INTEGER;
      let maxRectTop = Number.MIN_SAFE_INTEGER;
      const updateRanges = () => {
        groupRefRect = useRect(groupRef);
        const rects = itemRefs.value.map(useRect);
        ranges = [];
        rects.forEach((rect, index2) => {
          minRectTop = Math.min(rect.top, minRectTop);
          maxRectTop = Math.max(rect.top, maxRectTop);
          if (props2.allowHalf) {
            ranges.push({
              score: index2 + 0.5,
              left: rect.left,
              top: rect.top,
              height: rect.height
            }, {
              score: index2 + 1,
              left: rect.left + rect.width / 2,
              top: rect.top,
              height: rect.height
            });
          } else {
            ranges.push({
              score: index2 + 1,
              left: rect.left,
              top: rect.top,
              height: rect.height
            });
          }
        });
      };
      const getScoreByPosition = (x, y) => {
        for (let i2 = ranges.length - 1; i2 > 0; i2--) {
          if (y >= groupRefRect.top && y <= groupRefRect.bottom) {
            if (x > ranges[i2].left && y >= ranges[i2].top && y <= ranges[i2].top + ranges[i2].height) {
              return ranges[i2].score;
            }
          } else {
            const curTop = y < groupRefRect.top ? minRectTop : maxRectTop;
            if (x > ranges[i2].left && ranges[i2].top === curTop) {
              return ranges[i2].score;
            }
          }
        }
        return props2.allowHalf ? 0.5 : 1;
      };
      const select = (value) => {
        if (unselectable.value || value === props2.modelValue)
          return;
        emit("update:modelValue", value);
        emit("change", value);
      };
      const onTouchStart = (event) => {
        if (untouchable.value) {
          return;
        }
        touch.start(event);
        updateRanges();
      };
      const onTouchMove = (event) => {
        if (untouchable.value) {
          return;
        }
        touch.move(event);
        if (touch.isHorizontal() && !touch.isTap.value) {
          const {
            clientX,
            clientY
          } = event.touches[0];
          preventDefault(event);
          select(getScoreByPosition(clientX, clientY));
        }
      };
      const renderStar = (item, index2) => {
        const {
          icon,
          size,
          color,
          count,
          gutter,
          voidIcon,
          disabled,
          voidColor,
          allowHalf,
          iconPrefix,
          disabledColor
        } = props2;
        const score = index2 + 1;
        const isFull = item.status === "full";
        const isVoid = item.status === "void";
        const renderHalf = allowHalf && item.value > 0 && item.value < 1;
        let style;
        if (gutter && score !== +count) {
          style = {
            paddingRight: addUnit$2(gutter)
          };
        }
        const onClickItem = (event) => {
          updateRanges();
          let value = allowHalf ? getScoreByPosition(event.clientX, event.clientY) : score;
          if (props2.clearable && touch.isTap.value && value === props2.modelValue) {
            value = 0;
          }
          select(value);
        };
        return vue.createVNode("div", {
          "key": index2,
          "ref": setItemRefs(index2),
          "role": "radio",
          "style": style,
          "class": bem$p("item"),
          "tabindex": disabled ? void 0 : 0,
          "aria-setsize": count,
          "aria-posinset": score,
          "aria-checked": !isVoid,
          "onClick": onClickItem
        }, [vue.createVNode(Icon, {
          "size": size,
          "name": isFull ? icon : voidIcon,
          "class": bem$p("icon", {
            disabled,
            full: isFull
          }),
          "color": disabled ? disabledColor : isFull ? color : voidColor,
          "classPrefix": iconPrefix
        }, null), renderHalf && vue.createVNode(Icon, {
          "size": size,
          "style": {
            width: item.value + "em"
          },
          "name": isVoid ? voidIcon : icon,
          "class": bem$p("icon", ["half", {
            disabled,
            full: !isVoid
          }]),
          "color": disabled ? disabledColor : isVoid ? voidColor : color,
          "classPrefix": iconPrefix
        }, null)]);
      };
      useCustomFieldValue(() => props2.modelValue);
      useEventListener("touchmove", onTouchMove, {
        target: groupRef
      });
      return () => vue.createVNode("div", {
        "ref": groupRef,
        "role": "radiogroup",
        "class": bem$p({
          readonly: props2.readonly,
          disabled: props2.disabled
        }),
        "tabindex": props2.disabled ? void 0 : 0,
        "aria-disabled": props2.disabled,
        "aria-readonly": props2.readonly,
        "onTouchstartPassive": onTouchStart
      }, [list.value.map(renderStar)]);
    }
  });
  const Rate = withInstall(stdin_default$v);
  const props$1 = {
    figureArr: makeArrayProp(),
    delay: Number,
    duration: makeNumberProp(2),
    isStart: Boolean,
    direction: makeStringProp("down"),
    height: makeNumberProp(40)
  };
  const [name$p, bem$o] = createNamespace("rolling-text-item");
  var stdin_default$u = vue.defineComponent({
    name: name$p,
    props: props$1,
    setup(props2) {
      const newFigureArr = vue.computed(() => props2.direction === "down" ? props2.figureArr.slice().reverse() : props2.figureArr);
      const translatePx = vue.computed(() => {
        const totalHeight = props2.height * (props2.figureArr.length - 1);
        return `-${totalHeight}px`;
      });
      const itemStyle = vue.computed(() => ({
        lineHeight: addUnit$2(props2.height)
      }));
      const rootStyle = vue.computed(() => ({
        height: addUnit$2(props2.height),
        "--van-translate": translatePx.value,
        "--van-duration": props2.duration + "s",
        "--van-delay": props2.delay + "s"
      }));
      return () => vue.createVNode("div", {
        "class": bem$o([props2.direction]),
        "style": rootStyle.value
      }, [vue.createVNode("div", {
        "class": bem$o("box", {
          animate: props2.isStart
        })
      }, [Array.isArray(newFigureArr.value) && newFigureArr.value.map((figure) => vue.createVNode("div", {
        "class": bem$o("item"),
        "style": itemStyle.value
      }, [figure]))])]);
    }
  });
  const [name$o, bem$n] = createNamespace("rolling-text");
  const rollingTextProps = {
    startNum: makeNumberProp(0),
    targetNum: Number,
    textList: makeArrayProp(),
    duration: makeNumberProp(2),
    autoStart: truthProp,
    direction: makeStringProp("down"),
    stopOrder: makeStringProp("ltr"),
    height: makeNumberProp(40)
  };
  const CIRCLE_NUM = 2;
  var stdin_default$t = vue.defineComponent({
    name: name$o,
    props: rollingTextProps,
    setup(props2) {
      const isCustomType = vue.computed(() => Array.isArray(props2.textList) && props2.textList.length);
      const itemLength = vue.computed(() => {
        if (isCustomType.value)
          return props2.textList[0].length;
        return `${Math.max(props2.startNum, props2.targetNum)}`.length;
      });
      const getTextArrByIdx = (idx) => {
        const result = [];
        for (let i2 = 0; i2 < props2.textList.length; i2++) {
          result.push(props2.textList[i2][idx]);
        }
        return result;
      };
      const targetNumArr = vue.computed(() => {
        if (isCustomType.value)
          return new Array(itemLength.value).fill("");
        return padZero$1(props2.targetNum, itemLength.value).split("");
      });
      const startNumArr = vue.computed(() => padZero$1(props2.startNum, itemLength.value).split(""));
      const getFigureArr = (i2) => {
        const start22 = +startNumArr.value[i2];
        const target = +targetNumArr.value[i2];
        const result = [];
        for (let i22 = start22; i22 <= 9; i22++) {
          result.push(i22);
        }
        for (let i22 = 0; i22 <= CIRCLE_NUM; i22++) {
          for (let j = 0; j <= 9; j++) {
            result.push(j);
          }
        }
        for (let i22 = 0; i22 <= target; i22++) {
          result.push(i22);
        }
        return result;
      };
      const getDelay = (i2, len) => {
        if (props2.stopOrder === "ltr")
          return 0.2 * i2;
        return 0.2 * (len - 1 - i2);
      };
      const rolling = vue.ref(props2.autoStart);
      const start2 = () => {
        rolling.value = true;
      };
      const reset = () => {
        rolling.value = false;
        if (props2.autoStart) {
          raf(() => start2());
        }
      };
      vue.watch(() => props2.autoStart, (value) => {
        if (value) {
          start2();
        }
      });
      useExpose({
        start: start2,
        reset
      });
      return () => vue.createVNode("div", {
        "class": bem$n()
      }, [targetNumArr.value.map((_, i2) => vue.createVNode(stdin_default$u, {
        "figureArr": isCustomType.value ? getTextArrByIdx(i2) : getFigureArr(i2),
        "duration": props2.duration,
        "direction": props2.direction,
        "isStart": rolling.value,
        "height": props2.height,
        "delay": getDelay(i2, itemLength.value)
      }, null))]);
    }
  });
  const RollingText = withInstall(stdin_default$t);
  const Row = withInstall(stdin_default$14);
  const [name$n, bem$m, t$6] = createNamespace("search");
  const searchProps = extend({}, fieldSharedProps, {
    label: String,
    shape: makeStringProp("square"),
    leftIcon: makeStringProp("search"),
    clearable: truthProp,
    actionText: String,
    background: String,
    showAction: Boolean
  });
  var stdin_default$s = vue.defineComponent({
    name: name$n,
    props: searchProps,
    emits: ["blur", "focus", "clear", "search", "cancel", "clickInput", "clickLeftIcon", "clickRightIcon", "update:modelValue"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      const id = useId();
      const fieldRef = vue.ref();
      const onCancel = () => {
        if (!slots.action) {
          emit("update:modelValue", "");
          emit("cancel");
        }
      };
      const onKeypress = (event) => {
        const ENTER_CODE = 13;
        if (event.keyCode === ENTER_CODE) {
          preventDefault(event);
          emit("search", props2.modelValue);
        }
      };
      const getInputId = () => props2.id || `${id}-input`;
      const renderLabel = () => {
        if (slots.label || props2.label) {
          return vue.createVNode("label", {
            "class": bem$m("label"),
            "for": getInputId(),
            "data-allow-mismatch": "attribute"
          }, [slots.label ? slots.label() : props2.label]);
        }
      };
      const renderAction = () => {
        if (props2.showAction) {
          const text = props2.actionText || t$6("cancel");
          return vue.createVNode("div", {
            "class": bem$m("action"),
            "role": "button",
            "tabindex": 0,
            "onClick": onCancel
          }, [slots.action ? slots.action() : text]);
        }
      };
      const blur = () => {
        var _a;
        return (_a = fieldRef.value) == null ? void 0 : _a.blur();
      };
      const focus = () => {
        var _a;
        return (_a = fieldRef.value) == null ? void 0 : _a.focus();
      };
      const onBlur = (event) => emit("blur", event);
      const onFocus = (event) => emit("focus", event);
      const onClear = (event) => emit("clear", event);
      const onClickInput = (event) => emit("clickInput", event);
      const onClickLeftIcon = (event) => emit("clickLeftIcon", event);
      const onClickRightIcon = (event) => emit("clickRightIcon", event);
      const fieldPropNames = Object.keys(fieldSharedProps);
      const renderField = () => {
        const fieldAttrs = extend({}, attrs, pick(props2, fieldPropNames), {
          id: getInputId()
        });
        const onInput = (value) => emit("update:modelValue", value);
        return vue.createVNode(Field, vue.mergeProps({
          "ref": fieldRef,
          "type": "search",
          "class": bem$m("field", {
            "with-message": fieldAttrs.errorMessage
          }),
          "border": false,
          "onBlur": onBlur,
          "onFocus": onFocus,
          "onClear": onClear,
          "onKeypress": onKeypress,
          "onClickInput": onClickInput,
          "onClickLeftIcon": onClickLeftIcon,
          "onClickRightIcon": onClickRightIcon,
          "onUpdate:modelValue": onInput
        }, fieldAttrs), pick(slots, ["left-icon", "right-icon"]));
      };
      useExpose({
        focus,
        blur
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$m({
            "show-action": props2.showAction
          }),
          "style": {
            background: props2.background
          }
        }, [(_a = slots.left) == null ? void 0 : _a.call(slots), vue.createVNode("div", {
          "class": bem$m("content", props2.shape)
        }, [renderLabel(), renderField()]), renderAction()]);
      };
    }
  });
  const Search = withInstall(stdin_default$s);
  const isImage = (name2) => name2 == null ? void 0 : name2.includes("/");
  const popupInheritKeys = [...popupSharedPropKeys, "round", "closeOnPopstate", "safeAreaInsetBottom"];
  const iconMap = {
    qq: "qq",
    link: "link-o",
    weibo: "weibo",
    qrcode: "qr",
    poster: "photo-o",
    wechat: "wechat",
    "weapp-qrcode": "miniprogram-o",
    "wechat-moments": "wechat-moments"
  };
  const [name$m, bem$l, t$5] = createNamespace("share-sheet");
  const shareSheetProps = extend({}, popupSharedProps, {
    title: String,
    round: truthProp,
    options: makeArrayProp(),
    cancelText: String,
    description: String,
    closeOnPopstate: truthProp,
    safeAreaInsetBottom: truthProp
  });
  var stdin_default$r = vue.defineComponent({
    name: name$m,
    props: shareSheetProps,
    emits: ["cancel", "select", "update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      const updateShow = (value) => emit("update:show", value);
      const onCancel = () => {
        updateShow(false);
        emit("cancel");
      };
      const onSelect = (option, index2) => emit("select", option, index2);
      const renderHeader = () => {
        const title = slots.title ? slots.title() : props2.title;
        const description = slots.description ? slots.description() : props2.description;
        if (title || description) {
          return vue.createVNode("div", {
            "class": bem$l("header")
          }, [title && vue.createVNode("h2", {
            "class": bem$l("title")
          }, [title]), description && vue.createVNode("span", {
            "class": bem$l("description")
          }, [description])]);
        }
      };
      const renderIcon = (icon) => {
        if (isImage(icon)) {
          return vue.createVNode("img", {
            "src": icon,
            "class": bem$l("image-icon")
          }, null);
        }
        return vue.createVNode("div", {
          "class": bem$l("icon", [icon])
        }, [vue.createVNode(Icon, {
          "name": iconMap[icon] || icon
        }, null)]);
      };
      const renderOption = (option, index2) => {
        const {
          name: name2,
          icon,
          className,
          description
        } = option;
        return vue.createVNode("div", {
          "role": "button",
          "tabindex": 0,
          "class": [bem$l("option"), className, HAPTICS_FEEDBACK],
          "onClick": () => onSelect(option, index2)
        }, [renderIcon(icon), name2 && vue.createVNode("span", {
          "class": bem$l("name")
        }, [name2]), description && vue.createVNode("span", {
          "class": bem$l("option-description")
        }, [description])]);
      };
      const renderOptions = (options, border) => vue.createVNode("div", {
        "class": bem$l("options", {
          border
        })
      }, [options.map(renderOption)]);
      const renderRows = () => {
        const {
          options
        } = props2;
        if (Array.isArray(options[0])) {
          return options.map((item, index2) => renderOptions(item, index2 !== 0));
        }
        return renderOptions(options);
      };
      const renderCancelButton = () => {
        var _a;
        const cancelText = (_a = props2.cancelText) != null ? _a : t$5("cancel");
        if (slots.cancel || cancelText) {
          return vue.createVNode("button", {
            "type": "button",
            "class": bem$l("cancel"),
            "onClick": onCancel
          }, [slots.cancel ? slots.cancel() : cancelText]);
        }
      };
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": bem$l(),
        "position": "bottom",
        "onUpdate:show": updateShow
      }, pick(props2, popupInheritKeys)), {
        default: () => [renderHeader(), renderRows(), renderCancelButton()]
      });
    }
  });
  const ShareSheet = withInstall(stdin_default$r);
  const [name$l, bem$k] = createNamespace("sidebar");
  const SIDEBAR_KEY = Symbol(name$l);
  const sidebarProps = {
    modelValue: makeNumericProp(0)
  };
  var stdin_default$q = vue.defineComponent({
    name: name$l,
    props: sidebarProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        linkChildren
      } = useChildren(SIDEBAR_KEY);
      const getActive = () => +props2.modelValue;
      const setActive = (value) => {
        if (value !== getActive()) {
          emit("update:modelValue", value);
          emit("change", value);
        }
      };
      linkChildren({
        getActive,
        setActive
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "role": "tablist",
          "class": bem$k()
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Sidebar = withInstall(stdin_default$q);
  const [name$k, bem$j] = createNamespace("sidebar-item");
  const sidebarItemProps = extend({}, routeProps, {
    dot: Boolean,
    title: String,
    badge: numericProp,
    disabled: Boolean,
    badgeProps: Object
  });
  var stdin_default$p = vue.defineComponent({
    name: name$k,
    props: sidebarItemProps,
    emits: ["click"],
    setup(props2, {
      emit,
      slots
    }) {
      const route2 = useRoute();
      const {
        parent,
        index: index2
      } = useParent(SIDEBAR_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/sidebar-item/SidebarItem.mjs:30", "[Vant] <SidebarItem> must be a child component of <Sidebar>.");
        }
        return;
      }
      const onClick = () => {
        if (props2.disabled) {
          return;
        }
        emit("click", index2.value);
        parent.setActive(index2.value);
        route2();
      };
      return () => {
        const {
          dot,
          badge,
          title,
          disabled
        } = props2;
        const selected = index2.value === parent.getActive();
        return vue.createVNode("div", {
          "role": "tab",
          "class": bem$j({
            select: selected,
            disabled
          }),
          "tabindex": disabled ? void 0 : 0,
          "aria-selected": selected,
          "onClick": onClick
        }, [vue.createVNode(Badge, vue.mergeProps({
          "dot": dot,
          "class": bem$j("text"),
          "content": badge
        }, props2.badgeProps), {
          default: () => [slots.title ? slots.title() : title]
        })]);
      };
    }
  });
  const SidebarItem = withInstall(stdin_default$p);
  const [name$j, bem$i, t$4] = createNamespace("signature");
  const signatureProps = {
    tips: String,
    type: makeStringProp("png"),
    penColor: makeStringProp("#000"),
    lineWidth: makeNumberProp(3),
    clearButtonText: String,
    backgroundColor: makeStringProp(""),
    confirmButtonText: String
  };
  const hasCanvasSupport = () => {
    var _a;
    const canvas = document.createElement("canvas");
    return !!((_a = canvas.getContext) == null ? void 0 : _a.call(canvas, "2d"));
  };
  var stdin_default$o = vue.defineComponent({
    name: name$j,
    props: signatureProps,
    emits: ["submit", "clear", "start", "end", "signing"],
    setup(props2, {
      emit
    }) {
      const canvasRef = vue.ref();
      const wrapRef = vue.ref();
      const ctx = vue.computed(() => {
        if (!canvasRef.value)
          return null;
        return canvasRef.value.getContext("2d");
      });
      const isRenderCanvas = inBrowser$1 ? hasCanvasSupport() : true;
      let canvasWidth = 0;
      let canvasHeight = 0;
      let canvasRect;
      const touchStart = () => {
        if (!ctx.value) {
          return false;
        }
        ctx.value.beginPath();
        ctx.value.lineWidth = props2.lineWidth;
        ctx.value.strokeStyle = props2.penColor;
        canvasRect = useRect(canvasRef);
        emit("start");
      };
      const touchMove = (event) => {
        if (!ctx.value) {
          return false;
        }
        preventDefault(event);
        const touch = event.touches[0];
        const mouseX = touch.clientX - ((canvasRect == null ? void 0 : canvasRect.left) || 0);
        const mouseY = touch.clientY - ((canvasRect == null ? void 0 : canvasRect.top) || 0);
        ctx.value.lineCap = "round";
        ctx.value.lineJoin = "round";
        ctx.value.lineTo(mouseX, mouseY);
        ctx.value.stroke();
        emit("signing", event);
      };
      const touchEnd = (event) => {
        preventDefault(event);
        emit("end");
      };
      const isCanvasEmpty = (canvas) => {
        const empty2 = document.createElement("canvas");
        empty2.width = canvas.width;
        empty2.height = canvas.height;
        if (props2.backgroundColor) {
          const emptyCtx = empty2.getContext("2d");
          setCanvasBgColor(emptyCtx);
        }
        return canvas.toDataURL() === empty2.toDataURL();
      };
      const setCanvasBgColor = (ctx2) => {
        if (ctx2 && props2.backgroundColor) {
          ctx2.fillStyle = props2.backgroundColor;
          ctx2.fillRect(0, 0, canvasWidth, canvasHeight);
        }
      };
      const submit = () => {
        var _a, _b;
        const canvas = canvasRef.value;
        if (!canvas) {
          return;
        }
        const isEmpty = isCanvasEmpty(canvas);
        const image2 = isEmpty ? "" : ((_b = (_a = {
          jpg: () => canvas.toDataURL("image/jpeg", 0.8),
          jpeg: () => canvas.toDataURL("image/jpeg", 0.8)
        })[props2.type]) == null ? void 0 : _b.call(_a)) || canvas.toDataURL(`image/${props2.type}`);
        emit("submit", {
          image: image2,
          canvas
        });
      };
      const clear = () => {
        if (ctx.value) {
          ctx.value.clearRect(0, 0, canvasWidth, canvasHeight);
          ctx.value.closePath();
          setCanvasBgColor(ctx.value);
        }
        emit("clear");
      };
      const initialize = () => {
        var _a, _b, _c;
        if (isRenderCanvas && canvasRef.value) {
          const canvas = canvasRef.value;
          const dpr = inBrowser$1 ? window.devicePixelRatio : 1;
          canvasWidth = canvas.width = (((_a = wrapRef.value) == null ? void 0 : _a.offsetWidth) || 0) * dpr;
          canvasHeight = canvas.height = (((_b = wrapRef.value) == null ? void 0 : _b.offsetHeight) || 0) * dpr;
          (_c = ctx.value) == null ? void 0 : _c.scale(dpr, dpr);
          setCanvasBgColor(ctx.value);
        }
      };
      const resize = () => {
        if (ctx.value) {
          const data = ctx.value.getImageData(0, 0, canvasWidth, canvasHeight);
          initialize();
          ctx.value.putImageData(data, 0, 0);
        }
      };
      vue.watch(windowWidth, resize);
      vue.onMounted(initialize);
      useExpose({
        resize,
        clear,
        submit
      });
      return () => vue.createVNode("div", {
        "class": bem$i()
      }, [vue.createVNode("div", {
        "class": bem$i("content"),
        "ref": wrapRef
      }, [isRenderCanvas ? vue.createVNode("canvas", {
        "ref": canvasRef,
        "onTouchstartPassive": touchStart,
        "onTouchmove": touchMove,
        "onTouchend": touchEnd
      }, null) : vue.createVNode("p", null, [props2.tips])]), vue.createVNode("div", {
        "class": bem$i("footer")
      }, [vue.createVNode(Button, {
        "size": "small",
        "onClick": clear
      }, {
        default: () => [props2.clearButtonText || t$4("clear")]
      }), vue.createVNode(Button, {
        "type": "primary",
        "size": "small",
        "onClick": submit
      }, {
        default: () => [props2.confirmButtonText || t$4("confirm")]
      })])]);
    }
  });
  const Signature = withInstall(stdin_default$o);
  const [name$i, bem$h] = createNamespace("skeleton-title");
  const skeletonTitleProps = {
    round: Boolean,
    titleWidth: numericProp
  };
  var stdin_default$n = vue.defineComponent({
    name: name$i,
    props: skeletonTitleProps,
    setup(props2) {
      return () => vue.createVNode("h3", {
        "class": bem$h([{
          round: props2.round
        }]),
        "style": {
          width: addUnit$2(props2.titleWidth)
        }
      }, null);
    }
  });
  const SkeletonTitle = withInstall(stdin_default$n);
  var stdin_default$m = SkeletonTitle;
  const [name$h, bem$g] = createNamespace("skeleton-avatar");
  const skeletonAvatarProps = {
    avatarSize: numericProp,
    avatarShape: makeStringProp("round")
  };
  var stdin_default$l = vue.defineComponent({
    name: name$h,
    props: skeletonAvatarProps,
    setup(props2) {
      return () => vue.createVNode("div", {
        "class": bem$g([props2.avatarShape]),
        "style": getSizeStyle(props2.avatarSize)
      }, null);
    }
  });
  const SkeletonAvatar = withInstall(stdin_default$l);
  var stdin_default$k = SkeletonAvatar;
  const DEFAULT_ROW_WIDTH = "100%";
  const skeletonParagraphProps = {
    round: Boolean,
    rowWidth: {
      type: numericProp,
      default: DEFAULT_ROW_WIDTH
    }
  };
  const [name$g, bem$f] = createNamespace("skeleton-paragraph");
  var stdin_default$j = vue.defineComponent({
    name: name$g,
    props: skeletonParagraphProps,
    setup(props2) {
      return () => vue.createVNode("div", {
        "class": bem$f([{
          round: props2.round
        }]),
        "style": {
          width: props2.rowWidth
        }
      }, null);
    }
  });
  const SkeletonParagraph = withInstall(stdin_default$j);
  var stdin_default$i = SkeletonParagraph;
  const [name$f, bem$e] = createNamespace("skeleton");
  const DEFAULT_LAST_ROW_WIDTH = "60%";
  const skeletonProps = {
    row: makeNumericProp(0),
    round: Boolean,
    title: Boolean,
    titleWidth: numericProp,
    avatar: Boolean,
    avatarSize: numericProp,
    avatarShape: makeStringProp("round"),
    loading: truthProp,
    animate: truthProp,
    rowWidth: {
      type: [Number, String, Array],
      default: DEFAULT_ROW_WIDTH
    }
  };
  var stdin_default$h = vue.defineComponent({
    name: name$f,
    inheritAttrs: false,
    props: skeletonProps,
    setup(props2, {
      slots,
      attrs
    }) {
      const renderAvatar = () => {
        if (props2.avatar) {
          return vue.createVNode(stdin_default$k, {
            "avatarShape": props2.avatarShape,
            "avatarSize": props2.avatarSize
          }, null);
        }
      };
      const renderTitle = () => {
        if (props2.title) {
          return vue.createVNode(stdin_default$m, {
            "round": props2.round,
            "titleWidth": props2.titleWidth
          }, null);
        }
      };
      const getRowWidth = (index2) => {
        const {
          rowWidth
        } = props2;
        if (rowWidth === DEFAULT_ROW_WIDTH && index2 === +props2.row - 1) {
          return DEFAULT_LAST_ROW_WIDTH;
        }
        if (Array.isArray(rowWidth)) {
          return rowWidth[index2];
        }
        return rowWidth;
      };
      const renderRows = () => Array(+props2.row).fill("").map((_, i2) => vue.createVNode(stdin_default$i, {
        "key": i2,
        "round": props2.round,
        "rowWidth": addUnit$2(getRowWidth(i2))
      }, null));
      const renderContents = () => {
        if (slots.template) {
          return slots.template();
        }
        return vue.createVNode(vue.Fragment, null, [renderAvatar(), vue.createVNode("div", {
          "class": bem$e("content")
        }, [renderTitle(), renderRows()])]);
      };
      return () => {
        var _a;
        if (!props2.loading) {
          return (_a = slots.default) == null ? void 0 : _a.call(slots);
        }
        return vue.createVNode("div", vue.mergeProps({
          "class": bem$e({
            animate: props2.animate,
            round: props2.round
          })
        }, attrs), [renderContents()]);
      };
    }
  });
  const Skeleton = withInstall(stdin_default$h);
  const [name$e, bem$d] = createNamespace("skeleton-image");
  const skeletonImageProps = {
    imageSize: numericProp,
    imageShape: makeStringProp("square")
  };
  var stdin_default$g = vue.defineComponent({
    name: name$e,
    props: skeletonImageProps,
    setup(props2) {
      return () => vue.createVNode("div", {
        "class": bem$d([props2.imageShape]),
        "style": getSizeStyle(props2.imageSize)
      }, [vue.createVNode(Icon, {
        "name": "photo",
        "class": bem$d("icon")
      }, null)]);
    }
  });
  const SkeletonImage = withInstall(stdin_default$g);
  const [name$d, bem$c] = createNamespace("slider");
  const sliderProps = {
    min: makeNumericProp(0),
    max: makeNumericProp(100),
    step: makeNumericProp(1),
    range: Boolean,
    reverse: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    vertical: Boolean,
    barHeight: numericProp,
    buttonSize: numericProp,
    activeColor: String,
    inactiveColor: String,
    modelValue: {
      type: [Number, Array],
      default: 0
    }
  };
  var stdin_default$f = vue.defineComponent({
    name: name$d,
    props: sliderProps,
    emits: ["change", "dragEnd", "dragStart", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      let buttonIndex;
      let current2;
      let startValue;
      const root = vue.ref();
      const slider = [vue.ref(), vue.ref()];
      const dragStatus = vue.ref();
      const touch = useTouch();
      const scope = vue.computed(() => Number(props2.max) - Number(props2.min));
      const wrapperStyle = vue.computed(() => {
        const crossAxis = props2.vertical ? "width" : "height";
        return {
          background: props2.inactiveColor,
          [crossAxis]: addUnit$2(props2.barHeight)
        };
      });
      const isRange = (val) => props2.range && Array.isArray(val);
      const calcMainAxis = () => {
        const {
          modelValue,
          min
        } = props2;
        if (isRange(modelValue)) {
          return `${(modelValue[1] - modelValue[0]) * 100 / scope.value}%`;
        }
        return `${(modelValue - Number(min)) * 100 / scope.value}%`;
      };
      const calcOffset = () => {
        const {
          modelValue,
          min
        } = props2;
        if (isRange(modelValue)) {
          return `${(modelValue[0] - Number(min)) * 100 / scope.value}%`;
        }
        return "0%";
      };
      const barStyle = vue.computed(() => {
        const mainAxis = props2.vertical ? "height" : "width";
        const style = {
          [mainAxis]: calcMainAxis(),
          background: props2.activeColor
        };
        if (dragStatus.value) {
          style.transition = "none";
        }
        const getPositionKey = () => {
          if (props2.vertical) {
            return props2.reverse ? "bottom" : "top";
          }
          return props2.reverse ? "right" : "left";
        };
        style[getPositionKey()] = calcOffset();
        return style;
      });
      const format2 = (value) => {
        const min = +props2.min;
        const max = +props2.max;
        const step = +props2.step;
        value = clamp(value, min, max);
        const diff = Math.round((value - min) / step) * step;
        return addNumber(min, diff);
      };
      const updateStartValue = () => {
        const current22 = props2.modelValue;
        if (isRange(current22)) {
          startValue = current22.map(format2);
        } else {
          startValue = format2(current22);
        }
      };
      const handleRangeValue = (value) => {
        var _a, _b;
        const left2 = (_a = value[0]) != null ? _a : Number(props2.min);
        const right2 = (_b = value[1]) != null ? _b : Number(props2.max);
        return left2 > right2 ? [right2, left2] : [left2, right2];
      };
      const updateValue = (value, end2) => {
        if (isRange(value)) {
          value = handleRangeValue(value).map(format2);
        } else {
          value = format2(value);
        }
        if (!isSameValue(value, props2.modelValue)) {
          emit("update:modelValue", value);
        }
        if (end2 && !isSameValue(value, startValue)) {
          emit("change", value);
        }
      };
      const onClick = (event) => {
        event.stopPropagation();
        if (props2.disabled || props2.readonly) {
          return;
        }
        updateStartValue();
        const {
          min,
          reverse,
          vertical,
          modelValue
        } = props2;
        const rect = useRect(root);
        const getDelta = () => {
          if (vertical) {
            if (reverse) {
              return rect.bottom - event.clientY;
            }
            return event.clientY - rect.top;
          }
          if (reverse) {
            return rect.right - event.clientX;
          }
          return event.clientX - rect.left;
        };
        const total = vertical ? rect.height : rect.width;
        const value = Number(min) + getDelta() / total * scope.value;
        if (isRange(modelValue)) {
          const [left2, right2] = modelValue;
          const middle = (left2 + right2) / 2;
          if (value <= middle) {
            updateValue([value, right2], true);
          } else {
            updateValue([left2, value], true);
          }
        } else {
          updateValue(value, true);
        }
      };
      const onTouchStart = (event) => {
        if (props2.disabled || props2.readonly) {
          return;
        }
        touch.start(event);
        current2 = props2.modelValue;
        updateStartValue();
        dragStatus.value = "start";
      };
      const onTouchMove = (event) => {
        if (props2.disabled || props2.readonly) {
          return;
        }
        if (dragStatus.value === "start") {
          emit("dragStart", event);
        }
        preventDefault(event, true);
        touch.move(event);
        dragStatus.value = "dragging";
        const rect = useRect(root);
        const delta = props2.vertical ? touch.deltaY.value : touch.deltaX.value;
        const total = props2.vertical ? rect.height : rect.width;
        let diff = delta / total * scope.value;
        if (props2.reverse) {
          diff = -diff;
        }
        if (isRange(startValue)) {
          const index2 = props2.reverse ? 1 - buttonIndex : buttonIndex;
          current2[index2] = startValue[index2] + diff;
        } else {
          current2 = startValue + diff;
        }
        updateValue(current2);
      };
      const onTouchEnd = (event) => {
        if (props2.disabled || props2.readonly) {
          return;
        }
        if (dragStatus.value === "dragging") {
          updateValue(current2, true);
          emit("dragEnd", event);
        }
        dragStatus.value = "";
      };
      const getButtonClassName = (index2) => {
        if (typeof index2 === "number") {
          const position = ["left", "right"];
          return bem$c(`button-wrapper`, position[index2]);
        }
        return bem$c("button-wrapper", props2.reverse ? "left" : "right");
      };
      const renderButtonContent = (value, index2) => {
        const dragging = dragStatus.value === "dragging";
        if (typeof index2 === "number") {
          const slot = slots[index2 === 0 ? "left-button" : "right-button"];
          let dragIndex;
          if (dragging && Array.isArray(current2)) {
            dragIndex = current2[0] > current2[1] ? buttonIndex ^ 1 : buttonIndex;
          }
          if (slot) {
            return slot({
              value,
              dragging,
              dragIndex
            });
          }
        }
        if (slots.button) {
          return slots.button({
            value,
            dragging
          });
        }
        return vue.createVNode("div", {
          "class": bem$c("button"),
          "style": getSizeStyle(props2.buttonSize)
        }, null);
      };
      const renderButton = (index2) => {
        const current22 = typeof index2 === "number" ? props2.modelValue[index2] : props2.modelValue;
        return vue.createVNode("div", {
          "ref": slider[index2 != null ? index2 : 0],
          "role": "slider",
          "class": getButtonClassName(index2),
          "tabindex": props2.disabled ? void 0 : 0,
          "aria-valuemin": props2.min,
          "aria-valuenow": current22,
          "aria-valuemax": props2.max,
          "aria-disabled": props2.disabled || void 0,
          "aria-readonly": props2.readonly || void 0,
          "aria-orientation": props2.vertical ? "vertical" : "horizontal",
          "onTouchstartPassive": (event) => {
            if (typeof index2 === "number") {
              buttonIndex = index2;
            }
            onTouchStart(event);
          },
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd,
          "onClick": stopPropagation
        }, [renderButtonContent(current22, index2)]);
      };
      updateValue(props2.modelValue);
      useCustomFieldValue(() => props2.modelValue);
      slider.forEach((item) => {
        useEventListener("touchmove", onTouchMove, {
          target: item
        });
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "style": wrapperStyle.value,
        "class": bem$c({
          vertical: props2.vertical,
          disabled: props2.disabled
        }),
        "onClick": onClick
      }, [vue.createVNode("div", {
        "class": bem$c("bar"),
        "style": barStyle.value
      }, [props2.range ? [renderButton(0), renderButton(1)] : renderButton()])]);
    }
  });
  const Slider = withInstall(stdin_default$f);
  const [name$c, bem$b] = createNamespace("space");
  const spaceProps = {
    align: String,
    direction: {
      type: String,
      default: "horizontal"
    },
    size: {
      type: [Number, String, Array],
      default: 8
    },
    wrap: Boolean,
    fill: Boolean
  };
  function filterEmpty(children = []) {
    const nodes = [];
    children.forEach((child) => {
      if (Array.isArray(child)) {
        nodes.push(...child);
      } else if (child.type === vue.Fragment) {
        nodes.push(...filterEmpty(child.children));
      } else {
        nodes.push(child);
      }
    });
    return nodes.filter((c2) => {
      var _a;
      return !(c2 && (c2.type === vue.Comment || c2.type === vue.Fragment && ((_a = c2.children) == null ? void 0 : _a.length) === 0 || c2.type === vue.Text && c2.children.trim() === ""));
    });
  }
  var stdin_default$e = vue.defineComponent({
    name: name$c,
    props: spaceProps,
    setup(props2, {
      slots
    }) {
      const mergedAlign = vue.computed(() => {
        var _a;
        return (_a = props2.align) != null ? _a : props2.direction === "horizontal" ? "center" : "";
      });
      const getMargin = (size) => {
        if (typeof size === "number") {
          return size + "px";
        }
        return size;
      };
      const getMarginStyle = (isLast) => {
        const style = {};
        const marginRight = `${getMargin(Array.isArray(props2.size) ? props2.size[0] : props2.size)}`;
        const marginBottom = `${getMargin(Array.isArray(props2.size) ? props2.size[1] : props2.size)}`;
        if (isLast) {
          return props2.wrap ? {
            marginBottom
          } : {};
        }
        if (props2.direction === "horizontal") {
          style.marginRight = marginRight;
        }
        if (props2.direction === "vertical" || props2.wrap) {
          style.marginBottom = marginBottom;
        }
        return style;
      };
      return () => {
        var _a;
        const children = filterEmpty((_a = slots.default) == null ? void 0 : _a.call(slots));
        return vue.createVNode("div", {
          "class": [bem$b({
            [props2.direction]: props2.direction,
            [`align-${mergedAlign.value}`]: mergedAlign.value,
            wrap: props2.wrap,
            fill: props2.fill
          })]
        }, [children.map((c2, i2) => vue.createVNode("div", {
          "key": `item-${i2}`,
          "class": `${name$c}-item`,
          "style": getMarginStyle(i2 === children.length - 1)
        }, [c2]))]);
      };
    }
  });
  const Space = withInstall(stdin_default$e);
  const [name$b, bem$a] = createNamespace("steps");
  const stepsProps = {
    active: makeNumericProp(0),
    direction: makeStringProp("horizontal"),
    activeIcon: makeStringProp("checked"),
    iconPrefix: String,
    finishIcon: String,
    activeColor: String,
    inactiveIcon: String,
    inactiveColor: String
  };
  const STEPS_KEY = Symbol(name$b);
  var stdin_default$d = vue.defineComponent({
    name: name$b,
    props: stepsProps,
    emits: ["clickStep"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        linkChildren
      } = useChildren(STEPS_KEY);
      const onClickStep = (index2) => emit("clickStep", index2);
      linkChildren({
        props: props2,
        onClickStep
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$a([props2.direction])
        }, [vue.createVNode("div", {
          "class": bem$a("items")
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
      };
    }
  });
  const [name$a, bem$9] = createNamespace("step");
  var stdin_default$c = vue.defineComponent({
    name: name$a,
    setup(props2, {
      slots
    }) {
      const {
        parent,
        index: index2
      } = useParent(STEPS_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/step/Step.mjs:18", "[Vant] <Step> must be a child component of <Steps>.");
        }
        return;
      }
      const parentProps = parent.props;
      const getStatus = () => {
        const active = +parentProps.active;
        if (index2.value < active) {
          return "finish";
        }
        return index2.value === active ? "process" : "waiting";
      };
      const isActive = () => getStatus() === "process";
      const lineStyle = vue.computed(() => ({
        background: getStatus() === "finish" ? parentProps.activeColor : parentProps.inactiveColor
      }));
      const titleStyle = vue.computed(() => {
        if (isActive()) {
          return {
            color: parentProps.activeColor
          };
        }
        if (getStatus() === "waiting") {
          return {
            color: parentProps.inactiveColor
          };
        }
      });
      const onClickStep = () => parent.onClickStep(index2.value);
      const renderCircle = () => {
        const {
          iconPrefix,
          finishIcon,
          activeIcon,
          activeColor,
          inactiveIcon
        } = parentProps;
        if (isActive()) {
          if (slots["active-icon"]) {
            return slots["active-icon"]();
          }
          return vue.createVNode(Icon, {
            "class": bem$9("icon", "active"),
            "name": activeIcon,
            "color": activeColor,
            "classPrefix": iconPrefix
          }, null);
        }
        if (getStatus() === "finish" && (finishIcon || slots["finish-icon"])) {
          if (slots["finish-icon"]) {
            return slots["finish-icon"]();
          }
          return vue.createVNode(Icon, {
            "class": bem$9("icon", "finish"),
            "name": finishIcon,
            "color": activeColor,
            "classPrefix": iconPrefix
          }, null);
        }
        if (slots["inactive-icon"]) {
          return slots["inactive-icon"]();
        }
        if (inactiveIcon) {
          return vue.createVNode(Icon, {
            "class": bem$9("icon"),
            "name": inactiveIcon,
            "classPrefix": iconPrefix
          }, null);
        }
        return vue.createVNode("i", {
          "class": bem$9("circle"),
          "style": lineStyle.value
        }, null);
      };
      return () => {
        var _a;
        const status = getStatus();
        return vue.createVNode("div", {
          "class": [BORDER, bem$9([parentProps.direction, {
            [status]: status
          }])]
        }, [vue.createVNode("div", {
          "class": bem$9("title", {
            active: isActive()
          }),
          "style": titleStyle.value,
          "onClick": onClickStep
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), vue.createVNode("div", {
          "class": bem$9("circle-container"),
          "onClick": onClickStep
        }, [renderCircle()]), vue.createVNode("div", {
          "class": bem$9("line"),
          "style": lineStyle.value
        }, null)]);
      };
    }
  });
  const Step = withInstall(stdin_default$c);
  const [name$9, bem$8] = createNamespace("stepper");
  const LONG_PRESS_INTERVAL = 200;
  const isEqual = (value1, value2) => String(value1) === String(value2);
  const stepperProps = {
    min: makeNumericProp(1),
    max: makeNumericProp(Infinity),
    name: makeNumericProp(""),
    step: makeNumericProp(1),
    theme: String,
    integer: Boolean,
    disabled: Boolean,
    showPlus: truthProp,
    showMinus: truthProp,
    showInput: truthProp,
    longPress: truthProp,
    autoFixed: truthProp,
    allowEmpty: Boolean,
    modelValue: numericProp,
    inputWidth: numericProp,
    buttonSize: numericProp,
    placeholder: String,
    disablePlus: Boolean,
    disableMinus: Boolean,
    disableInput: Boolean,
    beforeChange: Function,
    defaultValue: makeNumericProp(1),
    decimalLength: numericProp
  };
  var stdin_default$b = vue.defineComponent({
    name: name$9,
    props: stepperProps,
    emits: ["plus", "blur", "minus", "focus", "change", "overlimit", "update:modelValue"],
    setup(props2, {
      emit
    }) {
      const format2 = (value, autoFixed = true) => {
        const {
          min,
          max,
          allowEmpty,
          decimalLength
        } = props2;
        if (allowEmpty && value === "") {
          return value;
        }
        value = formatNumber(String(value), !props2.integer);
        value = value === "" ? 0 : +value;
        value = Number.isNaN(value) ? +min : value;
        value = autoFixed ? Math.max(Math.min(+max, value), +min) : value;
        if (isDef(decimalLength)) {
          value = value.toFixed(+decimalLength);
        }
        return value;
      };
      const getInitialValue = () => {
        var _a;
        const defaultValue = (_a = props2.modelValue) != null ? _a : props2.defaultValue;
        const value = format2(defaultValue);
        if (!isEqual(value, props2.modelValue)) {
          emit("update:modelValue", value);
        }
        return value;
      };
      let actionType;
      const inputRef = vue.ref();
      const current2 = vue.ref(getInitialValue());
      const minusDisabled = vue.computed(() => props2.disabled || props2.disableMinus || +current2.value <= +props2.min);
      const plusDisabled = vue.computed(() => props2.disabled || props2.disablePlus || +current2.value >= +props2.max);
      const inputStyle = vue.computed(() => ({
        width: addUnit$2(props2.inputWidth),
        height: addUnit$2(props2.buttonSize)
      }));
      const buttonStyle = vue.computed(() => getSizeStyle(props2.buttonSize));
      const check = () => {
        const value = format2(current2.value);
        if (!isEqual(value, current2.value)) {
          current2.value = value;
        }
      };
      const setValue = (value) => {
        if (props2.beforeChange) {
          callInterceptor(props2.beforeChange, {
            args: [value],
            done() {
              current2.value = value;
            }
          });
        } else {
          current2.value = value;
        }
      };
      const onChange = () => {
        if (actionType === "plus" && plusDisabled.value || actionType === "minus" && minusDisabled.value) {
          emit("overlimit", actionType);
          return;
        }
        const diff = actionType === "minus" ? -props2.step : +props2.step;
        const value = format2(addNumber(+current2.value, diff));
        setValue(value);
        emit(actionType);
      };
      const onInput = (event) => {
        const input = event.target;
        const {
          value
        } = input;
        const {
          decimalLength
        } = props2;
        let formatted = formatNumber(String(value), !props2.integer);
        if (isDef(decimalLength) && formatted.includes(".")) {
          const pair = formatted.split(".");
          formatted = `${pair[0]}.${pair[1].slice(0, +decimalLength)}`;
        }
        if (props2.beforeChange) {
          input.value = String(current2.value);
        } else if (!isEqual(value, formatted)) {
          input.value = formatted;
        }
        const isNumeric2 = formatted === String(+formatted);
        setValue(isNumeric2 ? +formatted : formatted);
      };
      const onFocus = (event) => {
        var _a;
        if (props2.disableInput) {
          (_a = inputRef.value) == null ? void 0 : _a.blur();
        } else {
          emit("focus", event);
        }
      };
      const onBlur = (event) => {
        const input = event.target;
        const value = format2(input.value, props2.autoFixed);
        input.value = String(value);
        current2.value = value;
        vue.nextTick(() => {
          emit("blur", event);
          resetScroll();
        });
      };
      let isLongPress;
      let longPressTimer;
      const longPressStep = () => {
        longPressTimer = setTimeout(() => {
          onChange();
          longPressStep();
        }, LONG_PRESS_INTERVAL);
      };
      const onTouchStart = () => {
        if (props2.longPress) {
          isLongPress = false;
          clearTimeout(longPressTimer);
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            onChange();
            longPressStep();
          }, LONG_PRESS_START_TIME);
        }
      };
      const onTouchEnd = (event) => {
        if (props2.longPress) {
          clearTimeout(longPressTimer);
          if (isLongPress) {
            preventDefault(event);
          }
        }
      };
      const onMousedown = (event) => {
        if (props2.disableInput) {
          preventDefault(event);
        }
      };
      const createListeners = (type) => ({
        onClick: (event) => {
          preventDefault(event);
          actionType = type;
          onChange();
        },
        onTouchstartPassive: () => {
          actionType = type;
          onTouchStart();
        },
        onTouchend: onTouchEnd,
        onTouchcancel: onTouchEnd
      });
      vue.watch(() => [props2.max, props2.min, props2.integer, props2.decimalLength], check);
      vue.watch(() => props2.modelValue, (value) => {
        if (!isEqual(value, current2.value)) {
          current2.value = format2(value);
        }
      });
      vue.watch(current2, (value) => {
        emit("update:modelValue", value);
        emit("change", value, {
          name: props2.name
        });
      });
      useCustomFieldValue(() => props2.modelValue);
      return () => vue.createVNode("div", {
        "role": "group",
        "class": bem$8([props2.theme])
      }, [vue.withDirectives(vue.createVNode("button", vue.mergeProps({
        "type": "button",
        "style": buttonStyle.value,
        "class": [bem$8("minus", {
          disabled: minusDisabled.value
        }), {
          [HAPTICS_FEEDBACK]: !minusDisabled.value
        }],
        "aria-disabled": minusDisabled.value || void 0
      }, createListeners("minus")), null), [[vue.vShow, props2.showMinus]]), vue.withDirectives(vue.createVNode("input", {
        "ref": inputRef,
        "type": props2.integer ? "tel" : "text",
        "role": "spinbutton",
        "class": bem$8("input"),
        "value": current2.value,
        "style": inputStyle.value,
        "disabled": props2.disabled,
        "readonly": props2.disableInput,
        "inputmode": props2.integer ? "numeric" : "decimal",
        "placeholder": props2.placeholder,
        "autocomplete": "off",
        "aria-valuemax": props2.max,
        "aria-valuemin": props2.min,
        "aria-valuenow": current2.value,
        "onBlur": onBlur,
        "onInput": onInput,
        "onFocus": onFocus,
        "onMousedown": onMousedown
      }, null), [[vue.vShow, props2.showInput]]), vue.withDirectives(vue.createVNode("button", vue.mergeProps({
        "type": "button",
        "style": buttonStyle.value,
        "class": [bem$8("plus", {
          disabled: plusDisabled.value
        }), {
          [HAPTICS_FEEDBACK]: !plusDisabled.value
        }],
        "aria-disabled": plusDisabled.value || void 0
      }, createListeners("plus")), null), [[vue.vShow, props2.showPlus]])]);
    }
  });
  const Stepper = withInstall(stdin_default$b);
  const Steps = withInstall(stdin_default$d);
  const [name$8, bem$7, t$3] = createNamespace("submit-bar");
  const submitBarProps = {
    tip: String,
    label: String,
    price: Number,
    tipIcon: String,
    loading: Boolean,
    currency: makeStringProp("¥"),
    disabled: Boolean,
    textAlign: String,
    buttonText: String,
    buttonType: makeStringProp("danger"),
    buttonColor: String,
    suffixLabel: String,
    placeholder: Boolean,
    decimalLength: makeNumericProp(2),
    safeAreaInsetBottom: truthProp
  };
  var stdin_default$a = vue.defineComponent({
    name: name$8,
    props: submitBarProps,
    emits: ["submit"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const renderPlaceholder = usePlaceholder(root, bem$7);
      const renderText = () => {
        const {
          price,
          label,
          currency,
          textAlign,
          suffixLabel,
          decimalLength
        } = props2;
        if (typeof price === "number") {
          const pricePair = (price / 100).toFixed(+decimalLength).split(".");
          const decimal = decimalLength ? `.${pricePair[1]}` : "";
          return vue.createVNode("div", {
            "class": bem$7("text"),
            "style": {
              textAlign
            }
          }, [vue.createVNode("span", null, [label || t$3("label")]), vue.createVNode("span", {
            "class": bem$7("price")
          }, [currency, vue.createVNode("span", {
            "class": bem$7("price-integer")
          }, [pricePair[0]]), decimal]), suffixLabel && vue.createVNode("span", {
            "class": bem$7("suffix-label")
          }, [suffixLabel])]);
        }
      };
      const renderTip = () => {
        var _a;
        const {
          tip,
          tipIcon
        } = props2;
        if (slots.tip || tip) {
          return vue.createVNode("div", {
            "class": bem$7("tip")
          }, [tipIcon && vue.createVNode(Icon, {
            "class": bem$7("tip-icon"),
            "name": tipIcon
          }, null), tip && vue.createVNode("span", {
            "class": bem$7("tip-text")
          }, [tip]), (_a = slots.tip) == null ? void 0 : _a.call(slots)]);
        }
      };
      const onClickButton = () => emit("submit");
      const renderButton = () => {
        if (slots.button) {
          return slots.button();
        }
        return vue.createVNode(Button, {
          "round": true,
          "type": props2.buttonType,
          "text": props2.buttonText,
          "class": bem$7("button", props2.buttonType),
          "color": props2.buttonColor,
          "loading": props2.loading,
          "disabled": props2.disabled,
          "onClick": onClickButton
        }, null);
      };
      const renderSubmitBar = () => {
        var _a, _b;
        return vue.createVNode("div", {
          "ref": root,
          "class": [bem$7(), {
            "van-safe-area-bottom": props2.safeAreaInsetBottom
          }]
        }, [(_a = slots.top) == null ? void 0 : _a.call(slots), renderTip(), vue.createVNode("div", {
          "class": bem$7("bar")
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots), renderText(), renderButton()])]);
      };
      return () => {
        if (props2.placeholder) {
          return renderPlaceholder(renderSubmitBar);
        }
        return renderSubmitBar();
      };
    }
  });
  const SubmitBar = withInstall(stdin_default$a);
  const [name$7, bem$6] = createNamespace("swipe-cell");
  const swipeCellProps = {
    name: makeNumericProp(""),
    disabled: Boolean,
    leftWidth: numericProp,
    rightWidth: numericProp,
    beforeClose: Function,
    stopPropagation: Boolean
  };
  var stdin_default$9 = vue.defineComponent({
    name: name$7,
    props: swipeCellProps,
    emits: ["open", "close", "click"],
    setup(props2, {
      emit,
      slots
    }) {
      let opened;
      let lockClick2;
      let startOffset;
      let isInBeforeClosing;
      const root = vue.ref();
      const leftRef = vue.ref();
      const rightRef = vue.ref();
      const state = vue.reactive({
        offset: 0,
        dragging: false
      });
      const touch = useTouch();
      const getWidthByRef = (ref2) => ref2.value ? useRect(ref2).width : 0;
      const leftWidth = vue.computed(() => isDef(props2.leftWidth) ? +props2.leftWidth : getWidthByRef(leftRef));
      const rightWidth = vue.computed(() => isDef(props2.rightWidth) ? +props2.rightWidth : getWidthByRef(rightRef));
      const open2 = (side) => {
        state.offset = side === "left" ? leftWidth.value : -rightWidth.value;
        if (!opened) {
          opened = true;
          emit("open", {
            name: props2.name,
            position: side
          });
        }
      };
      const close = (position) => {
        state.offset = 0;
        if (opened) {
          opened = false;
          emit("close", {
            name: props2.name,
            position
          });
        }
      };
      const toggle = (side) => {
        const offset2 = Math.abs(state.offset);
        const THRESHOLD = 0.15;
        const threshold = opened ? 1 - THRESHOLD : THRESHOLD;
        const width2 = side === "left" ? leftWidth.value : rightWidth.value;
        if (width2 && offset2 > width2 * threshold) {
          open2(side);
        } else {
          close(side);
        }
      };
      const onTouchStart = (event) => {
        if (!props2.disabled) {
          startOffset = state.offset;
          touch.start(event);
        }
      };
      const onTouchMove = (event) => {
        if (props2.disabled) {
          return;
        }
        const {
          deltaX
        } = touch;
        touch.move(event);
        if (touch.isHorizontal()) {
          lockClick2 = true;
          state.dragging = true;
          const isEdge = !opened || deltaX.value * startOffset < 0;
          if (isEdge) {
            preventDefault(event, props2.stopPropagation);
          }
          state.offset = clamp(deltaX.value + startOffset, -rightWidth.value, leftWidth.value);
        }
      };
      const onTouchEnd = () => {
        if (state.dragging) {
          state.dragging = false;
          toggle(state.offset > 0 ? "left" : "right");
          setTimeout(() => {
            lockClick2 = false;
          }, 0);
        }
      };
      const onClick = (position = "outside", event) => {
        if (isInBeforeClosing)
          return;
        emit("click", position);
        if (opened && !lockClick2) {
          isInBeforeClosing = true;
          callInterceptor(props2.beforeClose, {
            args: [{
              event,
              name: props2.name,
              position
            }],
            done: () => {
              isInBeforeClosing = false;
              close(position);
            },
            canceled: () => isInBeforeClosing = false,
            error: () => isInBeforeClosing = false
          });
        }
      };
      const getClickHandler = (position, stop) => (event) => {
        if (stop) {
          event.stopPropagation();
        }
        if (lockClick2) {
          return;
        }
        onClick(position, event);
      };
      const renderSideContent = (side, ref2) => {
        const contentSlot = slots[side];
        if (contentSlot) {
          return vue.createVNode("div", {
            "ref": ref2,
            "class": bem$6(side),
            "onClick": getClickHandler(side, true)
          }, [contentSlot()]);
        }
      };
      useExpose({
        open: open2,
        close
      });
      useClickAway(root, (event) => onClick("outside", event), {
        eventName: "touchstart"
      });
      useEventListener("touchmove", onTouchMove, {
        target: root
      });
      return () => {
        var _a;
        const wrapperStyle = {
          transform: `translate3d(${state.offset}px, 0, 0)`,
          transitionDuration: state.dragging ? "0s" : ".6s"
        };
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$6(),
          "onClick": getClickHandler("cell", lockClick2),
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd
        }, [vue.createVNode("div", {
          "class": bem$6("wrapper"),
          "style": wrapperStyle
        }, [renderSideContent("left", leftRef), (_a = slots.default) == null ? void 0 : _a.call(slots), renderSideContent("right", rightRef)])]);
      };
    }
  });
  const SwipeCell = withInstall(stdin_default$9);
  const [name$6, bem$5] = createNamespace("tabbar");
  const tabbarProps = {
    route: Boolean,
    fixed: truthProp,
    border: truthProp,
    zIndex: numericProp,
    placeholder: Boolean,
    activeColor: String,
    beforeChange: Function,
    inactiveColor: String,
    modelValue: makeNumericProp(0),
    safeAreaInsetBottom: {
      type: Boolean,
      default: null
    }
  };
  const TABBAR_KEY = Symbol(name$6);
  var stdin_default$8 = vue.defineComponent({
    name: name$6,
    props: tabbarProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const {
        linkChildren
      } = useChildren(TABBAR_KEY);
      const renderPlaceholder = usePlaceholder(root, bem$5);
      const enableSafeArea = () => {
        var _a;
        return (_a = props2.safeAreaInsetBottom) != null ? _a : props2.fixed;
      };
      const renderTabbar = () => {
        var _a;
        const {
          fixed,
          zIndex,
          border
        } = props2;
        return vue.createVNode("div", {
          "ref": root,
          "role": "tablist",
          "style": getZIndexStyle(zIndex),
          "class": [bem$5({
            fixed
          }), {
            [BORDER_TOP_BOTTOM]: border,
            "van-safe-area-bottom": enableSafeArea()
          }]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
      const setActive = (active, afterChange) => {
        callInterceptor(props2.beforeChange, {
          args: [active],
          done() {
            emit("update:modelValue", active);
            emit("change", active);
            afterChange();
          }
        });
      };
      linkChildren({
        props: props2,
        setActive
      });
      return () => {
        if (props2.fixed && props2.placeholder) {
          return renderPlaceholder(renderTabbar);
        }
        return renderTabbar();
      };
    }
  });
  const Tabbar = withInstall(stdin_default$8);
  const [name$5, bem$4] = createNamespace("tabbar-item");
  const tabbarItemProps = extend({}, routeProps, {
    dot: Boolean,
    icon: String,
    name: numericProp,
    badge: numericProp,
    badgeProps: Object,
    iconPrefix: String
  });
  var stdin_default$7 = vue.defineComponent({
    name: name$5,
    props: tabbarItemProps,
    emits: ["click"],
    setup(props2, {
      emit,
      slots
    }) {
      const route2 = useRoute();
      const vm = vue.getCurrentInstance().proxy;
      const {
        parent,
        index: index2
      } = useParent(TABBAR_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/tabbar-item/TabbarItem.mjs:33", "[Vant] <TabbarItem> must be a child component of <Tabbar>.");
        }
        return;
      }
      const active = vue.computed(() => {
        var _a;
        const {
          route: route22,
          modelValue
        } = parent.props;
        if (route22 && "$route" in vm) {
          const {
            $route
          } = vm;
          const {
            to
          } = props2;
          const config2 = isObject$1(to) ? to : {
            path: to
          };
          return !!$route.matched.find((val) => {
            const pathMatched = "path" in config2 && config2.path === val.path;
            const nameMatched = "name" in config2 && config2.name === val.name;
            return pathMatched || nameMatched;
          });
        }
        return ((_a = props2.name) != null ? _a : index2.value) === modelValue;
      });
      const onClick = (event) => {
        var _a;
        if (!active.value) {
          parent.setActive((_a = props2.name) != null ? _a : index2.value, route2);
        }
        emit("click", event);
      };
      const renderIcon = () => {
        if (slots.icon) {
          return slots.icon({
            active: active.value
          });
        }
        if (props2.icon) {
          return vue.createVNode(Icon, {
            "name": props2.icon,
            "classPrefix": props2.iconPrefix
          }, null);
        }
      };
      return () => {
        var _a;
        const {
          dot,
          badge
        } = props2;
        const {
          activeColor,
          inactiveColor
        } = parent.props;
        const color = active.value ? activeColor : inactiveColor;
        return vue.createVNode("div", {
          "role": "tab",
          "class": bem$4({
            active: active.value
          }),
          "style": {
            color
          },
          "tabindex": 0,
          "aria-selected": active.value,
          "onClick": onClick
        }, [vue.createVNode(Badge, vue.mergeProps({
          "dot": dot,
          "class": bem$4("icon"),
          "content": badge
        }, props2.badgeProps), {
          default: renderIcon
        }), vue.createVNode("div", {
          "class": bem$4("text")
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots, {
          active: active.value
        })])]);
      };
    }
  });
  const TabbarItem = withInstall(stdin_default$7);
  const [name$4, bem$3] = createNamespace("text-ellipsis");
  const textEllipsisProps = {
    rows: makeNumericProp(1),
    dots: makeStringProp("..."),
    content: makeStringProp(""),
    expandText: makeStringProp(""),
    collapseText: makeStringProp(""),
    position: makeStringProp("end")
  };
  var stdin_default$6 = vue.defineComponent({
    name: name$4,
    props: textEllipsisProps,
    emits: ["clickAction"],
    setup(props2, {
      emit,
      slots
    }) {
      const text = vue.ref(props2.content);
      const expanded = vue.ref(false);
      const hasAction = vue.ref(false);
      const root = vue.ref();
      const actionRef = vue.ref();
      let needRecalculate = false;
      const actionText = vue.computed(() => expanded.value ? props2.collapseText : props2.expandText);
      const pxToNum = (value) => {
        if (!value)
          return 0;
        const match = value.match(/^\d*(\.\d*)?/);
        return match ? Number(match[0]) : 0;
      };
      const cloneContainer = () => {
        if (!root.value || !root.value.isConnected)
          return;
        const originStyle = window.getComputedStyle(root.value);
        const container = document.createElement("div");
        const styleNames = Array.prototype.slice.apply(originStyle);
        styleNames.forEach((name2) => {
          container.style.setProperty(name2, originStyle.getPropertyValue(name2));
        });
        container.style.position = "fixed";
        container.style.zIndex = "-9999";
        container.style.top = "-9999px";
        container.style.height = "auto";
        container.style.minHeight = "auto";
        container.style.maxHeight = "auto";
        container.innerText = props2.content;
        document.body.appendChild(container);
        return container;
      };
      const calcEllipsisText = (container, maxHeight) => {
        var _a, _b;
        const {
          content,
          position,
          dots
        } = props2;
        const end2 = content.length;
        const middle = 0 + end2 >> 1;
        const actionHTML = slots.action ? (_b = (_a = actionRef.value) == null ? void 0 : _a.outerHTML) != null ? _b : "" : props2.expandText;
        const calcEllipse = () => {
          const tail = (left2, right2) => {
            if (right2 - left2 <= 1) {
              if (position === "end") {
                return content.slice(0, left2) + dots;
              }
              return dots + content.slice(right2, end2);
            }
            const middle2 = Math.round((left2 + right2) / 2);
            if (position === "end") {
              container.innerText = content.slice(0, middle2) + dots;
            } else {
              container.innerText = dots + content.slice(middle2, end2);
            }
            container.innerHTML += actionHTML;
            if (container.offsetHeight > maxHeight) {
              if (position === "end") {
                return tail(left2, middle2);
              }
              return tail(middle2, right2);
            }
            if (position === "end") {
              return tail(middle2, right2);
            }
            return tail(left2, middle2);
          };
          return tail(0, end2);
        };
        const middleTail = (leftPart, rightPart) => {
          if (leftPart[1] - leftPart[0] <= 1 && rightPart[1] - rightPart[0] <= 1) {
            return content.slice(0, leftPart[0]) + dots + content.slice(rightPart[1], end2);
          }
          const leftMiddle = Math.floor((leftPart[0] + leftPart[1]) / 2);
          const rightMiddle = Math.ceil((rightPart[0] + rightPart[1]) / 2);
          container.innerText = props2.content.slice(0, leftMiddle) + props2.dots + props2.content.slice(rightMiddle, end2);
          container.innerHTML += actionHTML;
          if (container.offsetHeight >= maxHeight) {
            return middleTail([leftPart[0], leftMiddle], [rightMiddle, rightPart[1]]);
          }
          return middleTail([leftMiddle, leftPart[1]], [rightPart[0], rightMiddle]);
        };
        return props2.position === "middle" ? middleTail([0, middle], [middle, end2]) : calcEllipse();
      };
      const calcEllipsised = () => {
        const container = cloneContainer();
        if (!container) {
          needRecalculate = true;
          return;
        }
        const {
          paddingBottom,
          paddingTop,
          lineHeight
        } = container.style;
        const maxHeight = Math.ceil((Number(props2.rows) + 0.5) * pxToNum(lineHeight) + pxToNum(paddingTop) + pxToNum(paddingBottom));
        if (maxHeight < container.offsetHeight) {
          hasAction.value = true;
          text.value = calcEllipsisText(container, maxHeight);
        } else {
          hasAction.value = false;
          text.value = props2.content;
        }
        document.body.removeChild(container);
      };
      const toggle = (isExpanded = !expanded.value) => {
        expanded.value = isExpanded;
      };
      const onClickAction = (event) => {
        toggle();
        emit("clickAction", event);
      };
      const renderAction = () => {
        const action = slots.action ? slots.action({
          expanded: expanded.value
        }) : actionText.value;
        return vue.createVNode("span", {
          "ref": actionRef,
          "class": bem$3("action"),
          "onClick": onClickAction
        }, [action]);
      };
      vue.onMounted(() => {
        calcEllipsised();
        if (slots.action) {
          vue.nextTick(calcEllipsised);
        }
      });
      vue.onActivated(() => {
        if (needRecalculate) {
          needRecalculate = false;
          calcEllipsised();
        }
      });
      vue.watch([windowWidth, () => [props2.content, props2.rows, props2.position]], calcEllipsised);
      useExpose({
        toggle
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "class": bem$3()
      }, [expanded.value ? props2.content : text.value, hasAction.value ? renderAction() : null]);
    }
  });
  const TextEllipsis = withInstall(stdin_default$6);
  const [name$3] = createNamespace("time-picker");
  const validateTime = (val) => /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/.test(val);
  const fullColumns = ["hour", "minute", "second"];
  const timePickerProps = extend({}, sharedProps, {
    minHour: makeNumericProp(0),
    maxHour: makeNumericProp(23),
    minMinute: makeNumericProp(0),
    maxMinute: makeNumericProp(59),
    minSecond: makeNumericProp(0),
    maxSecond: makeNumericProp(59),
    minTime: {
      type: String,
      validator: validateTime
    },
    maxTime: {
      type: String,
      validator: validateTime
    },
    columnsType: {
      type: Array,
      default: () => ["hour", "minute"]
    }
  });
  var stdin_default$5 = vue.defineComponent({
    name: name$3,
    props: timePickerProps,
    emits: ["confirm", "cancel", "change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const currentValues = vue.ref(props2.modelValue);
      const pickerRef = vue.ref();
      const getValidTime = (time) => {
        const timeLimitArr = time.split(":");
        return fullColumns.map((col, i2) => props2.columnsType.includes(col) ? timeLimitArr[i2] : "00");
      };
      const confirm = () => {
        var _a;
        return (_a = pickerRef.value) == null ? void 0 : _a.confirm();
      };
      const getSelectedTime = () => currentValues.value;
      const columns = vue.computed(() => {
        let {
          minHour,
          maxHour,
          minMinute,
          maxMinute,
          minSecond,
          maxSecond
        } = props2;
        if (props2.minTime || props2.maxTime) {
          const fullTime = {
            hour: 0,
            minute: 0,
            second: 0
          };
          props2.columnsType.forEach((col, i2) => {
            var _a;
            fullTime[col] = (_a = currentValues.value[i2]) != null ? _a : 0;
          });
          const {
            hour,
            minute
          } = fullTime;
          if (props2.minTime) {
            const [minH, minM, minS] = getValidTime(props2.minTime);
            minHour = minH;
            minMinute = +hour <= +minHour ? minM : "00";
            minSecond = +hour <= +minHour && +minute <= +minMinute ? minS : "00";
          }
          if (props2.maxTime) {
            const [maxH, maxM, maxS] = getValidTime(props2.maxTime);
            maxHour = maxH;
            maxMinute = +hour >= +maxHour ? maxM : "59";
            maxSecond = +hour >= +maxHour && +minute >= +maxMinute ? maxS : "59";
          }
        }
        return props2.columnsType.map((type) => {
          const {
            filter,
            formatter
          } = props2;
          switch (type) {
            case "hour":
              return genOptions(+minHour, +maxHour, type, formatter, filter, currentValues.value);
            case "minute":
              return genOptions(+minMinute, +maxMinute, type, formatter, filter, currentValues.value);
            case "second":
              return genOptions(+minSecond, +maxSecond, type, formatter, filter, currentValues.value);
            default: {
              throw new Error(`[Vant] DatePicker: unsupported columns type: ${type}`);
            }
          }
        });
      });
      vue.watch(currentValues, (newValues) => {
        if (!isSameValue(newValues, props2.modelValue)) {
          emit("update:modelValue", newValues);
        }
      });
      vue.watch(() => props2.modelValue, (newValues) => {
        newValues = formatValueRange(newValues, columns.value);
        if (!isSameValue(newValues, currentValues.value)) {
          currentValues.value = newValues;
        }
      }, {
        immediate: true
      });
      const onChange = (...args) => emit("change", ...args);
      const onCancel = (...args) => emit("cancel", ...args);
      const onConfirm = (...args) => emit("confirm", ...args);
      useExpose({
        confirm,
        getSelectedTime
      });
      return () => vue.createVNode(Picker, vue.mergeProps({
        "ref": pickerRef,
        "modelValue": currentValues.value,
        "onUpdate:modelValue": ($event) => currentValues.value = $event,
        "columns": columns.value,
        "onChange": onChange,
        "onCancel": onCancel,
        "onConfirm": onConfirm
      }, pick(props2, pickerInheritKeys)), slots);
    }
  });
  const TimePicker = withInstall(stdin_default$5);
  const [name$2, bem$2] = createNamespace("tree-select");
  const treeSelectProps = {
    max: makeNumericProp(Infinity),
    items: makeArrayProp(),
    height: makeNumericProp(300),
    selectedIcon: makeStringProp("success"),
    mainActiveIndex: makeNumericProp(0),
    activeId: {
      type: [Number, String, Array],
      default: 0
    }
  };
  var stdin_default$4 = vue.defineComponent({
    name: name$2,
    props: treeSelectProps,
    emits: ["clickNav", "clickItem", "update:activeId", "update:mainActiveIndex"],
    setup(props2, {
      emit,
      slots
    }) {
      const isActiveItem = (id) => Array.isArray(props2.activeId) ? props2.activeId.includes(id) : props2.activeId === id;
      const renderSubItem = (item) => {
        const onClick = () => {
          if (item.disabled) {
            return;
          }
          let activeId;
          if (Array.isArray(props2.activeId)) {
            activeId = props2.activeId.slice();
            const index2 = activeId.indexOf(item.id);
            if (index2 !== -1) {
              activeId.splice(index2, 1);
            } else if (activeId.length < +props2.max) {
              activeId.push(item.id);
            }
          } else {
            activeId = item.id;
          }
          emit("update:activeId", activeId);
          emit("clickItem", item);
        };
        return vue.createVNode("div", {
          "key": item.id,
          "class": ["van-ellipsis", bem$2("item", {
            active: isActiveItem(item.id),
            disabled: item.disabled
          })],
          "onClick": onClick
        }, [item.text, isActiveItem(item.id) && vue.createVNode(Icon, {
          "name": props2.selectedIcon,
          "class": bem$2("selected")
        }, null)]);
      };
      const onSidebarChange = (index2) => {
        emit("update:mainActiveIndex", index2);
      };
      const onClickSidebarItem = (index2) => emit("clickNav", index2);
      const renderSidebar = () => {
        const Items = props2.items.map((item) => vue.createVNode(SidebarItem, {
          "dot": item.dot,
          "badge": item.badge,
          "class": [bem$2("nav-item"), item.className],
          "disabled": item.disabled,
          "onClick": onClickSidebarItem
        }, {
          title: () => slots["nav-text"] ? slots["nav-text"](item) : item.text
        }));
        return vue.createVNode(Sidebar, {
          "class": bem$2("nav"),
          "modelValue": props2.mainActiveIndex,
          "onChange": onSidebarChange
        }, {
          default: () => [Items]
        });
      };
      const renderContent = () => {
        if (slots.content) {
          return slots.content();
        }
        const selected = props2.items[+props2.mainActiveIndex] || {};
        if (selected.children) {
          return selected.children.map(renderSubItem);
        }
      };
      return () => vue.createVNode("div", {
        "class": bem$2(),
        "style": {
          height: addUnit$2(props2.height)
        }
      }, [renderSidebar(), vue.createVNode("div", {
        "class": bem$2("content")
      }, [renderContent()])]);
    }
  });
  const TreeSelect = withInstall(stdin_default$4);
  const [name$1, bem$1, t$2] = createNamespace("uploader");
  function readFileContent(file, resultType) {
    return new Promise((resolve) => {
      if (resultType === "file") {
        resolve();
        return;
      }
      const reader = new FileReader();
      reader.onload = (event) => {
        resolve(event.target.result);
      };
      if (resultType === "dataUrl") {
        reader.readAsDataURL(file);
      } else if (resultType === "text") {
        reader.readAsText(file);
      }
    });
  }
  function isOversize(items, maxSize) {
    return toArray(items).some((item) => {
      if (item.file) {
        if (isFunction(maxSize)) {
          return maxSize(item.file);
        }
        return item.file.size > +maxSize;
      }
      return false;
    });
  }
  function filterFiles(items, maxSize) {
    const valid = [];
    const invalid = [];
    items.forEach((item) => {
      if (isOversize(item, maxSize)) {
        invalid.push(item);
      } else {
        valid.push(item);
      }
    });
    return { valid, invalid };
  }
  const IMAGE_REGEXP = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg|avif)/i;
  const isImageUrl = (url2) => IMAGE_REGEXP.test(url2);
  function isImageFile(item) {
    if (item.isImage) {
      return true;
    }
    if (item.file && item.file.type) {
      return item.file.type.indexOf("image") === 0;
    }
    if (item.url) {
      return isImageUrl(item.url);
    }
    if (typeof item.content === "string") {
      return item.content.indexOf("data:image") === 0;
    }
    return false;
  }
  var stdin_default$3 = vue.defineComponent({
    props: {
      name: numericProp,
      item: makeRequiredProp(Object),
      index: Number,
      imageFit: String,
      lazyLoad: Boolean,
      deletable: Boolean,
      reupload: Boolean,
      previewSize: [Number, String, Array],
      beforeDelete: Function
    },
    emits: ["delete", "preview", "reupload"],
    setup(props2, {
      emit,
      slots
    }) {
      const renderMask = () => {
        const {
          status,
          message
        } = props2.item;
        if (status === "uploading" || status === "failed") {
          const MaskIcon = status === "failed" ? vue.createVNode(Icon, {
            "name": "close",
            "class": bem$1("mask-icon")
          }, null) : vue.createVNode(Loading, {
            "class": bem$1("loading")
          }, null);
          const showMessage = isDef(message) && message !== "";
          return vue.createVNode("div", {
            "class": bem$1("mask")
          }, [MaskIcon, showMessage && vue.createVNode("div", {
            "class": bem$1("mask-message")
          }, [message])]);
        }
      };
      const onDelete = (event) => {
        const {
          name: name2,
          item,
          index: index2,
          beforeDelete
        } = props2;
        event.stopPropagation();
        callInterceptor(beforeDelete, {
          args: [item, {
            name: name2,
            index: index2
          }],
          done: () => emit("delete")
        });
      };
      const onPreview = () => emit("preview");
      const onReupload = () => emit("reupload");
      const renderDeleteIcon = () => {
        if (props2.deletable && props2.item.status !== "uploading") {
          const slot = slots["preview-delete"];
          return vue.createVNode("div", {
            "role": "button",
            "class": bem$1("preview-delete", {
              shadow: !slot
            }),
            "tabindex": 0,
            "aria-label": t$2("delete"),
            "onClick": onDelete
          }, [slot ? slot() : vue.createVNode(Icon, {
            "name": "cross",
            "class": bem$1("preview-delete-icon")
          }, null)]);
        }
      };
      const renderCover = () => {
        if (slots["preview-cover"]) {
          const {
            index: index2,
            item
          } = props2;
          return vue.createVNode("div", {
            "class": bem$1("preview-cover")
          }, [slots["preview-cover"](extend({
            index: index2
          }, item))]);
        }
      };
      const renderPreview = () => {
        const {
          item,
          lazyLoad,
          imageFit,
          previewSize,
          reupload
        } = props2;
        if (isImageFile(item)) {
          return vue.createVNode(Image$1, {
            "fit": imageFit,
            "src": item.objectUrl || item.content || item.url,
            "class": bem$1("preview-image"),
            "width": Array.isArray(previewSize) ? previewSize[0] : previewSize,
            "height": Array.isArray(previewSize) ? previewSize[1] : previewSize,
            "lazyLoad": lazyLoad,
            "onClick": reupload ? onReupload : onPreview
          }, {
            default: renderCover
          });
        }
        return vue.createVNode("div", {
          "class": bem$1("file"),
          "style": getSizeStyle(props2.previewSize)
        }, [vue.createVNode(Icon, {
          "class": bem$1("file-icon"),
          "name": "description"
        }, null), vue.createVNode("div", {
          "class": [bem$1("file-name"), "van-ellipsis"]
        }, [item.file ? item.file.name : item.url]), renderCover()]);
      };
      return () => vue.createVNode("div", {
        "class": bem$1("preview")
      }, [renderPreview(), renderMask(), renderDeleteIcon()]);
    }
  });
  const uploaderProps = {
    name: makeNumericProp(""),
    accept: makeStringProp("image/*"),
    capture: String,
    multiple: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    lazyLoad: Boolean,
    maxCount: makeNumericProp(Infinity),
    imageFit: makeStringProp("cover"),
    resultType: makeStringProp("dataUrl"),
    uploadIcon: makeStringProp("photograph"),
    uploadText: String,
    deletable: truthProp,
    reupload: Boolean,
    afterRead: Function,
    showUpload: truthProp,
    modelValue: makeArrayProp(),
    beforeRead: Function,
    beforeDelete: Function,
    previewSize: [Number, String, Array],
    previewImage: truthProp,
    previewOptions: Object,
    previewFullImage: truthProp,
    maxSize: {
      type: [Number, String, Function],
      default: Infinity
    }
  };
  var stdin_default$2 = vue.defineComponent({
    name: name$1,
    props: uploaderProps,
    emits: ["delete", "oversize", "clickUpload", "closePreview", "clickPreview", "clickReupload", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const inputRef = vue.ref();
      const urls = [];
      const reuploadIndex = vue.ref(-1);
      const isReuploading = vue.ref(false);
      const getDetail = (index2 = props2.modelValue.length) => ({
        name: props2.name,
        index: index2
      });
      const resetInput = () => {
        if (inputRef.value) {
          inputRef.value.value = "";
        }
      };
      const onAfterRead = (items) => {
        resetInput();
        if (isOversize(items, props2.maxSize)) {
          if (Array.isArray(items)) {
            const result = filterFiles(items, props2.maxSize);
            items = result.valid;
            emit("oversize", result.invalid, getDetail());
            if (!items.length) {
              return;
            }
          } else {
            emit("oversize", items, getDetail());
            return;
          }
        }
        items = vue.reactive(items);
        if (reuploadIndex.value > -1) {
          const arr = [...props2.modelValue];
          arr.splice(reuploadIndex.value, 1, items);
          emit("update:modelValue", arr);
          reuploadIndex.value = -1;
        } else {
          emit("update:modelValue", [...props2.modelValue, ...toArray(items)]);
        }
        if (props2.afterRead) {
          props2.afterRead(items, getDetail());
        }
      };
      const readFile = (files) => {
        const {
          maxCount,
          modelValue,
          resultType
        } = props2;
        if (Array.isArray(files)) {
          const remainCount = +maxCount - modelValue.length;
          if (files.length > remainCount) {
            files = files.slice(0, remainCount);
          }
          Promise.all(files.map((file) => readFileContent(file, resultType))).then((contents) => {
            const fileList = files.map((file, index2) => {
              const result = {
                file,
                status: "",
                message: "",
                objectUrl: URL.createObjectURL(file)
              };
              if (contents[index2]) {
                result.content = contents[index2];
              }
              return result;
            });
            onAfterRead(fileList);
          });
        } else {
          readFileContent(files, resultType).then((content) => {
            const result = {
              file: files,
              status: "",
              message: "",
              objectUrl: URL.createObjectURL(files)
            };
            if (content) {
              result.content = content;
            }
            onAfterRead(result);
          });
        }
      };
      const onChange = (event) => {
        const {
          files
        } = event.target;
        if (props2.disabled || !files || !files.length) {
          return;
        }
        const file = files.length === 1 ? files[0] : [].slice.call(files);
        if (props2.beforeRead) {
          const response = props2.beforeRead(file, getDetail());
          if (!response) {
            resetInput();
            return;
          }
          if (isPromise$1(response)) {
            response.then((data) => {
              if (data) {
                readFile(data);
              } else {
                readFile(file);
              }
            }).catch(resetInput);
            return;
          }
        }
        readFile(file);
      };
      let imagePreview;
      const onClosePreview = () => emit("closePreview");
      const previewImage = (item) => {
        if (props2.previewFullImage) {
          const imageFiles = props2.modelValue.filter(isImageFile);
          const images = imageFiles.map((item2) => {
            if (item2.objectUrl && !item2.url && item2.status !== "failed") {
              item2.url = item2.objectUrl;
              urls.push(item2.url);
            }
            return item2.url;
          }).filter(Boolean);
          imagePreview = showImagePreview(extend({
            images,
            startPosition: imageFiles.indexOf(item),
            onClose: onClosePreview
          }, props2.previewOptions));
        }
      };
      const closeImagePreview = () => {
        if (imagePreview) {
          imagePreview.close();
        }
      };
      const deleteFile = (item, index2) => {
        const fileList = props2.modelValue.slice(0);
        fileList.splice(index2, 1);
        emit("update:modelValue", fileList);
        emit("delete", item, getDetail(index2));
      };
      const reuploadFile = (index2) => {
        isReuploading.value = true;
        reuploadIndex.value = index2;
        vue.nextTick(() => chooseFile());
      };
      const onInputClick = () => {
        if (!isReuploading.value) {
          reuploadIndex.value = -1;
        }
        isReuploading.value = false;
      };
      const renderPreviewItem = (item, index2) => {
        const needPickData = ["imageFit", "deletable", "reupload", "previewSize", "beforeDelete"];
        const previewData = extend(pick(props2, needPickData), pick(item, needPickData, true));
        return vue.createVNode(stdin_default$3, vue.mergeProps({
          "item": item,
          "index": index2,
          "onClick": () => emit(props2.reupload ? "clickReupload" : "clickPreview", item, getDetail(index2)),
          "onDelete": () => deleteFile(item, index2),
          "onPreview": () => previewImage(item),
          "onReupload": () => reuploadFile(index2)
        }, pick(props2, ["name", "lazyLoad"]), previewData), pick(slots, ["preview-cover", "preview-delete"]));
      };
      const renderPreviewList = () => {
        if (props2.previewImage) {
          return props2.modelValue.map(renderPreviewItem);
        }
      };
      const onClickUpload = (event) => emit("clickUpload", event);
      const renderUpload = () => {
        const lessThanMax = props2.modelValue.length < +props2.maxCount;
        const Input = props2.readonly ? null : vue.createVNode("input", {
          "ref": inputRef,
          "type": "file",
          "class": bem$1("input"),
          "accept": props2.accept,
          "capture": props2.capture,
          "multiple": props2.multiple && reuploadIndex.value === -1,
          "disabled": props2.disabled,
          "onChange": onChange,
          "onClick": onInputClick
        }, null);
        if (slots.default) {
          return vue.withDirectives(vue.createVNode("div", {
            "class": bem$1("input-wrapper"),
            "onClick": onClickUpload
          }, [slots.default(), Input]), [[vue.vShow, lessThanMax]]);
        }
        return vue.withDirectives(vue.createVNode("div", {
          "class": bem$1("upload", {
            readonly: props2.readonly
          }),
          "style": getSizeStyle(props2.previewSize),
          "onClick": onClickUpload
        }, [vue.createVNode(Icon, {
          "name": props2.uploadIcon,
          "class": bem$1("upload-icon")
        }, null), props2.uploadText && vue.createVNode("span", {
          "class": bem$1("upload-text")
        }, [props2.uploadText]), Input]), [[vue.vShow, props2.showUpload && lessThanMax]]);
      };
      const chooseFile = () => {
        if (inputRef.value && !props2.disabled) {
          inputRef.value.click();
        }
      };
      vue.onBeforeUnmount(() => {
        urls.forEach((url2) => URL.revokeObjectURL(url2));
      });
      useExpose({
        chooseFile,
        reuploadFile,
        closeImagePreview
      });
      useCustomFieldValue(() => props2.modelValue);
      return () => vue.createVNode("div", {
        "class": bem$1()
      }, [vue.createVNode("div", {
        "class": bem$1("wrapper", {
          disabled: props2.disabled
        })
      }, [renderPreviewList(), renderUpload()])]);
    }
  });
  const Uploader = withInstall(stdin_default$2);
  const [name, bem] = createNamespace("watermark");
  const watermarkProps = {
    gapX: makeNumberProp(0),
    gapY: makeNumberProp(0),
    image: String,
    width: makeNumberProp(100),
    height: makeNumberProp(100),
    rotate: makeNumericProp(-22),
    zIndex: numericProp,
    content: String,
    opacity: numericProp,
    fullPage: truthProp,
    textColor: makeStringProp("#dcdee0")
  };
  var stdin_default$1 = vue.defineComponent({
    name,
    props: watermarkProps,
    setup(props2, {
      slots
    }) {
      const svgElRef = vue.ref();
      const watermarkUrl = vue.ref("");
      const imageBase64 = vue.ref("");
      const renderWatermark = () => {
        const rotateStyle = {
          transformOrigin: "center",
          transform: `rotate(${props2.rotate}deg)`
        };
        const svgInner = () => {
          if (props2.image && !slots.content) {
            return vue.createVNode("image", {
              "href": imageBase64.value,
              "xlink:href": imageBase64.value,
              "x": "0",
              "y": "0",
              "width": props2.width,
              "height": props2.height,
              "style": rotateStyle
            }, null);
          }
          return vue.createVNode("foreignObject", {
            "x": "0",
            "y": "0",
            "width": props2.width,
            "height": props2.height
          }, [vue.createVNode("div", {
            "xmlns": "http://www.w3.org/1999/xhtml",
            "style": rotateStyle
          }, [slots.content ? slots.content() : vue.createVNode("span", {
            "style": {
              color: props2.textColor
            }
          }, [props2.content])])]);
        };
        const svgWidth = props2.width + props2.gapX;
        const svgHeight = props2.height + props2.gapY;
        return vue.createVNode("svg", {
          "viewBox": `0 0 ${svgWidth} ${svgHeight}`,
          "width": svgWidth,
          "height": svgHeight,
          "xmlns": "http://www.w3.org/2000/svg",
          "xmlns:xlink": "http://www.w3.org/1999/xlink",
          "style": {
            padding: `0 ${props2.gapX}px ${props2.gapY}px 0`,
            opacity: props2.opacity
          }
        }, [svgInner()]);
      };
      const makeImageToBase64 = (url2) => {
        const canvas = document.createElement("canvas");
        const image2 = new Image();
        image2.crossOrigin = "anonymous";
        image2.referrerPolicy = "no-referrer";
        image2.onload = () => {
          canvas.width = image2.naturalWidth;
          canvas.height = image2.naturalHeight;
          const ctx = canvas.getContext("2d");
          ctx == null ? void 0 : ctx.drawImage(image2, 0, 0);
          imageBase64.value = canvas.toDataURL();
        };
        image2.src = url2;
      };
      const makeSvgToBlobUrl = (svgStr) => {
        const svgBlob = new Blob([svgStr], {
          type: "image/svg+xml"
        });
        return URL.createObjectURL(svgBlob);
      };
      vue.watchEffect(() => {
        if (props2.image) {
          makeImageToBase64(props2.image);
        }
      });
      vue.watch(() => [imageBase64.value, props2.content, props2.textColor, props2.height, props2.width, props2.rotate, props2.gapX, props2.gapY], () => {
        vue.nextTick(() => {
          if (svgElRef.value) {
            if (watermarkUrl.value) {
              URL.revokeObjectURL(watermarkUrl.value);
            }
            watermarkUrl.value = makeSvgToBlobUrl(svgElRef.value.innerHTML);
          }
        });
      }, {
        immediate: true
      });
      vue.onUnmounted(() => {
        if (watermarkUrl.value) {
          URL.revokeObjectURL(watermarkUrl.value);
        }
      });
      return () => {
        const style = extend({
          backgroundImage: `url(${watermarkUrl.value})`
        }, getZIndexStyle(props2.zIndex));
        return vue.createVNode("div", {
          "class": bem({
            full: props2.fullPage
          }),
          "style": style
        }, [vue.createVNode("div", {
          "class": bem("wrapper"),
          "ref": svgElRef
        }, [renderWatermark()])]);
      };
    }
  });
  const Watermark = withInstall(stdin_default$1);
  const version = "4.9.9";
  function install(app) {
    const components = [
      ActionBar,
      ActionBarButton,
      ActionBarIcon,
      ActionSheet,
      AddressEdit,
      AddressList,
      Area,
      BackTop,
      Badge,
      Barrage,
      Button,
      Calendar,
      Card,
      Cascader,
      Cell,
      CellGroup,
      Checkbox,
      CheckboxGroup,
      Circle,
      Col,
      Collapse,
      CollapseItem,
      ConfigProvider,
      ContactCard,
      ContactEdit,
      ContactList,
      CountDown,
      Coupon,
      CouponCell,
      CouponList,
      DatePicker,
      Dialog,
      Divider,
      DropdownItem,
      DropdownMenu,
      Empty,
      Field,
      FloatingBubble,
      FloatingPanel,
      Form,
      Grid,
      GridItem,
      Highlight,
      Icon,
      Image$1,
      ImagePreview,
      IndexAnchor,
      IndexBar,
      List,
      Loading,
      Locale,
      NavBar,
      NoticeBar,
      Notify,
      NumberKeyboard,
      Overlay,
      Pagination,
      PasswordInput,
      Picker,
      PickerGroup,
      Popover,
      Popup,
      Progress,
      PullRefresh,
      Radio,
      RadioGroup,
      Rate,
      RollingText,
      Row,
      Search,
      ShareSheet,
      Sidebar,
      SidebarItem,
      Signature,
      Skeleton,
      SkeletonAvatar,
      SkeletonImage,
      SkeletonParagraph,
      SkeletonTitle,
      Slider,
      Space,
      Step,
      Stepper,
      Steps,
      Sticky,
      SubmitBar,
      Swipe,
      SwipeCell,
      SwipeItem,
      Switch,
      Tab,
      Tabbar,
      TabbarItem,
      Tabs,
      Tag,
      TextEllipsis,
      TimePicker,
      Toast,
      TreeSelect,
      Uploader,
      Watermark
    ];
    components.forEach((item) => {
      if (item.install) {
        app.use(item);
      } else if (item.name) {
        app.component(item.name, item);
      }
    });
  }
  var stdin_default = {
    install,
    version
  };
  ({
    "authorization": uni.getStorageSync("token"),
    "lang": uni.getStorageSync("language"),
    "Authorization": ""
  });
  function request(options) {
    uni.getStorageSync("token");
    return new Promise(async (resolve, reject) => {
      function next() {
        uni.request({
          ...options,
          header: {
            Authorization: uni.getStorageSync("token") || "",
            "tenant-id": 1,
            "content-type": "application/json;charset=UTF-8"
          },
          method: options.methods,
          url: "https://dev.waisj.com:3003" + options.url,
          // url: 'http://192.168.1.13:48080' + options.url,
          success(res) {
            const { code: code2, data, msg } = res.data;
            if (res.statusCode === 401) {
              uni.clearStorageSync();
              uni.navigateTo({
                url: "/pages/login/login"
              });
              return;
            }
            if (res.statusCode === 502) {
              return reject({
                message: "Abnormal service"
              });
            }
            if (res.statusCode === 404) {
              return reject({
                message: `[404] ${options.url}`
              });
            }
            if (res.statusCode === 200) {
              switch (code2) {
                case 0:
                  resolve(data);
                  break;
                case 401:
                  refreshToken();
                  reject({ msg, code: code2 });
                  break;
                default:
                  showToast(msg);
                  uni.hideLoading();
                  reject({ msg, code: code2 });
              }
            }
          },
          fail(err) {
            showToast("Request fail");
            reject({ message: err.errMsg });
          }
        });
      }
      next();
    });
  }
  let requestList = [];
  const refreshToken = async (config2) => {
    const refreshToken2 = getRefreshToken();
    try {
      await request({
        url: "/app-api/member/auth/refresh-token?refreshToken=" + refreshToken2,
        methods: "POST"
      }).then((res) => {
        uni.setStorageSync("token", res.accessToken);
        uni.setStorageSync("refresh-token", res.refreshToken);
        return reload();
      });
    } catch (e2) {
      requestList.forEach((cb) => {
        cb();
      });
      return true;
    } finally {
      requestList = [];
    }
  };
  function reload() {
    const pages2 = getCurrentPages();
    const curPage = pages2[pages2.length - 1];
    curPage.onLoad(curPage.options);
    curPage.onShow();
    curPage.onReady();
  }
  const getRefreshToken = () => {
    return uni.getStorageSync("refresh-token");
  };
  const _sfc_main$o = {
    __name: "login",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        locale,
        t: t2
      } = useI18n();
      const mobile2 = vue.ref("");
      const code2 = vue.ref("");
      const confirmHandle = () => {
        request({
          url: "/admin-api/system/auth/login",
          methods: "POST",
          data: {
            username: mobile2.value,
            password: code2.value,
            captchaVerification: "iHy+rM5L3CGeqbeRh+Rq73DJkevrD8SZMgKdQOnG/GLnJk9RbJntjMgmmrZM2abW3XejjvmQQw51zFpBOp8oNw=="
          }
        }).then((res) => {
          uni.setStorageSync("token", res.accessToken);
          uni.setStorageSync("refresh-token", res.refreshToken);
          uni.showToast({
            title: "Login success",
            icon: "none"
          });
          uni.setStorageSync("staffType", res.staffType);
          uni.setStorageSync("username", res.username);
          uni.navigateTo({
            url: "../tab/index"
          });
          if (res.staffType == 1) {
            locale.value = "en";
            uni.setStorageSync("language", "en");
          } else {
            locale.value = "zh";
            uni.setStorageSync("language", "zh");
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const __returned__ = { locale, t: t2, mobile: mobile2, code: code2, confirmHandle, get request() {
        return request;
      }, get showToast() {
        return showToast;
      }, computed: vue.computed, ref: vue.ref, get useI18n() {
        return useI18n;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "white_bg" }, [
      vue.createElementVNode("view", { class: "pdlr30 mt40" }, [
        vue.createElementVNode(
          "view",
          { class: "f34 text_bold" },
          vue.toDisplayString($setup.t("login.l1")),
          1
          /* TEXT */
        ),
        vue.createElementVNode(
          "view",
          { class: "f20 mt10" },
          vue.toDisplayString($setup.t("login.l2")),
          1
          /* TEXT */
        ),
        vue.createElementVNode("view", { class: "mt50" }, [
          vue.createElementVNode("view", null, "Account"),
          vue.createElementVNode("view", { class: "mt12 pb9 borderB f13" }, [
            vue.withDirectives(vue.createElementVNode("input", {
              type: "text",
              placeholder: $setup.t("login.l4"),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.mobile = $event)
            }, null, 8, ["placeholder"]), [
              [vue.vModelText, $setup.mobile]
            ])
          ])
        ]),
        vue.createElementVNode("view", { class: "mt40" }, [
          vue.createElementVNode(
            "view",
            null,
            vue.toDisplayString($setup.t("login.l5")),
            1
            /* TEXT */
          ),
          vue.createElementVNode("view", { class: "mt12 pb9 borderB f13" }, [
            vue.withDirectives(vue.createElementVNode("input", {
              type: "password",
              placeholder: $setup.t("login.l6"),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.code = $event)
            }, null, 8, ["placeholder"]), [
              [vue.vModelText, $setup.code]
            ])
          ])
        ]),
        vue.createElementVNode("view", { class: "mt60" }, [
          vue.createElementVNode(
            "view",
            {
              class: "btns f14 text_white center",
              onClick: $setup.confirmHandle
            },
            vue.toDisplayString($setup.t("login.l7")),
            1
            /* TEXT */
          )
        ])
      ])
    ]);
  }
  const PagesHomeLogin = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$n], ["__scopeId", "data-v-6a5bfa47"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/login.vue"]]);
  const _sfc_main$n = {
    __name: "topNavbar",
    props: {
      title: {
        type: String
      },
      backIcon: {
        default: "/static/icons/right.png"
      },
      isBig: {
        default: true
      },
      backUrl: {
        default: ""
      },
      isWhiteBg: {
        default: false
      }
    },
    setup(__props, { expose: __expose }) {
      __expose();
      const props2 = __props;
      const isTopFixed = ref(false);
      const topChangeHandle = (e2) => {
        isTopFixed.value = e2;
      };
      const goBack = () => {
        uni.navigateBack();
        return;
      };
      const __returned__ = { props: props2, isTopFixed, topChangeHandle, goBack };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_sticky = vue.resolveComponent("van-sticky");
    return vue.openBlock(), vue.createBlock(_component_van_sticky, {
      "offset-top": 0,
      onChange: $setup.topChangeHandle
    }, {
      default: vue.withCtx(() => [
        vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
          vue.createElementVNode("view", {
            class: "left",
            onClick: $setup.goBack
          }, [
            vue.createElementVNode("image", {
              src: $props.backIcon,
              class: "ww32 hh32"
            }, null, 8, ["src"])
          ]),
          vue.createElementVNode("view", { class: "text_center f17" }, [
            vue.createVNode(_component_van_text_ellipsis, {
              rows: "1",
              content: $props.title,
              class: "text_bold",
              style: { "width": "100%" }
            }, null, 8, ["content"])
          ]),
          vue.createElementVNode("view", {
            class: "right",
            style: { "min-width": "24px" }
          }, [
            vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ])
        ])
      ]),
      _: 3
      /* FORWARDED */
    });
  }
  const topNavbar = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$m], ["__scopeId", "data-v-b9ca3ee9"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/components/topNavbar/topNavbar.vue"]]);
  const _imports_0$2 = "/static/icons/right.png";
  const _imports_1$a = "/static/icons/s1.png";
  const _imports_2$2 = "/static/icons/g_right.png";
  const _imports_3$2 = "/static/icons/s2.png";
  const _sfc_main$m = {
    __name: "index",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        t: t2
      } = useI18n();
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const showPopCenter = vue.ref(false);
      const popConfirmHandle = () => {
        let curLang = uni.getStorageSync("language");
        uni.clearStorageSync();
        uni.setStorageSync("language", curLang);
        uni.navigateTo({
          url: "../home/login"
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { t: t2, changePage, showPopCenter, popConfirmHandle, goBack, topNavbar, get request() {
        return request;
      }, get useI18n() {
        return useI18n;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: $setup.t("setting.s_s1"),
            class: "text_bold",
            style: { "width": "100%" }
          }, null, 8, ["content"])
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createElementVNode("view", { class: "contentBox" }, [
          vue.createElementVNode("view", {
            class: "setItem pb28 between borderB",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("./updatePwd"))
          }, [
            vue.createElementVNode("view", { class: "flex col_center" }, [
              vue.createElementVNode("image", {
                src: _imports_1$a,
                alt: "",
                class: "ww24 hh24"
              }),
              vue.createElementVNode(
                "view",
                { class: "ml8" },
                vue.toDisplayString($setup.t("setting.s_s2")),
                1
                /* TEXT */
              )
            ]),
            vue.createElementVNode("view", null, [
              vue.createElementVNode("image", {
                src: _imports_2$2,
                class: "ww24 hh24"
              })
            ])
          ]),
          vue.createElementVNode("view", {
            class: "setItem between pt28",
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.showPopCenter = true)
          }, [
            vue.createElementVNode("view", { class: "flex col_center" }, [
              vue.createElementVNode("image", {
                src: _imports_3$2,
                alt: "",
                class: "ww24 hh24"
              }),
              vue.createElementVNode(
                "view",
                { class: "ml8" },
                vue.toDisplayString($setup.t("setting.s_s3")),
                1
                /* TEXT */
              )
            ]),
            vue.createElementVNode("view", null, [
              vue.createElementVNode("image", {
                src: _imports_2$2,
                class: "ww24 hh24"
              })
            ])
          ])
        ])
      ]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPopCenter,
        "onUpdate:show": _cache[3] || (_cache[3] = ($event) => $setup.showPopCenter = $event),
        round: "",
        style: { "width": "280px" }
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "pt30 pdlr26" }, [
            vue.createElementVNode(
              "view",
              {
                class: "f15 text_center borderB pb24",
                style: { "line-height": "18px" }
              },
              vue.toDisplayString($setup.t("setting.s_s4")),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", { class: "pdlr20 pdtb16" }, [
            vue.createElementVNode("view", { class: "girdBtn" }, [
              vue.createElementVNode(
                "view",
                {
                  class: "botBtn cancelBtn center color7C",
                  onClick: _cache[2] || (_cache[2] = ($event) => $setup.showPopCenter = false)
                },
                vue.toDisplayString($setup.t("setting.s_s5")),
                1
                /* TEXT */
              ),
              vue.createElementVNode(
                "view",
                {
                  class: "botBtn center text_white confirmBtn",
                  onClick: $setup.popConfirmHandle
                },
                vue.toDisplayString($setup.t("setting.s_s6")),
                1
                /* TEXT */
              )
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"])
    ]);
  }
  const PagesSettingIndex = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$l], ["__scopeId", "data-v-861f37f2"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/setting/index.vue"]]);
  const _sfc_main$l = {
    __name: "updatePwd",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        t: t2
      } = useI18n();
      const username = uni.getStorageSync("username");
      const newPassword = vue.ref("");
      const oldPassword = vue.ref("");
      const confirmHandle = () => {
        request({
          url: "/admin-api/system/user/profile/update-password",
          methods: "PUT",
          data: {
            newPassword: newPassword.value,
            oldPassword: oldPassword.value
          }
        }).then((res) => {
          uni.showToast({
            title: t2("setting.s_j1"),
            icon: "none"
          });
          newPassword.value = "";
          oldPassword.value = "";
          uni.navigateTo({
            url: "../home/login"
          });
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { t: t2, username, newPassword, oldPassword, confirmHandle, goBack, topNavbar, get request() {
        return request;
      }, ref: vue.ref, get useI18n() {
        return useI18n;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: $setup.t("setting.s_t1"),
            class: "text_bold",
            style: { "width": "100%" }
          }, null, 8, ["content"])
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createElementVNode("view", { class: "contentBox" }, [
          vue.createElementVNode("view", { class: "setItem between f14 borderB" }, [
            vue.createElementVNode(
              "view",
              null,
              vue.toDisplayString($setup.t("setting.s_s7")),
              1
              /* TEXT */
            ),
            vue.createElementVNode(
              "view",
              null,
              vue.toDisplayString($setup.username),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", { class: "setItem between f14 borderB" }, [
            vue.createElementVNode(
              "view",
              null,
              vue.toDisplayString($setup.t("setting.s_s8")),
              1
              /* TEXT */
            ),
            vue.withDirectives(vue.createElementVNode("input", {
              type: "password",
              placeholder: $setup.t("setting.s_s9"),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.oldPassword = $event)
            }, null, 8, ["placeholder"]), [
              [vue.vModelText, $setup.oldPassword]
            ])
          ]),
          vue.createElementVNode("view", { class: "setItem between f14" }, [
            vue.createElementVNode(
              "view",
              null,
              vue.toDisplayString($setup.t("setting.s_s10")),
              1
              /* TEXT */
            ),
            vue.withDirectives(vue.createElementVNode("input", {
              type: "password",
              placeholder: $setup.t("setting.s_s9"),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.newPassword = $event)
            }, null, 8, ["placeholder"]), [
              [vue.vModelText, $setup.newPassword]
            ])
          ])
        ]),
        vue.createElementVNode(
          "view",
          {
            class: "btns f14 text_white center",
            onClick: $setup.confirmHandle
          },
          vue.toDisplayString($setup.t("setting.s_s6")),
          1
          /* TEXT */
        )
      ])
    ]);
  }
  const PagesSettingUpdatePwd = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$k], ["__scopeId", "data-v-27874a33"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/setting/updatePwd.vue"]]);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var clipboard = { exports: {} };
  /*!
   * clipboard.js v2.0.11
   * https://clipboardjs.com/
   *
   * Licensed MIT © Zeno Rocha
   */
  (function(module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
      module.exports = factory();
    })(commonjsGlobal, function() {
      return (
        /******/
        function() {
          var __webpack_modules__ = {
            /***/
            686: (
              /***/
              function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
                __webpack_require__2.d(__webpack_exports__, {
                  "default": function() {
                    return (
                      /* binding */
                      clipboard2
                    );
                  }
                });
                var tiny_emitter = __webpack_require__2(279);
                var tiny_emitter_default = /* @__PURE__ */ __webpack_require__2.n(tiny_emitter);
                var listen = __webpack_require__2(370);
                var listen_default = /* @__PURE__ */ __webpack_require__2.n(listen);
                var src_select = __webpack_require__2(817);
                var select_default = /* @__PURE__ */ __webpack_require__2.n(src_select);
                function command(type) {
                  try {
                    return document.execCommand(type);
                  } catch (err) {
                    return false;
                  }
                }
                var ClipboardActionCut = function ClipboardActionCut2(target) {
                  var selectedText = select_default()(target);
                  command("cut");
                  return selectedText;
                };
                var actions_cut = ClipboardActionCut;
                function createFakeElement(value) {
                  var isRTL = document.documentElement.getAttribute("dir") === "rtl";
                  var fakeElement = document.createElement("textarea");
                  fakeElement.style.fontSize = "12pt";
                  fakeElement.style.border = "0";
                  fakeElement.style.padding = "0";
                  fakeElement.style.margin = "0";
                  fakeElement.style.position = "absolute";
                  fakeElement.style[isRTL ? "right" : "left"] = "-9999px";
                  var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                  fakeElement.style.top = "".concat(yPosition, "px");
                  fakeElement.setAttribute("readonly", "");
                  fakeElement.value = value;
                  return fakeElement;
                }
                var fakeCopyAction = function fakeCopyAction2(value, options) {
                  var fakeElement = createFakeElement(value);
                  options.container.appendChild(fakeElement);
                  var selectedText = select_default()(fakeElement);
                  command("copy");
                  fakeElement.remove();
                  return selectedText;
                };
                var ClipboardActionCopy = function ClipboardActionCopy2(target) {
                  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                    container: document.body
                  };
                  var selectedText = "";
                  if (typeof target === "string") {
                    selectedText = fakeCopyAction(target, options);
                  } else if (target instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(target === null || target === void 0 ? void 0 : target.type)) {
                    selectedText = fakeCopyAction(target.value, options);
                  } else {
                    selectedText = select_default()(target);
                    command("copy");
                  }
                  return selectedText;
                };
                var actions_copy = ClipboardActionCopy;
                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof2(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof = function _typeof2(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof(obj);
                }
                var ClipboardActionDefault = function ClipboardActionDefault2() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var _options$action = options.action, action = _options$action === void 0 ? "copy" : _options$action, container = options.container, target = options.target, text = options.text;
                  if (action !== "copy" && action !== "cut") {
                    throw new Error('Invalid "action" value, use either "copy" or "cut"');
                  }
                  if (target !== void 0) {
                    if (target && _typeof(target) === "object" && target.nodeType === 1) {
                      if (action === "copy" && target.hasAttribute("disabled")) {
                        throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                      }
                      if (action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                        throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                      }
                    } else {
                      throw new Error('Invalid "target" value, use a valid Element');
                    }
                  }
                  if (text) {
                    return actions_copy(text, {
                      container
                    });
                  }
                  if (target) {
                    return action === "cut" ? actions_cut(target) : actions_copy(target, {
                      container
                    });
                  }
                };
                var actions_default = ClipboardActionDefault;
                function clipboard_typeof(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    clipboard_typeof = function _typeof2(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    clipboard_typeof = function _typeof2(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return clipboard_typeof(obj);
                }
                function _classCallCheck(instance2, Constructor) {
                  if (!(instance2 instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props2) {
                  for (var i2 = 0; i2 < props2.length; i2++) {
                    var descriptor = props2[i2];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o2, p2) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
                    o3.__proto__ = p3;
                    return o3;
                  };
                  return _setPrototypeOf(o2, p2);
                }
                function _createSuper(Derived) {
                  var hasNativeReflectConstruct = _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super = _getPrototypeOf(Derived), result;
                    if (hasNativeReflectConstruct) {
                      var NewTarget = _getPrototypeOf(this).constructor;
                      result = Reflect.construct(Super, arguments, NewTarget);
                    } else {
                      result = Super.apply(this, arguments);
                    }
                    return _possibleConstructorReturn(this, result);
                  };
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _isNativeReflectConstruct() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                    }));
                    return true;
                  } catch (e2) {
                    return false;
                  }
                }
                function _getPrototypeOf(o2) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
                    return o3.__proto__ || Object.getPrototypeOf(o3);
                  };
                  return _getPrototypeOf(o2);
                }
                function getAttributeValue(suffix, element) {
                  var attribute = "data-clipboard-".concat(suffix);
                  if (!element.hasAttribute(attribute)) {
                    return;
                  }
                  return element.getAttribute(attribute);
                }
                var Clipboard2 = /* @__PURE__ */ function(_Emitter) {
                  _inherits(Clipboard3, _Emitter);
                  var _super = _createSuper(Clipboard3);
                  function Clipboard3(trigger, options) {
                    var _this;
                    _classCallCheck(this, Clipboard3);
                    _this = _super.call(this);
                    _this.resolveOptions(options);
                    _this.listenClick(trigger);
                    return _this;
                  }
                  _createClass(Clipboard3, [{
                    key: "resolveOptions",
                    value: function resolveOptions() {
                      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                      this.action = typeof options.action === "function" ? options.action : this.defaultAction;
                      this.target = typeof options.target === "function" ? options.target : this.defaultTarget;
                      this.text = typeof options.text === "function" ? options.text : this.defaultText;
                      this.container = clipboard_typeof(options.container) === "object" ? options.container : document.body;
                    }
                    /**
                     * Adds a click event listener to the passed trigger.
                     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                     */
                  }, {
                    key: "listenClick",
                    value: function listenClick(trigger) {
                      var _this2 = this;
                      this.listener = listen_default()(trigger, "click", function(e2) {
                        return _this2.onClick(e2);
                      });
                    }
                    /**
                     * Defines a new `ClipboardAction` on each click event.
                     * @param {Event} e
                     */
                  }, {
                    key: "onClick",
                    value: function onClick(e2) {
                      var trigger = e2.delegateTarget || e2.currentTarget;
                      var action = this.action(trigger) || "copy";
                      var text = actions_default({
                        action,
                        container: this.container,
                        target: this.target(trigger),
                        text: this.text(trigger)
                      });
                      this.emit(text ? "success" : "error", {
                        action,
                        text,
                        trigger,
                        clearSelection: function clearSelection() {
                          if (trigger) {
                            trigger.focus();
                          }
                          window.getSelection().removeAllRanges();
                        }
                      });
                    }
                    /**
                     * Default `action` lookup function.
                     * @param {Element} trigger
                     */
                  }, {
                    key: "defaultAction",
                    value: function defaultAction(trigger) {
                      return getAttributeValue("action", trigger);
                    }
                    /**
                     * Default `target` lookup function.
                     * @param {Element} trigger
                     */
                  }, {
                    key: "defaultTarget",
                    value: function defaultTarget(trigger) {
                      var selector = getAttributeValue("target", trigger);
                      if (selector) {
                        return document.querySelector(selector);
                      }
                    }
                    /**
                     * Allow fire programmatically a copy action
                     * @param {String|HTMLElement} target
                     * @param {Object} options
                     * @returns Text copied.
                     */
                  }, {
                    key: "defaultText",
                    /**
                     * Default `text` lookup function.
                     * @param {Element} trigger
                     */
                    value: function defaultText(trigger) {
                      return getAttributeValue("text", trigger);
                    }
                    /**
                     * Destroy lifecycle.
                     */
                  }, {
                    key: "destroy",
                    value: function destroy() {
                      this.listener.destroy();
                    }
                  }], [{
                    key: "copy",
                    value: function copy(target) {
                      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                        container: document.body
                      };
                      return actions_copy(target, options);
                    }
                    /**
                     * Allow fire programmatically a cut action
                     * @param {String|HTMLElement} target
                     * @returns Text cutted.
                     */
                  }, {
                    key: "cut",
                    value: function cut(target) {
                      return actions_cut(target);
                    }
                    /**
                     * Returns the support of the given action, or all actions if no action is
                     * given.
                     * @param {String} [action]
                     */
                  }, {
                    key: "isSupported",
                    value: function isSupported() {
                      var action = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"];
                      var actions = typeof action === "string" ? [action] : action;
                      var support = !!document.queryCommandSupported;
                      actions.forEach(function(action2) {
                        support = support && !!document.queryCommandSupported(action2);
                      });
                      return support;
                    }
                  }]);
                  return Clipboard3;
                }(tiny_emitter_default());
                var clipboard2 = Clipboard2;
              }
            ),
            /***/
            828: (
              /***/
              function(module2) {
                var DOCUMENT_NODE_TYPE = 9;
                if (typeof Element !== "undefined" && !Element.prototype.matches) {
                  var proto = Element.prototype;
                  proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
                }
                function closest2(element, selector) {
                  while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                    if (typeof element.matches === "function" && element.matches(selector)) {
                      return element;
                    }
                    element = element.parentNode;
                  }
                }
                module2.exports = closest2;
              }
            ),
            /***/
            438: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var closest2 = __webpack_require__2(828);
                function _delegate(element, selector, type, callback, useCapture) {
                  var listenerFn = listener.apply(this, arguments);
                  element.addEventListener(type, listenerFn, useCapture);
                  return {
                    destroy: function() {
                      element.removeEventListener(type, listenerFn, useCapture);
                    }
                  };
                }
                function delegate(elements, selector, type, callback, useCapture) {
                  if (typeof elements.addEventListener === "function") {
                    return _delegate.apply(null, arguments);
                  }
                  if (typeof type === "function") {
                    return _delegate.bind(null, document).apply(null, arguments);
                  }
                  if (typeof elements === "string") {
                    elements = document.querySelectorAll(elements);
                  }
                  return Array.prototype.map.call(elements, function(element) {
                    return _delegate(element, selector, type, callback, useCapture);
                  });
                }
                function listener(element, selector, type, callback) {
                  return function(e2) {
                    e2.delegateTarget = closest2(e2.target, selector);
                    if (e2.delegateTarget) {
                      callback.call(element, e2);
                    }
                  };
                }
                module2.exports = delegate;
              }
            ),
            /***/
            879: (
              /***/
              function(__unused_webpack_module, exports2) {
                exports2.node = function(value) {
                  return value !== void 0 && value instanceof HTMLElement && value.nodeType === 1;
                };
                exports2.nodeList = function(value) {
                  var type = Object.prototype.toString.call(value);
                  return value !== void 0 && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports2.node(value[0]));
                };
                exports2.string = function(value) {
                  return typeof value === "string" || value instanceof String;
                };
                exports2.fn = function(value) {
                  var type = Object.prototype.toString.call(value);
                  return type === "[object Function]";
                };
              }
            ),
            /***/
            370: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var is = __webpack_require__2(879);
                var delegate = __webpack_require__2(438);
                function listen(target, type, callback) {
                  if (!target && !type && !callback) {
                    throw new Error("Missing required arguments");
                  }
                  if (!is.string(type)) {
                    throw new TypeError("Second argument must be a String");
                  }
                  if (!is.fn(callback)) {
                    throw new TypeError("Third argument must be a Function");
                  }
                  if (is.node(target)) {
                    return listenNode(target, type, callback);
                  } else if (is.nodeList(target)) {
                    return listenNodeList(target, type, callback);
                  } else if (is.string(target)) {
                    return listenSelector(target, type, callback);
                  } else {
                    throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
                  }
                }
                function listenNode(node, type, callback) {
                  node.addEventListener(type, callback);
                  return {
                    destroy: function() {
                      node.removeEventListener(type, callback);
                    }
                  };
                }
                function listenNodeList(nodeList, type, callback) {
                  Array.prototype.forEach.call(nodeList, function(node) {
                    node.addEventListener(type, callback);
                  });
                  return {
                    destroy: function() {
                      Array.prototype.forEach.call(nodeList, function(node) {
                        node.removeEventListener(type, callback);
                      });
                    }
                  };
                }
                function listenSelector(selector, type, callback) {
                  return delegate(document.body, selector, type, callback);
                }
                module2.exports = listen;
              }
            ),
            /***/
            817: (
              /***/
              function(module2) {
                function select(element) {
                  var selectedText;
                  if (element.nodeName === "SELECT") {
                    element.focus();
                    selectedText = element.value;
                  } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
                    var isReadOnly = element.hasAttribute("readonly");
                    if (!isReadOnly) {
                      element.setAttribute("readonly", "");
                    }
                    element.select();
                    element.setSelectionRange(0, element.value.length);
                    if (!isReadOnly) {
                      element.removeAttribute("readonly");
                    }
                    selectedText = element.value;
                  } else {
                    if (element.hasAttribute("contenteditable")) {
                      element.focus();
                    }
                    var selection = window.getSelection();
                    var range2 = document.createRange();
                    range2.selectNodeContents(element);
                    selection.removeAllRanges();
                    selection.addRange(range2);
                    selectedText = selection.toString();
                  }
                  return selectedText;
                }
                module2.exports = select;
              }
            ),
            /***/
            279: (
              /***/
              function(module2) {
                function E() {
                }
                E.prototype = {
                  on: function(name2, callback, ctx) {
                    var e2 = this.e || (this.e = {});
                    (e2[name2] || (e2[name2] = [])).push({
                      fn: callback,
                      ctx
                    });
                    return this;
                  },
                  once: function(name2, callback, ctx) {
                    var self2 = this;
                    function listener() {
                      self2.off(name2, listener);
                      callback.apply(ctx, arguments);
                    }
                    listener._ = callback;
                    return this.on(name2, listener, ctx);
                  },
                  emit: function(name2) {
                    var data = [].slice.call(arguments, 1);
                    var evtArr = ((this.e || (this.e = {}))[name2] || []).slice();
                    var i2 = 0;
                    var len = evtArr.length;
                    for (i2; i2 < len; i2++) {
                      evtArr[i2].fn.apply(evtArr[i2].ctx, data);
                    }
                    return this;
                  },
                  off: function(name2, callback) {
                    var e2 = this.e || (this.e = {});
                    var evts = e2[name2];
                    var liveEvents = [];
                    if (evts && callback) {
                      for (var i2 = 0, len = evts.length; i2 < len; i2++) {
                        if (evts[i2].fn !== callback && evts[i2].fn._ !== callback)
                          liveEvents.push(evts[i2]);
                      }
                    }
                    liveEvents.length ? e2[name2] = liveEvents : delete e2[name2];
                    return this;
                  }
                };
                module2.exports = E;
                module2.exports.TinyEmitter = E;
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            if (__webpack_module_cache__[moduleId]) {
              return __webpack_module_cache__[moduleId].exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          !function() {
            __webpack_require__.n = function(module2) {
              var getter = module2 && module2.__esModule ? (
                /******/
                function() {
                  return module2["default"];
                }
              ) : (
                /******/
                function() {
                  return module2;
                }
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          }();
          !function() {
            __webpack_require__.d = function(exports2, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          }();
          !function() {
            __webpack_require__.o = function(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            };
          }();
          return __webpack_require__(686);
        }().default
      );
    });
  })(clipboard);
  var clipboardExports = clipboard.exports;
  const Clipboard = /* @__PURE__ */ getDefaultExportFromCjs(clipboardExports);
  const useClipboard = (opts) => {
    const appendToBody = (opts === null || opts === void 0 ? void 0 : opts.appendToBody) === void 0 ? true : opts.appendToBody;
    return {
      toClipboard(text, container) {
        return new Promise((resolve, reject) => {
          const fakeEl = document.createElement("button");
          const clipboard2 = new Clipboard(fakeEl, {
            text: () => text,
            action: () => "copy",
            container: container !== void 0 ? container : document.body
          });
          clipboard2.on("success", (e2) => {
            clipboard2.destroy();
            resolve(e2);
          });
          clipboard2.on("error", (e2) => {
            clipboard2.destroy();
            reject(e2);
          });
          if (appendToBody)
            document.body.appendChild(fakeEl);
          fakeEl.click();
          if (appendToBody)
            document.body.removeChild(fakeEl);
        });
      }
    };
  };
  const _imports_1$9 = "/static/icons/b_copy.png";
  const _sfc_main$k = {
    __name: "recive",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const copyHandle = async (data) => {
        uni.setClipboardData({
          data,
          success: function() {
            uni.showToast({
              title: "Copy Success",
              icon: "none"
            });
          }
        });
      };
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const pages2 = vue.ref({
        pageSize: 10,
        pageNo: 1
      });
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pageData = vue.ref("");
      const codeVal = vue.ref("");
      onLoad((e2) => {
        if (e2.code) {
          codeVal.value = e2.code;
          queryList();
        }
      });
      const queryList = () => {
        request({
          url: "/admin-api/storage/local/goods/get-logistics-info/" + codeVal.value
        }).then((res) => {
          pageData.value = res;
          dataList.value = res.orderSheetList;
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { toClipboard, copyHandle, changePage, pages: pages2, dataList, paging, pageData, codeVal, queryList, goBack, get request() {
        return request;
      }, ref: vue.ref, get showToast() {
        return showToast;
      }, get useClipboard() {
        return useClipboard;
      }, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "收货",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt20 pdlr12" }, [
        vue.createElementVNode("view", { class: "color7C" }, " 供应商物流单号 "),
        vue.createElementVNode("view", { class: "mt12 copyBox between" }, [
          vue.createElementVNode(
            "view",
            { class: "f20 text_bold" },
            vue.toDisplayString($setup.pageData.supplierLogisticsNo),
            1
            /* TEXT */
          ),
          vue.createElementVNode("image", {
            src: _imports_1$9,
            class: "ww18 hh18",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.copyHandle($setup.pageData.supplierLogisticsNo))
          })
        ]),
        vue.createElementVNode(
          "view",
          { class: "mt30 f13 color7C" },
          vue.toDisplayString($setup.pageData.categoryName) + " x" + vue.toDisplayString($setup.pageData.goodsNum),
          1
          /* TEXT */
        ),
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($setup.dataList, (item, index2) => {
            return vue.openBlock(), vue.createElementBlock("view", {
              class: "copyBox mt12 between",
              key: index2
            }, [
              vue.createElementVNode("view", null, [
                vue.createElementVNode(
                  "view",
                  { class: "f15" },
                  vue.toDisplayString(item.receiverName + " " + item.receiverMobile),
                  1
                  /* TEXT */
                ),
                vue.createElementVNode(
                  "view",
                  { class: "mt4 f12 colorAf" },
                  " 单号:" + vue.toDisplayString(item.orderNo),
                  1
                  /* TEXT */
                )
              ])
            ]);
          }),
          128
          /* KEYED_FRAGMENT */
        )),
        vue.createCommentVNode(" </z-paging> ")
      ]),
      vue.createElementVNode("view", { style: { "height": "100px" } }),
      vue.createElementVNode("view", { class: "fixedBot" }, [
        vue.createElementVNode("view", { class: "pdlr12 pb10" }, [
          vue.createElementVNode("view", {
            class: "botBtn center text_white confirmBtn",
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.changePage("./reciveSuccess"))
          }, "Confirm")
        ])
      ])
    ]);
  }
  const PagesGdRecive = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$j], ["__scopeId", "data-v-be889817"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/recive.vue"]]);
  const _imports_0$1 = "/static/bg/recSuc.png";
  const _sfc_main$j = {
    __name: "reciveSuccess",
    setup(__props, { expose: __expose }) {
      __expose();
      const scanVal = vue.ref(0);
      onLoad((e2) => {
        if (e2.code) {
          scanVal.value = e2.code;
        }
      });
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const __returned__ = { scanVal, changePage, onMounted: vue.onMounted, ref: vue.ref, topNavbar, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10" }, [
        vue.createElementVNode("view", { class: "ww50" }),
        vue.createElementVNode("view", { class: "text_bold f17" }, "结果反馈"),
        vue.createElementVNode("view", { class: "ww50" })
      ]),
      vue.createElementVNode("view", { class: "pdlr20 mt73" }, [
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("image", {
            src: _imports_0$1,
            style: { "width": "69px", "height": "94px" }
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f20 text_bold mt20" }, " 收货成功 "),
        vue.createElementVNode("view", {
          class: "colorAf pdlr35 f12 mt8 text_center",
          style: { "line-height": "18px" }
        }, " 请将打印出的面单贴到对应的包裹上 "),
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("view", {
            class: "center botBtn",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("../tab/index"))
          }, [
            vue.createElementVNode("view", { class: "f14 ml8" }, " 返回首页 ")
          ])
        ])
      ])
    ]);
  }
  const PagesGdReciveSuccess = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$i], ["__scopeId", "data-v-4c341c0d"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/reciveSuccess.vue"]]);
  var isVue2 = false;
  function set(target, key, val) {
    if (Array.isArray(target)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    target[key] = val;
    return val;
  }
  function del(target, key) {
    if (Array.isArray(target)) {
      target.splice(key, 1);
      return;
    }
    delete target[key];
  }
  function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  }
  const isProxyAvailable = typeof Proxy === "function";
  const HOOK_SETUP = "devtools-plugin:setup";
  const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
  let supported;
  let perf;
  function isPerformanceSupported() {
    var _a;
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
      supported = true;
      perf = global.perf_hooks.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
  }
  class ApiProxy {
    constructor(plugin, hook) {
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      const defaultSettings = {};
      if (plugin.settings) {
        for (const id in plugin.settings) {
          const item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
      let currentSettings = Object.assign({}, defaultSettings);
      try {
        const raw = localStorage.getItem(localSettingsSaveId);
        const data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e2) {
      }
      this.fallbacks = {
        getSettings() {
          return currentSettings;
        },
        setSettings(value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e2) {
          }
          currentSettings = value;
        },
        now() {
          return now();
        }
      };
      if (hook) {
        hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
          if (pluginId === this.plugin.id) {
            this.fallbacks.setSettings(value);
          }
        });
      }
      this.proxiedOn = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target.on[prop];
          } else {
            return (...args) => {
              this.onQueue.push({
                method: prop,
                args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target[prop];
          } else if (prop === "on") {
            return this.proxiedOn;
          } else if (Object.keys(this.fallbacks).includes(prop)) {
            return (...args) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: () => {
                }
              });
              return this.fallbacks[prop](...args);
            };
          } else {
            return (...args) => {
              return new Promise((resolve) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve
                });
              });
            };
          }
        }
      });
    }
    async setRealTarget(target) {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(await this.target[item.method](...item.args));
      }
    }
  }
  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = getTarget();
    const hook = getDevtoolsGlobalHook();
    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    } else {
      const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
      const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor: descriptor,
        setupFn,
        proxy
      });
      if (proxy)
        setupFn(proxy.proxiedTarget);
    }
  }
  /*!
   * pinia v2.1.7
   * (c) 2023 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia2) => activePinia = pinia2;
  const piniaSymbol = Symbol("pinia");
  function isPlainObject(o2) {
    return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  const IS_CLIENT = typeof window !== "undefined";
  const USE_DEVTOOLS = IS_CLIENT;
  const _global = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
  function bom(blob, { autoBom = false } = {}) {
    if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
      return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
    }
    return blob;
  }
  function download(url2, name2, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url2);
    xhr.responseType = "blob";
    xhr.onload = function() {
      saveAs(xhr.response, name2, opts);
    };
    xhr.onerror = function() {
      console.error("could not download file");
    };
    xhr.send();
  }
  function corsEnabled(url2) {
    const xhr = new XMLHttpRequest();
    xhr.open("HEAD", url2, false);
    try {
      xhr.send();
    } catch (e2) {
    }
    return xhr.status >= 200 && xhr.status <= 299;
  }
  function click(node) {
    try {
      node.dispatchEvent(new MouseEvent("click"));
    } catch (e2) {
      const evt = document.createEvent("MouseEvents");
      evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      node.dispatchEvent(evt);
    }
  }
  const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
  const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
  const saveAs = !IS_CLIENT ? () => {
  } : (
    // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
    typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
      // Use msSaveOrOpenBlob as a second approach
      "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
        // Fallback to using FileReader and a popup
        fileSaverSaveAs
      )
    )
  );
  function downloadSaveAs(blob, name2 = "download", opts) {
    const a2 = document.createElement("a");
    a2.download = name2;
    a2.rel = "noopener";
    if (typeof blob === "string") {
      a2.href = blob;
      if (a2.origin !== location.origin) {
        if (corsEnabled(a2.href)) {
          download(blob, name2, opts);
        } else {
          a2.target = "_blank";
          click(a2);
        }
      } else {
        click(a2);
      }
    } else {
      a2.href = URL.createObjectURL(blob);
      setTimeout(function() {
        URL.revokeObjectURL(a2.href);
      }, 4e4);
      setTimeout(function() {
        click(a2);
      }, 0);
    }
  }
  function msSaveAs(blob, name2 = "download", opts) {
    if (typeof blob === "string") {
      if (corsEnabled(blob)) {
        download(blob, name2, opts);
      } else {
        const a2 = document.createElement("a");
        a2.href = blob;
        a2.target = "_blank";
        setTimeout(function() {
          click(a2);
        });
      }
    } else {
      navigator.msSaveOrOpenBlob(bom(blob, opts), name2);
    }
  }
  function fileSaverSaveAs(blob, name2, opts, popup) {
    popup = popup || open("", "_blank");
    if (popup) {
      popup.document.title = popup.document.body.innerText = "downloading...";
    }
    if (typeof blob === "string")
      return download(blob, name2, opts);
    const force = blob.type === "application/octet-stream";
    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== "undefined") {
      const reader = new FileReader();
      reader.onloadend = function() {
        let url2 = reader.result;
        if (typeof url2 !== "string") {
          popup = null;
          throw new Error("Wrong reader.result type");
        }
        url2 = isChromeIOS ? url2 : url2.replace(/^data:[^;]*;/, "data:attachment/file;");
        if (popup) {
          popup.location.href = url2;
        } else {
          location.assign(url2);
        }
        popup = null;
      };
      reader.readAsDataURL(blob);
    } else {
      const url2 = URL.createObjectURL(blob);
      if (popup)
        popup.location.assign(url2);
      else
        location.href = url2;
      popup = null;
      setTimeout(function() {
        URL.revokeObjectURL(url2);
      }, 4e4);
    }
  }
  function toastMessage(message, type) {
    const piniaMessage = "🍍 " + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
      __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    } else if (type === "error") {
      console.error(piniaMessage);
    } else if (type === "warn") {
      console.warn(piniaMessage);
    } else {
      console.log(piniaMessage);
    }
  }
  function isPinia(o2) {
    return "_a" in o2 && "install" in o2;
  }
  function checkClipboardAccess() {
    if (!("clipboard" in navigator)) {
      toastMessage(`Your browser doesn't support the Clipboard API`, "error");
      return true;
    }
  }
  function checkNotFocusedError(error2) {
    if (error2 instanceof Error && error2.message.toLowerCase().includes("document is not focused")) {
      toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
      return true;
    }
    return false;
  }
  async function actionGlobalCopyState(pinia2) {
    if (checkClipboardAccess())
      return;
    try {
      await navigator.clipboard.writeText(JSON.stringify(pinia2.state.value));
      toastMessage("Global state copied to clipboard.");
    } catch (error2) {
      if (checkNotFocusedError(error2))
        return;
      toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
      console.error(error2);
    }
  }
  async function actionGlobalPasteState(pinia2) {
    if (checkClipboardAccess())
      return;
    try {
      loadStoresState(pinia2, JSON.parse(await navigator.clipboard.readText()));
      toastMessage("Global state pasted from clipboard.");
    } catch (error2) {
      if (checkNotFocusedError(error2))
        return;
      toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
      console.error(error2);
    }
  }
  async function actionGlobalSaveState(pinia2) {
    try {
      saveAs(new Blob([JSON.stringify(pinia2.state.value)], {
        type: "text/plain;charset=utf-8"
      }), "pinia-state.json");
    } catch (error2) {
      toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
      console.error(error2);
    }
  }
  let fileInput;
  function getFileOpener() {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = ".json";
    }
    function openFile() {
      return new Promise((resolve, reject) => {
        fileInput.onchange = async () => {
          const files = fileInput.files;
          if (!files)
            return resolve(null);
          const file = files.item(0);
          if (!file)
            return resolve(null);
          return resolve({ text: await file.text(), file });
        };
        fileInput.oncancel = () => resolve(null);
        fileInput.onerror = reject;
        fileInput.click();
      });
    }
    return openFile;
  }
  async function actionGlobalOpenStateFile(pinia2) {
    try {
      const open2 = getFileOpener();
      const result = await open2();
      if (!result)
        return;
      const { text, file } = result;
      loadStoresState(pinia2, JSON.parse(text));
      toastMessage(`Global state imported from "${file.name}".`);
    } catch (error2) {
      toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
      console.error(error2);
    }
  }
  function loadStoresState(pinia2, state) {
    for (const key in state) {
      const storeState = pinia2.state.value[key];
      if (storeState) {
        Object.assign(storeState, state[key]);
      } else {
        pinia2.state.value[key] = state[key];
      }
    }
  }
  function formatDisplay(display) {
    return {
      _custom: {
        display
      }
    };
  }
  const PINIA_ROOT_LABEL = "🍍 Pinia (root)";
  const PINIA_ROOT_ID = "_root";
  function formatStoreForInspectorTree(store) {
    return isPinia(store) ? {
      id: PINIA_ROOT_ID,
      label: PINIA_ROOT_LABEL
    } : {
      id: store.$id,
      label: store.$id
    };
  }
  function formatStoreForInspectorState(store) {
    if (isPinia(store)) {
      const storeNames = Array.from(store._s.keys());
      const storeMap = store._s;
      const state2 = {
        state: storeNames.map((storeId) => ({
          editable: true,
          key: storeId,
          value: store.state.value[storeId]
        })),
        getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {
          const store2 = storeMap.get(id);
          return {
            editable: false,
            key: id,
            value: store2._getters.reduce((getters, key) => {
              getters[key] = store2[key];
              return getters;
            }, {})
          };
        })
      };
      return state2;
    }
    const state = {
      state: Object.keys(store.$state).map((key) => ({
        editable: true,
        key,
        value: store.$state[key]
      }))
    };
    if (store._getters && store._getters.length) {
      state.getters = store._getters.map((getterName) => ({
        editable: false,
        key: getterName,
        value: store[getterName]
      }));
    }
    if (store._customProperties.size) {
      state.customProperties = Array.from(store._customProperties).map((key) => ({
        editable: true,
        key,
        value: store[key]
      }));
    }
    return state;
  }
  function formatEventData(events) {
    if (!events)
      return {};
    if (Array.isArray(events)) {
      return events.reduce((data, event) => {
        data.keys.push(event.key);
        data.operations.push(event.type);
        data.oldValue[event.key] = event.oldValue;
        data.newValue[event.key] = event.newValue;
        return data;
      }, {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
      });
    } else {
      return {
        operation: formatDisplay(events.type),
        key: formatDisplay(events.key),
        oldValue: events.oldValue,
        newValue: events.newValue
      };
    }
  }
  function formatMutationType(type) {
    switch (type) {
      case MutationType.direct:
        return "mutation";
      case MutationType.patchFunction:
        return "$patch";
      case MutationType.patchObject:
        return "$patch";
      default:
        return "unknown";
    }
  }
  let isTimelineActive = true;
  const componentStateTypes = [];
  const MUTATIONS_LAYER_ID = "pinia:mutations";
  const INSPECTOR_ID = "pinia";
  const { assign: assign$1 } = Object;
  const getStoreType = (id) => "🍍 " + id;
  function registerPiniaDevtools(app, pinia2) {
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia 🍍",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app
    }, (api) => {
      if (typeof api.now !== "function") {
        toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
      }
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: `Pinia 🍍`,
        color: 15064968
      });
      api.addInspector({
        id: INSPECTOR_ID,
        label: "Pinia 🍍",
        icon: "storage",
        treeFilterPlaceholder: "Search stores",
        actions: [
          {
            icon: "content_copy",
            action: () => {
              actionGlobalCopyState(pinia2);
            },
            tooltip: "Serialize and copy the state"
          },
          {
            icon: "content_paste",
            action: async () => {
              await actionGlobalPasteState(pinia2);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Replace the state with the content of your clipboard"
          },
          {
            icon: "save",
            action: () => {
              actionGlobalSaveState(pinia2);
            },
            tooltip: "Save the state as a JSON file"
          },
          {
            icon: "folder_open",
            action: async () => {
              await actionGlobalOpenStateFile(pinia2);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Import the state from a JSON file"
          }
        ],
        nodeActions: [
          {
            icon: "restore",
            tooltip: 'Reset the state (with "$reset")',
            action: (nodeId) => {
              const store = pinia2._s.get(nodeId);
              if (!store) {
                toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
              } else if (typeof store.$reset !== "function") {
                toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
              } else {
                store.$reset();
                toastMessage(`Store "${nodeId}" reset.`);
              }
            }
          }
        ]
      });
      api.on.inspectComponent((payload, ctx) => {
        const proxy = payload.componentInstance && payload.componentInstance.proxy;
        if (proxy && proxy._pStores) {
          const piniaStores = payload.componentInstance.proxy._pStores;
          Object.values(piniaStores).forEach((store) => {
            payload.instanceData.state.push({
              type: getStoreType(store.$id),
              key: "state",
              editable: true,
              value: store._isOptionsAPI ? {
                _custom: {
                  value: vue.toRaw(store.$state),
                  actions: [
                    {
                      icon: "restore",
                      tooltip: "Reset the state of this store",
                      action: () => store.$reset()
                    }
                  ]
                }
              } : (
                // NOTE: workaround to unwrap transferred refs
                Object.keys(store.$state).reduce((state, key) => {
                  state[key] = store.$state[key];
                  return state;
                }, {})
              )
            });
            if (store._getters && store._getters.length) {
              payload.instanceData.state.push({
                type: getStoreType(store.$id),
                key: "getters",
                editable: false,
                value: store._getters.reduce((getters, key) => {
                  try {
                    getters[key] = store[key];
                  } catch (error2) {
                    getters[key] = error2;
                  }
                  return getters;
                }, {})
              });
            }
          });
        }
      });
      api.on.getInspectorTree((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          let stores = [pinia2];
          stores = stores.concat(Array.from(pinia2._s.values()));
          payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
        }
      });
      api.on.getInspectorState((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
          if (!inspectedStore) {
            return;
          }
          if (inspectedStore) {
            payload.state = formatStoreForInspectorState(inspectedStore);
          }
        }
      });
      api.on.editInspectorState((payload, ctx) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
          if (!inspectedStore) {
            return toastMessage(`store "${payload.nodeId}" not found`, "error");
          }
          const { path } = payload;
          if (!isPinia(inspectedStore)) {
            if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
              path.unshift("$state");
            }
          } else {
            path.unshift("state");
          }
          isTimelineActive = false;
          payload.set(inspectedStore, path, payload.state.value);
          isTimelineActive = true;
        }
      });
      api.on.editComponentState((payload) => {
        if (payload.type.startsWith("🍍")) {
          const storeId = payload.type.replace(/^🍍\s*/, "");
          const store = pinia2._s.get(storeId);
          if (!store) {
            return toastMessage(`store "${storeId}" not found`, "error");
          }
          const { path } = payload;
          if (path[0] !== "state") {
            return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
          }
          path[0] = "$state";
          isTimelineActive = false;
          payload.set(store, path, payload.state.value);
          isTimelineActive = true;
        }
      });
    });
  }
  function addStoreToDevtools(app, store) {
    if (!componentStateTypes.includes(getStoreType(store.$id))) {
      componentStateTypes.push(getStoreType(store.$id));
    }
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia 🍍",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app,
      settings: {
        logStoreChanges: {
          label: "Notify about new/deleted stores",
          type: "boolean",
          defaultValue: true
        }
        // useEmojis: {
        //   label: 'Use emojis in messages ⚡️',
        //   type: 'boolean',
        //   defaultValue: true,
        // },
      }
    }, (api) => {
      const now2 = typeof api.now === "function" ? api.now.bind(api) : Date.now;
      store.$onAction(({ after, onError, name: name2, args }) => {
        const groupId = runningActionId++;
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "🛫 " + name2,
            subtitle: "start",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name2),
              args
            },
            groupId
          }
        });
        after((result) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "🛬 " + name2,
              subtitle: "end",
              data: {
                store: formatDisplay(store.$id),
                action: formatDisplay(name2),
                args,
                result
              },
              groupId
            }
          });
        });
        onError((error2) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              logType: "error",
              title: "💥 " + name2,
              subtitle: "end",
              data: {
                store: formatDisplay(store.$id),
                action: formatDisplay(name2),
                args,
                error: error2
              },
              groupId
            }
          });
        });
      }, true);
      store._customProperties.forEach((name2) => {
        vue.watch(() => vue.unref(store[name2]), (newValue, oldValue) => {
          api.notifyComponentUpdate();
          api.sendInspectorState(INSPECTOR_ID);
          if (isTimelineActive) {
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                title: "Change",
                subtitle: name2,
                data: {
                  newValue,
                  oldValue
                },
                groupId: activeAction
              }
            });
          }
        }, { deep: true });
      });
      store.$subscribe(({ events, type }, state) => {
        api.notifyComponentUpdate();
        api.sendInspectorState(INSPECTOR_ID);
        if (!isTimelineActive)
          return;
        const eventData = {
          time: now2(),
          title: formatMutationType(type),
          data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
          groupId: activeAction
        };
        if (type === MutationType.patchFunction) {
          eventData.subtitle = "⤵️";
        } else if (type === MutationType.patchObject) {
          eventData.subtitle = "🧩";
        } else if (events && !Array.isArray(events)) {
          eventData.subtitle = events.type;
        }
        if (events) {
          eventData.data["rawEvent(s)"] = {
            _custom: {
              display: "DebuggerEvent",
              type: "object",
              tooltip: "raw DebuggerEvent[]",
              value: events
            }
          };
        }
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: eventData
        });
      }, { detached: true, flush: "sync" });
      const hotUpdate = store._hotUpdate;
      store._hotUpdate = vue.markRaw((newStore) => {
        hotUpdate(newStore);
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "🔥 " + store.$id,
            subtitle: "HMR update",
            data: {
              store: formatDisplay(store.$id),
              info: formatDisplay(`HMR update`)
            }
          }
        });
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
      });
      const { $dispose } = store;
      store.$dispose = () => {
        $dispose();
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store 🗑`);
      };
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed 🆕`);
    });
  }
  let runningActionId = 0;
  let activeAction;
  function patchActionForGrouping(store, actionNames, wrapWithProxy) {
    const actions = actionNames.reduce((storeActions, actionName) => {
      storeActions[actionName] = vue.toRaw(store)[actionName];
      return storeActions;
    }, {});
    for (const actionName in actions) {
      store[actionName] = function() {
        const _actionId = runningActionId;
        const trackedStore = wrapWithProxy ? new Proxy(store, {
          get(...args) {
            activeAction = _actionId;
            return Reflect.get(...args);
          },
          set(...args) {
            activeAction = _actionId;
            return Reflect.set(...args);
          }
        }) : store;
        activeAction = _actionId;
        const retValue = actions[actionName].apply(trackedStore, arguments);
        activeAction = void 0;
        return retValue;
      };
    }
  }
  function devtoolsPlugin({ app, store, options }) {
    if (store.$id.startsWith("__hot:")) {
      return;
    }
    store._isOptionsAPI = !!options.state;
    patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
    const originalHotUpdate = store._hotUpdate;
    vue.toRaw(store)._hotUpdate = function(newStore) {
      originalHotUpdate.apply(this, arguments);
      patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
    };
    addStoreToDevtools(
      app,
      // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
      store
    );
  }
  function createPinia() {
    const scope = vue.effectScope(true);
    const state = scope.run(() => vue.ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia2 = vue.markRaw({
      install(app) {
        setActivePinia(pinia2);
        {
          pinia2._a = app;
          app.provide(piniaSymbol, pinia2);
          app.config.globalProperties.$pinia = pinia2;
          if (USE_DEVTOOLS) {
            registerPiniaDevtools(app, pinia2);
          }
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
      pinia2.use(devtoolsPlugin);
    }
    return pinia2;
  }
  function patchObject(newState, oldState) {
    for (const key in oldState) {
      const subPatch = oldState[key];
      if (!(key in newState)) {
        continue;
      }
      const targetValue = newState[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
        newState[key] = patchObject(targetValue, subPatch);
      } else {
        {
          newState[key] = subPatch;
        }
      }
    }
    return newState;
  }
  const noop = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && vue.getCurrentScope()) {
      vue.onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    }
    if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = Symbol("pinia:skipHydration");
  function shouldHydrate(obj) {
    return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o2) {
    return !!(vue.isRef(o2) && o2.effect);
  }
  function createOptionsStore(id, options, pinia2, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia2.state.value[id];
    let store;
    function setup() {
      if (!initialState && !hot) {
        {
          pinia2.state.value[id] = state ? state() : {};
        }
      }
      const localState = hot ? (
        // use ref() to unwrap refs inside state TODO: check if this is still necessary
        vue.toRefs(vue.ref(state ? state() : {}).value)
      ) : vue.toRefs(pinia2.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name2) => {
        if (name2 in localState) {
          console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name2}" in store "${id}".`);
        }
        computedGetters[name2] = vue.markRaw(vue.computed(() => {
          setActivePinia(pinia2);
          const store2 = pinia2._s.get(id);
          return getters[name2].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options, pinia2, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    if (!pinia2._e.active) {
      throw new Error("Pinia destroyed");
    }
    const $subscribeOptions = {
      deep: true
      // flush: 'post',
    };
    {
      $subscribeOptions.onTrigger = (event) => {
        if (isListening) {
          debuggerEvents = event;
        } else if (isListening == false && !store._hotUpdating) {
          if (Array.isArray(debuggerEvents)) {
            debuggerEvents.push(event);
          } else {
            console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.");
          }
        }
      };
    }
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia2.state.value[$id];
    if (!isOptionsStore && !initialState && !hot) {
      {
        pinia2.state.value[$id] = {};
      }
    }
    const hotState = vue.ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      {
        debuggerEvents = [];
      }
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia2.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      vue.nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      () => {
        throw new Error(`🍍: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
      }
    );
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia2._s.delete($id);
    }
    function wrapAction(name2, action) {
      return function() {
        setActivePinia(pinia2);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name: name2,
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = action.apply(this && this.$id === $id ? this : store, args);
        } catch (error2) {
          triggerSubscriptions(onErrorCallbackList, error2);
          throw error2;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error2) => {
            triggerSubscriptions(onErrorCallbackList, error2);
            return Promise.reject(error2);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
    }
    const _hmrPayload = /* @__PURE__ */ vue.markRaw({
      actions: {},
      getters: {},
      state: [],
      hotState
    });
    const partialStore = {
      _p: pinia2,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => vue.watch(() => pinia2.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = vue.reactive(assign(
      {
        _hmrPayload,
        _customProperties: vue.markRaw(/* @__PURE__ */ new Set())
        // devtools custom properties
      },
      partialStore
      // must be added later
      // setupStore
    ));
    pinia2._s.set($id, store);
    const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia2._e.run(() => (scope = vue.effectScope()).run(setup)));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (vue.isRef(prop) && !isComputed(prop) || vue.isReactive(prop)) {
        if (hot) {
          set(hotState.value, key, vue.toRef(setupStore, key));
        } else if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (vue.isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia2.state.value[$id][key] = prop;
          }
        }
        {
          _hmrPayload.state.push(key);
        }
      } else if (typeof prop === "function") {
        const actionValue = hot ? prop : wrapAction(key, prop);
        {
          setupStore[key] = actionValue;
        }
        {
          _hmrPayload.actions[key] = prop;
        }
        optionsForPlugin.actions[key] = prop;
      } else {
        if (isComputed(prop)) {
          _hmrPayload.getters[key] = isOptionsStore ? (
            // @ts-expect-error
            options.getters[key]
          ) : prop;
          if (IS_CLIENT) {
            const getters = setupStore._getters || // @ts-expect-error: same
            (setupStore._getters = vue.markRaw([]));
            getters.push(key);
          }
        }
      }
    }
    {
      assign(store, setupStore);
      assign(vue.toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => hot ? hotState.value : pinia2.state.value[$id],
      set: (state) => {
        if (hot) {
          throw new Error("cannot set hotState");
        }
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    {
      store._hotUpdate = vue.markRaw((newStore) => {
        store._hotUpdating = true;
        newStore._hmrPayload.state.forEach((stateKey) => {
          if (stateKey in store.$state) {
            const newStateTarget = newStore.$state[stateKey];
            const oldStateSource = store.$state[stateKey];
            if (typeof newStateTarget === "object" && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) {
              patchObject(newStateTarget, oldStateSource);
            } else {
              newStore.$state[stateKey] = oldStateSource;
            }
          }
          set(store, stateKey, vue.toRef(newStore.$state, stateKey));
        });
        Object.keys(store.$state).forEach((stateKey) => {
          if (!(stateKey in newStore.$state)) {
            del(store, stateKey);
          }
        });
        isListening = false;
        isSyncListening = false;
        pinia2.state.value[$id] = vue.toRef(newStore._hmrPayload, "hotState");
        isSyncListening = true;
        vue.nextTick().then(() => {
          isListening = true;
        });
        for (const actionName in newStore._hmrPayload.actions) {
          const action = newStore[actionName];
          set(store, actionName, wrapAction(actionName, action));
        }
        for (const getterName in newStore._hmrPayload.getters) {
          const getter = newStore._hmrPayload.getters[getterName];
          const getterValue = isOptionsStore ? (
            // special handling of options api
            vue.computed(() => {
              setActivePinia(pinia2);
              return getter.call(store, store);
            })
          ) : getter;
          set(store, getterName, getterValue);
        }
        Object.keys(store._hmrPayload.getters).forEach((key) => {
          if (!(key in newStore._hmrPayload.getters)) {
            del(store, key);
          }
        });
        Object.keys(store._hmrPayload.actions).forEach((key) => {
          if (!(key in newStore._hmrPayload.actions)) {
            del(store, key);
          }
        });
        store._hmrPayload = newStore._hmrPayload;
        store._getters = newStore._getters;
        store._hotUpdating = false;
      });
    }
    if (USE_DEVTOOLS) {
      const nonEnumerable = {
        writable: true,
        configurable: true,
        // avoid warning on devtools trying to display this property
        enumerable: false
      };
      ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
        Object.defineProperty(store, p2, assign({ value: store[p2] }, nonEnumerable));
      });
    }
    pinia2._p.forEach((extender) => {
      if (USE_DEVTOOLS) {
        const extensions = scope.run(() => extender({
          store,
          app: pinia2._a,
          pinia: pinia2,
          options: optionsForPlugin
        }));
        Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
        assign(store, extensions);
      } else {
        assign(store, scope.run(() => extender({
          store,
          app: pinia2._a,
          pinia: pinia2,
          options: optionsForPlugin
        })));
      }
    });
    if (store.$state && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) {
      console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
    }
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    } else {
      options = idOrOptions;
      id = idOrOptions.id;
      if (typeof id !== "string") {
        throw new Error(`[🍍]: "defineStore()" must be passed a store id as its first argument.`);
      }
    }
    function useStore(pinia2, hot) {
      const hasContext = vue.hasInjectionContext();
      pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia2 || (hasContext ? vue.inject(piniaSymbol, null) : null);
      if (pinia2)
        setActivePinia(pinia2);
      if (!activePinia) {
        throw new Error(`[🍍]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
      }
      pinia2 = activePinia;
      if (!pinia2._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia2);
        } else {
          createOptionsStore(id, options, pinia2);
        }
        {
          useStore._pinia = pinia2;
        }
      }
      const store = pinia2._s.get(id);
      if (hot) {
        const hotId = "__hot:" + id;
        const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia2, true) : createOptionsStore(hotId, assign({}, options), pinia2, true);
        hot._hotUpdate(newStore);
        delete pinia2.state.value[hotId];
        pinia2._s.delete(hotId);
      }
      if (IS_CLIENT) {
        const currentInstance = vue.getCurrentInstance();
        if (currentInstance && currentInstance.proxy && // avoid adding stores that are just built for hot module replacement
        !hot) {
          const vm = currentInstance.proxy;
          const cache2 = "_pStores" in vm ? vm._pStores : vm._pStores = {};
          cache2[id] = store;
        }
      }
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  const GDHPStore = defineStore("GDHPStore", {
    // 推荐使用 完整类型推断的箭头函数
    state: () => {
      return {
        // 所有这些属性都将自动推断其类型
        outboundList: [],
        reviceObj: {}
      };
    },
    actions: {
      addToList(obj) {
        this.outboundList.push(obj);
      },
      celByList(index2) {
        this.outboundList.splice(index2, 1);
      }
    }
  });
  const _imports_1$8 = "/static/icons/scan_blue.png";
  const _imports_2$1 = "/static/icons/delete.png";
  const _sfc_main$i = {
    __name: "warehouse",
    setup(__props, { expose: __expose }) {
      __expose();
      const GDHPStoreInfo = GDHPStore();
      const getData = () => {
        let storageType;
        try {
          storageType = GDHPStoreInfo.$state.outboundList[0].storageType;
        } catch (e2) {
        }
        request({
          url: "/admin-api/storage/local/goods/get-for-outbound",
          data: {
            orderNo: window.location.href.split("code=")[1],
            storageType
          }
        }).then((res) => {
          if (!GDHPStoreInfo.$state.outboundList.some((item) => item.orderNo == res.orderNo)) {
            GDHPStoreInfo.addToList(res);
          } else {
            uni.showToast({
              title: "该商品已添加",
              icon: "none"
            });
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const deleteHandle = (item, index2) => {
        GDHPStoreInfo.celByList(index2);
      };
      const uploadGoods = () => {
        const goodsIds = GDHPStoreInfo.$state.outboundList.map((item) => {
          return item.id;
        });
        request({
          url: "/admin-api/storage/local/goods/outbound/create",
          methods: "POST",
          data: {
            goodsIds
          }
        }).then((res) => {
          GDHPStoreInfo.$state.outboundList = [];
          changePage("./warehouseSuccess");
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const dataList = vue.computed(() => {
        return GDHPStoreInfo.$state.outboundList;
      });
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { GDHPStoreInfo, getData, deleteHandle, uploadGoods, changePage, dataList, goBack, topNavbar, get request() {
        return request;
      }, get GDHPStore() {
        return GDHPStore;
      }, get showToast() {
        return showToast;
      }, ref: vue.ref, computed: vue.computed };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "出库",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "pdlr12 pt12" }, [
        vue.createElementVNode("view", { class: "topBox pdlr12 pt21 pb16" }, [
          vue.createElementVNode("view", { class: "f14" }, "仓储类型"),
          vue.createElementVNode("view", { class: "mt19 shelfBox center flex-col" }, [
            vue.createElementVNode(
              "view",
              { class: "f20 text_bold colorBlue" },
              vue.toDisplayString((_a = $setup.GDHPStoreInfo.$state.outboundList[0]) == null ? void 0 : _a.storageTypeName),
              1
              /* TEXT */
            )
          ])
        ]),
        vue.createElementVNode("view", { class: "mt12 botBox" }, [
          vue.createElementVNode("view", { class: "between" }, [
            vue.createElementVNode(
              "view",
              { class: "f14" },
              "商品总数 x" + vue.toDisplayString($setup.dataList.length),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", {
              class: "rightBtn flex col_center f12",
              onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("../home/scanCode?type=7"))
            }, [
              vue.createElementVNode("image", {
                src: _imports_1$8,
                class: "ww24 hh24"
              }),
              vue.createTextVNode(" 继续添加 ")
            ])
          ]),
          vue.createElementVNode("view", { class: "goodsBox pt12" }, [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "between goodsItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "flex col_center f14 text_bold" }, [
                    vue.createElementVNode(
                      "view",
                      null,
                      vue.toDisplayString(item.categoryName) + " -- " + vue.toDisplayString(item.orderNo),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "pl15" },
                      "x" + vue.toDisplayString(item.num),
                      1
                      /* TEXT */
                    )
                  ]),
                  vue.createElementVNode("image", {
                    src: _imports_2$1,
                    class: "ww24 hh24",
                    onClick: ($event) => $setup.deleteHandle(item, index2)
                  }, null, 8, ["onClick"])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ]),
        vue.createElementVNode("view", { class: "botFixed" }, [
          vue.createElementVNode("view", { class: "pdlr12 pb10" }, [
            vue.createElementVNode("view", {
              class: "btns f14 text_white center",
              onClick: $setup.uploadGoods
            }, " 确认出库 ")
          ])
        ])
      ]),
      vue.createElementVNode("view", { style: { "height": "100px" } })
    ]);
  }
  const PagesGdWarehouse = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$h], ["__scopeId", "data-v-d0b5625b"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/warehouse.vue"]]);
  const _sfc_main$h = {
    __name: "warehouseSuccess",
    setup(__props, { expose: __expose }) {
      __expose();
      const scanVal = vue.ref(0);
      onLoad((e2) => {
        if (e2.code) {
          scanVal.value = e2.code;
        }
      });
      function changePage() {
        uni.navigateTo({
          url: "/pages/tab/index"
        });
      }
      const __returned__ = { scanVal, changePage, get onLoad() {
        return onLoad;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10" }, [
        vue.createElementVNode("view", { class: "ww50" }),
        vue.createElementVNode("view", { class: "text_bold f17" }, "结果反馈"),
        vue.createElementVNode("view", { class: "ww50" })
      ]),
      vue.createElementVNode("view", { class: "pdlr20 mt73" }, [
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("image", {
            src: _imports_0$1,
            style: { "width": "69px", "height": "94px" }
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f20 text_bold mt20" }, " 出库成功 "),
        vue.createElementVNode("view", {
          class: "colorAf pdlr35 f12 mt8 text_center",
          style: { "line-height": "18px" }
        }, " 请将打印出的面单贴到对应的包裹上 "),
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("view", {
            class: "center botBtn",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("/pages/tab/index"))
          }, [
            vue.createElementVNode("view", { class: "f14 ml8" }, " 返回首页 ")
          ])
        ])
      ])
    ]);
  }
  const PagesGdWarehouseSuccess = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$g], ["__scopeId", "data-v-a5e49ea5"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/warehouseSuccess.vue"]]);
  const zStatic = {
    base64Arrow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAD1BMVEVHcExRUVFMTExRUVFRUVE9CdWsAAAABHRSTlMAjjrY9ZnUjwAAAQFJREFUWMPt2MsNgzAMgGEEE1B1gKJmAIRYoCH7z9RCXrabh33iYktcIv35EEg5ZBh07pvxJU6MFSPOSRnjnBUjUsaciRUjMsb4xIoRCWNiYsUInzE5sWKEyxiYWDbyefqHx1zIeiYTk7mQYziTYecxHvEJjwmIT3hMQELCYSISEg4TkZj0mYTEpM8kJCU9JiMp6TEZyUmbAUhO2gxAQNJiIAKSFgMRmNQZhMCkziAEJTUGIyipMRjBSZkhCE7KDEFIUmTeGCHJxWz0zXaE0GTCG8ZFtEaS347r/1fe11YyHYVfubxayfjoHmc0YYwmmmiiiSaaaKLJ7ckyz5ve+dw3Xw2emdwm9xSbAAAAAElFTkSuQmCC",
    base64ArrowWhite: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAElBMVEVHcEz///////////////////+IGTx/AAAABnRSTlMA/dAkXZOhASU/AAABYElEQVRYw+2YwXLCIBCGsdAHWGbyAKZ4zxi9O017rxLf/1UaWFAgA1m8dcpedNSPf/l/Vh0Ya/Wn6hN0JcGvoCqRM4C8VBFiDwBqqNuJKV0rAnCgy3AUqZE57x0iqTL8Br4U3WBf/YWaIlTKfAcELU/h9w72CSVPa3C3OCDvhpHbRp/s2vq4fHhCeiCl2A3m4Qd71DQR257mFBlMcTlbFnFWzNtHxewYEfSiaLS4el8d8nyhmKJd1CF4eOS0keLMAuSxubLBIeIGQW8YHCFFo7EH9+YDcQt9FMZEswTheaNxTHwHT8SZorJjMrEVwo4Zo0U8HSEyZvJMOg4RjnmmRr8nDYeIz3OMkbfE/QhBo+U9RnZJxjGCRh/WKmHEMWLNkfPKsGh/CWJk1JjG0kcuJggTt34VDP8aWAFhp4nybVb5+9qQhjSkIQ1pSEMa8k+Q5U9rV3dF8MpFBK+/7miVq1/HZ2qmo9D+pAAAAABJRU5ErkJggg==",
    base64Flower: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAKlBMVEVHcEzDw8Ovr6+pqamUlJTCwsKenp61tbWxsbGysrLNzc2bm5u5ubmjo6MpovhuAAAACnRSTlMA/P79/sHDhiZS0DxZowAABBBJREFUWMPtl89rE0EUx7ctTXatB3MI1SWnDbUKPUgXqh4ED8Uf7KUVSm3ooVSpSii0Fn/gD4j4o+APiEoVmos9FO2celiqZVgwgaKHPQiCCkv+F99kM7Ozm5kxq1dfD91k9pPve9/3ZjbRNHHok/mKli4eIPNgSuRObuN9SqSEzM20iGnm0yIbqCuV7NSSSIV7uyPM6JMBYdeTOanh/QihJYZsUCSby+VkMj2AvOt0rAeQAwqE3lfKMZVlQCZk1QOCKkkVPadITCfIRNKxfoJI5+0OIFtJx14CMSg1mRSDko7VAfksRQzEbGYqxOJcVTWMCH2I1/IACNW0PWU2M8cmAVHtnH5mM1VRWtwKZjOd5JbF6s1IbaYqaotjNlPHgDAnlAizubTR6ovMYn052g/U5qcmOpi0WL8xTS/3IfSet5m8MEr5ajjF5le6dq/OJpobrdY0t3i9QgefWrxW9/1BLhk0E9m8FeUMhhXal499iD0eQRfDF+ts/tttORRerfp+oV7f4xJj82iUYm1Yzod+ZQEAlS/8mMBwKebVmCVp1f0JLS6zKd17+iwRKTARVg2SHtz3iEbBH+Q+U28zW2Jiza8Tjb1YFoYZMsJyjDqp3M9XBQdSdPLFdxEpvOB37JrHcmR/y9+LgoTlCFGZEa2sc6d4PGlweEa2JSVPoVm+IfGG3ZL037iV9oH+P+Jxc4HGVflNq1M0pivao/EopO4b/ojVCP9GjmiXOeS0DOn1o/iiccT4ORnyvBGF3yUywkQajW4Ti0SGuiy/wVSg/L8w+X/8Q+hvUx8Xd90z4oV5a1i88MbFWHz0WZZ1UrTwBGPX3Rat9AFiXRMRjoMdIdJLEOt2h7jrYOzgOamKZSWSNspOS0X8SAqRYmxRL7sg4eLzYmNehcxh3uoyud/BH2Udux4ywxFTc1xC7Mgf4vMhc5S+kSH3Y7yj+qpwIWSoPTVCOOPVthGx9FbGqrwFw6wSFxJr+17zeKcztt3u+2roAEVgUjDd+AHGuxHy2rZHaa8JMkTHEeyi85ANPO9j9BVuBRD2FY5LDMo/Sz/2hReqGIs/KiFin+CsPsYO/yvM3jL2vE8EbX7/Bf8ejtr2GLN65bioAdgLd8Bis/mD5GmP2qeqyo2ZwQEOtAjRIDH7mBKpUcMoApbZJ5UIxkEwxyMZyMxW/uKFvHCFR3SSmerHyDNQ2dF4JG6zIMpBgLfjSF9x1D6smFcYnGApjmSLICO3ecCDWrQ48geba9DI3STy2i7ax6WIB62fSyIZIiO3GFQqSURp8wCo7GhJBGwuSovJBNjb7kT6FPVnIa9qJ2Ko+l9mefGIdinaMp0yC1URYiwsdfNE45EuA5Cx9EhalfvN5s+UyItm81vaB3p4joniN+SCP7Qc1hblAAAAAElFTkSuQmCC",
    base64FlowerWhite: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAElBMVEX///9HcEz///////////////84chYNAAAABnRSTlP/AGzCOYZj5g1nAAACfklEQVRYw+2YTVPDIBCGtza9Jw25a0bvcax30o73OOr//yvma2F3YWlpPTijXNpAHrK8LLALVPFium2vNIFSbwGKTGQA2GUiHcD29yDNy3sMIdUBQl7r2H8mOEVqAHgPkYZUS6Qc2zYhQqtjyDZEximCZwWZLIBeIgYShs2NzxKpSUehYpMJhURGb+O+w5BpMCAREKPnCDHbIY20SzhM5yxziAXpOiBXydrekT9i5XDEq4NIIHHgyU5mRGqviII4mREJJA4QJzMiILwlRJzpKxJKvCBm8OsBBbLux0tsPl4RKYm5aPu6jw1U4mGxEUR9g8M1PcqBEp/WJliNgYOXueBzS4jZSIcgY5lCtevgDSgyzE+rAfuOTQMq0yzvoGH18qju27Mayzs4fPyMziCx81NJa5RNfW7vPYK9KOfDiVkBxFHG8hAj9txuoBuSWORsFfkpBf7xKFLSeaOefEojh5jz22DJEqMP8fUyaKdQx+RnG+yXMpe8Aars8ueR1pVH/bW3FyyvPRw90upLDHwpgBDtg4aUBNkxRLXMAi03IhcZtr1m+FeI/O/JNyDmmL1djLOauSlNflBpW18RQ2bPqXI22MXXEk75KRHTnkPkYbESbdKP2ZFk0r5sIwffAjy1lx+vx7NLjB6/E7Jfv5ERKhzpN0w8IDE8IGFDv5dhz10s7GFiXRZcUeLCEG5P5nDq9k4PFDcoMpE3GY4OuxuCXhmuyNB6k0RsLIAvqp9NE5r8ZCSS8gxnUp7ODdYhZTqxuiJ9uyJJtPmpqJ7wVj+XVieS903iViHziqAhchLEJAyb7jWU647EpUofQ0ziUuXXXhDddtlllSwjgSQu7r4BRWhQqfDPMVwAAAAASUVORK5CYII=",
    base64Success: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAElBMVEVRUVFHcExTU1NRUVFRUVFRUVFOSlSUAAAABnRSTlP/AI6+VySB3ZENAAACcElEQVRYw+2YyYKCMAyGI8hdpdxdZu7gcpdZ7jL6/s8yYheSNi0aPdqbwOffpGmaFOYPD3gj4bisN7vddv17N/JVgxn5x12IWgIaWTuO/IE3PseQbwjGPo2cgRmHFLJwdm/X643zwiqOKPPJ1nj3sjEP2iiifZWj5bhopSyGaEO2HX5fbQJzwJ+W7x/jw5ZFjsEU0PMph9xE8i5EqprKALW95eJQURkgzw98uJ/JvwGecR7bIjWWsUgVrrIfFZ2HlLy3sKETD1mmRLRMRhGVssRa0xJkdn3SpJBymBkM8+pSSDXMDNyDaToVHd2fgpNt0sjwiUZO19+jGQ+gQEg9Oq+bufmAVGihomNmjQG7UG3020vrlm7lkFnKFGU3kZ0KGAdmKe821pipQ+qEKcrZeTL2g5FsUks4cStjEZWwXg0b0n4GxmEpkWwIs5VBynjgK7xZaz1/0D7OxkVuLpsY5BQNFyLS84VBjjbg0iL2r2EQHBOxBhikuUOkdxODVF1cxHoWtPPsiyXO455Iv34hssCO8EV4ZIYTjS8SR4qYSHRiTiYQ4ZFbHi0iIhhBTi6dTCgSWRcnw4h4yGTuyTAiOGBIWGoZTgSHJQl+LcOJ4OCnW6yX2bMnJ9pidCOXtkTkTrIGpYuOynAiOF14SamMiOCk5Ke+mq8BcOrrvym8d0zKIQnWT+M1WwOQNO4fFiWb18hhERxJPx2fblbPHHyC41VyiAtKBUFBIih7JMWVoIQTFIr3lKPN80WvoLSWFPC653ioTZA0I0FrQ7qU6asaK0H7JmkSJa2ooOGVtNUsc3j9FYHkIkJy3SG6VHnfXKXGP9t4N9Q4Ye98AAAAAElFTkSuQmCC",
    base64SuccessWhite: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAGFBMVEVHcEz///////////////////////////8dS1W+AAAAB3RSTlMAiVYk6KvDHLfaegAAAo1JREFUWMPtWEtzmzAQNhCTq910ytXpiyvxTNOr60zrayepx9d02gnX4sTm7xcEiJX2gdnkGJ1A4tOnfWqXyeR1vMRYzrcPD9v5h5MBl3/Ldvx4cxIg/FWC8X0xjLjalM54uhhCfCrRuJURX0pi3EmIqZV7O59vrRZmguStHL9b7S7ftfLwOtiZDw7AHMtmquAQ12b5Wwbnordm8g9zLLO49qc/m2n6aKnhwPOGZ08hAiNHhheiHae1lOUPGZpQkPKa3q0mOUjaRzSRaGUjpy/mmWSwySSpllcEteBKAT52KEnSbblA51pJEPxBQoiH1FP4E3s5+FJv07h6/ylD6ui7B+9fq/ehrFB98ghec9EoVtyjK8pqCHLmCBOwMWSCeWFNN4MbPAk55NhsvoFHSSVR0k5TCTTEzlUGcqV/nVp7n9oIVkmtaqbAEqEgfdgHJPwsEAyZ9r4VAZXFjpEwyaw3+H2v42KYxKhs1XvY/gSSGv+IHyUSuHXCeZhLAgVI3EjgSGo1Fb3xO0tGGU9S2/KAIbtjxpJASG73qox6w5LUq0cEOa+iIONIWIilQSQ0pPa2jgaRQAgQP7c0mITRWGxpMAmEQFN2NAQJNCV0mI6GIIEO47hlQ0ORQLd0nL+hoUjg1m6I1TRr8uYEAriBHLcVFQ5UEMiBe3XkTBEG04WXlGKGxPnMS305XQPA1Ocn2JiuAZwE66fxnKwBnDTuXxZTMq85lwW6kt5ndLqZPefiU1yvmktcUSooChJF2aMprhQlnKJQ5FxRKkcVRa+itNYU8Io2oVkY14w0NMWYlqft91Bj9VHq+ca3b43BxjWJmla0sfKohlfTVpPN+93L/yLQ/IjQ/O5Q/VR5HdL4D7mlxmjwVdELAAAAAElFTkSuQmCC",
    base64Empty: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAMAAAAL34HQAAALeGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0NDg4LCAyMDIwLzA3LzEwLTIyOjA2OjUzICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTIyVDIxOjIxOjQ1KzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTAxLTEzVDE5OjA5OjQwKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyNC0wMS0xM1QxOTowOTo0MCswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ZWQwMWYzNWQtOWRjOC00MDBiLWEyMmQtNjM5OGZiNzVhNGRiIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6ZDhlMzQ3ZmEtMDY2My1jYTRiLTgzNTctNTk4YjBkNGIzOTU2IiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZDA4MDI4MDItMzUyYS04NTRhLTkxYjctNmRlNmQ1MmViM2QwIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjMwMDAwMDAvMTAwMDAiIHRpZmY6WVJlc29sdXRpb249IjMwMDAwMDAvMTAwMDAiIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiIGV4aWY6Q29sb3JTcGFjZT0iMSIgZXhpZjpQaXhlbFhEaW1lbnNpb249IjMwMCIgZXhpZjpQaXhlbFlEaW1lbnNpb249IjMwMCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZDA4MDI4MDItMzUyYS04NTRhLTkxYjctNmRlNmQ1MmViM2QwIiBzdEV2dDp3aGVuPSIyMDIyLTAyLTIyVDIxOjIxOjQ1KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQwNjg2NzJkLWY5NDMtOTU0Mi1iMDBiLTVlMDExNmE1NmIzZSIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xM1QxMDoyNjoxNiswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphYmJkZmUyZC0xY2Q2LTJiNDgtYjUyNS05YzlhZjdlNjA4NDMiIHN0RXZ0OndoZW49IjIwMjQtMDEtMTNUMTE6MjM6NDArMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YTQ5MjM5MDAtNDhiZC03YTQ1LWI4NGItYmVlZTVjOWUxYTM1IiBzdEV2dDp3aGVuPSIyMDI0LTAxLTEzVDExOjIzOjQwKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmVkMDFmMzVkLTlkYzgtNDAwYi1hMjJkLTYzOThmYjc1YTRkYiIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xM1QxOTowOTo0MCswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmFiYmRmZTJkLTFjZDYtMmI0OC1iNTI1LTljOWFmN2U2MDg0MyIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjM2ZGQ4NTQxLWQ0MWEtYmY0Yy1iZjA3LWNmNjZhNjZhMDg2MSIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmQwODAyODAyLTM1MmEtODU0YS05MWI3LTZkZTZkNTJlYjNkMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pm30U/gAAAAJcEhZcwAALiMAAC4jAXilP3YAAAA/UExURUdwTODg4O3t7e7u7unp6d7e3uTk5M/Pz8nJyePj4+jo6Pj4+MrKyszMzO7u7unp6fb29vLy8vr6+v7+/sHBweag3xAAAAAOdFJOUwAxia5pF0n+/vzX3KbULQ2DYQAACG1JREFUeNrtm4l2o7gShi20IWFrAd7/WUc7EosDWKZ976Hc7WTmdMKXv0qlqpLyeNx222233Xbbbbfddtv/mOHn8xexSNsiRH5PrbFtW4p+DetpsF4v8Gs+HA3WEwOAfwzriYxaLTVsP8X1QK0z+vqQCzewYogi60aL9SEX5oyxphYVCFTGjfSJCTmN1jBruN5KTGCUS8bhySQGHRaohmW4glwtldbOeYJYKlgvbyUuA8aFFEKc++aIM4hrRnyiMnIZKq1PrihcM3GNKboMF1Naa9X9+8T1KrxIlVbGjv3cAEHOYYMqqgUsVuJqqehV3+sjDwB+DTJp0lYtMCyZpxqjF4e+74+sRcQSFZO8UonUSEFzuUY+DKo59A2kZDatGCjzCauy/2AmhSyCq0WHEj0KTNJDmVeNhErMt1Q8W4xti4/FwMJ4jaxl05TKFiNtD3kBGrHnhiph9V0eXQc6DkyE2xX830AlKshFTErXeuCZXK/9m41wFsGSfZ4lcGeyZ98PrylJ7MWCojQZ3qSukL2QslgdngqJnTEPdTJhXvbNBoR/+7wabIxWduN/Ja5dWEivm4XSZ2uQckNzmRlHrn2lc6eiafvS4V2Hd12tesau8toZW0CtWoZYb9t+OqxdCYKYjVPF16pVbILIy/gR7MVaWMHYPCoa2VkzkX4Iry2rirXbumGyAjGC1h62YLw6ApsNKZph3fpIWHt08JovRWD62sejpXhTrhWrPpl6zZ6PW2oTG5ltlvgtF6weNYCWKeJJSfg4W6PNJlj3sVZgOXV4lc8n4RlkMTLEBDVoYc3nI09kpyzzfgWsjyzBZSNDKF2/wjh+sxYvn8Y1scxlfLF9T1RBO3wVHsnq8Fk4oGkEh/0KJPSa8T2CeWE5X9BPmgLsaRIGeNL2kshCsWoLBmdPJW5Wbz1ndAKUXjPwxXYAUpSV3fy5BJg1aa1tyVXHHMgVH31ewDVrleHr9XqC684SUF4mecR3+wW5SC2QNvxUizRv98mLDhPgYiMDb+v8g0OADxqxcnf9w01mZYJF0fUVP5LcdswbsMmy1DVs5PlE5NpNiTR8M8qAWZkOy6aN13VcoOF2/s3xn3Mes8Xza05tgR/BuNz69nlNzMR0fH45p+G4R9oxh2mKt9MF4J7K/lvWUojwF5nCgCpuRUptnZMQ3au0nSo2UsHgV3xpmeLYzGml3ZFBBzYGPCpOQRwXs1/GG1J74dlZc6JKUOtjBAz9XjVxucGWHbZVJDPJQGYDRl1Qmf1ovk2Sbghb6MQlnF7mBzM1bgOqJAPpoOQaVe+4Skcit3uqHMyG/Sh1rHNN0gAfM0nnPrmulfLVBSm20TSZSdWa0LJl2ukVyE4vTYCgP3uQkwv1TKtQWgxDzBSg80OQjCs4klKvuUzHLCfIbDKIE/S5VIGqD1iD2819pkAqTWdmeina+oZABi7X5B1MGoTJqJSchuk6JNHcgUPAcsVFk0+N0oDN68Vo7FQSmCXjx46OEtUk1lpY2ZFQGr/AcpqVato4wPUD+RhfAeyQI5sJ6l2sDwnKqNFSJvpiyJbFl3kTOjZ2ievwCR7hkUoWeV2vOLAXvB39AJoyqYa81A5cvaAidXYTFTycKDBcalVK5f3XS89kzLVl9txfL+K+p6NUnitz5KkKm7D3DrRPNq4bk7l20aFRppNilmuQI+uzTtj9wPBkTsVwM7HbJ5pwGgujyRyZDzQLNoiRFluRtQ+GzEguqRxUL+ZMFqulMzIfaP3ARj2k/txB8c+2HyjmDizCaVWtNoE5MvMlKs/4VQ7HUJZCrU6qCKcNJ2aSWUZhJZu4VI0LB4CHFdj77DRuGi28WKAxoRyZyzGVrmc0jmk1nP5QaxZo1puqq1YIAqgZb8e/rABZJWNCNxV7DSTpOO7Aail9J9nYHtua/4ouE/aS0X1qtXQzwGx+rnbi2vhF/TfZG52oc6DPo1WCi3RTDnRk7TEntoEp38gg+DjYs2opkR3JW5EpL9rU0XSK5/6LOTAVS+72x7pm60zSf5HMdldjhzJqw1FRcxXdS3ZNZp0s92FiyluUvBPoD9ynZNkBiu2NF11ofnlnQbZgKqvusj9R/f6DOzgVsahbNlXxlsxU8y7qrbTupitRyxFBKG6H3aEPUqj7YrzAymq41FXlZLlO4WLbvG2Kg4vYB+wPfWS2B5Rq8TW9ROpAZbiF6MmCTsx1NLLsx7NOoOiZup2CNbZ36xc96ErcxzuILGrmmFhimjtwKo/yTm7feTVwB61IzbnW4967Kt3cDDotGt8JKrTiUyO3Uy2PZZt9tapXEfXhWmTgcoB+JchFWsiCKvYnhmn/tKuJDbgly897FnFfkE1rQLKy810OU7xW3bEJHCD5gERtuTGuxoJqA6qI9TNMa6MbvZomsiubbPYx78YXDaaRqqsyqfSaLZdjYGHLu65rDgydXCWm1P5EvcQ828f9pcBapTILSMv1nZCAc0WzFIFsGfUi/kmAxc6cFqDSYuPSMIbs1OVrwITTQM9HVRFJ5JL56qcoFzzT1uVcd2v9jFw8BHlcWtmEI86hp5Dy/zOlK8cUp/rVseRUBqawz6kmAcPLM9l5m8h4V53Iz/2mFJaTCvF8JbsMvPjU/7crbUXart0v4WyE0LnDPcAX95Knj4VUE8HCdNdUP8BDcOXKdPl4uSWbh4LfOV0HDdfipOmu+eIRrDsNPkIT7np/8ZAzVdOd1u8wHIqeXt8VqtgiO50ePeNaGG+uO9rHiKdL71pnIun8jxEKXv2r2HYBzO/mz96vFKoMM5WLk7tQXS9U5kwCu5lk7n6++kdCFWRaTUzm0/5fClWGWTrM/AGhCrJO/ZBQhTPFLwmV7ebgcdttt91222233Xbbbf+H9h+2WEtdHVinLAAAAABJRU5ErkJggg==",
    base64Error: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAMAAAAL34HQAAALeGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0NDg4LCAyMDIwLzA3LzEwLTIyOjA2OjUzICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTIyVDIxOjIxOjQ1KzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTAxLTEzVDE5OjEwOjEwKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyNC0wMS0xM1QxOToxMDoxMCswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTQ3NTExNjAtZDY5MC00ZTkzLWFhNGUtNGMwYTViNGU1ZGFjIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6YzRiNzlkYWMtZTJmYS1iNzQ0LWIxM2ItOWU1N2VjMDhhM2YwIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZDA4MDI4MDItMzUyYS04NTRhLTkxYjctNmRlNmQ1MmViM2QwIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjMwMDAwMDAvMTAwMDAiIHRpZmY6WVJlc29sdXRpb249IjMwMDAwMDAvMTAwMDAiIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiIGV4aWY6Q29sb3JTcGFjZT0iMSIgZXhpZjpQaXhlbFhEaW1lbnNpb249IjMwMCIgZXhpZjpQaXhlbFlEaW1lbnNpb249IjMwMCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZDA4MDI4MDItMzUyYS04NTRhLTkxYjctNmRlNmQ1MmViM2QwIiBzdEV2dDp3aGVuPSIyMDIyLTAyLTIyVDIxOjIxOjQ1KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQwNjg2NzJkLWY5NDMtOTU0Mi1iMDBiLTVlMDExNmE1NmIzZSIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xM1QxMDoyNjoxNiswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjZjk1NTE1OC04MjFiLTA4NDUtYWJmNS05YTE1NGM1ZTY4NjEiIHN0RXZ0OndoZW49IjIwMjQtMDEtMTNUMTE6MDQ6MDQrMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZGM1Y2IyNWItZDZlNC0yZjQ2LTgyODQtZmUwOTNlY2M2ZTkxIiBzdEV2dDp3aGVuPSIyMDI0LTAxLTEzVDExOjA0OjA0KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0NzUxMTYwLWQ2OTAtNGU5My1hYTRlLTRjMGE1YjRlNWRhYyIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xM1QxOToxMDoxMCswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmNmOTU1MTU4LTgyMWItMDg0NS1hYmY1LTlhMTU0YzVlNjg2MSIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjM2ZGQ4NTQxLWQ0MWEtYmY0Yy1iZjA3LWNmNjZhNjZhMDg2MSIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmQwODAyODAyLTM1MmEtODU0YS05MWI3LTZkZTZkNTJlYjNkMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Ph2LDQsAAAAJcEhZcwAACxMAAAsTAQCanBgAAAA5UExURUdwTNra2s7Ozq2tre3t7dPT087OzuPj4+3t7dbW1u/v79bW1vz8/MrKytDQ0Nzc3MPDw/X19bi4uMZQDnEAAAAKdFJOUwBqEPywotz+wzqApqiTAAAHW0lEQVR42u1b25akIAwcbx2UFoj//7HLTQVBRcSZfTDnbM/uTl/KSlEkwf75eeONN95444033njjjTduR9/0/yOsbqoevObL7101tYX1HFs9QFtfZalRP+rpQVgdAFx990ZnT8L6eZItUl99jeGpf1DxdV/VP9fV1f/PFlF1bYHoVFSRC60IyVjrFRnuB8IoxpExSrstsErKHpJw1eqybNLbAQvAYkKjUrjoBgKRqAaeIjG5+qaps6hKcMWmcdSwqAJWBbAgCZZaIYbsqggqqlHNbFFa5yVR4jKvrKEErOEjNCqNSwHrfE8lpLsod/u+cOPPMPBJ+Gz5dM0cXNgclre+pSxhYI1WW5Tf9ENSMIdLCiWs6q9hwQprBVYKFqyPlx4WtoSvrT9lC/wkGt8qlkQooC3hi6sgW3Bb8gtdpSV/za/mn49pC0oYhONbfyd5hzDLFivKFpTS1gKM0we0tQCEncfgQn7Rt+DC/299i1MSRJcBC0r7VviG5KZvwV5WIUobxHyrJKy8VRjXVgFYsPu5kOtbxdhycCDuihziXVLoW7xwEiUmDgd544B46luWLW+nugMLB2BimmC3cxTNxCDg8xFtuUSNqoFsDKzY8psa+XtBNWXr74N6qxwsS5T6VL5robKl10+ZRu5S9qBvUYuJwVHzjwjrE3G33qKh+WXBgmkmCvHYquTvZ8oo7rLFA4PJgYW0MdePIRQIGUPNbSMw5lubJMKtJI6+Wk6cVFMmACO+VVryeL7ZgI8MhwS2fnNPPK0geHBRd11eJSiyL4KjrL2umm1XIpRii1MKB/mU/iCZwF+pt5z3UJ7UiF3nQqadAXC3T3xEW2IyuDBe3yDTe0+A64it2WTyYSGVHymUI/EduvSWKJ80Dtv2NbYSoQxbMkVC7yzNGIWFvDF7gRD79RYrWW/BDGti4wwLtgvO7gWKUZ8Mt94qX8vLJE70+xVNwzDm9ghNM+FX7p/jlZUId2HJD+Tf79hMe3WNrAK/30E+C8/6xOCqbqxE5JNMYrNbnaLUvJAewfCg8zF0Ba/tbviWLvPYfsGFA1PVD8ZdnjlVc/DS/o7LK4NHjOjKKbfCTSCo5XmwKbaZM4jlc9NGEYd9Ijd0QS5ZGaOR2O+DPlGyRb2nXZzgnI1GdFWF+0gh3ifyTRqvzpXI2eElk58FeHziCF5hY+hSMV9Ge/mohUTGuQ4vzHYe8bW5sNdFQ58St22Vcf5zzJbtcGT4iYQ7iz8dFuxoWRYMjAM7KCnypHOTLSqdUwYIFpndOD/6B2FBzNQxYmW/zxYE4j8yLHga1s2Rbm/O5PXtGcuNDIW1dTj5hpjGsO+7z2Kk9NP1JWDlnWKAM4H6zCUNM05KyVPHBclYzUbgjE3N3tP2JWHBmbqD4GLeCs2jhMT13lMVljwcEbetwZgtHUxVQ21ho3fE7inf2s8vzMWq0EWpfOBg5hcDSGwaF2+LaysRIzNFqRgBv2sMhi/Ix0WiW8rBKNBv4ExBI7eorx9ANazsPCb5FkSNH+Reacos+AYxaFzX76KMH65c8ytzZ40YvpFAqtgC/otn1eCmMI5K8yVRQVVwq3aVtU+jJktwjyP7x+BKv8vtoH098vXYSJcrWGJcAW11r8WVRxe5vgcuFbXqwnaEZejS6mrLwYKUg1ch2RJswTFYgMOwoau+AQsSp/FuDhVZi7J402ifgGla/GJIzGLYG5H4rnKMCUydL9wcsmZSuPikR2QmjQbWqaV2ob2RdMvaLEvFlRiXpYeTwqVOtMZF+qi0dS4uEjJKMvWuYK3S0jHZwaq7BylYp/O2uu3q04lNqudLWEJQd/3paTBz12IaLIPtzE5P1AUuW9TB8NVzaG9/TIfV+eXsWeezz6HWlptEbo4SIAeWur/Y/RZC/gmZTiLzUY2j5ct6fjKsFvxqgyQxE9sbmfYtnJMIciEKo6+FL0wziJmtkzspIcUl0PgWrL7VCKP7hl61U4WLeN+7Ieli2vZhmq0VgjDOgIyhJ62sSpDkWNZa1wiB8WoLlxzy29XpGVPgn1ut5VYcGyRLK7OCiJaDYMrAneJUkZWdw0yDgNm5nDowqLc0Kp581FO7QS4pC9S/YRW9xkVdNOj0ZHCp9anEZw3VEK/fopiDrkMObkcdJtT1g6+uzQ60bIdUPztdWZWy53m+v/zFYPOGHO4AZsalmtJNkyHrCAx1RXX7mt5g1L1pDezpkXv8wJwpVRSSaf2c26Y0rrXXxyWBptu/ovdak+VhkqjGBZUdvKygqANKA/MqZ/36kcGwFn90RnWp66ksKuHgitLFY8BU+F2ZvqpxpMY9qR3YwOUJ12fc0KUHVKdswcKXuwetErCnwvMKuXxfc/3RVJ2yFc+iosQd3X+WGSVz1UiuN2J156FyVyHbsOUp3krezaPUT/VxXqdfwvknb/Zgp+idTxTbrkLqYuKreRnhy65Gf4W0NsDoYiqf6uZsvr8V9eo6XWc5+3TVf/3N1TfeeOONN95444033njjjTfeSI1/IeOYOeO4fGAAAAAASUVORK5CYII=",
    base64BackToTop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIBAMAAABfdrOtAAAAElBMVEVRUVH+/v5HcEyZmZlRUVFRUVGm1ByOAAAABnRSTlPMzADMTZAJBBGsAAAEnElEQVR42t2cS27jMAyGf7/2U+QCQeDsbeQCgZDujaC5/1UmkzaJn+JDFGcw3LdfflKibJkkDnxrL7dbg7sNt6+L4O8OYBM+B0ys+QrGkHZG+OEEQ8g6go8Bx1GIGMdpNOQyIG6XdMgnSPtKhLQDGEZFBgYMkhKFtGBb0EIEjDgFRowoBVaMGAWpMedEfxMiZtwpUsgZCqtlkCNUdpVAWigtCCCDFtLwIWeoreZCWiRYYEKGFEjDg+yRZCUH0iLRAgNyToXUNCRZyMqWhGnUN2IPm3wSlwJ7IUspyCBkIQUZhCykIIeQuRTkEDKXAuM9srrtYbrZN7Y98giZSoFd+t1OxmMITG0dcrSFXFchZ1tIvQZpYWxhBbK3hpQrkMEa0iwh5t4a+QvZvDXyF7J5a+Qv5PPW21/I5623v5DPW29/IaO3Xv5Clrw1y1/Ikrdm+Qs5svw83yNnSJ5BQb4F/F7EIEJSnThGBAXxkFQfLOviQUE8JAUPsosHBfGQfDAtHhREQ1JxIV00KIgmrnRI84S0yAd5BAXxxJUck0f6Qnwr9qmr6xF5xLMjcwn/iudIEAdWnyjkEXlQKZiRVzoqRyLbgeUKKR8Q4alY7cSnoxzSf2ggsqehKr6YVpcXpOd7H93f60cKhOd7Re2LteUF4eLqiVS1mr0ge4io6C2+soaFkJ7MuuuQs1yITEp9hwwKISIpzR2iESKSIoT0rLNwuVHQqoSIpAQJpGce60vIUSdEIuUqgPTsJ5QFZK8UIpBS8iG94GFrDjlrhfCl8CG96Llxmle4kEr6vKWBPIVo9kqDQSRk9/3cWoikcCFPAd33v4dIChPyEvLzBA6RlEYWke4JEUnhKXkLeUEKxRHJFfKCQHGucIW8IdZSRkLeEGMpYyEjiK2UsZARxFTKRMgYYillImQMMZQyFTKB2EmZCplAuFLIHT8TMoWwpQwiIVMIUwqpZP5bp5CCvCTiQKr5f5lCQN+tPCBn2ZvVDFJwIDUP0m1BYAfZYRNSsCB7BqTbhoARePIxtZ9tgwWkoJcwCalmv3MBAemtO4R6dah2HaKQqj8Zvp9sQDjvJ21+SPCBHPJDDk6QITekEV7gqCC19CpKAym9IMfckKv4olMBCeIrWwVEfvkshzQekO9r9P1/ALk+IG1eSPCDiCJfyG+FyU+A6ZCa/piZDinpz7LpkCv5gdkAEshP5emQhv7onw6pGeULyZCSUYiRDAmMkpJkCKs4JhFSq8p8hJBSVbAkhARV6ZUQoisik0FqXTmcDHLVFfbJIEFXoiiCNMpiSxGkVJaNiiBBWQArgTTaUl4JpNQWJUsgQVteXQg+AKkLxQWFGKW+5J2+eVp4S168X3CF1CltCKdTJ8lb84YK2bUBO+wZW0Pqv9nk4tKu49N45NJC5dMM5tLW5tOg59Jq6NM06dL+abFXwr/RkuvTXJwae1abtE/Dt0/ruksTvs84AZ/BCC4jHnyGVfiM3VBQFANEXEah+Ax18RlP4zNox2dkkM/wI58xTn8yDCXGYCDV3W5RGSajtXyGhG1jbpbjzpwGt/0MJft8jqC7iUbQ/QZaxdnKqcIftwAAAABJRU5ErkJggg=="
  };
  const _sfc_main$g = {
    name: "z-paging-empty-view",
    data() {
      return {};
    },
    props: {
      // 空数据描述文字
      emptyViewText: {
        type: String,
        default: "没有数据哦~"
      },
      // 空数据图片
      emptyViewImg: {
        type: String,
        default: ""
      },
      // 是否显示空数据图重新加载按钮
      showEmptyViewReload: {
        type: Boolean,
        default: false
      },
      // 空数据点击重新加载文字
      emptyViewReloadText: {
        type: String,
        default: "重新加载"
      },
      // 是否是加载失败
      isLoadFailed: {
        type: Boolean,
        default: false
      },
      // 空数据图样式
      emptyViewStyle: {
        type: Object,
        default: function() {
          return {};
        }
      },
      // 空数据图img样式
      emptyViewImgStyle: {
        type: Object,
        default: function() {
          return {};
        }
      },
      // 空数据图描述文字样式
      emptyViewTitleStyle: {
        type: Object,
        default: function() {
          return {};
        }
      },
      // 空数据图重新加载按钮样式
      emptyViewReloadStyle: {
        type: Object,
        default: function() {
          return {};
        }
      },
      // 空数据图z-index
      emptyViewZIndex: {
        type: Number,
        default: 9
      },
      // 空数据图片是否使用fixed布局并铺满z-paging
      emptyViewFixed: {
        type: Boolean,
        default: true
      },
      // 空数据图中布局的单位，默认为rpx
      unit: {
        type: String,
        default: "rpx"
      }
    },
    computed: {
      emptyImg() {
        return this.isLoadFailed ? zStatic.base64Error : zStatic.base64Empty;
      },
      finalEmptyViewStyle() {
        this.emptyViewStyle["z-index"] = this.emptyViewZIndex;
        return this.emptyViewStyle;
      }
    },
    methods: {
      // 点击了reload按钮
      reloadClick() {
        this.$emit("reload");
      },
      // 点击了空数据view
      emptyViewClick() {
        this.$emit("viewClick");
      }
    }
  };
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass({ "zp-container": true, "zp-container-fixed": $props.emptyViewFixed }),
        style: vue.normalizeStyle([$options.finalEmptyViewStyle]),
        onClick: _cache[1] || (_cache[1] = (...args) => $options.emptyViewClick && $options.emptyViewClick(...args))
      },
      [
        vue.createElementVNode("view", { class: "zp-main" }, [
          !$props.emptyViewImg.length ? (vue.openBlock(), vue.createElementBlock("image", {
            key: 0,
            class: vue.normalizeClass({ "zp-main-image-rpx": $props.unit === "rpx", "zp-main-image-px": $props.unit === "px" }),
            style: vue.normalizeStyle([$props.emptyViewImgStyle]),
            src: $options.emptyImg
          }, null, 14, ["src"])) : (vue.openBlock(), vue.createElementBlock("image", {
            key: 1,
            class: vue.normalizeClass({ "zp-main-image-rpx": $props.unit === "rpx", "zp-main-image-px": $props.unit === "px" }),
            mode: "aspectFit",
            style: vue.normalizeStyle([$props.emptyViewImgStyle]),
            src: $props.emptyViewImg
          }, null, 14, ["src"])),
          vue.createElementVNode(
            "text",
            {
              class: vue.normalizeClass(["zp-main-title", { "zp-main-title-rpx": $props.unit === "rpx", "zp-main-title-px": $props.unit === "px" }]),
              style: vue.normalizeStyle([$props.emptyViewTitleStyle])
            },
            vue.toDisplayString($props.emptyViewText),
            7
            /* TEXT, CLASS, STYLE */
          ),
          $props.showEmptyViewReload ? (vue.openBlock(), vue.createElementBlock(
            "text",
            {
              key: 2,
              class: vue.normalizeClass({ "zp-main-error-btn": true, "zp-main-error-btn-rpx": $props.unit === "rpx", "zp-main-error-btn-px": $props.unit === "px" }),
              style: vue.normalizeStyle([$props.emptyViewReloadStyle]),
              onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $options.reloadClick && $options.reloadClick(...args), ["stop"]))
            },
            vue.toDisplayString($props.emptyViewReloadText),
            7
            /* TEXT, CLASS, STYLE */
          )) : vue.createCommentVNode("v-if", true)
        ])
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const __easycom_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$f], ["__scopeId", "data-v-b55bdf15"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/z-paging/components/z-paging-empty-view/z-paging-empty-view.vue"]]);
  const c$1 = {
    // 当前版本号
    version: "2.7.12",
    // 延迟操作的通用时间
    delayTime: 100,
    // 请求失败时候全局emit使用的key
    errorUpdateKey: "z-paging-error-emit",
    // 全局emit complete的key
    completeUpdateKey: "z-paging-complete-emit",
    // z-paging缓存的前缀key
    cachePrefixKey: "z-paging-cache",
    // 虚拟列表中列表index的key
    listCellIndexKey: "zp_index",
    // 虚拟列表中列表的唯一key
    listCellIndexUniqueKey: "zp_unique_index"
  };
  const zLocalConfig = {};
  const storageKey = "Z-PAGING-REFRESHER-TIME-STORAGE-KEY";
  let config = null;
  let configLoaded = false;
  const timeoutMap = {};
  function gc(key, defaultValue) {
    return () => {
      _handleDefaultConfig();
      if (!config)
        return defaultValue;
      const value = config[key];
      return value === void 0 ? defaultValue : value;
    };
  }
  function getTouch(e2) {
    let touch = null;
    if (e2.touches && e2.touches.length) {
      touch = e2.touches[0];
    } else if (e2.changedTouches && e2.changedTouches.length) {
      touch = e2.changedTouches[0];
    } else if (e2.datail && e2.datail != {}) {
      touch = e2.datail;
    } else {
      return { touchX: 0, touchY: 0 };
    }
    return {
      touchX: touch.clientX,
      touchY: touch.clientY
    };
  }
  function getTouchFromZPaging(target) {
    if (target && target.tagName && target.tagName !== "BODY" && target.tagName !== "UNI-PAGE-BODY") {
      const classList = target.classList;
      if (classList && classList.contains("z-paging-content")) {
        return {
          isFromZp: true,
          isPageScroll: classList.contains("z-paging-content-page"),
          isReachedTop: classList.contains("z-paging-reached-top"),
          isUseChatRecordMode: classList.contains("z-paging-use-chat-record-mode")
        };
      } else {
        return getTouchFromZPaging(target.parentNode);
      }
    } else {
      return { isFromZp: false };
    }
  }
  function getParent(parent) {
    if (!parent)
      return null;
    if (parent.$refs.paging)
      return parent;
    return getParent(parent.$parent);
  }
  function consoleErr(err) {
    formatAppLog("error", "at node_modules/z-paging/components/z-paging/js/z-paging-utils.js:72", `[z-paging]${err}`);
  }
  function delay(callback, ms = c$1.delayTime, key) {
    const timeout2 = setTimeout(callback, ms);
    if (!!key) {
      timeoutMap[key] && clearTimeout(timeoutMap[key]);
      timeoutMap[key] = timeout2;
    }
    return timeout2;
  }
  function setRefesrherTime(time, key) {
    const datas = getRefesrherTime() || {};
    datas[key] = time;
    uni.setStorageSync(storageKey, datas);
  }
  function getRefesrherTime() {
    return uni.getStorageSync(storageKey);
  }
  function getRefesrherTimeByKey(key) {
    const datas = getRefesrherTime();
    return datas && datas[key] ? datas[key] : null;
  }
  function getRefesrherFormatTimeByKey(key, textMap) {
    const time = getRefesrherTimeByKey(key);
    const timeText = time ? _timeFormat(time, textMap) : textMap.none;
    return `${textMap.title}${timeText}`;
  }
  function convertToPx(text) {
    const dataType = Object.prototype.toString.call(text);
    if (dataType === "[object Number]")
      return text;
    let isRpx = false;
    if (text.indexOf("rpx") !== -1 || text.indexOf("upx") !== -1) {
      text = text.replace("rpx", "").replace("upx", "");
      isRpx = true;
    } else if (text.indexOf("px") !== -1) {
      text = text.replace("px", "");
    }
    if (!isNaN(text)) {
      if (isRpx)
        return Number(uni.upx2px(text));
      return Number(text);
    }
    return 0;
  }
  function getTime() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function getInstanceId() {
    const s2 = [];
    const hexDigits = "0123456789abcdef";
    for (let i2 = 0; i2 < 10; i2++) {
      s2[i2] = hexDigits.substr(Math.floor(Math.random() * 16), 1);
    }
    return s2.join("") + getTime();
  }
  function wait(ms) {
    return new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
  }
  function isPromise(func2) {
    return Object.prototype.toString.call(func2) === "[object Promise]";
  }
  function addUnit$1(value, unit) {
    if (Object.prototype.toString.call(value) === "[object String]") {
      let tempValue = value;
      tempValue = tempValue.replace("rpx", "").replace("upx", "").replace("px", "");
      if (value.indexOf("rpx") === -1 && value.indexOf("upx") === -1 && value.indexOf("px") !== -1) {
        tempValue = parseFloat(tempValue) * 2;
      }
      value = tempValue;
    }
    return unit === "rpx" ? value + "rpx" : value / 2 + "px";
  }
  function deepCopy(obj) {
    if (typeof obj !== "object" || obj === null)
      return obj;
    let newObj = Array.isArray(obj) ? [] : {};
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        newObj[key] = deepCopy(obj[key]);
      }
    }
    return newObj;
  }
  function _handleDefaultConfig() {
    if (configLoaded)
      return;
    if (zLocalConfig && Object.keys(zLocalConfig).length) {
      config = zLocalConfig;
    }
    if (!config && uni.$zp) {
      config = uni.$zp.config;
    }
    config = config ? Object.keys(config).reduce((result, key) => {
      result[_toCamelCase(key)] = config[key];
      return result;
    }, {}) : null;
    configLoaded = true;
  }
  function _timeFormat(time, textMap) {
    const date2 = new Date(time);
    const currentDate = /* @__PURE__ */ new Date();
    const dateDay = new Date(time).setHours(0, 0, 0, 0);
    const currentDateDay = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
    const disTime = dateDay - currentDateDay;
    let dayStr = "";
    const timeStr = _dateTimeFormat(date2);
    if (disTime === 0) {
      dayStr = textMap.today;
    } else if (disTime === -864e5) {
      dayStr = textMap.yesterday;
    } else {
      dayStr = _dateDayFormat(date2, date2.getFullYear() !== currentDate.getFullYear());
    }
    return `${dayStr} ${timeStr}`;
  }
  function _dateDayFormat(date2, showYear = true) {
    const year = date2.getFullYear();
    const month = date2.getMonth() + 1;
    const day = date2.getDate();
    return showYear ? `${year}-${_fullZeroToTwo(month)}-${_fullZeroToTwo(day)}` : `${_fullZeroToTwo(month)}-${_fullZeroToTwo(day)}`;
  }
  function _dateTimeFormat(date2) {
    const hour = date2.getHours();
    const minute = date2.getMinutes();
    return `${_fullZeroToTwo(hour)}:${_fullZeroToTwo(minute)}`;
  }
  function _fullZeroToTwo(str) {
    str = str.toString();
    return str.length === 1 ? "0" + str : str;
  }
  function _toCamelCase(value) {
    return value.replace(/-([a-z])/g, (_, group1) => group1.toUpperCase());
  }
  const u$1 = {
    gc,
    setRefesrherTime,
    getRefesrherFormatTimeByKey,
    getTouch,
    getTouchFromZPaging,
    getParent,
    convertToPx,
    getTime,
    getInstanceId,
    consoleErr,
    delay,
    wait,
    isPromise,
    addUnit: addUnit$1,
    deepCopy
  };
  const Enum = {
    // 当前加载类型 0.下拉刷新 1.上拉加载更多
    LoadingType: {
      Refresher: 0,
      LoadingMore: 1
    },
    // 下拉刷新状态 0.默认状态 1.松手立即刷新 2.刷新中 3.刷新结束 4.松手进入二楼
    Refresher: {
      Default: 0,
      ReleaseToRefresh: 1,
      Loading: 2,
      Complete: 3,
      GoF2: 4
    },
    // 底部加载更多状态 0.默认状态 1.加载中 2.没有更多数据 3.加载失败
    More: {
      Default: 0,
      Loading: 1,
      NoMore: 2,
      Fail: 3
    },
    // @query触发来源 0.用户主动下拉刷新 1.通过reload触发 2.通过refresh触发 3.通过滚动到底部加载更多或点击底部加载更多触发
    QueryFrom: {
      UserPullDown: 0,
      Reload: 1,
      Refresh: 2,
      LoadingMore: 3
    },
    // 虚拟列表cell高度模式
    CellHeightMode: {
      // 固定高度
      Fixed: "fixed",
      // 动态高度
      Dynamic: "dynamic"
    },
    // 列表缓存模式
    CacheMode: {
      // 默认模式，只会缓存一次
      Default: "default",
      // 总是缓存，每次列表刷新(下拉刷新、调用reload等)都会更新缓存
      Always: "always"
    }
  };
  const _sfc_main$f = {
    name: "z-paging-refresh",
    data() {
      return {
        R: Enum.Refresher,
        isIos: uni.getSystemInfoSync().platform === "ios",
        refresherTimeText: "",
        zTheme: {
          title: { white: "#efefef", black: "#555555" },
          arrow: { white: zStatic.base64ArrowWhite, black: zStatic.base64Arrow },
          flower: { white: zStatic.base64FlowerWhite, black: zStatic.base64Flower },
          success: { white: zStatic.base64SuccessWhite, black: zStatic.base64Success },
          indicator: { white: "#eeeeee", black: "#777777" }
        }
      };
    },
    props: [
      "status",
      "defaultThemeStyle",
      "defaultText",
      "pullingText",
      "refreshingText",
      "completeText",
      "goF2Text",
      "defaultImg",
      "pullingImg",
      "refreshingImg",
      "completeImg",
      "refreshingAnimated",
      "showUpdateTime",
      "updateTimeKey",
      "imgStyle",
      "titleStyle",
      "updateTimeStyle",
      "updateTimeTextMap",
      "unit"
    ],
    computed: {
      ts() {
        return this.defaultThemeStyle;
      },
      // 当前状态数组
      statusTextArr() {
        this.updateTime();
        return [this.defaultText, this.pullingText, this.refreshingText, this.completeText, this.goF2Text];
      },
      // 当前状态文字
      currentTitle() {
        return this.statusTextArr[this.status] || this.defaultText;
      },
      // 左侧图片class
      leftImageClass() {
        const preSizeClass = `zp-r-left-image-pre-size-${this.unit}`;
        if (this.status === this.R.Complete)
          return preSizeClass;
        return `zp-r-left-image ${preSizeClass} ${this.status === this.R.Default ? "zp-r-arrow-down" : "zp-r-arrow-top"}`;
      },
      // 左侧图片style
      leftImageStyle() {
        const showUpdateTime = this.showUpdateTime;
        const size = showUpdateTime ? u$1.addUnit(36, this.unit) : u$1.addUnit(34, this.unit);
        return { width: size, height: size, "margin-right": showUpdateTime ? u$1.addUnit(20, this.unit) : u$1.addUnit(9, this.unit) };
      },
      // 左侧图片src
      leftImageSrc() {
        const R = this.R;
        const status = this.status;
        if (status === R.Default) {
          if (!!this.defaultImg)
            return this.defaultImg;
          return this.zTheme.arrow[this.ts];
        } else if (status === R.ReleaseToRefresh) {
          if (!!this.pullingImg)
            return this.pullingImg;
          if (!!this.defaultImg)
            return this.defaultImg;
          return this.zTheme.arrow[this.ts];
        } else if (status === R.Loading) {
          if (!!this.refreshingImg)
            return this.refreshingImg;
          return this.zTheme.flower[this.ts];
        } else if (status === R.Complete) {
          if (!!this.completeImg)
            return this.completeImg;
          return this.zTheme.success[this.ts];
        } else if (status === R.GoF2) {
          return this.zTheme.arrow[this.ts];
        }
        return "";
      },
      // 右侧文字style
      rightTextStyle() {
        let stl = {};
        stl["color"] = this.zTheme.title[this.ts];
        stl["font-size"] = u$1.addUnit(30, this.unit);
        return stl;
      }
    },
    methods: {
      // 添加单位
      addUnit(value, unit) {
        return u$1.addUnit(value, unit);
      },
      // 更新下拉刷新时间
      updateTime() {
        if (this.showUpdateTime) {
          this.refresherTimeText = u$1.getRefesrherFormatTimeByKey(this.updateTimeKey, this.updateTimeTextMap);
        }
      }
    }
  };
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { style: { "height": "100%" } }, [
      vue.createElementVNode(
        "view",
        {
          class: vue.normalizeClass($props.showUpdateTime ? "zp-r-container zp-r-container-padding" : "zp-r-container")
        },
        [
          vue.createElementVNode("view", { class: "zp-r-left" }, [
            vue.createCommentVNode(" 非加载中(继续下拉刷新、松手立即刷新状态图片) "),
            $props.status !== $data.R.Loading ? (vue.openBlock(), vue.createElementBlock("image", {
              key: 0,
              class: vue.normalizeClass($options.leftImageClass),
              style: vue.normalizeStyle([$options.leftImageStyle, $props.imgStyle]),
              src: $options.leftImageSrc
            }, null, 14, ["src"])) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" 加载状态图片 "),
                vue.createElementVNode("image", {
                  class: vue.normalizeClass({ "zp-line-loading-image": $props.refreshingAnimated, "zp-r-left-image": true, "zp-r-left-image-pre-size-rpx": $props.unit === "rpx", "zp-r-left-image-pre-size-px": $props.unit === "px" }),
                  style: vue.normalizeStyle([$options.leftImageStyle, $props.imgStyle]),
                  src: $options.leftImageSrc
                }, null, 14, ["src"])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )),
            vue.createCommentVNode(" 在nvue中，加载状态loading使用系统loading ")
          ]),
          vue.createCommentVNode(" 右侧文字内容 "),
          vue.createElementVNode("view", { class: "zp-r-right" }, [
            vue.createCommentVNode(" 右侧下拉刷新状态文字 "),
            vue.createElementVNode(
              "text",
              {
                class: "zp-r-right-text",
                style: vue.normalizeStyle([$options.rightTextStyle, $props.titleStyle])
              },
              vue.toDisplayString($options.currentTitle),
              5
              /* TEXT, STYLE */
            ),
            vue.createCommentVNode(" 右侧下拉刷新时间文字 "),
            $props.showUpdateTime && $data.refresherTimeText.length ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 0,
                class: vue.normalizeClass(["zp-r-right-text", { "zp-r-right-time-text-rpx": $props.unit === "rpx", "zp-r-right-time-text-px": $props.unit === "px" }]),
                style: vue.normalizeStyle([{ color: $data.zTheme.title[$options.ts] }, $props.updateTimeStyle])
              },
              vue.toDisplayString($data.refresherTimeText),
              7
              /* TEXT, CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true)
          ])
        ],
        2
        /* CLASS */
      )
    ]);
  }
  const zPagingRefresh = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$e], ["__scopeId", "data-v-fff6d205"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/z-paging/components/z-paging/components/z-paging-refresh.vue"]]);
  const _sfc_main$e = {
    name: "z-paging-load-more",
    data() {
      return {
        M: Enum.More,
        zTheme: {
          title: { white: "#efefef", black: "#a4a4a4" },
          line: { white: "#efefef", black: "#eeeeee" },
          circleBorder: { white: "#aaaaaa", black: "#c8c8c8" },
          circleBorderTop: { white: "#ffffff", black: "#444444" },
          flower: { white: zStatic.base64FlowerWhite, black: zStatic.base64Flower },
          indicator: { white: "#eeeeee", black: "#777777" }
        }
      };
    },
    props: ["zConfig"],
    computed: {
      ts() {
        return this.c.defaultThemeStyle;
      },
      // 底部加载更多配置
      c() {
        return this.zConfig || {};
      },
      // 底部加载更多文字
      ownLoadingMoreText() {
        const statusTextArr = [this.c.defaultText, this.c.loadingText, this.c.noMoreText, this.c.failText];
        return statusTextArr[this.finalStatus];
      },
      // 底部加载更多状态
      finalStatus() {
        if (this.c.defaultAsLoading && this.c.status === this.M.Default)
          return this.M.Loading;
        return this.c.status;
      },
      // 加载更多icon类型
      finalLoadingIconType() {
        return this.c.loadingIconType;
      }
    },
    methods: {
      // 点击了加载更多
      doClick() {
        this.$emit("doClick");
      }
    }
  };
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["zp-l-container", { "zp-l-container-rpx": $options.c.unit === "rpx", "zp-l-container-px": $options.c.unit === "px" }]),
        style: vue.normalizeStyle([$options.c.customStyle]),
        onClick: _cache[0] || (_cache[0] = (...args) => $options.doClick && $options.doClick(...args))
      },
      [
        !$options.c.hideContent ? (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          { key: 0 },
          [
            vue.createCommentVNode(" 底部加载更多没有更多数据分割线 "),
            $options.c.showNoMoreLine && $options.finalStatus === $data.M.NoMore ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 0,
                class: vue.normalizeClass({ "zp-l-line-rpx": $options.c.unit === "rpx", "zp-l-line-px": $options.c.unit === "px" }),
                style: vue.normalizeStyle([{ backgroundColor: $data.zTheme.line[$options.ts] }, $options.c.noMoreLineCustomStyle])
              },
              null,
              6
              /* CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode(" 底部加载更多loading "),
            $options.finalStatus === $data.M.Loading && !!$options.c.loadingIconCustomImage ? (vue.openBlock(), vue.createElementBlock("image", {
              key: 1,
              src: $options.c.loadingIconCustomImage,
              style: vue.normalizeStyle([$options.c.iconCustomStyle]),
              class: vue.normalizeClass({ "zp-l-line-loading-custom-image": true, "zp-l-line-loading-custom-image-animated": $options.c.loadingAnimated, "zp-l-line-loading-custom-image-rpx": $options.c.unit === "rpx", "zp-l-line-loading-custom-image-px": $options.c.unit === "px" })
            }, null, 14, ["src"])) : vue.createCommentVNode("v-if", true),
            $options.finalStatus === $data.M.Loading && $options.finalLoadingIconType === "flower" && !$options.c.loadingIconCustomImage.length ? (vue.openBlock(), vue.createElementBlock("image", {
              key: 2,
              class: vue.normalizeClass({ "zp-line-loading-image": true, "zp-line-loading-image-rpx": $options.c.unit === "rpx", "zp-line-loading-image-px": $options.c.unit === "px" }),
              style: vue.normalizeStyle([$options.c.iconCustomStyle]),
              src: $data.zTheme.flower[$options.ts]
            }, null, 14, ["src"])) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode(" 底部加载更多文字 "),
            $options.finalStatus === $data.M.Loading && $options.finalLoadingIconType === "circle" && !$options.c.loadingIconCustomImage.length ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 3,
                class: vue.normalizeClass(["zp-l-circle-loading-view", { "zp-l-circle-loading-view-rpx": $options.c.unit === "rpx", "zp-l-circle-loading-view-px": $options.c.unit === "px" }]),
                style: vue.normalizeStyle([{ borderColor: $data.zTheme.circleBorder[$options.ts], borderTopColor: $data.zTheme.circleBorderTop[$options.ts] }, $options.c.iconCustomStyle])
              },
              null,
              6
              /* CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true),
            !$options.c.isChat || !$options.c.chatDefaultAsLoading && $options.finalStatus === $data.M.Default || $options.finalStatus === $data.M.Fail ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 4,
                class: vue.normalizeClass({ "zp-l-text-rpx": $options.c.unit === "rpx", "zp-l-text-px": $options.c.unit === "px" }),
                style: vue.normalizeStyle([{ color: $data.zTheme.title[$options.ts] }, $options.c.titleCustomStyle])
              },
              vue.toDisplayString($options.ownLoadingMoreText),
              7
              /* TEXT, CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode(" 底部加载更多没有更多数据分割线 "),
            $options.c.showNoMoreLine && $options.finalStatus === $data.M.NoMore ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 5,
                class: vue.normalizeClass({ "zp-l-line-rpx": $options.c.unit === "rpx", "zp-l-line-px": $options.c.unit === "px" }),
                style: vue.normalizeStyle([{ backgroundColor: $data.zTheme.line[$options.ts] }, $options.c.noMoreLineCustomStyle])
              },
              null,
              6
              /* CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true)
          ],
          64
          /* STABLE_FRAGMENT */
        )) : vue.createCommentVNode("v-if", true)
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const zPagingLoadMore = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d], ["__scopeId", "data-v-0a5fd7d6"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/z-paging/components/z-paging/components/z-paging-load-more.vue"]]);
  const commonLayoutModule = {
    data() {
      return {
        systemInfo: null,
        cssSafeAreaInsetBottom: -1,
        isReadyDestroy: false
      };
    },
    computed: {
      // 顶部可用距离
      windowTop() {
        if (!this.systemInfo)
          return 0;
        return this.systemInfo.windowTop || 0;
      },
      // 底部安全区域高度
      safeAreaBottom() {
        if (!this.systemInfo)
          return 0;
        let safeAreaBottom = 0;
        safeAreaBottom = this.systemInfo.safeAreaInsets.bottom || 0;
        return safeAreaBottom;
      },
      // 是否是比较老的webview，在一些老的webview中，需要进行一些特殊处理
      isOldWebView() {
        try {
          const systemInfos = uni.getSystemInfoSync().system.split(" ");
          const deviceType = systemInfos[0];
          const version2 = parseInt(systemInfos[1]);
          if (deviceType === "iOS" && version2 <= 10 || deviceType === "Android" && version2 <= 6) {
            return true;
          }
        } catch (e2) {
          return false;
        }
        return false;
      },
      // 当前组件的$slots，兼容不同平台
      zSlots() {
        return this.$slots;
      }
    },
    beforeDestroy() {
      this.isReadyDestroy = true;
    },
    unmounted() {
      this.isReadyDestroy = true;
    },
    methods: {
      // 更新fixed模式下z-paging的布局
      updateFixedLayout() {
        this.fixed && this.$nextTick(() => {
          this.systemInfo = uni.getSystemInfoSync();
        });
      },
      // 获取节点尺寸
      _getNodeClientRect(select, inDom = true, scrollOffset = false) {
        if (this.isReadyDestroy) {
          return Promise.resolve(false);
        }
        let res = !!inDom ? uni.createSelectorQuery().in(inDom === true ? this : inDom) : uni.createSelectorQuery();
        scrollOffset ? res.select(select).scrollOffset() : res.select(select).boundingClientRect();
        return new Promise((resolve, reject) => {
          res.exec((data) => {
            resolve(data && data != "" && data != void 0 && data.length ? data : false);
          });
        });
      },
      // 获取slot="left"和slot="right"宽度并且更新布局
      _updateLeftAndRightWidth(targetStyle, parentNodePrefix) {
        this.$nextTick(() => {
          let delayTime = 0;
          setTimeout(() => {
            ["left", "right"].map((position) => {
              this._getNodeClientRect(`.${parentNodePrefix}-${position}`).then((res) => {
                this.$set(targetStyle, position, res ? res[0].width + "px" : "0px");
              });
            });
          }, delayTime);
        });
      },
      // 通过获取css设置的底部安全区域占位view高度设置bottom距离（直接通过systemInfo在部分平台上无法获取到底部安全区域）
      _getCssSafeAreaInsetBottom(success) {
        this._getNodeClientRect(".zp-safe-area-inset-bottom").then((res) => {
          this.cssSafeAreaInsetBottom = res ? res[0].height : -1;
          res && success && success();
        });
      }
    }
  };
  const queryKey = "Query";
  const fetchParamsKey = "FetchParams";
  const fetchResultKey = "FetchResult";
  const language2LocalKey = "Language2Local";
  function handleQuery(callback) {
    _addHandleByKey(queryKey, callback);
    return this;
  }
  function _handleQuery(pageNo, pageSize, from, lastItem) {
    const callback = _getHandleByKey(queryKey);
    return callback ? callback(pageNo, pageSize, from, lastItem) : [pageNo, pageSize, from];
  }
  function handleFetchParams(callback) {
    _addHandleByKey(fetchParamsKey, callback);
    return this;
  }
  function _handleFetchParams(parmas, extraParams) {
    const callback = _getHandleByKey(fetchParamsKey);
    return callback ? callback(parmas, extraParams || {}) : { pageNo: parmas.pageNo, pageSize: parmas.pageSize, ...extraParams || {} };
  }
  function handleFetchResult(callback) {
    _addHandleByKey(fetchResultKey, callback);
    return this;
  }
  function _handleFetchResult(result, paging, params) {
    const callback = _getHandleByKey(fetchResultKey);
    callback && callback(result, paging, params);
    return callback ? true : false;
  }
  function handleLanguage2Local(callback) {
    _addHandleByKey(language2LocalKey, callback);
    return this;
  }
  function _handleLanguage2Local(language2, local) {
    const callback = _getHandleByKey(language2LocalKey);
    return callback ? callback(language2, local) : local;
  }
  function _getApp() {
    return getApp();
  }
  function _hasGlobalData() {
    return _getApp() && _getApp().globalData;
  }
  function _addHandleByKey(key, callback) {
    try {
      setTimeout(function() {
        if (_hasGlobalData()) {
          _getApp().globalData[`zp_handle${key}Callback`] = callback;
        }
      }, 1);
    } catch (_) {
    }
  }
  function _getHandleByKey(key) {
    return _hasGlobalData() ? _getApp().globalData[`zp_handle${key}Callback`] : null;
  }
  const interceptor = {
    handleQuery,
    _handleQuery,
    handleFetchParams,
    _handleFetchParams,
    handleFetchResult,
    _handleFetchResult,
    handleLanguage2Local,
    _handleLanguage2Local
  };
  const dataHandleModule = {
    props: {
      // 自定义初始的pageNo，默认为1
      defaultPageNo: {
        type: [Number, String],
        default: u$1.gc("defaultPageNo", 1),
        observer: function(newVal) {
          this.pageNo = newVal;
        }
      },
      // 自定义pageSize，默认为10
      defaultPageSize: {
        type: [Number, String],
        default: u$1.gc("defaultPageSize", 10),
        validator: (value) => {
          if (value <= 0)
            u$1.consoleErr("default-page-size必须大于0！");
          return value > 0;
        }
      },
      // 为保证数据一致，设置当前tab切换时的标识key，并在complete中传递相同key，若二者不一致，则complete将不会生效
      dataKey: {
        type: [Number, String, Object],
        default: u$1.gc("dataKey", null)
      },
      // 使用缓存，若开启将自动缓存第一页的数据，默认为否。请注意，因考虑到切换tab时不同tab数据不同的情况，默认仅会缓存组件首次加载时第一次请求到的数据，后续的下拉刷新操作不会更新缓存。
      useCache: {
        type: Boolean,
        default: u$1.gc("useCache", false)
      },
      // 使用缓存时缓存的key，用于区分不同列表的缓存数据，useCache为true时必须设置，否则缓存无效
      cacheKey: {
        type: String,
        default: u$1.gc("cacheKey", null)
      },
      // 缓存模式，默认仅会缓存组件首次加载时第一次请求到的数据，可设置为always，即代表总是缓存，每次列表刷新(下拉刷新、调用reload等)都会更新缓存
      cacheMode: {
        type: String,
        default: u$1.gc("cacheMode", Enum.CacheMode.Default)
      },
      // 自动注入的list名，可自动修改父view(包含ref="paging")中对应name的list值
      autowireListName: {
        type: String,
        default: u$1.gc("autowireListName", "")
      },
      // 自动注入的query名，可自动调用父view(包含ref="paging")中的query方法
      autowireQueryName: {
        type: String,
        default: u$1.gc("autowireQueryName", "")
      },
      // 获取分页数据Function，功能与@query类似。若设置了fetch则@query将不再触发
      fetch: {
        type: Function,
        default: null
      },
      // fetch的附加参数，fetch配置后有效
      fetchParams: {
        type: Object,
        default: u$1.gc("fetchParams", null)
      },
      // z-paging mounted后自动调用reload方法(mounted后自动调用接口)，默认为是
      auto: {
        type: Boolean,
        default: u$1.gc("auto", true)
      },
      // 用户下拉刷新时是否触发reload方法，默认为是
      reloadWhenRefresh: {
        type: Boolean,
        default: u$1.gc("reloadWhenRefresh", true)
      },
      // reload时自动滚动到顶部，默认为是
      autoScrollToTopWhenReload: {
        type: Boolean,
        default: u$1.gc("autoScrollToTopWhenReload", true)
      },
      // reload时立即自动清空原list，默认为是，若立即自动清空，则在reload之后、请求回调之前页面是空白的
      autoCleanListWhenReload: {
        type: Boolean,
        default: u$1.gc("autoCleanListWhenReload", true)
      },
      // 列表刷新时自动显示下拉刷新view，默认为否
      showRefresherWhenReload: {
        type: Boolean,
        default: u$1.gc("showRefresherWhenReload", false)
      },
      // 列表刷新时自动显示加载更多view，且为加载中状态，默认为否
      showLoadingMoreWhenReload: {
        type: Boolean,
        default: u$1.gc("showLoadingMoreWhenReload", false)
      },
      // 组件created时立即触发reload(可解决一些情况下先看到页面再看到loading的问题)，auto为true时有效。为否时将在mounted+nextTick后触发reload，默认为否
      createdReload: {
        type: Boolean,
        default: u$1.gc("createdReload", false)
      },
      // 本地分页时上拉加载更多延迟时间，单位为毫秒，默认200毫秒
      localPagingLoadingTime: {
        type: [Number, String],
        default: u$1.gc("localPagingLoadingTime", 200)
      },
      // 自动拼接complete中传过来的数组(使用聊天记录模式时无效)
      concat: {
        type: Boolean,
        default: u$1.gc("concat", true)
      },
      // 请求失败是否触发reject，默认为是
      callNetworkReject: {
        type: Boolean,
        default: u$1.gc("callNetworkReject", true)
      },
      // 父组件v-model所绑定的list的值
      value: {
        type: Array,
        default: function() {
          return [];
        }
      },
      modelValue: {
        type: Array,
        default: function() {
          return [];
        }
      }
    },
    data() {
      return {
        currentData: [],
        totalData: [],
        realTotalData: [],
        totalLocalPagingList: [],
        dataPromiseResultMap: {
          reload: null,
          complete: null,
          localPaging: null
        },
        isSettingCacheList: false,
        pageNo: 1,
        currentRefreshPageSize: 0,
        isLocalPaging: false,
        isAddedData: false,
        isTotalChangeFromAddData: false,
        privateConcat: true,
        myParentQuery: -1,
        firstPageLoaded: false,
        pagingLoaded: false,
        loaded: false,
        isUserReload: true,
        fromEmptyViewReload: false,
        queryFrom: "",
        listRendering: false,
        isHandlingRefreshToPage: false,
        isFirstPageAndNoMore: false,
        totalDataChangeThrow: true
      };
    },
    computed: {
      pageSize() {
        return this.defaultPageSize;
      },
      finalConcat() {
        return this.concat && this.privateConcat;
      },
      finalUseCache() {
        if (this.useCache && !this.cacheKey) {
          u$1.consoleErr("use-cache为true时，必须设置cache-key，否则缓存无效！");
        }
        return this.useCache && !!this.cacheKey;
      },
      finalCacheKey() {
        return this.cacheKey ? `${c$1.cachePrefixKey}-${this.cacheKey}` : null;
      },
      isFirstPage() {
        return this.pageNo === this.defaultPageNo;
      }
    },
    watch: {
      totalData(newVal, oldVal) {
        this._totalDataChange(newVal, oldVal, this.totalDataChangeThrow);
        this.totalDataChangeThrow = true;
      },
      currentData(newVal, oldVal) {
        this._currentDataChange(newVal, oldVal);
      },
      useChatRecordMode(newVal, oldVal) {
        if (newVal) {
          this.nLoadingMoreFixedHeight = false;
        }
      },
      value: {
        handler(newVal) {
          if (newVal !== this.totalData) {
            this.totalDataChangeThrow = false;
            this.totalData = newVal;
          }
        },
        immediate: true
      },
      modelValue: {
        handler(newVal) {
          if (newVal !== this.totalData) {
            this.totalDataChangeThrow = false;
            this.totalData = newVal;
          }
        },
        immediate: true
      }
    },
    methods: {
      // 请求结束(成功或者失败)调用此方法，将请求的结果传递给z-paging处理，第一个参数为请求结果数组，第二个参数为是否成功(默认为是）
      complete(data, success = true) {
        this.customNoMore = -1;
        return this.addData(data, success);
      },
      //【保证数据一致】请求结束(成功或者失败)调用此方法，将请求的结果传递给z-paging处理，第一个参数为请求结果数组，第二个参数为dataKey，需与:data-key绑定的一致，第三个参数为是否成功(默认为是）
      completeByKey(data, dataKey = null, success = true) {
        if (dataKey !== null && this.dataKey !== null && dataKey !== this.dataKey) {
          this.isFirstPage && this.endRefresh();
          return new Promise((resolve) => resolve());
        }
        this.customNoMore = -1;
        return this.addData(data, success);
      },
      //【通过total判断是否有更多数据】请求结束(成功或者失败)调用此方法，将请求的结果传递给z-paging处理，第一个参数为请求结果数组，第二个参数为total(列表总数)，第三个参数为是否成功(默认为是）
      completeByTotal(data, total, success = true) {
        if (total == "undefined") {
          this.customNoMore = -1;
        } else {
          const dataTypeRes = this._checkDataType(data, success, false);
          data = dataTypeRes.data;
          success = dataTypeRes.success;
          if (total >= 0 && success) {
            return new Promise((resolve, reject) => {
              this.$nextTick(() => {
                let nomore = false;
                const realTotalDataCount = this.pageNo == this.defaultPageNo ? 0 : this.realTotalData.length;
                const dataLength = this.privateConcat ? data.length : 0;
                let exceedCount = realTotalDataCount + dataLength - total;
                if (exceedCount >= 0) {
                  nomore = true;
                  exceedCount = this.defaultPageSize - exceedCount;
                  if (this.privateConcat && exceedCount > 0 && exceedCount < data.length) {
                    data = data.splice(0, exceedCount);
                  }
                }
                this.completeByNoMore(data, nomore, success).then((res) => resolve(res)).catch(() => reject());
              });
            });
          }
        }
        return this.addData(data, success);
      },
      //【自行判断是否有更多数据】请求结束(成功或者失败)调用此方法，将请求的结果传递给z-paging处理，第一个参数为请求结果数组，第二个参数为是否没有更多数据，第三个参数为是否成功(默认是是）
      completeByNoMore(data, nomore, success = true) {
        if (nomore != "undefined") {
          this.customNoMore = nomore == true ? 1 : 0;
        }
        return this.addData(data, success);
      },
      // 请求结束且请求失败时调用，支持传入请求失败原因
      completeByError(errorMsg) {
        this.customerEmptyViewErrorText = errorMsg;
        return this.complete(false);
      },
      // 与上方complete方法功能一致，新版本中设置服务端回调数组请使用complete方法
      addData(data, success = true) {
        if (!this.fromCompleteEmit) {
          this.disabledCompleteEmit = true;
          this.fromCompleteEmit = false;
        }
        const currentTimeStamp = u$1.getTime();
        const disTime = currentTimeStamp - this.requestTimeStamp;
        let minDelay = this.minDelay;
        if (this.isFirstPage && this.finalShowRefresherWhenReload) {
          minDelay = Math.max(400, minDelay);
        }
        const addDataDalay = this.requestTimeStamp > 0 && disTime < minDelay ? minDelay - disTime : 0;
        this.$nextTick(() => {
          u$1.delay(() => {
            this._addData(data, success, false);
          }, this.delay > 0 ? this.delay : addDataDalay);
        });
        return new Promise((resolve, reject) => {
          this.dataPromiseResultMap.complete = { resolve, reject };
        });
      },
      // 从顶部添加数据，不会影响分页的pageNo和pageSize
      addDataFromTop(data, toTop = true, toTopWithAnimate = true) {
        let addFromTop = !this.isChatRecordModeAndNotInversion;
        data = Object.prototype.toString.call(data) !== "[object Array]" ? [data] : addFromTop ? data.reverse() : data;
        this.finalUseVirtualList && this._setCellIndex(data, "top");
        this.totalData = addFromTop ? [...data, ...this.totalData] : [...this.totalData, ...data];
        if (toTop) {
          u$1.delay(() => this.useChatRecordMode ? this.scrollToBottom(toTopWithAnimate) : this.scrollToTop(toTopWithAnimate));
        }
      },
      // 重新设置列表数据，调用此方法不会影响pageNo和pageSize，也不会触发请求。适用场景：当需要删除列表中某一项时，将删除对应项后的数组通过此方法传递给z-paging。(当出现类似的需要修改列表数组的场景时，请使用此方法，请勿直接修改page中:list.sync绑定的数组)
      resetTotalData(data) {
        this.isTotalChangeFromAddData = true;
        data = Object.prototype.toString.call(data) !== "[object Array]" ? [data] : data;
        this.totalData = data;
      },
      // 设置本地分页数据，请求结束(成功或者失败)调用此方法，将请求的结果传递给z-paging作分页处理（若调用了此方法，则上拉加载更多时内部会自动分页，不会触发@query所绑定的事件）
      setLocalPaging(data, success = true) {
        this.isLocalPaging = true;
        this.$nextTick(() => {
          this._addData(data, success, true);
        });
        return new Promise((resolve, reject) => {
          this.dataPromiseResultMap.localPaging = { resolve, reject };
        });
      },
      // 重新加载分页数据，pageNo会恢复为默认值，相当于下拉刷新的效果(animate为true时会展示下拉刷新动画，默认为false)
      reload(animate = this.showRefresherWhenReload) {
        if (animate) {
          this.privateShowRefresherWhenReload = animate;
          this.isUserPullDown = true;
        }
        if (!this.showLoadingMoreWhenReload) {
          this.listRendering = true;
        }
        this.$nextTick(() => {
          this._preReload(animate, false);
        });
        return new Promise((resolve, reject) => {
          this.dataPromiseResultMap.reload = { resolve, reject };
        });
      },
      // 刷新列表数据，pageNo和pageSize不会重置，列表数据会重新从服务端获取。必须保证@query绑定的方法中的pageNo和pageSize和传给服务端的一致
      refresh() {
        return this._handleRefreshWithDisPageNo(this.pageNo - this.defaultPageNo + 1);
      },
      // 刷新列表数据至指定页，例如pageNo=5时则代表刷新列表至第5页，此时pageNo会变为5，列表会展示前5页的数据。必须保证@query绑定的方法中的pageNo和pageSize和传给服务端的一致
      refreshToPage(pageNo) {
        this.isHandlingRefreshToPage = true;
        return this._handleRefreshWithDisPageNo(pageNo + this.defaultPageNo - 1);
      },
      // 手动更新列表缓存数据，将自动截取v-model绑定的list中的前pageSize条覆盖缓存，请确保在list数据更新到预期结果后再调用此方法
      updateCache() {
        if (this.finalUseCache && this.totalData.length) {
          this._saveLocalCache(this.totalData.slice(0, Math.min(this.totalData.length, this.pageSize)));
        }
      },
      // 清空分页数据
      clean() {
        this._reload(true);
        this._addData([], true, false);
      },
      // 清空分页数据
      clear() {
        this.clean();
      },
      // reload之前的一些处理
      _preReload(animate = this.showRefresherWhenReload, isFromMounted = true, retryCount = 0) {
        const showRefresher = this.finalRefresherEnabled && this.useCustomRefresher;
        if (this.customRefresherHeight === -1 && showRefresher) {
          u$1.delay(() => {
            retryCount++;
            if (retryCount % 10 === 0) {
              this._updateCustomRefresherHeight();
            }
            this._preReload(animate, isFromMounted, retryCount);
          }, c$1.delayTime / 2);
          return;
        }
        this.isUserReload = true;
        this.loadingType = Enum.LoadingType.Refresher;
        if (animate) {
          this.privateShowRefresherWhenReload = animate;
          if (this.useCustomRefresher) {
            this._doRefresherRefreshAnimate();
          } else {
            this.refresherTriggered = true;
          }
        } else {
          this._refresherEnd(false, false, false, false);
        }
        this._reload(false, isFromMounted);
      },
      // 重新加载分页数据
      _reload(isClean = false, isFromMounted = false, isUserPullDown = false) {
        this.isAddedData = false;
        this.insideOfPaging = -1;
        this.cacheScrollNodeHeight = -1;
        this.pageNo = this.defaultPageNo;
        this._cleanRefresherEndTimeout();
        !this.privateShowRefresherWhenReload && !isClean && this._startLoading(true);
        this.firstPageLoaded = true;
        this.isTotalChangeFromAddData = false;
        if (!this.isSettingCacheList) {
          this.totalData = [];
        }
        if (!isClean) {
          this._emitQuery(this.pageNo, this.defaultPageSize, isUserPullDown ? Enum.QueryFrom.UserPullDown : Enum.QueryFrom.Reload);
          let delay2 = 0;
          u$1.delay(this._callMyParentQuery, delay2);
          if (!isFromMounted && this.autoScrollToTopWhenReload) {
            this._scrollToTop(false);
          }
        }
      },
      // 处理服务端返回的数组
      _addData(data, success, isLocal) {
        this.isAddedData = true;
        this.fromEmptyViewReload = false;
        this.isTotalChangeFromAddData = true;
        this.refresherTriggered = false;
        this._endSystemLoadingAndRefresh();
        const tempIsUserPullDown = this.isUserPullDown;
        if (this.showRefresherUpdateTime && this.isFirstPage) {
          u$1.setRefesrherTime(u$1.getTime(), this.refresherUpdateTimeKey);
          this.$refs.refresh && this.$refs.refresh.updateTime();
        }
        if (!isLocal && tempIsUserPullDown && this.isFirstPage) {
          this.isUserPullDown = false;
        }
        if (!this.isFirstPage) {
          this.listRendering = true;
          this.$nextTick(() => {
            u$1.delay(() => this.listRendering = false);
          });
        } else {
          this.listRendering = false;
        }
        let dataTypeRes = this._checkDataType(data, success, isLocal);
        data = dataTypeRes.data;
        success = dataTypeRes.success;
        let delayTime = c$1.delayTime;
        if (this.useChatRecordMode)
          delayTime = 0;
        this.loadingForNow = false;
        u$1.delay(() => {
          this.pagingLoaded = true;
          this.$nextTick(() => {
            !isLocal && this._refresherEnd(delayTime > 0, true, tempIsUserPullDown);
          });
        });
        if (this.isFirstPage) {
          this.isLoadFailed = !success;
          this.$emit("isLoadFailedChange", this.isLoadFailed);
          if (this.finalUseCache && success && (this.cacheMode === Enum.CacheMode.Always ? true : this.isSettingCacheList)) {
            this._saveLocalCache(data);
          }
        }
        this.isSettingCacheList = false;
        if (success) {
          if (!(this.privateConcat === false && !this.isHandlingRefreshToPage && this.loadingStatus === Enum.More.NoMore)) {
            this.loadingStatus = Enum.More.Default;
          }
          if (isLocal) {
            this.totalLocalPagingList = data;
            const localPageNo = this.defaultPageNo;
            const localPageSize = this.queryFrom !== Enum.QueryFrom.Refresh ? this.defaultPageSize : this.currentRefreshPageSize;
            this._localPagingQueryList(localPageNo, localPageSize, 0, (res) => {
              u$1.delay(() => {
                this.completeByTotal(res, this.totalLocalPagingList.length);
              }, 0);
            });
          } else {
            let dataChangeDelayTime = 0;
            u$1.delay(() => {
              this._currentDataChange(data, this.currentData);
              this._callDataPromise(true, this.totalData);
            }, dataChangeDelayTime);
          }
          if (this.isHandlingRefreshToPage) {
            this.isHandlingRefreshToPage = false;
            this.pageNo = this.defaultPageNo + Math.ceil(data.length / this.pageSize) - 1;
            if (data.length % this.pageSize !== 0) {
              this.customNoMore = 1;
            }
          }
        } else {
          this._currentDataChange(data, this.currentData);
          this._callDataPromise(false);
          this.loadingStatus = Enum.More.Fail;
          this.isHandlingRefreshToPage = false;
          if (this.loadingType === Enum.LoadingType.LoadingMore) {
            this.pageNo--;
          }
        }
      },
      // 所有数据改变时调用
      _totalDataChange(newVal, oldVal, eventThrow = true) {
        if ((!this.isUserReload || !this.autoCleanListWhenReload) && this.firstPageLoaded && !newVal.length && oldVal.length) {
          return;
        }
        this._doCheckScrollViewShouldFullHeight(newVal);
        if (!this.realTotalData.length && !newVal.length) {
          eventThrow = false;
        }
        this.realTotalData = newVal;
        if (eventThrow) {
          this.$emit("input", newVal);
          this.$emit("update:modelValue", newVal);
          this.$emit("update:list", newVal);
          this.$emit("listChange", newVal);
          this._callMyParentList(newVal);
        }
        this.firstPageLoaded = false;
        this.isTotalChangeFromAddData = false;
        this.$nextTick(() => {
          u$1.delay(() => {
            this._getNodeClientRect(".zp-paging-container-content").then((res) => {
              res && this.$emit("contentHeightChanged", res[0].height);
            });
          }, c$1.delayTime * (this.isIos ? 1 : 3));
        });
      },
      // 当前数据改变时调用
      _currentDataChange(newVal, oldVal) {
        newVal = [...newVal];
        this.finalUseVirtualList && this._setCellIndex(newVal, "bottom");
        if (this.isFirstPage && this.finalConcat) {
          this.totalData = [];
        }
        if (this.customNoMore !== -1) {
          if (this.customNoMore === 1 || this.customNoMore !== 0 && !newVal.length) {
            this.loadingStatus = Enum.More.NoMore;
          }
        } else {
          if (!newVal.length || newVal.length && newVal.length < this.defaultPageSize) {
            this.loadingStatus = Enum.More.NoMore;
          }
        }
        if (!this.totalData.length) {
          this.totalData = newVal;
        } else {
          if (this.finalConcat) {
            this.oldScrollTop;
            this.totalData = [...this.totalData, ...newVal];
          } else {
            this.totalData = newVal;
          }
        }
        this.privateConcat = true;
      },
      // 根据pageNo处理refresh操作
      _handleRefreshWithDisPageNo(pageNo) {
        if (!this.isHandlingRefreshToPage && !this.realTotalData.length)
          return this.reload();
        if (pageNo >= 1) {
          this.loading = true;
          this.privateConcat = false;
          const totalPageSize = pageNo * this.pageSize;
          this.currentRefreshPageSize = totalPageSize;
          if (this.isLocalPaging && this.isHandlingRefreshToPage) {
            this._localPagingQueryList(this.defaultPageNo, totalPageSize, 0, (res) => {
              this.complete(res);
            });
          } else {
            this._emitQuery(this.defaultPageNo, totalPageSize, Enum.QueryFrom.Refresh);
            this._callMyParentQuery(this.defaultPageNo, totalPageSize);
          }
        }
        return new Promise((resolve, reject) => {
          this.dataPromiseResultMap.reload = { resolve, reject };
        });
      },
      // 本地分页请求
      _localPagingQueryList(pageNo, pageSize, localPagingLoadingTime, callback) {
        pageNo = Math.max(1, pageNo);
        pageSize = Math.max(1, pageSize);
        const totalPagingList = [...this.totalLocalPagingList];
        const pageNoIndex = (pageNo - 1) * pageSize;
        const finalPageNoIndex = Math.min(totalPagingList.length, pageNoIndex + pageSize);
        const resultPagingList = totalPagingList.splice(pageNoIndex, finalPageNoIndex - pageNoIndex);
        u$1.delay(() => callback(resultPagingList), localPagingLoadingTime);
      },
      // 存储列表缓存数据
      _saveLocalCache(data) {
        uni.setStorageSync(this.finalCacheKey, data);
      },
      // 通过缓存数据填充列表数据
      _setListByLocalCache() {
        this.totalData = uni.getStorageSync(this.finalCacheKey) || [];
        this.isSettingCacheList = true;
      },
      // 修改父view的list
      _callMyParentList(newVal) {
        if (this.autowireListName.length) {
          const myParent = u$1.getParent(this.$parent);
          if (myParent && myParent[this.autowireListName]) {
            myParent[this.autowireListName] = newVal;
          }
        }
      },
      // 调用父view的query
      _callMyParentQuery(customPageNo = 0, customPageSize = 0) {
        if (this.autowireQueryName) {
          if (this.myParentQuery === -1) {
            const myParent = u$1.getParent(this.$parent);
            if (myParent && myParent[this.autowireQueryName]) {
              this.myParentQuery = myParent[this.autowireQueryName];
            }
          }
          if (this.myParentQuery !== -1) {
            customPageSize > 0 ? this.myParentQuery(customPageNo, customPageSize) : this.myParentQuery(this.pageNo, this.defaultPageSize);
          }
        }
      },
      // emit query事件
      _emitQuery(pageNo, pageSize, from) {
        this.queryFrom = from;
        this.requestTimeStamp = u$1.getTime();
        const [lastItem] = this.realTotalData.slice(-1);
        if (this.fetch) {
          const fetchParams = interceptor._handleFetchParams({ pageNo, pageSize, from, lastItem: lastItem || null }, this.fetchParams);
          const fetchResult = this.fetch(fetchParams);
          if (!interceptor._handleFetchResult(fetchResult, this, fetchParams)) {
            u$1.isPromise(fetchResult) ? fetchResult.then((res) => {
              this.complete(res);
            }).catch((err) => {
              this.complete(false);
            }) : this.complete(fetchResult);
          }
        } else {
          this.$emit("query", ...interceptor._handleQuery(pageNo, pageSize, from, lastItem || null));
        }
      },
      // 触发数据改变promise
      _callDataPromise(success, totalList) {
        for (const key in this.dataPromiseResultMap) {
          const obj = this.dataPromiseResultMap[key];
          if (!obj)
            continue;
          success ? obj.resolve({ totalList, noMore: this.loadingStatus === Enum.More.NoMore }) : this.callNetworkReject && obj.reject(`z-paging-${key}-error`);
        }
      },
      // 检查complete data的类型
      _checkDataType(data, success, isLocal) {
        const dataType = Object.prototype.toString.call(data);
        if (dataType === "[object Boolean]") {
          success = data;
          data = [];
        } else if (dataType !== "[object Array]") {
          data = [];
          if (dataType !== "[object Undefined]" && dataType !== "[object Null]") {
            u$1.consoleErr(`${isLocal ? "setLocalPaging" : "complete"}参数类型不正确，第一个参数类型必须为Array!`);
          }
        }
        return { data, success };
      }
    }
  };
  const isObject = (val) => val !== null && typeof val === "object";
  const defaultDelimiters = ["{", "}"];
  class BaseFormatter {
    constructor() {
      this._caches = /* @__PURE__ */ Object.create(null);
    }
    interpolate(message, values, delimiters = defaultDelimiters) {
      if (!values) {
        return [message];
      }
      let tokens = this._caches[message];
      if (!tokens) {
        tokens = parse(message, delimiters);
        this._caches[message] = tokens;
      }
      return compile(tokens, values);
    }
  }
  const RE_TOKEN_LIST_VALUE = /^(?:\d)+/;
  const RE_TOKEN_NAMED_VALUE = /^(?:\w)+/;
  function parse(format2, [startDelimiter, endDelimiter]) {
    const tokens = [];
    let position = 0;
    let text = "";
    while (position < format2.length) {
      let char = format2[position++];
      if (char === startDelimiter) {
        if (text) {
          tokens.push({ type: "text", value: text });
        }
        text = "";
        let sub = "";
        char = format2[position++];
        while (char !== void 0 && char !== endDelimiter) {
          sub += char;
          char = format2[position++];
        }
        const isClosed = char === endDelimiter;
        const type = RE_TOKEN_LIST_VALUE.test(sub) ? "list" : isClosed && RE_TOKEN_NAMED_VALUE.test(sub) ? "named" : "unknown";
        tokens.push({ value: sub, type });
      } else {
        text += char;
      }
    }
    text && tokens.push({ type: "text", value: text });
    return tokens;
  }
  function compile(tokens, values) {
    const compiled = [];
    let index2 = 0;
    const mode = Array.isArray(values) ? "list" : isObject(values) ? "named" : "unknown";
    if (mode === "unknown") {
      return compiled;
    }
    while (index2 < tokens.length) {
      const token = tokens[index2];
      switch (token.type) {
        case "text":
          compiled.push(token.value);
          break;
        case "list":
          compiled.push(values[parseInt(token.value, 10)]);
          break;
        case "named":
          if (mode === "named") {
            compiled.push(values[token.value]);
          } else {
            {
              console.warn(`Type of token '${token.type}' and format of value '${mode}' don't match!`);
            }
          }
          break;
        case "unknown":
          {
            console.warn(`Detect 'unknown' type of token!`);
          }
          break;
      }
      index2++;
    }
    return compiled;
  }
  const LOCALE_ZH_HANS = "zh-Hans";
  const LOCALE_ZH_HANT = "zh-Hant";
  const LOCALE_EN = "en";
  const LOCALE_FR = "fr";
  const LOCALE_ES = "es";
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty.call(val, key);
  const defaultFormatter = new BaseFormatter();
  function include(str, parts) {
    return !!parts.find((part) => str.indexOf(part) !== -1);
  }
  function startsWith(str, parts) {
    return parts.find((part) => str.indexOf(part) === 0);
  }
  function normalizeLocale(locale, messages2) {
    if (!locale) {
      return;
    }
    locale = locale.trim().replace(/_/g, "-");
    if (messages2 && messages2[locale]) {
      return locale;
    }
    locale = locale.toLowerCase();
    if (locale === "chinese") {
      return LOCALE_ZH_HANS;
    }
    if (locale.indexOf("zh") === 0) {
      if (locale.indexOf("-hans") > -1) {
        return LOCALE_ZH_HANS;
      }
      if (locale.indexOf("-hant") > -1) {
        return LOCALE_ZH_HANT;
      }
      if (include(locale, ["-tw", "-hk", "-mo", "-cht"])) {
        return LOCALE_ZH_HANT;
      }
      return LOCALE_ZH_HANS;
    }
    let locales = [LOCALE_EN, LOCALE_FR, LOCALE_ES];
    if (messages2 && Object.keys(messages2).length > 0) {
      locales = Object.keys(messages2);
    }
    const lang2 = startsWith(locale, locales);
    if (lang2) {
      return lang2;
    }
  }
  class I18n {
    constructor({ locale, fallbackLocale, messages: messages2, watcher, formater: formater2 }) {
      this.locale = LOCALE_EN;
      this.fallbackLocale = LOCALE_EN;
      this.message = {};
      this.messages = {};
      this.watchers = [];
      if (fallbackLocale) {
        this.fallbackLocale = fallbackLocale;
      }
      this.formater = formater2 || defaultFormatter;
      this.messages = messages2 || {};
      this.setLocale(locale || LOCALE_EN);
      if (watcher) {
        this.watchLocale(watcher);
      }
    }
    setLocale(locale) {
      const oldLocale = this.locale;
      this.locale = normalizeLocale(locale, this.messages) || this.fallbackLocale;
      if (!this.messages[this.locale]) {
        this.messages[this.locale] = {};
      }
      this.message = this.messages[this.locale];
      if (oldLocale !== this.locale) {
        this.watchers.forEach((watcher) => {
          watcher(this.locale, oldLocale);
        });
      }
    }
    getLocale() {
      return this.locale;
    }
    watchLocale(fn) {
      const index2 = this.watchers.push(fn) - 1;
      return () => {
        this.watchers.splice(index2, 1);
      };
    }
    add(locale, message, override = true) {
      const curMessages = this.messages[locale];
      if (curMessages) {
        if (override) {
          Object.assign(curMessages, message);
        } else {
          Object.keys(message).forEach((key) => {
            if (!hasOwn(curMessages, key)) {
              curMessages[key] = message[key];
            }
          });
        }
      } else {
        this.messages[locale] = message;
      }
    }
    f(message, values, delimiters) {
      return this.formater.interpolate(message, values, delimiters).join("");
    }
    t(key, locale, values) {
      let message = this.message;
      if (typeof locale === "string") {
        locale = normalizeLocale(locale, this.messages);
        locale && (message = this.messages[locale]);
      } else {
        values = locale;
      }
      if (!hasOwn(message, key)) {
        console.warn(`Cannot translate the value of keypath ${key}. Use the value of keypath as default.`);
        return key;
      }
      return this.formater.interpolate(message[key], values).join("");
    }
  }
  function watchAppLocale(appVm, i18n2) {
    if (appVm.$watchLocale) {
      appVm.$watchLocale((newLocale) => {
        i18n2.setLocale(newLocale);
      });
    } else {
      appVm.$watch(() => appVm.$locale, (newLocale) => {
        i18n2.setLocale(newLocale);
      });
    }
  }
  function getDefaultLocale() {
    if (typeof uni !== "undefined" && uni.getLocale) {
      return uni.getLocale();
    }
    if (typeof global !== "undefined" && global.getLocale) {
      return global.getLocale();
    }
    return LOCALE_EN;
  }
  function initVueI18n(locale, messages2 = {}, fallbackLocale, watcher) {
    if (typeof locale !== "string") {
      const options = [
        messages2,
        locale
      ];
      locale = options[0];
      messages2 = options[1];
    }
    if (typeof locale !== "string") {
      locale = getDefaultLocale();
    }
    if (typeof fallbackLocale !== "string") {
      fallbackLocale = typeof __uniConfig !== "undefined" && __uniConfig.fallbackLocale || LOCALE_EN;
    }
    const i18n2 = new I18n({
      locale,
      fallbackLocale,
      messages: messages2,
      watcher
    });
    let t2 = (key, values) => {
      if (typeof getApp !== "function") {
        t2 = function(key2, values2) {
          return i18n2.t(key2, values2);
        };
      } else {
        let isWatchedAppLocale = false;
        t2 = function(key2, values2) {
          const appVm = getApp().$vm;
          if (appVm) {
            appVm.$locale;
            if (!isWatchedAppLocale) {
              isWatchedAppLocale = true;
              watchAppLocale(appVm, i18n2);
            }
          }
          return i18n2.t(key2, values2);
        };
      }
      return t2(key, values);
    };
    return {
      i18n: i18n2,
      f(message, values, delimiters) {
        return i18n2.f(message, values, delimiters);
      },
      t(key, values) {
        return t2(key, values);
      },
      add(locale2, message, override = true) {
        return i18n2.add(locale2, message, override);
      },
      watch(fn) {
        return i18n2.watchLocale(fn);
      },
      getLocale() {
        return i18n2.getLocale();
      },
      setLocale(newLocale) {
        return i18n2.setLocale(newLocale);
      }
    };
  }
  const en$1 = {
    "zp.refresher.default": "Pull down to refresh",
    "zp.refresher.pulling": "Release to refresh",
    "zp.refresher.refreshing": "Refreshing...",
    "zp.refresher.complete": "Refresh succeeded",
    "zp.refresher.f2": "Refresh to enter 2f",
    "zp.loadingMore.default": "Click to load more",
    "zp.loadingMore.loading": "Loading...",
    "zp.loadingMore.noMore": "No more data",
    "zp.loadingMore.fail": "Load failed,click to reload",
    "zp.emptyView.title": "No data",
    "zp.emptyView.reload": "Reload",
    "zp.emptyView.error": "Sorry,load failed",
    "zp.refresherUpdateTime.title": "Last update: ",
    "zp.refresherUpdateTime.none": "None",
    "zp.refresherUpdateTime.today": "Today",
    "zp.refresherUpdateTime.yesterday": "Yesterday",
    "zp.systemLoading.title": "Loading..."
  };
  const zhHans = {
    "zp.refresher.default": "继续下拉刷新",
    "zp.refresher.pulling": "松开立即刷新",
    "zp.refresher.refreshing": "正在刷新...",
    "zp.refresher.complete": "刷新成功",
    "zp.refresher.f2": "松手进入二楼",
    "zp.loadingMore.default": "点击加载更多",
    "zp.loadingMore.loading": "正在加载...",
    "zp.loadingMore.noMore": "没有更多了",
    "zp.loadingMore.fail": "加载失败，点击重新加载",
    "zp.emptyView.title": "没有数据哦~",
    "zp.emptyView.reload": "重新加载",
    "zp.emptyView.error": "很抱歉，加载失败",
    "zp.refresherUpdateTime.title": "最后更新：",
    "zp.refresherUpdateTime.none": "无",
    "zp.refresherUpdateTime.today": "今天",
    "zp.refresherUpdateTime.yesterday": "昨天",
    "zp.systemLoading.title": "加载中..."
  };
  const zhHant = {
    "zp.refresher.default": "繼續下拉重繪",
    "zp.refresher.pulling": "鬆開立即重繪",
    "zp.refresher.refreshing": "正在重繪...",
    "zp.refresher.complete": "重繪成功",
    "zp.refresher.f2": "鬆手進入二樓",
    "zp.loadingMore.default": "點擊加載更多",
    "zp.loadingMore.loading": "正在加載...",
    "zp.loadingMore.noMore": "沒有更多了",
    "zp.loadingMore.fail": "加載失敗，點擊重新加載",
    "zp.emptyView.title": "沒有數據哦~",
    "zp.emptyView.reload": "重新加載",
    "zp.emptyView.error": "很抱歉，加載失敗",
    "zp.refresherUpdateTime.title": "最後更新：",
    "zp.refresherUpdateTime.none": "無",
    "zp.refresherUpdateTime.today": "今天",
    "zp.refresherUpdateTime.yesterday": "昨天",
    "zp.systemLoading.title": "加載中..."
  };
  const messages = {
    en: en$1,
    "zh-Hans": zhHans,
    "zh-Hant": zhHant
  };
  const { t: t$1 } = initVueI18n(messages);
  const language = uni.getSystemInfoSync().language;
  const i18nModule = {
    data() {
      return {
        language
      };
    },
    computed: {
      finalLanguage() {
        try {
          const local = uni.getLocale();
          const language2 = this.language;
          return local === "auto" ? interceptor._handleLanguage2Local(language2, this._language2Local(language2)) : local;
        } catch (e2) {
          return "zh-Hans";
        }
      },
      // 最终的下拉刷新默认状态的文字
      finalRefresherDefaultText() {
        return this._getI18nText("zp.refresher.default", this.refresherDefaultText);
      },
      // 最终的下拉刷新下拉中的文字
      finalRefresherPullingText() {
        return this._getI18nText("zp.refresher.pulling", this.refresherPullingText);
      },
      // 最终的下拉刷新中文字
      finalRefresherRefreshingText() {
        return this._getI18nText("zp.refresher.refreshing", this.refresherRefreshingText);
      },
      // 最终的下拉刷新完成文字
      finalRefresherCompleteText() {
        return this._getI18nText("zp.refresher.complete", this.refresherCompleteText);
      },
      // 最终的下拉刷新上次更新时间文字
      finalRefresherUpdateTimeTextMap() {
        return {
          title: t$1("zp.refresherUpdateTime.title"),
          none: t$1("zp.refresherUpdateTime.none"),
          today: t$1("zp.refresherUpdateTime.today"),
          yesterday: t$1("zp.refresherUpdateTime.yesterday")
        };
      },
      // 最终的继续下拉进入二楼文字
      finalRefresherGoF2Text() {
        return this._getI18nText("zp.refresher.f2", this.refresherGoF2Text);
      },
      // 最终的底部加载更多默认状态文字
      finalLoadingMoreDefaultText() {
        return this._getI18nText("zp.loadingMore.default", this.loadingMoreDefaultText);
      },
      // 最终的底部加载更多加载中文字
      finalLoadingMoreLoadingText() {
        return this._getI18nText("zp.loadingMore.loading", this.loadingMoreLoadingText);
      },
      // 最终的底部加载更多没有更多数据文字
      finalLoadingMoreNoMoreText() {
        return this._getI18nText("zp.loadingMore.noMore", this.loadingMoreNoMoreText);
      },
      // 最终的底部加载更多加载失败文字
      finalLoadingMoreFailText() {
        return this._getI18nText("zp.loadingMore.fail", this.loadingMoreFailText);
      },
      // 最终的空数据图title
      finalEmptyViewText() {
        return this.isLoadFailed ? this.finalEmptyViewErrorText : this._getI18nText("zp.emptyView.title", this.emptyViewText);
      },
      // 最终的空数据图reload title
      finalEmptyViewReloadText() {
        return this._getI18nText("zp.emptyView.reload", this.emptyViewReloadText);
      },
      // 最终的空数据图加载失败文字
      finalEmptyViewErrorText() {
        return this.customerEmptyViewErrorText || this._getI18nText("zp.emptyView.error", this.emptyViewErrorText);
      },
      // 最终的系统loading title
      finalSystemLoadingText() {
        return this._getI18nText("zp.systemLoading.title", this.systemLoadingText);
      }
    },
    methods: {
      // 获取当前z-paging的语言
      getLanguage() {
        return this.finalLanguage;
      },
      // 获取国际化转换后的文本
      _getI18nText(key, value) {
        const dataType = Object.prototype.toString.call(value);
        if (dataType === "[object Object]") {
          const nextValue = value[this.finalLanguage];
          if (nextValue)
            return nextValue;
        } else if (dataType === "[object String]") {
          return value;
        }
        return t$1(key);
      },
      // 系统language转i18n local
      _language2Local(language2) {
        const formatedLanguage = language2.toLowerCase().replace(new RegExp("_", ""), "-");
        if (formatedLanguage.indexOf("zh") !== -1) {
          if (formatedLanguage === "zh" || formatedLanguage === "zh-cn" || formatedLanguage.indexOf("zh-hans") !== -1) {
            return "zh-Hans";
          }
          return "zh-Hant";
        }
        if (formatedLanguage.indexOf("en") !== -1)
          return "en";
        return language2;
      }
    }
  };
  const nvueModule = {
    props: {},
    data() {
      return {
        nRefresherLoading: false,
        nListIsDragging: false,
        nShowBottom: true,
        nFixFreezing: false,
        nShowRefresherReveal: false,
        nLoadingMoreFixedHeight: false,
        nShowRefresherRevealHeight: 0,
        nOldShowRefresherRevealHeight: -1,
        nRefresherWidth: uni.upx2px(750),
        nF2Opacity: 0
      };
    },
    computed: {},
    mounted() {
    },
    methods: {}
  };
  const emptyModule = {
    props: {
      // 是否强制隐藏空数据图，默认为否
      hideEmptyView: {
        type: Boolean,
        default: u$1.gc("hideEmptyView", false)
      },
      // 空数据图描述文字，默认为“没有数据哦~”
      emptyViewText: {
        type: [String, Object],
        default: u$1.gc("emptyViewText", null)
      },
      // 是否显示空数据图重新加载按钮(无数据时)，默认为否
      showEmptyViewReload: {
        type: Boolean,
        default: u$1.gc("showEmptyViewReload", false)
      },
      // 加载失败时是否显示空数据图重新加载按钮，默认为是
      showEmptyViewReloadWhenError: {
        type: Boolean,
        default: u$1.gc("showEmptyViewReloadWhenError", true)
      },
      // 空数据图点击重新加载文字，默认为“重新加载”
      emptyViewReloadText: {
        type: [String, Object],
        default: u$1.gc("emptyViewReloadText", null)
      },
      // 空数据图图片，默认使用z-paging内置的图片
      emptyViewImg: {
        type: String,
        default: u$1.gc("emptyViewImg", "")
      },
      // 空数据图“加载失败”描述文字，默认为“很抱歉，加载失败”
      emptyViewErrorText: {
        type: [String, Object],
        default: u$1.gc("emptyViewErrorText", null)
      },
      // 空数据图“加载失败”图片，默认使用z-paging内置的图片
      emptyViewErrorImg: {
        type: String,
        default: u$1.gc("emptyViewErrorImg", "")
      },
      // 空数据图样式
      emptyViewStyle: {
        type: Object,
        default: u$1.gc("emptyViewStyle", {})
      },
      // 空数据图容器样式
      emptyViewSuperStyle: {
        type: Object,
        default: u$1.gc("emptyViewSuperStyle", {})
      },
      // 空数据图img样式
      emptyViewImgStyle: {
        type: Object,
        default: u$1.gc("emptyViewImgStyle", {})
      },
      // 空数据图描述文字样式
      emptyViewTitleStyle: {
        type: Object,
        default: u$1.gc("emptyViewTitleStyle", {})
      },
      // 空数据图重新加载按钮样式
      emptyViewReloadStyle: {
        type: Object,
        default: u$1.gc("emptyViewReloadStyle", {})
      },
      // 空数据图片是否铺满z-paging，默认为否，即填充满z-paging内列表(滚动区域)部分。若设置为否，则为填铺满整个z-paging
      emptyViewFixed: {
        type: Boolean,
        default: u$1.gc("emptyViewFixed", false)
      },
      // 空数据图片是否垂直居中，默认为是，若设置为否即为从空数据容器顶部开始显示。emptyViewFixed为false时有效
      emptyViewCenter: {
        type: Boolean,
        default: u$1.gc("emptyViewCenter", true)
      },
      // 加载中时是否自动隐藏空数据图，默认为是
      autoHideEmptyViewWhenLoading: {
        type: Boolean,
        default: u$1.gc("autoHideEmptyViewWhenLoading", true)
      },
      // 用户下拉列表触发下拉刷新加载中时是否自动隐藏空数据图，默认为是
      autoHideEmptyViewWhenPull: {
        type: Boolean,
        default: u$1.gc("autoHideEmptyViewWhenPull", true)
      },
      // 空数据view的z-index，默认为9
      emptyViewZIndex: {
        type: Number,
        default: u$1.gc("emptyViewZIndex", 9)
      }
    },
    data() {
      return {
        customerEmptyViewErrorText: ""
      };
    },
    computed: {
      finalEmptyViewImg() {
        return this.isLoadFailed ? this.emptyViewErrorImg : this.emptyViewImg;
      },
      finalShowEmptyViewReload() {
        return this.isLoadFailed ? this.showEmptyViewReloadWhenError : this.showEmptyViewReload;
      },
      // 是否展示空数据图
      showEmpty() {
        if (this.refresherOnly || this.hideEmptyView || this.realTotalData.length)
          return false;
        if (this.autoHideEmptyViewWhenLoading) {
          if (this.isAddedData && !this.firstPageLoaded && !this.loading)
            return true;
        } else {
          return true;
        }
        return !this.autoHideEmptyViewWhenPull && !this.isUserReload;
      }
    },
    methods: {
      // 点击了空数据view重新加载按钮
      _emptyViewReload() {
        let callbacked = false;
        this.$emit("emptyViewReload", (reload2) => {
          if (reload2 === void 0 || reload2 === true) {
            this.fromEmptyViewReload = true;
            this.reload().catch(() => {
            });
          }
          callbacked = true;
        });
        this.$nextTick(() => {
          if (!callbacked) {
            this.fromEmptyViewReload = true;
            this.reload().catch(() => {
            });
          }
        });
      },
      // 点击了空数据view
      _emptyViewClick() {
        this.$emit("emptyViewClick");
      }
    }
  };
  const refresherModule = {
    props: {
      // 下拉刷新的主题样式，支持black，white，默认black
      refresherThemeStyle: {
        type: String,
        default: u$1.gc("refresherThemeStyle", "")
      },
      // 自定义下拉刷新中左侧图标的样式
      refresherImgStyle: {
        type: Object,
        default: u$1.gc("refresherImgStyle", {})
      },
      // 自定义下拉刷新中右侧状态描述文字的样式
      refresherTitleStyle: {
        type: Object,
        default: u$1.gc("refresherTitleStyle", {})
      },
      // 自定义下拉刷新中右侧最后更新时间文字的样式(show-refresher-update-time为true时有效)
      refresherUpdateTimeStyle: {
        type: Object,
        default: u$1.gc("refresherUpdateTimeStyle", {})
      },
      // 在微信小程序和QQ小程序中，是否实时监听下拉刷新中进度，默认为否
      watchRefresherTouchmove: {
        type: Boolean,
        default: u$1.gc("watchRefresherTouchmove", false)
      },
      // 底部加载更多的主题样式，支持black，white，默认black
      loadingMoreThemeStyle: {
        type: String,
        default: u$1.gc("loadingMoreThemeStyle", "")
      },
      // 是否只使用下拉刷新，设置为true后将关闭mounted自动请求数据、关闭滚动到底部加载更多，强制隐藏空数据图。默认为否
      refresherOnly: {
        type: Boolean,
        default: u$1.gc("refresherOnly", false)
      },
      // 自定义下拉刷新默认状态下回弹动画时间，单位为毫秒，默认为100毫秒，nvue无效
      refresherDefaultDuration: {
        type: [Number, String],
        default: u$1.gc("refresherDefaultDuration", 100)
      },
      // 自定义下拉刷新结束以后延迟回弹的时间，单位为毫秒，默认为0
      refresherCompleteDelay: {
        type: [Number, String],
        default: u$1.gc("refresherCompleteDelay", 0)
      },
      // 自定义下拉刷新结束回弹动画时间，单位为毫秒，默认为300毫秒(refresherEndBounceEnabled为false时，refresherCompleteDuration为设定值的1/3)，nvue无效
      refresherCompleteDuration: {
        type: [Number, String],
        default: u$1.gc("refresherCompleteDuration", 300)
      },
      // 自定义下拉刷新中是否允许列表滚动，默认为是
      refresherRefreshingScrollable: {
        type: Boolean,
        default: u$1.gc("refresherRefreshingScrollable", true)
      },
      // 自定义下拉刷新结束状态下是否允许列表滚动，默认为否
      refresherCompleteScrollable: {
        type: Boolean,
        default: u$1.gc("refresherCompleteScrollable", false)
      },
      // 是否使用自定义的下拉刷新，默认为是，即使用z-paging的下拉刷新。设置为false即代表使用uni scroll-view自带的下拉刷新，h5、App、微信小程序以外的平台不支持uni scroll-view自带的下拉刷新
      useCustomRefresher: {
        type: Boolean,
        default: u$1.gc("useCustomRefresher", true)
      },
      // 自定义下拉刷新下拉帧率，默认为40，过高可能会出现抖动问题
      refresherFps: {
        type: [Number, String],
        default: u$1.gc("refresherFps", 40)
      },
      // 自定义下拉刷新允许触发的最大下拉角度，默认为40度，当下拉角度小于设定值时，自定义下拉刷新动画不会被触发
      refresherMaxAngle: {
        type: [Number, String],
        default: u$1.gc("refresherMaxAngle", 40)
      },
      // 自定义下拉刷新的角度由未达到最大角度变到达到最大角度时，是否继续下拉刷新手势，默认为否
      refresherAngleEnableChangeContinued: {
        type: Boolean,
        default: u$1.gc("refresherAngleEnableChangeContinued", false)
      },
      // 自定义下拉刷新默认状态下的文字
      refresherDefaultText: {
        type: [String, Object],
        default: u$1.gc("refresherDefaultText", null)
      },
      // 自定义下拉刷新松手立即刷新状态下的文字
      refresherPullingText: {
        type: [String, Object],
        default: u$1.gc("refresherPullingText", null)
      },
      // 自定义下拉刷新刷新中状态下的文字
      refresherRefreshingText: {
        type: [String, Object],
        default: u$1.gc("refresherRefreshingText", null)
      },
      // 自定义下拉刷新刷新结束状态下的文字
      refresherCompleteText: {
        type: [String, Object],
        default: u$1.gc("refresherCompleteText", null)
      },
      // 自定义继续下拉进入二楼文字
      refresherGoF2Text: {
        type: [String, Object],
        default: u$1.gc("refresherGoF2Text", null)
      },
      // 自定义下拉刷新默认状态下的图片
      refresherDefaultImg: {
        type: String,
        default: u$1.gc("refresherDefaultImg", null)
      },
      // 自定义下拉刷新松手立即刷新状态下的图片，默认与refresherDefaultImg一致
      refresherPullingImg: {
        type: String,
        default: u$1.gc("refresherPullingImg", null)
      },
      // 自定义下拉刷新刷新中状态下的图片
      refresherRefreshingImg: {
        type: String,
        default: u$1.gc("refresherRefreshingImg", null)
      },
      // 自定义下拉刷新刷新结束状态下的图片
      refresherCompleteImg: {
        type: String,
        default: u$1.gc("refresherCompleteImg", null)
      },
      // 自定义下拉刷新刷新中状态下是否展示旋转动画
      refresherRefreshingAnimated: {
        type: Boolean,
        default: u$1.gc("refresherRefreshingAnimated", true)
      },
      // 是否开启自定义下拉刷新刷新结束回弹效果，默认为是
      refresherEndBounceEnabled: {
        type: Boolean,
        default: u$1.gc("refresherEndBounceEnabled", true)
      },
      // 是否开启自定义下拉刷新，默认为是
      refresherEnabled: {
        type: Boolean,
        default: u$1.gc("refresherEnabled", true)
      },
      // 设置自定义下拉刷新阈值，默认为80rpx
      refresherThreshold: {
        type: [Number, String],
        default: u$1.gc("refresherThreshold", "80rpx")
      },
      // 设置系统下拉刷新默认样式，支持设置 black，white，none，none 表示不使用默认样式，默认为black
      refresherDefaultStyle: {
        type: String,
        default: u$1.gc("refresherDefaultStyle", "black")
      },
      // 设置自定义下拉刷新区域背景
      refresherBackground: {
        type: String,
        default: u$1.gc("refresherBackground", "transparent")
      },
      // 设置固定的自定义下拉刷新区域背景
      refresherFixedBackground: {
        type: String,
        default: u$1.gc("refresherFixedBackground", "transparent")
      },
      // 设置固定的自定义下拉刷新区域高度，默认为0
      refresherFixedBacHeight: {
        type: [Number, String],
        default: u$1.gc("refresherFixedBacHeight", 0)
      },
      // 设置自定义下拉刷新下拉超出阈值后继续下拉位移衰减的比例，范围0-1，值越大代表衰减越多。默认为0.65(nvue无效)
      refresherOutRate: {
        type: Number,
        default: u$1.gc("refresherOutRate", 0.65)
      },
      // 是否开启下拉进入二楼功能，默认为否
      refresherF2Enabled: {
        type: Boolean,
        default: u$1.gc("refresherF2Enabled", false)
      },
      // 下拉进入二楼阈值，默认为200rpx
      refresherF2Threshold: {
        type: [Number, String],
        default: u$1.gc("refresherF2Threshold", "200rpx")
      },
      // 下拉进入二楼动画时间，单位为毫秒，默认为200毫秒
      refresherF2Duration: {
        type: [Number, String],
        default: u$1.gc("refresherF2Duration", 200)
      },
      // 下拉进入二楼状态松手后是否弹出二楼，默认为是
      showRefresherF2: {
        type: Boolean,
        default: u$1.gc("showRefresherF2", true)
      },
      // 设置自定义下拉刷新下拉时实际下拉位移与用户下拉距离的比值，默认为0.75，即代表若用户下拉10px，则实际位移为7.5px(nvue无效)
      refresherPullRate: {
        type: Number,
        default: u$1.gc("refresherPullRate", 0.75)
      },
      // 是否显示最后更新时间，默认为否
      showRefresherUpdateTime: {
        type: Boolean,
        default: u$1.gc("showRefresherUpdateTime", false)
      },
      // 如果需要区别不同页面的最后更新时间，请为不同页面的z-paging的`refresher-update-time-key`设置不同的字符串
      refresherUpdateTimeKey: {
        type: String,
        default: u$1.gc("refresherUpdateTimeKey", "default")
      },
      // 下拉刷新时下拉到“松手立即刷新”或“松手进入二楼”状态时是否使手机短振动，默认为否（h5无效）
      refresherVibrate: {
        type: Boolean,
        default: u$1.gc("refresherVibrate", false)
      },
      // 下拉刷新时是否禁止下拉刷新view跟随用户触摸竖直移动，默认为否。注意此属性只是禁止下拉刷新view移动，其他下拉刷新逻辑依然会正常触发
      refresherNoTransform: {
        type: Boolean,
        default: u$1.gc("refresherNoTransform", false)
      },
      // 是否开启下拉刷新状态栏占位，适用于隐藏导航栏时，下拉刷新需要避开状态栏高度的情况，默认为否
      useRefresherStatusBarPlaceholder: {
        type: Boolean,
        default: u$1.gc("useRefresherStatusBarPlaceholder", false)
      }
    },
    data() {
      return {
        R: Enum.Refresher,
        //下拉刷新状态
        refresherStatus: Enum.Refresher.Default,
        refresherTouchstartY: 0,
        lastRefresherTouchmove: null,
        refresherReachMaxAngle: true,
        refresherTransform: "translateY(0px)",
        refresherTransition: "",
        finalRefresherDefaultStyle: "black",
        refresherRevealStackCount: 0,
        refresherCompleteTimeout: null,
        refresherCompleteSubTimeout: null,
        refresherEndTimeout: null,
        isTouchmovingTimeout: null,
        refresherTriggered: false,
        isTouchmoving: false,
        isTouchEnded: false,
        isUserPullDown: false,
        privateRefresherEnabled: -1,
        privateShowRefresherWhenReload: false,
        customRefresherHeight: -1,
        showCustomRefresher: false,
        doRefreshAnimateAfter: false,
        isRefresherInComplete: false,
        showF2: false,
        f2Transform: "",
        pullDownTimeStamp: 0,
        moveDis: 0,
        oldMoveDis: 0,
        currentDis: 0,
        oldCurrentMoveDis: 0,
        oldRefresherTouchmoveY: 0,
        oldTouchDirection: "",
        oldEmitedTouchDirection: "",
        oldPullingDistance: -1,
        refresherThresholdUpdateTag: 0
      };
    },
    watch: {
      refresherDefaultStyle: {
        handler(newVal) {
          if (newVal.length) {
            this.finalRefresherDefaultStyle = newVal;
          }
        },
        immediate: true
      },
      refresherStatus(newVal) {
        newVal === Enum.Refresher.Loading && this._cleanRefresherEndTimeout();
        this.refresherVibrate && (newVal === Enum.Refresher.ReleaseToRefresh || newVal === Enum.Refresher.GoF2) && this._doVibrateShort();
        this.$emit("refresherStatusChange", newVal);
        this.$emit("update:refresherStatus", newVal);
      },
      // 监听当前下拉刷新启用/禁用状态
      refresherEnabled(newVal) {
        !newVal && this.endRefresh();
      }
    },
    computed: {
      pullDownDisTimeStamp() {
        return 1e3 / this.refresherFps;
      },
      refresherThresholdUnitConverted() {
        return u$1.addUnit(this.refresherThreshold, this.unit);
      },
      finalRefresherEnabled() {
        if (this.useChatRecordMode)
          return false;
        if (this.privateRefresherEnabled === -1)
          return this.refresherEnabled;
        return this.privateRefresherEnabled === 1;
      },
      finalRefresherThreshold() {
        let refresherThreshold = this.refresherThresholdUnitConverted;
        let idDefault = false;
        if (refresherThreshold === u$1.addUnit(80, this.unit)) {
          idDefault = true;
          if (this.showRefresherUpdateTime) {
            refresherThreshold = u$1.addUnit(120, this.unit);
          }
        }
        if (idDefault && this.customRefresherHeight > 0)
          return this.customRefresherHeight + this.finalRefresherThresholdPlaceholder;
        return u$1.convertToPx(refresherThreshold) + this.finalRefresherThresholdPlaceholder;
      },
      finalRefresherF2Threshold() {
        return u$1.convertToPx(u$1.addUnit(this.refresherF2Threshold, this.unit));
      },
      finalRefresherThresholdPlaceholder() {
        return this.useRefresherStatusBarPlaceholder ? this.statusBarHeight : 0;
      },
      finalRefresherFixedBacHeight() {
        return u$1.convertToPx(this.refresherFixedBacHeight);
      },
      finalRefresherThemeStyle() {
        return this.refresherThemeStyle.length ? this.refresherThemeStyle : this.defaultThemeStyle;
      },
      finalRefresherOutRate() {
        let rate = this.refresherOutRate;
        rate = Math.max(0, rate);
        rate = Math.min(1, rate);
        return rate;
      },
      finalRefresherPullRate() {
        let rate = this.refresherPullRate;
        rate = Math.max(0, rate);
        return rate;
      },
      finalRefresherTransform() {
        if (this.refresherNoTransform || this.refresherTransform === "translateY(0px)")
          return "none";
        return this.refresherTransform;
      },
      finalShowRefresherWhenReload() {
        return this.showRefresherWhenReload || this.privateShowRefresherWhenReload;
      },
      finalRefresherTriggered() {
        if (!(this.finalRefresherEnabled && !this.useCustomRefresher))
          return false;
        return this.refresherTriggered;
      },
      showRefresher() {
        const showRefresher = this.finalRefresherEnabled || this.useCustomRefresher && !this.useChatRecordMode;
        this.active && this.customRefresherHeight === -1 && showRefresher && this.updateCustomRefresherHeight();
        return showRefresher;
      },
      hasTouchmove() {
        return this.watchRefresherTouchmove;
      }
    },
    methods: {
      // 终止下拉刷新状态
      endRefresh() {
        this.totalData = this.realTotalData;
        this._refresherEnd();
        this._endSystemLoadingAndRefresh();
        this._handleScrollViewBounce({ bounce: true });
        this.$nextTick(() => {
          this.refresherTriggered = false;
        });
      },
      // 手动更新自定义下拉刷新view高度
      updateCustomRefresherHeight() {
        u$1.delay(() => this.$nextTick(this._updateCustomRefresherHeight));
      },
      // 关闭二楼
      closeF2() {
        this._handleCloseF2();
      },
      // 自定义下拉刷新被触发
      _onRefresh(fromScrollView = false, isUserPullDown = true) {
        if (fromScrollView && !(this.finalRefresherEnabled && !this.useCustomRefresher))
          return;
        this.$emit("onRefresh");
        this.$emit("Refresh");
        if (this.loading || this.isRefresherInComplete)
          return;
        this.loadingType = Enum.LoadingType.Refresher;
        if (this.nShowRefresherReveal)
          return;
        this.isUserPullDown = isUserPullDown;
        this.isUserReload = !isUserPullDown;
        this._startLoading(true);
        this.refresherTriggered = true;
        if (this.reloadWhenRefresh && isUserPullDown) {
          this.useChatRecordMode ? this._onLoadingMore("click") : this._reload(false, false, isUserPullDown);
        }
      },
      // 自定义下拉刷新被复位
      _onRestore() {
        this.refresherTriggered = "restore";
        this.$emit("onRestore");
        this.$emit("Restore");
      },
      // 进一步处理touch开始结果
      _handleRefresherTouchstart(touch) {
        if (!this.loading && this.isTouchEnded) {
          this.isTouchmoving = false;
        }
        this.loadingType = Enum.LoadingType.Refresher;
        this.isTouchmovingTimeout && clearTimeout(this.isTouchmovingTimeout);
        this.isTouchEnded = false;
        this.refresherTransition = "";
        this.refresherTouchstartY = touch.touchY;
        this.$emit("refresherTouchstart", this.refresherTouchstartY);
        this.lastRefresherTouchmove = touch;
        this._cleanRefresherCompleteTimeout();
        this._cleanRefresherEndTimeout();
      },
      // 非appvue或微信小程序或QQ小程序或h5平台，使用js控制下拉刷新
      // 进一步处理touch中结果
      _handleRefresherTouchmove(moveDis, touch) {
        this.refresherReachMaxAngle = true;
        this.isTouchmovingTimeout && clearTimeout(this.isTouchmovingTimeout);
        this.isTouchmoving = true;
        this.isTouchEnded = false;
        if (moveDis >= this.finalRefresherThreshold) {
          this.refresherStatus = this.refresherF2Enabled && moveDis >= this.finalRefresherF2Threshold ? Enum.Refresher.GoF2 : Enum.Refresher.ReleaseToRefresh;
        } else {
          this.refresherStatus = Enum.Refresher.Default;
        }
        this.moveDis = moveDis;
      },
      // 进一步处理touch结束结果
      _handleRefresherTouchend(moveDis) {
        this.isTouchmovingTimeout && clearTimeout(this.isTouchmovingTimeout);
        this.refresherReachMaxAngle = true;
        this.isTouchEnded = true;
        const refresherThreshold = this.finalRefresherThreshold;
        if (moveDis >= refresherThreshold && (this.refresherStatus === Enum.Refresher.ReleaseToRefresh || this.refresherStatus === Enum.Refresher.GoF2)) {
          if (this.refresherStatus === Enum.Refresher.GoF2) {
            this._handleGoF2();
            this._refresherEnd();
          } else {
            u$1.delay(() => {
              this._emitTouchmove({ pullingDistance: refresherThreshold, dy: this.moveDis - refresherThreshold });
            }, 0.1);
            this.moveDis = refresherThreshold;
            this.refresherStatus = Enum.Refresher.Loading;
            this._doRefresherLoad();
          }
        } else {
          this._refresherEnd();
          this.isTouchmovingTimeout = u$1.delay(() => {
            this.isTouchmoving = false;
          }, this.refresherDefaultDuration);
        }
        this.scrollEnable = true;
        this.$emit("refresherTouchend", moveDis);
      },
      // 处理列表触摸开始事件
      _handleListTouchstart() {
        if (this.useChatRecordMode && this.autoHideKeyboardWhenChat) {
          uni.hideKeyboard();
          this.$emit("hidedKeyboard");
        }
      },
      // 处理scroll-view bounce是否生效
      _handleScrollViewBounce({ bounce }) {
        if (!this.usePageScroll && !this.scrollToTopBounceEnabled) {
          if (this.wxsScrollTop <= 5) {
            this.refresherTransition = "";
            this.scrollEnable = bounce;
          } else if (bounce) {
            this.scrollEnable = bounce;
          }
        }
      },
      // wxs正在下拉状态改变处理
      _handleWxsPullingDownStatusChange(onPullingDown) {
        this.wxsOnPullingDown = onPullingDown;
        if (onPullingDown && !this.useChatRecordMode) {
          this.renderPropScrollTop = 0;
        }
      },
      // wxs正在下拉处理
      _handleWxsPullingDown({ moveDis, diffDis }) {
        this._emitTouchmove({ pullingDistance: moveDis, dy: diffDis });
      },
      // wxs触摸方向改变
      _handleTouchDirectionChange({ direction }) {
        this.$emit("touchDirectionChange", direction);
      },
      // wxs通知更新其props
      _handlePropUpdate() {
        this.wxsPropType = u$1.getTime().toString();
      },
      // 下拉刷新结束
      _refresherEnd(shouldEndLoadingDelay = true, fromAddData = false, isUserPullDown = false, setLoading = true) {
        if (this.loadingType === Enum.LoadingType.Refresher) {
          const refresherCompleteDelay = fromAddData && (isUserPullDown || this.showRefresherWhenReload) ? this.refresherCompleteDelay : 0;
          const refresherStatus = refresherCompleteDelay > 0 ? Enum.Refresher.Complete : Enum.Refresher.Default;
          if (this.finalShowRefresherWhenReload) {
            const stackCount = this.refresherRevealStackCount;
            this.refresherRevealStackCount--;
            if (stackCount > 1)
              return;
          }
          this._cleanRefresherEndTimeout();
          this.refresherEndTimeout = u$1.delay(() => {
            this.refresherStatus = refresherStatus;
          }, this.refresherStatus !== Enum.Refresher.Default && refresherStatus === Enum.Refresher.Default ? this.refresherCompleteDuration : 0);
          if (refresherCompleteDelay > 0) {
            this.isRefresherInComplete = true;
          }
          this._cleanRefresherCompleteTimeout();
          this.refresherCompleteTimeout = u$1.delay(() => {
            let animateDuration = 1;
            const animateType = this.refresherEndBounceEnabled && fromAddData ? "cubic-bezier(0.19,1.64,0.42,0.72)" : "linear";
            if (fromAddData) {
              animateDuration = this.refresherEndBounceEnabled ? this.refresherCompleteDuration / 1e3 : this.refresherCompleteDuration / 3e3;
            }
            this.refresherTransition = `transform ${fromAddData ? animateDuration : this.refresherDefaultDuration / 1e3}s ${animateType}`;
            this.wxsPropType = this.refresherTransition + "end" + u$1.getTime();
            this.moveDis = 0;
            if (refresherStatus === Enum.Refresher.Complete) {
              if (this.refresherCompleteSubTimeout) {
                clearTimeout(this.refresherCompleteSubTimeout);
                this.refresherCompleteSubTimeout = null;
              }
              this.refresherCompleteSubTimeout = u$1.delay(() => {
                this.$nextTick(() => {
                  this.refresherStatus = Enum.Refresher.Default;
                  this.isRefresherInComplete = false;
                });
              }, animateDuration * 800);
            }
            this._emitTouchmove({ pullingDistance: 0, dy: this.moveDis });
          }, refresherCompleteDelay);
        }
        if (setLoading) {
          u$1.delay(() => this.loading = false, shouldEndLoadingDelay ? 10 : 0);
          isUserPullDown && this._onRestore();
        }
      },
      // 处理进入二楼
      _handleGoF2() {
        if (this.showF2 || !this.refresherF2Enabled)
          return;
        this.$emit("refresherF2Change", "go");
        if (!this.showRefresherF2)
          return;
        this.f2Transform = `translateY(${-this.superContentHeight}px)`;
        this.showF2 = true;
        u$1.delay(() => {
          this.f2Transform = "translateY(0px)";
        }, 100, "f2ShowDelay");
      },
      // 处理退出二楼
      _handleCloseF2() {
        if (!this.showF2 || !this.refresherF2Enabled)
          return;
        this.$emit("refresherF2Change", "close");
        if (!this.showRefresherF2)
          return;
        this.f2Transform = `translateY(${-this.superContentHeight}px)`;
        u$1.delay(() => {
          this.showF2 = false;
          this.nF2Opacity = 0;
        }, this.refresherF2Duration, "f2CloseDelay");
      },
      // 模拟用户手动触发下拉刷新
      _doRefresherRefreshAnimate() {
        this._cleanRefresherCompleteTimeout();
        const doRefreshAnimateAfter = !this.doRefreshAnimateAfter && this.finalShowRefresherWhenReload && this.customRefresherHeight === -1 && this.refresherThreshold === u$1.addUnit(80, this.unit);
        if (doRefreshAnimateAfter) {
          this.doRefreshAnimateAfter = true;
          return;
        }
        this.refresherRevealStackCount++;
        this.wxsPropType = "begin" + u$1.getTime();
        this.moveDis = this.finalRefresherThreshold;
        this.refresherStatus = Enum.Refresher.Loading;
        this.isTouchmoving = true;
        this.isTouchmovingTimeout && clearTimeout(this.isTouchmovingTimeout);
        this._doRefresherLoad(false);
      },
      // 触发下拉刷新
      _doRefresherLoad(isUserPullDown = true) {
        this._onRefresh(false, isUserPullDown);
        this.loading = true;
      },
      // 更新自定义下拉刷新view高度
      _updateCustomRefresherHeight() {
        this._getNodeClientRect(".zp-custom-refresher-slot-view").then((res) => {
          this.customRefresherHeight = res ? res[0].height : 0;
          this.showCustomRefresher = this.customRefresherHeight > 0;
          if (this.doRefreshAnimateAfter) {
            this.doRefreshAnimateAfter = false;
            this._doRefresherRefreshAnimate();
          }
        });
      },
      // emit pullingDown事件
      _emitTouchmove(e2) {
        e2.viewHeight = this.finalRefresherThreshold;
        e2.rate = e2.viewHeight > 0 ? e2.pullingDistance / e2.viewHeight : 0;
        this.hasTouchmove && this.oldPullingDistance !== e2.pullingDistance && this.$emit("refresherTouchmove", e2);
        this.oldPullingDistance = e2.pullingDistance;
      },
      // 清除refresherCompleteTimeout
      _cleanRefresherCompleteTimeout() {
        this.refresherCompleteTimeout = this._cleanTimeout(this.refresherCompleteTimeout);
      },
      // 清除refresherEndTimeout
      _cleanRefresherEndTimeout() {
        this.refresherEndTimeout = this._cleanTimeout(this.refresherEndTimeout);
      }
    }
  };
  const loadMoreModule = {
    props: {
      // 自定义底部加载更多样式
      loadingMoreCustomStyle: {
        type: Object,
        default: u$1.gc("loadingMoreCustomStyle", {})
      },
      // 自定义底部加载更多文字样式
      loadingMoreTitleCustomStyle: {
        type: Object,
        default: u$1.gc("loadingMoreTitleCustomStyle", {})
      },
      // 自定义底部加载更多加载中动画样式
      loadingMoreLoadingIconCustomStyle: {
        type: Object,
        default: u$1.gc("loadingMoreLoadingIconCustomStyle", {})
      },
      // 自定义底部加载更多加载中动画图标类型，可选flower或circle，默认为flower
      loadingMoreLoadingIconType: {
        type: String,
        default: u$1.gc("loadingMoreLoadingIconType", "flower")
      },
      // 自定义底部加载更多加载中动画图标图片
      loadingMoreLoadingIconCustomImage: {
        type: String,
        default: u$1.gc("loadingMoreLoadingIconCustomImage", "")
      },
      // 底部加载更多加载中view是否展示旋转动画，默认为是
      loadingMoreLoadingAnimated: {
        type: Boolean,
        default: u$1.gc("loadingMoreLoadingAnimated", true)
      },
      // 是否启用加载更多数据(含滑动到底部加载更多数据和点击加载更多数据)，默认为是
      loadingMoreEnabled: {
        type: Boolean,
        default: u$1.gc("loadingMoreEnabled", true)
      },
      // 是否启用滑动到底部加载更多数据，默认为是
      toBottomLoadingMoreEnabled: {
        type: Boolean,
        default: u$1.gc("toBottomLoadingMoreEnabled", true)
      },
      // 滑动到底部状态为默认状态时，以加载中的状态展示，默认为否。若设置为是，可避免滚动到底部看到默认状态然后立刻变为加载中状态的问题，但分页数量未超过一屏时，不会显示【点击加载更多】
      loadingMoreDefaultAsLoading: {
        type: Boolean,
        default: u$1.gc("loadingMoreDefaultAsLoading", false)
      },
      // 滑动到底部"默认"文字，默认为【点击加载更多】
      loadingMoreDefaultText: {
        type: [String, Object],
        default: u$1.gc("loadingMoreDefaultText", null)
      },
      // 滑动到底部"加载中"文字，默认为【正在加载...】
      loadingMoreLoadingText: {
        type: [String, Object],
        default: u$1.gc("loadingMoreLoadingText", null)
      },
      // 滑动到底部"没有更多"文字，默认为【没有更多了】
      loadingMoreNoMoreText: {
        type: [String, Object],
        default: u$1.gc("loadingMoreNoMoreText", null)
      },
      // 滑动到底部"加载失败"文字，默认为【加载失败，点击重新加载】
      loadingMoreFailText: {
        type: [String, Object],
        default: u$1.gc("loadingMoreFailText", null)
      },
      // 当没有更多数据且分页内容未超出z-paging时是否隐藏没有更多数据的view，默认为否
      hideNoMoreInside: {
        type: Boolean,
        default: u$1.gc("hideNoMoreInside", false)
      },
      // 当没有更多数据且分页数组长度少于这个值时，隐藏没有更多数据的view，默认为0，代表不限制。
      hideNoMoreByLimit: {
        type: Number,
        default: u$1.gc("hideNoMoreByLimit", 0)
      },
      // 是否显示默认的加载更多text，默认为是
      showDefaultLoadingMoreText: {
        type: Boolean,
        default: u$1.gc("showDefaultLoadingMoreText", true)
      },
      // 是否显示没有更多数据的view
      showLoadingMoreNoMoreView: {
        type: Boolean,
        default: u$1.gc("showLoadingMoreNoMoreView", true)
      },
      // 是否显示没有更多数据的分割线，默认为是
      showLoadingMoreNoMoreLine: {
        type: Boolean,
        default: u$1.gc("showLoadingMoreNoMoreLine", true)
      },
      // 自定义底部没有更多数据的分割线样式
      loadingMoreNoMoreLineCustomStyle: {
        type: Object,
        default: u$1.gc("loadingMoreNoMoreLineCustomStyle", {})
      },
      // 当分页未满一屏时，是否自动加载更多，默认为否(nvue无效)
      insideMore: {
        type: Boolean,
        default: u$1.gc("insideMore", false)
      },
      // 距底部/右边多远时（单位px），触发 scrolltolower 事件，默认为100rpx
      lowerThreshold: {
        type: [Number, String],
        default: u$1.gc("lowerThreshold", "100rpx")
      }
    },
    data() {
      return {
        M: Enum.More,
        // 底部加载更多状态
        loadingStatus: Enum.More.Default,
        // 在渲染之后的底部加载更多状态
        loadingStatusAfterRender: Enum.More.Default,
        // 底部加载更多时间戳
        loadingMoreTimeStamp: 0,
        // 底部加载更多slot
        loadingMoreDefaultSlot: null,
        // 是否展示底部加载更多
        showLoadingMore: false,
        // 是否是开发者自定义的加载更多，-1代表交由z-paging自行判断；1代表没有更多了；0代表还有更多数据
        customNoMore: -1
      };
    },
    computed: {
      // 底部加载更多配置
      zLoadMoreConfig() {
        return {
          status: this.loadingStatusAfterRender,
          defaultAsLoading: this.loadingMoreDefaultAsLoading || this.useChatRecordMode && this.chatLoadingMoreDefaultAsLoading,
          defaultThemeStyle: this.finalLoadingMoreThemeStyle,
          customStyle: this.loadingMoreCustomStyle,
          titleCustomStyle: this.loadingMoreTitleCustomStyle,
          iconCustomStyle: this.loadingMoreLoadingIconCustomStyle,
          loadingIconType: this.loadingMoreLoadingIconType,
          loadingIconCustomImage: this.loadingMoreLoadingIconCustomImage,
          loadingAnimated: this.loadingMoreLoadingAnimated,
          showNoMoreLine: this.showLoadingMoreNoMoreLine,
          noMoreLineCustomStyle: this.loadingMoreNoMoreLineCustomStyle,
          defaultText: this.finalLoadingMoreDefaultText,
          loadingText: this.finalLoadingMoreLoadingText,
          noMoreText: this.finalLoadingMoreNoMoreText,
          failText: this.finalLoadingMoreFailText,
          hideContent: !this.loadingMoreDefaultAsLoading && this.listRendering,
          unit: this.unit,
          isChat: this.useChatRecordMode,
          chatDefaultAsLoading: this.chatLoadingMoreDefaultAsLoading
        };
      },
      // 最终的底部加载更多主题
      finalLoadingMoreThemeStyle() {
        return this.loadingMoreThemeStyle.length ? this.loadingMoreThemeStyle : this.defaultThemeStyle;
      },
      // 最终的底部加载更多触发阈值
      finalLowerThreshold() {
        return u$1.convertToPx(this.lowerThreshold);
      },
      // 是否显示默认状态下的底部加载更多
      showLoadingMoreDefault() {
        return this._showLoadingMore("Default");
      },
      // 是否显示加载中状态下的底部加载更多
      showLoadingMoreLoading() {
        return this._showLoadingMore("Loading");
      },
      // 是否显示没有更多了状态下的底部加载更多
      showLoadingMoreNoMore() {
        return this._showLoadingMore("NoMore");
      },
      // 是否显示加载失败状态下的底部加载更多
      showLoadingMoreFail() {
        return this._showLoadingMore("Fail");
      },
      // 是否显示自定义状态下的底部加载更多
      showLoadingMoreCustom() {
        return this._showLoadingMore("Custom");
      },
      // 底部加载更多固定高度
      loadingMoreFixedHeight() {
        return u$1.addUnit("80rpx", this.unit);
      }
    },
    methods: {
      // 页面滚动到底部时通知z-paging进行进一步处理
      pageReachBottom() {
        !this.useChatRecordMode && this.toBottomLoadingMoreEnabled && this._onLoadingMore("toBottom");
      },
      // 手动触发上拉加载更多(非必须，可依据具体需求使用)
      doLoadMore(type) {
        this._onLoadingMore(type);
      },
      // 通过@scroll事件检测是否滚动到了底部(顺带检测下是否滚动到了顶部)
      _checkScrolledToBottom(scrollDiff, checked = false) {
        if (this.cacheScrollNodeHeight === -1) {
          this._getNodeClientRect(".zp-scroll-view").then((res) => {
            if (res) {
              const scrollNodeHeight = res[0].height;
              this.cacheScrollNodeHeight = scrollNodeHeight;
              if (scrollDiff - scrollNodeHeight <= this.finalLowerThreshold) {
                this._onLoadingMore("toBottom");
              }
            }
          });
        } else {
          if (scrollDiff - this.cacheScrollNodeHeight <= this.finalLowerThreshold) {
            this._onLoadingMore("toBottom");
          } else if (scrollDiff - this.cacheScrollNodeHeight <= 500 && !checked) {
            u$1.delay(() => {
              this._getNodeClientRect(".zp-scroll-view", true, true).then((res) => {
                if (res) {
                  this.oldScrollTop = res[0].scrollTop;
                  const newScrollDiff = res[0].scrollHeight - this.oldScrollTop;
                  this._checkScrolledToBottom(newScrollDiff, true);
                }
              });
            }, 150, "checkScrolledToBottomDelay");
          }
          if (this.oldScrollTop <= 150 && this.oldScrollTop !== 0) {
            u$1.delay(() => {
              if (this.oldScrollTop !== 0) {
                this._getNodeClientRect(".zp-scroll-view", true, true).then((res) => {
                  if (res && res[0].scrollTop === 0 && this.oldScrollTop !== 0) {
                    this._onScrollToUpper();
                  }
                });
              }
            }, 150, "checkScrolledToTopDelay");
          }
        }
      },
      // 触发加载更多时调用,from:toBottom-滑动到底部触发；1、click-点击加载更多触发
      _onLoadingMore(from = "click") {
        if (this.isIos && from === "toBottom" && !this.scrollToBottomBounceEnabled && this.scrollEnable) {
          this.scrollEnable = false;
          this.$nextTick(() => {
            this.scrollEnable = true;
          });
        }
        this.$emit("scrolltolower", from);
        if (this.refresherOnly || !this.loadingMoreEnabled || !(this.loadingStatus === Enum.More.Default || this.loadingStatus === Enum.More.Fail) || this.loading || this.showEmpty)
          return;
        this._doLoadingMore();
      },
      // 处理开始加载更多
      _doLoadingMore() {
        if (this.pageNo >= this.defaultPageNo && this.loadingStatus !== Enum.More.NoMore) {
          this.pageNo++;
          this._startLoading(false);
          if (this.isLocalPaging) {
            this._localPagingQueryList(this.pageNo, this.defaultPageSize, this.localPagingLoadingTime, (res) => {
              this.completeByTotal(res, this.totalLocalPagingList.length);
              this.queryFrom = Enum.QueryFrom.LoadingMore;
            });
          } else {
            this._emitQuery(this.pageNo, this.defaultPageSize, Enum.QueryFrom.LoadingMore);
            this._callMyParentQuery();
          }
          this.loadingType = Enum.LoadingType.LoadingMore;
        }
      },
      // (预处理)判断当没有更多数据且分页内容未超出z-paging时是否显示没有更多数据的view
      _preCheckShowNoMoreInside(newVal, scrollViewNode, pagingContainerNode) {
        if (this.loadingStatus === Enum.More.NoMore && this.hideNoMoreByLimit > 0 && newVal.length) {
          this.showLoadingMore = newVal.length > this.hideNoMoreByLimit;
        } else if (this.loadingStatus === Enum.More.NoMore && this.hideNoMoreInside && newVal.length || this.insideMore && this.insideOfPaging !== false && newVal.length) {
          this.$nextTick(() => {
            this._checkShowNoMoreInside(newVal, scrollViewNode, pagingContainerNode);
          });
          if (this.insideMore && this.insideOfPaging !== false && newVal.length) {
            this.showLoadingMore = newVal.length;
          }
        } else {
          this.showLoadingMore = newVal.length;
        }
      },
      // 判断当没有更多数据且分页内容未超出z-paging时是否显示没有更多数据的view
      async _checkShowNoMoreInside(totalData, oldScrollViewNode, oldPagingContainerNode) {
        try {
          const scrollViewNode = oldScrollViewNode || await this._getNodeClientRect(".zp-scroll-view");
          if (this.usePageScroll) {
            if (scrollViewNode) {
              const scrollViewTotalH = scrollViewNode[0].top + scrollViewNode[0].height;
              this.insideOfPaging = scrollViewTotalH < this.windowHeight;
              if (this.hideNoMoreInside) {
                this.showLoadingMore = !this.insideOfPaging;
              }
              this._updateInsideOfPaging();
            }
          } else {
            const pagingContainerNode = oldPagingContainerNode || await this._getNodeClientRect(".zp-paging-container-content");
            const pagingContainerH = pagingContainerNode ? pagingContainerNode[0].height : 0;
            const scrollViewH = scrollViewNode ? scrollViewNode[0].height : 0;
            this.insideOfPaging = pagingContainerH < scrollViewH;
            if (this.hideNoMoreInside) {
              this.showLoadingMore = !this.insideOfPaging;
            }
            this._updateInsideOfPaging();
          }
        } catch (e2) {
          this.insideOfPaging = !totalData.length;
          if (this.hideNoMoreInside) {
            this.showLoadingMore = !this.insideOfPaging;
          }
          this._updateInsideOfPaging();
        }
      },
      // 是否要展示上拉加载更多view
      _showLoadingMore(type) {
        if (!this.showLoadingMoreWhenReload && (!(this.loadingStatus === Enum.More.Default ? this.nShowBottom : true) || !this.realTotalData.length))
          return false;
        if ((!this.showLoadingMoreWhenReload || this.isUserPullDown || this.loadingStatus !== Enum.More.Loading) && !this.showLoadingMore || !this.loadingMoreEnabled && (!this.showLoadingMoreWhenReload || this.isUserPullDown || this.loadingStatus !== Enum.More.Loading) || this.refresherOnly) {
          return false;
        }
        if (this.useChatRecordMode && type !== "Loading")
          return false;
        if (!this.zSlots)
          return false;
        if (type === "Custom") {
          return this.showDefaultLoadingMoreText && !(this.loadingStatus === Enum.More.NoMore && !this.showLoadingMoreNoMoreView);
        }
        const res = this.loadingStatus === Enum.More[type] && this.zSlots[`loadingMore${type}`] && (type === "NoMore" ? this.showLoadingMoreNoMoreView : true);
        return res;
      }
    }
  };
  const loadingModule = {
    props: {
      // 第一次加载后自动隐藏loading slot，默认为是
      autoHideLoadingAfterFirstLoaded: {
        type: Boolean,
        default: u$1.gc("autoHideLoadingAfterFirstLoaded", true)
      },
      // loading slot是否铺满屏幕并固定，默认为否
      loadingFullFixed: {
        type: Boolean,
        default: u$1.gc("loadingFullFixed", false)
      },
      // 是否自动显示系统Loading：即uni.showLoading，若开启则将在刷新列表时(调用reload、refresh时)显示，下拉刷新和滚动到底部加载更多不会显示，默认为false。
      autoShowSystemLoading: {
        type: Boolean,
        default: u$1.gc("autoShowSystemLoading", false)
      },
      // 显示系统Loading时是否显示透明蒙层，防止触摸穿透，默认为是(H5、App、微信小程序、百度小程序有效)
      systemLoadingMask: {
        type: Boolean,
        default: u$1.gc("systemLoadingMask", true)
      },
      // 显示系统Loading时显示的文字，默认为"加载中"
      systemLoadingText: {
        type: [String, Object],
        default: u$1.gc("systemLoadingText", null)
      }
    },
    data() {
      return {
        loading: false,
        loadingForNow: false
      };
    },
    watch: {
      // loading状态
      loadingStatus(newVal) {
        this.$emit("loadingStatusChange", newVal);
        this.$nextTick(() => {
          this.loadingStatusAfterRender = newVal;
        });
        if (this.useChatRecordMode) {
          if (this.isFirstPage && (newVal === Enum.More.NoMore || newVal === Enum.More.Fail)) {
            this.isFirstPageAndNoMore = true;
            return;
          }
        }
        this.isFirstPageAndNoMore = false;
      },
      loading(newVal) {
        if (newVal) {
          this.loadingForNow = newVal;
        }
      }
    },
    computed: {
      // 是否显示loading
      showLoading() {
        if (this.firstPageLoaded || !this.loading || !this.loadingForNow)
          return false;
        if (this.finalShowSystemLoading) {
          uni.showLoading({
            title: this.finalSystemLoadingText,
            mask: this.systemLoadingMask
          });
        }
        return this.autoHideLoadingAfterFirstLoaded ? this.fromEmptyViewReload ? true : !this.pagingLoaded : this.loadingType === Enum.LoadingType.Refresher;
      },
      // 最终的是否显示系统loading
      finalShowSystemLoading() {
        return this.autoShowSystemLoading && this.loadingType === Enum.LoadingType.Refresher;
      }
    },
    methods: {
      // 处理开始加载更多状态
      _startLoading(isReload = false) {
        if (this.showLoadingMoreWhenReload && !this.isUserPullDown || !isReload) {
          this.loadingStatus = Enum.More.Loading;
        }
        this.loading = true;
      },
      // 停止系统loading和refresh
      _endSystemLoadingAndRefresh() {
        this.finalShowSystemLoading && uni.hideLoading();
        !this.useCustomRefresher && uni.stopPullDownRefresh();
      }
    }
  };
  const chatRecordModerModule = {
    props: {
      // 使用聊天记录模式，默认为否
      useChatRecordMode: {
        type: Boolean,
        default: u$1.gc("useChatRecordMode", false)
      },
      // 使用聊天记录模式时滚动到顶部后，列表垂直移动偏移距离。默认0rpx。单位px（暂时无效）
      chatRecordMoreOffset: {
        type: [Number, String],
        default: u$1.gc("chatRecordMoreOffset", "0rpx")
      },
      // 使用聊天记录模式时是否自动隐藏键盘：在用户触摸列表时候自动隐藏键盘，默认为是
      autoHideKeyboardWhenChat: {
        type: Boolean,
        default: u$1.gc("autoHideKeyboardWhenChat", true)
      },
      // 使用聊天记录模式中键盘弹出时是否自动调整slot="bottom"高度，默认为是
      autoAdjustPositionWhenChat: {
        type: Boolean,
        default: u$1.gc("autoAdjustPositionWhenChat", true)
      },
      // 使用聊天记录模式中键盘弹出时占位高度偏移距离。默认0rpx。单位px
      chatAdjustPositionOffset: {
        type: [Number, String],
        default: u$1.gc("chatAdjustPositionOffset", "0rpx")
      },
      // 使用聊天记录模式中键盘弹出时是否自动滚动到底部，默认为否
      autoToBottomWhenChat: {
        type: Boolean,
        default: u$1.gc("autoToBottomWhenChat", false)
      },
      // 使用聊天记录模式中reload时是否显示chatLoading，默认为否
      showChatLoadingWhenReload: {
        type: Boolean,
        default: u$1.gc("showChatLoadingWhenReload", false)
      },
      // 在聊天记录模式中滑动到顶部状态为默认状态时，以加载中的状态展示，默认为是。若设置为否，则默认会显示【点击加载更多】，然后才会显示loading
      chatLoadingMoreDefaultAsLoading: {
        type: Boolean,
        default: u$1.gc("chatLoadingMoreDefaultAsLoading", true)
      }
    },
    data() {
      return {
        // 键盘高度
        keyboardHeight: 0,
        // 键盘高度是否未改变，此时占位高度变化不需要动画效果
        isKeyboardHeightChanged: false
      };
    },
    computed: {
      finalChatRecordMoreOffset() {
        return u$1.convertToPx(this.chatRecordMoreOffset);
      },
      finalChatAdjustPositionOffset() {
        return u$1.convertToPx(this.chatAdjustPositionOffset);
      },
      // 聊天记录模式旋转180度style
      chatRecordRotateStyle() {
        let cellStyle;
        cellStyle = this.useChatRecordMode ? { transform: "scaleY(-1)" } : {};
        this.$emit("update:cellStyle", cellStyle);
        this.$emit("cellStyleChange", cellStyle);
        this.$nextTick(() => {
          if (this.isFirstPage && this.isChatRecordModeAndNotInversion) {
            this.$nextTick(() => {
              this._scrollToBottom(false);
              u$1.delay(() => {
                this._scrollToBottom(false);
                u$1.delay(() => {
                  this._scrollToBottom(false);
                }, 50);
              }, 50);
            });
          }
        });
        return cellStyle;
      },
      // 是否是聊天记录列表并且有配置transform
      isChatRecordModeHasTransform() {
        return this.useChatRecordMode && this.chatRecordRotateStyle && this.chatRecordRotateStyle.transform;
      },
      // 是否是聊天记录列表并且列表未倒置
      isChatRecordModeAndNotInversion() {
        return this.isChatRecordModeHasTransform && this.chatRecordRotateStyle.transform === "scaleY(1)";
      },
      // 是否是聊天记录列表并且列表倒置
      isChatRecordModeAndInversion() {
        return this.isChatRecordModeHasTransform && this.chatRecordRotateStyle.transform === "scaleY(-1)";
      },
      // 最终的聊天记录模式中底部安全区域的高度，如果开启了底部安全区域并且键盘未弹出，则添加底部区域高度
      chatRecordModeSafeAreaBottom() {
        return this.safeAreaInsetBottom && !this.keyboardHeight ? this.safeAreaBottom : 0;
      }
    },
    mounted() {
      if (this.useChatRecordMode) {
        uni.onKeyboardHeightChange(this._handleKeyboardHeightChange);
      }
    },
    methods: {
      // 添加聊天记录
      addChatRecordData(data, toBottom = true, toBottomWithAnimate = true) {
        if (!this.useChatRecordMode)
          return;
        this.isTotalChangeFromAddData = true;
        this.addDataFromTop(data, toBottom, toBottomWithAnimate);
      },
      // 手动触发滚动到顶部加载更多，聊天记录模式时有效
      doChatRecordLoadMore() {
        this.useChatRecordMode && this._onLoadingMore("click");
      },
      // 处理键盘高度变化
      _handleKeyboardHeightChange(res) {
        this.$emit("keyboardHeightChange", res);
        if (this.autoAdjustPositionWhenChat) {
          this.isKeyboardHeightChanged = true;
          this.keyboardHeight = res.height > 0 ? res.height + this.finalChatAdjustPositionOffset : res.height;
        }
        if (this.autoToBottomWhenChat && this.keyboardHeight > 0) {
          u$1.delay(() => {
            this.scrollToBottom(false);
            u$1.delay(() => {
              this.scrollToBottom(false);
            });
          });
        }
      }
    }
  };
  const scrollerModule = {
    props: {
      // 使用页面滚动，默认为否，当设置为是时则使用页面的滚动而非此组件内部的scroll-view的滚动，使用页面滚动时z-paging无需设置确定的高度且对于长列表展示性能更高，但配置会略微繁琐
      usePageScroll: {
        type: Boolean,
        default: u$1.gc("usePageScroll", false)
      },
      // 是否可以滚动，使用内置scroll-view和nvue时有效，默认为是
      scrollable: {
        type: Boolean,
        default: u$1.gc("scrollable", true)
      },
      // 控制是否出现滚动条，默认为是
      showScrollbar: {
        type: Boolean,
        default: u$1.gc("showScrollbar", true)
      },
      // 是否允许横向滚动，默认为否
      scrollX: {
        type: Boolean,
        default: u$1.gc("scrollX", false)
      },
      // iOS设备上滚动到顶部时是否允许回弹效果，默认为否。关闭回弹效果后可使滚动到顶部与下拉刷新更连贯，但是有吸顶view时滚动到顶部时可能出现抖动。
      scrollToTopBounceEnabled: {
        type: Boolean,
        default: u$1.gc("scrollToTopBounceEnabled", false)
      },
      // iOS设备上滚动到底部时是否允许回弹效果，默认为是。
      scrollToBottomBounceEnabled: {
        type: Boolean,
        default: u$1.gc("scrollToBottomBounceEnabled", true)
      },
      // 在设置滚动条位置时使用动画过渡，默认为否
      scrollWithAnimation: {
        type: Boolean,
        default: u$1.gc("scrollWithAnimation", false)
      },
      // 值应为某子元素id（id不能以数字开头）。设置哪个方向可滚动，则在哪个方向滚动到该元素
      scrollIntoView: {
        type: String,
        default: u$1.gc("scrollIntoView", "")
      }
    },
    data() {
      return {
        scrollTop: 0,
        oldScrollTop: 0,
        scrollViewStyle: {},
        scrollViewContainerStyle: {},
        scrollViewInStyle: {},
        pageScrollTop: -1,
        scrollEnable: true,
        privateScrollWithAnimation: -1,
        cacheScrollNodeHeight: -1,
        superContentHeight: 0
      };
    },
    watch: {
      oldScrollTop(newVal) {
        !this.usePageScroll && this._scrollTopChange(newVal, false);
      },
      pageScrollTop(newVal) {
        this.usePageScroll && this._scrollTopChange(newVal, true);
      },
      usePageScroll: {
        handler(newVal) {
          this.loaded && this.autoHeight && this._setAutoHeight(!newVal);
        },
        immediate: true
      },
      finalScrollTop(newVal) {
        this.renderPropScrollTop = newVal < 6 ? 0 : 10;
      }
    },
    computed: {
      finalScrollWithAnimation() {
        if (this.privateScrollWithAnimation !== -1) {
          return this.privateScrollWithAnimation === 1;
        }
        return this.scrollWithAnimation;
      },
      finalScrollViewStyle() {
        if (this.superContentZIndex != 1) {
          this.scrollViewStyle["z-index"] = this.superContentZIndex;
          this.scrollViewStyle["position"] = "relative";
        }
        return this.scrollViewStyle;
      },
      finalScrollTop() {
        return this.usePageScroll ? this.pageScrollTop : this.oldScrollTop;
      },
      // 当前是否是旧版webview
      finalIsOldWebView() {
        return this.isOldWebView && !this.usePageScroll;
      },
      // 当前scroll-view/list-view是否允许滚动
      finalScrollable() {
        return this.scrollable && !this.usePageScroll && this.scrollEnable && (this.refresherCompleteScrollable ? true : this.refresherStatus !== Enum.Refresher.Complete) && (this.refresherRefreshingScrollable ? true : this.refresherStatus !== Enum.Refresher.Loading);
      }
    },
    methods: {
      // 滚动到顶部，animate为是否展示滚动动画，默认为是
      scrollToTop(animate, checkReverse = true) {
        if (this.useChatRecordMode && checkReverse && !this.isChatRecordModeAndNotInversion) {
          this.scrollToBottom(animate, false);
          return;
        }
        this.$nextTick(() => {
          this._scrollToTop(animate, false);
        });
      },
      // 滚动到底部，animate为是否展示滚动动画，默认为是
      scrollToBottom(animate, checkReverse = true) {
        if (this.useChatRecordMode && checkReverse && !this.isChatRecordModeAndNotInversion) {
          this.scrollToTop(animate, false);
          return;
        }
        this.$nextTick(() => {
          this._scrollToBottom(animate);
        });
      },
      // 滚动到指定view(vue中有效)。sel为需要滚动的view的id值，不包含"#"；offset为偏移量，单位为px；animate为是否展示滚动动画，默认为否
      scrollIntoViewById(sel, offset2, animate) {
        this._scrollIntoView(sel, offset2, animate);
      },
      // 滚动到指定view(vue中有效)。nodeTop为需要滚动的view的top值(通过uni.createSelectorQuery()获取)；offset为偏移量，单位为px；animate为是否展示滚动动画，默认为否
      scrollIntoViewByNodeTop(nodeTop, offset2, animate) {
        this.scrollTop = this.oldScrollTop;
        this.$nextTick(() => {
          this._scrollIntoViewByNodeTop(nodeTop, offset2, animate);
        });
      },
      // 滚动到指定位置(vue中有效)。y为与顶部的距离，单位为px；offset为偏移量，单位为px；animate为是否展示滚动动画，默认为否
      scrollToY(y, offset2, animate) {
        this.scrollTop = this.oldScrollTop;
        this.$nextTick(() => {
          this._scrollToY(y, offset2, animate);
        });
      },
      // 滚动到指定view(nvue中和虚拟列表中有效)。index为需要滚动的view的index(第几个，从0开始)；offset为偏移量，单位为px；animate为是否展示滚动动画，默认为否
      scrollIntoViewByIndex(index2, offset2, animate) {
        if (index2 >= this.realTotalData.length) {
          u$1.consoleErr("当前滚动的index超出已渲染列表长度，请先通过refreshToPage加载到对应index页并等待渲染成功后再调用此方法！");
          return;
        }
        this.$nextTick(() => {
          if (this.finalUseVirtualList) {
            const isCellFixed = this.cellHeightMode === Enum.CellHeightMode.Fixed;
            u$1.delay(() => {
              if (this.finalUseVirtualList) {
                const scrollTop = isCellFixed ? this.virtualCellHeight * index2 : this.virtualHeightCacheList[index2].lastTotalHeight;
                this.scrollToY(scrollTop, offset2, animate);
              }
            }, isCellFixed ? 0 : 100);
          }
        });
      },
      // 滚动到指定view(nvue中有效)。view为需要滚动的view(通过`this.$refs.xxx`获取)，不包含"#"；offset为偏移量，单位为px；animate为是否展示滚动动画，默认为否
      scrollIntoViewByView(view, offset2, animate) {
        this._scrollIntoView(view, offset2, animate);
      },
      // 当使用页面滚动并且自定义下拉刷新时，请在页面的onPageScroll中调用此方法，告知z-paging当前的pageScrollTop，否则会导致在任意位置都可以下拉刷新
      updatePageScrollTop(value) {
        this.pageScrollTop = value;
      },
      // 当使用页面滚动并且设置了slot="top"时，默认初次加载会自动获取其高度，并使内部容器下移，当slot="top"的view高度动态改变时，在其高度需要更新时调用此方法
      updatePageScrollTopHeight() {
        this._updatePageScrollTopOrBottomHeight("top");
      },
      // 当使用页面滚动并且设置了slot="bottom"时，默认初次加载会自动获取其高度，并使内部容器下移，当slot="bottom"的view高度动态改变时，在其高度需要更新时调用此方法
      updatePageScrollBottomHeight() {
        this._updatePageScrollTopOrBottomHeight("bottom");
      },
      // 更新slot="left"和slot="right"宽度，当slot="left"或slot="right"宽度动态改变时调用
      updateLeftAndRightWidth() {
        if (!this.finalIsOldWebView)
          return;
        this.$nextTick(() => this._updateLeftAndRightWidth(this.scrollViewContainerStyle, "zp-page"));
      },
      // 更新z-paging内置scroll-view的scrollTop
      updateScrollViewScrollTop(scrollTop, animate = true) {
        this._updatePrivateScrollWithAnimation(animate);
        this.scrollTop = this.oldScrollTop;
        this.$nextTick(() => {
          this.scrollTop = scrollTop;
          this.oldScrollTop = this.scrollTop;
        });
      },
      // 当滚动到顶部时
      _onScrollToUpper() {
        this.$emit("scrolltoupper");
        this.$emit("scrollTopChange", 0);
        this.$nextTick(() => {
          this.oldScrollTop = 0;
        });
      },
      // 当滚动到底部时
      _onScrollToLower(e2) {
        (!e2.detail || !e2.detail.direction || e2.detail.direction === "bottom") && this.toBottomLoadingMoreEnabled && this._onLoadingMore(this.useChatRecordMode ? "click" : "toBottom");
      },
      // 滚动到顶部
      _scrollToTop(animate = true, isPrivate = true) {
        if (this.usePageScroll) {
          this.$nextTick(() => {
            uni.pageScrollTo({
              scrollTop: 0,
              duration: animate ? 100 : 0
            });
          });
          return;
        }
        this._updatePrivateScrollWithAnimation(animate);
        this.scrollTop = this.oldScrollTop;
        this.$nextTick(() => {
          this.scrollTop = 0;
          this.oldScrollTop = this.scrollTop;
        });
      },
      // 滚动到底部
      async _scrollToBottom(animate = true) {
        if (this.usePageScroll) {
          this.$nextTick(() => {
            uni.pageScrollTo({
              scrollTop: Number.MAX_VALUE,
              duration: animate ? 100 : 0
            });
          });
          return;
        }
        try {
          this._updatePrivateScrollWithAnimation(animate);
          const pagingContainerNode = await this._getNodeClientRect(".zp-paging-container");
          const scrollViewNode = await this._getNodeClientRect(".zp-scroll-view");
          const pagingContainerH = pagingContainerNode ? pagingContainerNode[0].height : 0;
          const scrollViewH = scrollViewNode ? scrollViewNode[0].height : 0;
          if (pagingContainerH > scrollViewH) {
            this.scrollTop = this.oldScrollTop;
            this.$nextTick(() => {
              this.scrollTop = pagingContainerH - scrollViewH + this.virtualPlaceholderTopHeight;
              this.oldScrollTop = this.scrollTop;
            });
          }
        } catch (e2) {
        }
      },
      // 滚动到指定view
      _scrollIntoView(sel, offset2 = 0, animate = false, finishCallback) {
        try {
          this.scrollTop = this.oldScrollTop;
          this.$nextTick(() => {
            this._getNodeClientRect("#" + sel.replace("#", ""), this.$parent).then((node) => {
              if (node) {
                let nodeTop = node[0].top;
                this._scrollIntoViewByNodeTop(nodeTop, offset2, animate);
                finishCallback && finishCallback();
              }
            });
          });
        } catch (e2) {
        }
      },
      // 通过nodeTop滚动到指定view
      _scrollIntoViewByNodeTop(nodeTop, offset2 = 0, animate = false) {
        if (this.isChatRecordModeAndInversion) {
          this._getNodeClientRect(".zp-scroll-view").then((sNode) => {
            if (sNode) {
              this._scrollToY(sNode[0].height - nodeTop, offset2, animate, true);
            }
          });
        } else {
          this._scrollToY(nodeTop, offset2, animate, true);
        }
      },
      // 滚动到指定位置
      _scrollToY(y, offset2 = 0, animate = false, addScrollTop = false) {
        this._updatePrivateScrollWithAnimation(animate);
        u$1.delay(() => {
          if (this.usePageScroll) {
            if (addScrollTop && this.pageScrollTop !== -1) {
              y += this.pageScrollTop;
            }
            const scrollTop = y - offset2;
            uni.pageScrollTo({
              scrollTop,
              duration: animate ? 100 : 0
            });
          } else {
            if (addScrollTop) {
              y += this.oldScrollTop;
            }
            this.scrollTop = y - offset2;
          }
        }, 10);
      },
      // scroll-view滚动中
      _scroll(e2) {
        this.$emit("scroll", e2);
        const scrollTop = e2.detail.scrollTop;
        this.finalUseVirtualList && this._updateVirtualScroll(scrollTop, this.oldScrollTop - scrollTop);
        this.oldScrollTop = scrollTop;
        const scrollDiff = e2.detail.scrollHeight - this.oldScrollTop;
        !this.isIos && this._checkScrolledToBottom(scrollDiff);
      },
      // 更新内置的scroll-view是否启用滚动动画
      _updatePrivateScrollWithAnimation(animate) {
        this.privateScrollWithAnimation = animate ? 1 : 0;
        u$1.delay(() => this.$nextTick(() => {
          this.privateScrollWithAnimation = -1;
        }), 100, "updateScrollWithAnimationDelay");
      },
      // 检测scrollView是否要铺满屏幕
      _doCheckScrollViewShouldFullHeight(totalData) {
        if (this.autoFullHeight && this.usePageScroll && this.isTotalChangeFromAddData) {
          this.$nextTick(() => {
            this._checkScrollViewShouldFullHeight((scrollViewNode, pagingContainerNode) => {
              this._preCheckShowNoMoreInside(totalData, scrollViewNode, pagingContainerNode);
            });
          });
        } else {
          this._preCheckShowNoMoreInside(totalData);
        }
      },
      // 检测z-paging是否要全屏覆盖(当使用页面滚动并且不满全屏时，默认z-paging需要铺满全屏，避免数据过少时内部的empty-view无法正确展示)
      async _checkScrollViewShouldFullHeight(callback) {
        try {
          const scrollViewNode = await this._getNodeClientRect(".zp-scroll-view");
          const pagingContainerNode = await this._getNodeClientRect(".zp-paging-container-content");
          if (!scrollViewNode || !pagingContainerNode)
            return;
          const scrollViewHeight = pagingContainerNode[0].height;
          const scrollViewTop = scrollViewNode[0].top;
          if (this.isAddedData && scrollViewHeight + scrollViewTop <= this.windowHeight) {
            this._setAutoHeight(true, scrollViewNode);
            callback(scrollViewNode, pagingContainerNode);
          } else {
            this._setAutoHeight(false);
            callback(null, null);
          }
        } catch (e2) {
          callback(null, null);
        }
      },
      // 更新缓存中z-paging整个内容容器高度
      async _updateCachedSuperContentHeight() {
        const superContentNode = await this._getNodeClientRect(".z-paging-content");
        if (superContentNode) {
          this.superContentHeight = superContentNode[0].height;
        }
      },
      // scrollTop改变时触发
      _scrollTopChange(newVal, isPageScrollTop) {
        this.$emit("scrollTopChange", newVal);
        this.$emit("update:scrollTop", newVal);
        this._checkShouldShowBackToTop(newVal);
        const scrollTop = newVal > 5 ? 6 : 0;
        if (isPageScrollTop && this.wxsPageScrollTop !== scrollTop) {
          this.wxsPageScrollTop = scrollTop;
        } else if (!isPageScrollTop && this.wxsScrollTop !== scrollTop) {
          this.wxsScrollTop = scrollTop;
          if (scrollTop > 6) {
            this.scrollEnable = true;
          }
        }
      },
      // 更新使用页面滚动时slot="top"或"bottom"插入view的高度
      _updatePageScrollTopOrBottomHeight(type) {
        if (!this.usePageScroll)
          return;
        this._doCheckScrollViewShouldFullHeight(this.realTotalData);
        const node = `.zp-page-${type}`;
        const marginText = `margin${type.slice(0, 1).toUpperCase() + type.slice(1)}`;
        let safeAreaInsetBottomAdd = this.safeAreaInsetBottom;
        this.$nextTick(() => {
          let delayTime = 0;
          u$1.delay(() => {
            this._getNodeClientRect(node).then((res) => {
              if (res) {
                let pageScrollNodeHeight = res[0].height;
                if (type === "bottom") {
                  if (safeAreaInsetBottomAdd) {
                    pageScrollNodeHeight += this.safeAreaBottom;
                  }
                } else {
                  this.cacheTopHeight = pageScrollNodeHeight;
                }
                this.$set(this.scrollViewStyle, marginText, `${pageScrollNodeHeight}px`);
              } else if (safeAreaInsetBottomAdd) {
                this.$set(this.scrollViewStyle, marginText, `${this.safeAreaBottom}px`);
              }
            });
          }, delayTime);
        });
      }
    }
  };
  const backToTopModule = {
    props: {
      // 自动显示点击返回顶部按钮，默认为否
      autoShowBackToTop: {
        type: Boolean,
        default: u$1.gc("autoShowBackToTop", false)
      },
      // 点击返回顶部按钮显示/隐藏的阈值(滚动距离)，单位为px，默认为400rpx
      backToTopThreshold: {
        type: [Number, String],
        default: u$1.gc("backToTopThreshold", "400rpx")
      },
      // 点击返回顶部按钮的自定义图片地址，默认使用z-paging内置的图片
      backToTopImg: {
        type: String,
        default: u$1.gc("backToTopImg", "")
      },
      // 点击返回顶部按钮返回到顶部时是否展示过渡动画，默认为是
      backToTopWithAnimate: {
        type: Boolean,
        default: u$1.gc("backToTopWithAnimate", true)
      },
      // 点击返回顶部按钮与底部的距离，注意添加单位px或rpx，默认为160rpx
      backToTopBottom: {
        type: [Number, String],
        default: u$1.gc("backToTopBottom", "160rpx")
      },
      // 点击返回顶部按钮的自定义样式
      backToTopStyle: {
        type: Object,
        default: u$1.gc("backToTopStyle", {})
      },
      // iOS点击顶部状态栏、安卓双击标题栏时，滚动条返回顶部，只支持竖向，默认为是
      enableBackToTop: {
        type: Boolean,
        default: u$1.gc("enableBackToTop", true)
      }
    },
    data() {
      return {
        // 点击返回顶部的class
        backToTopClass: "zp-back-to-top zp-back-to-top-hide",
        // 上次点击返回顶部的时间
        lastBackToTopShowTime: 0,
        // 点击返回顶部显示的class是否在展示中，使得按钮展示/隐藏过度效果更自然
        showBackToTopClass: false
      };
    },
    computed: {
      backToTopThresholdUnitConverted() {
        return u$1.addUnit(this.backToTopThreshold, this.unit);
      },
      backToTopBottomUnitConverted() {
        return u$1.addUnit(this.backToTopBottom, this.unit);
      },
      finalEnableBackToTop() {
        return this.usePageScroll ? false : this.enableBackToTop;
      },
      finalBackToTopThreshold() {
        return u$1.convertToPx(this.backToTopThresholdUnitConverted);
      },
      finalBackToTopStyle() {
        const backToTopStyle = this.backToTopStyle;
        if (!backToTopStyle.bottom) {
          backToTopStyle.bottom = this.windowBottom + u$1.convertToPx(this.backToTopBottomUnitConverted) + "px";
        }
        if (!backToTopStyle.position) {
          backToTopStyle.position = this.usePageScroll ? "fixed" : "absolute";
        }
        return backToTopStyle;
      },
      finalBackToTopClass() {
        return `${this.backToTopClass} zp-back-to-top-${this.unit}`;
      }
    },
    methods: {
      // 点击了返回顶部
      _backToTopClick() {
        let callbacked = false;
        this.$emit("backToTopClick", (toTop) => {
          (toTop === void 0 || toTop === true) && this._handleToTop();
          callbacked = true;
        });
        this.$nextTick(() => {
          !callbacked && this._handleToTop();
        });
      },
      // 处理滚动到顶部（聊天记录模式中为滚动到底部）
      _handleToTop() {
        !this.backToTopWithAnimate && this._checkShouldShowBackToTop(0);
        !this.useChatRecordMode ? this.scrollToTop(this.backToTopWithAnimate) : this.scrollToBottom(this.backToTopWithAnimate);
      },
      // 判断是否要显示返回顶部按钮
      _checkShouldShowBackToTop(scrollTop) {
        if (!this.autoShowBackToTop) {
          this.showBackToTopClass = false;
          return;
        }
        if (scrollTop > this.finalBackToTopThreshold) {
          if (!this.showBackToTopClass) {
            this.showBackToTopClass = true;
            this.lastBackToTopShowTime = (/* @__PURE__ */ new Date()).getTime();
            u$1.delay(() => {
              this.backToTopClass = "zp-back-to-top zp-back-to-top-show";
            }, 300);
          }
        } else {
          if (this.showBackToTopClass) {
            this.backToTopClass = "zp-back-to-top zp-back-to-top-hide";
            u$1.delay(() => {
              this.showBackToTopClass = false;
            }, (/* @__PURE__ */ new Date()).getTime() - this.lastBackToTopShowTime < 500 ? 0 : 300);
          }
        }
      }
    }
  };
  const virtualListModule = {
    props: {
      // 是否使用虚拟列表，默认为否
      useVirtualList: {
        type: Boolean,
        default: u$1.gc("useVirtualList", false)
      },
      // 在使用虚拟列表时，是否使用兼容模式，默认为否
      useCompatibilityMode: {
        type: Boolean,
        default: u$1.gc("useCompatibilityMode", false)
      },
      // 使用兼容模式时传递的附加数据
      extraData: {
        type: Object,
        default: u$1.gc("extraData", {})
      },
      // 是否在z-paging内部循环渲染列表(内置列表)，默认为否。若use-virtual-list为true，则此项恒为true
      useInnerList: {
        type: Boolean,
        default: u$1.gc("useInnerList", false)
      },
      // 强制关闭inner-list，默认为false，如果为true将强制关闭innerList，适用于开启了虚拟列表后需要强制关闭inner-list的情况
      forceCloseInnerList: {
        type: Boolean,
        default: u$1.gc("forceCloseInnerList", false)
      },
      // 内置列表cell的key名称，仅nvue有效，在nvue中开启use-inner-list时必须填此项
      cellKeyName: {
        type: String,
        default: u$1.gc("cellKeyName", "")
      },
      // innerList样式
      innerListStyle: {
        type: Object,
        default: u$1.gc("innerListStyle", {})
      },
      // innerCell样式
      innerCellStyle: {
        type: Object,
        default: u$1.gc("innerCellStyle", {})
      },
      // 预加载的列表可视范围(列表高度)页数，默认为12，即预加载当前页及上下各12页的cell。此数值越大，则虚拟列表中加载的dom越多，内存消耗越大(会维持在一个稳定值)，但增加预加载页面数量可缓解快速滚动短暂白屏问题
      preloadPage: {
        type: [Number, String],
        default: u$1.gc("preloadPage", 12),
        validator: (value) => {
          if (value <= 0)
            u$1.consoleErr("preload-page必须大于0！");
          return value > 0;
        }
      },
      // 虚拟列表cell高度模式，默认为fixed，也就是每个cell高度完全相同，将以第一个cell高度为准进行计算。可选值【dynamic】，即代表高度是动态非固定的，【dynamic】性能低于【fixed】。
      cellHeightMode: {
        type: String,
        default: u$1.gc("cellHeightMode", Enum.CellHeightMode.Fixed)
      },
      // 固定的cell高度，cellHeightMode=fixed才有效，若设置了值，则不计算第一个cell高度而使用设置的cell高度
      fixedCellHeight: {
        type: [Number, String],
        default: u$1.gc("fixedCellHeight", 0)
      },
      // 虚拟列表列数，默认为1。常用于每行有多列的情况，例如每行有2列数据，需要将此值设置为2
      virtualListCol: {
        type: [Number, String],
        default: u$1.gc("virtualListCol", 1)
      },
      // 虚拟列表scroll取样帧率，默认为80，过低容易出现白屏问题，过高容易出现卡顿问题
      virtualScrollFps: {
        type: [Number, String],
        default: u$1.gc("virtualScrollFps", 80)
      }
    },
    data() {
      return {
        virtualListKey: u$1.getInstanceId(),
        virtualPageHeight: 0,
        virtualCellHeight: 0,
        virtualScrollTimeStamp: 0,
        virtualList: [],
        virtualPlaceholderTopHeight: 0,
        virtualPlaceholderBottomHeight: 0,
        virtualTopRangeIndex: 0,
        virtualBottomRangeIndex: 0,
        lastVirtualTopRangeIndex: 0,
        lastVirtualBottomRangeIndex: 0,
        virtualItemInsertedCount: 0,
        virtualHeightCacheList: [],
        getCellHeightRetryCount: {
          fixed: 0,
          dynamic: 0
        },
        pagingOrgTop: -1,
        updateVirtualListFromDataChange: false
      };
    },
    watch: {
      // 监听总数据的改变，刷新虚拟列表布局
      realTotalData() {
        this.updateVirtualListRender();
      },
      // 监听虚拟列表渲染数组的改变并emit
      virtualList(newVal) {
        this.$emit("update:virtualList", newVal);
        this.$emit("virtualListChange", newVal);
      },
      // 监听虚拟列表顶部占位高度改变并emit
      virtualPlaceholderTopHeight(newVal) {
        this.$emit("virtualTopHeightChange", newVal);
      }
    },
    computed: {
      virtualCellIndexKey() {
        return c$1.listCellIndexKey;
      },
      finalUseVirtualList() {
        if (this.useVirtualList && this.usePageScroll) {
          u$1.consoleErr("使用页面滚动时，开启虚拟列表无效！");
        }
        return this.useVirtualList && !this.usePageScroll;
      },
      finalUseInnerList() {
        return this.useInnerList || this.finalUseVirtualList && !this.forceCloseInnerList;
      },
      finalCellKeyName() {
        return this.cellKeyName;
      },
      finalVirtualPageHeight() {
        return this.virtualPageHeight > 0 ? this.virtualPageHeight : this.windowHeight;
      },
      finalFixedCellHeight() {
        return u$1.convertToPx(this.fixedCellHeight);
      },
      virtualRangePageHeight() {
        return this.finalVirtualPageHeight * this.preloadPage;
      },
      virtualScrollDisTimeStamp() {
        return 1e3 / this.virtualScrollFps;
      }
    },
    methods: {
      // 在使用动态高度虚拟列表时，若在列表数组中需要插入某个item，需要调用此方法；item:需要插入的item，index:插入的cell位置，若index为2，则插入的item在原list的index=1之后，index从0开始
      doInsertVirtualListItem(item, index2) {
        if (this.cellHeightMode !== Enum.CellHeightMode.Dynamic)
          return;
        this.virtualItemInsertedCount++;
        if (!item || Object.prototype.toString.call(item) !== "[object Object]") {
          item = { item };
        }
        const cellIndexKey = this.virtualCellIndexKey;
        item[cellIndexKey] = `custom-${this.virtualItemInsertedCount}`;
        item[c$1.listCellIndexUniqueKey] = `${this.virtualListKey}-${item[cellIndexKey]}`;
        this.$nextTick(async () => {
          let retryCount = 0;
          while (retryCount <= 10) {
            await u$1.wait(c$1.delayTime);
            const cellNode = await this._getNodeClientRect(`#zp-id-${item[cellIndexKey]}`, this.finalUseInnerList);
            if (!cellNode) {
              retryCount++;
              continue;
            }
            const currentHeight = cellNode ? cellNode[0].height : 0;
            const lastHeightCache = this.virtualHeightCacheList[index2 - 1];
            const lastTotalHeight = lastHeightCache ? lastHeightCache.totalHeight : 0;
            this.virtualHeightCacheList.splice(index2, 0, {
              height: currentHeight,
              lastTotalHeight,
              totalHeight: lastTotalHeight + currentHeight
            });
            for (let i2 = index2 + 1; i2 < this.virtualHeightCacheList.length; i2++) {
              const thisNode = this.virtualHeightCacheList[i2];
              thisNode.lastTotalHeight += currentHeight;
              thisNode.totalHeight += currentHeight;
            }
            this._updateVirtualScroll(this.oldScrollTop);
            break;
          }
        });
      },
      // 在使用动态高度虚拟列表时，手动更新指定cell的缓存高度(当cell高度在初始化之后再次改变时调用)；index:需要更新的cell在列表中的位置，从0开始
      didUpdateVirtualListCell(index2) {
        if (this.cellHeightMode !== Enum.CellHeightMode.Dynamic)
          return;
        const currentNode = this.virtualHeightCacheList[index2];
        this.$nextTick(() => {
          this._getNodeClientRect(`#zp-id-${index2}`, this.finalUseInnerList).then((cellNode) => {
            const cellNodeHeight = cellNode ? cellNode[0].height : 0;
            const heightDis = cellNodeHeight - currentNode.height;
            currentNode.height = cellNodeHeight;
            currentNode.totalHeight = currentNode.lastTotalHeight + cellNodeHeight;
            for (let i2 = index2 + 1; i2 < this.virtualHeightCacheList.length; i2++) {
              const thisNode = this.virtualHeightCacheList[i2];
              thisNode.totalHeight += heightDis;
              thisNode.lastTotalHeight += heightDis;
            }
          });
        });
      },
      // 在使用动态高度虚拟列表时，若删除了列表数组中的某个item，需要调用此方法以更新高度缓存数组；index:删除的cell在列表中的位置，从0开始
      didDeleteVirtualListCell(index2) {
        if (this.cellHeightMode !== Enum.CellHeightMode.Dynamic)
          return;
        const currentNode = this.virtualHeightCacheList[index2];
        for (let i2 = index2 + 1; i2 < this.virtualHeightCacheList.length; i2++) {
          const thisNode = this.virtualHeightCacheList[i2];
          thisNode.totalHeight -= currentNode.height;
          thisNode.lastTotalHeight -= currentNode.height;
        }
        this.virtualHeightCacheList.splice(index2, 1);
      },
      // 手动触发虚拟列表渲染更新，可用于解决例如修改了虚拟列表数组中元素，但展示未更新的情况
      updateVirtualListRender() {
        if (this.finalUseVirtualList) {
          this.updateVirtualListFromDataChange = true;
          this.$nextTick(() => {
            this.getCellHeightRetryCount.fixed = 0;
            if (this.realTotalData.length) {
              this.cellHeightMode === Enum.CellHeightMode.Fixed && this.isFirstPage && this._updateFixedCellHeight();
            } else {
              this._resetDynamicListState(!this.isUserPullDown);
            }
            this._updateVirtualScroll(this.oldScrollTop);
          });
        }
      },
      // 初始化虚拟列表
      _virtualListInit() {
        this.$nextTick(() => {
          u$1.delay(() => {
            this._getNodeClientRect(".zp-scroll-view").then((node) => {
              if (node) {
                this.pagingOrgTop = node[0].top;
                this.virtualPageHeight = node[0].height;
              }
            });
          });
        });
      },
      // cellHeightMode为fixed时获取第一个cell高度
      _updateFixedCellHeight() {
        if (!this.finalFixedCellHeight) {
          this.$nextTick(() => {
            u$1.delay(() => {
              this._getNodeClientRect(`#zp-id-${0}`, this.finalUseInnerList).then((cellNode) => {
                if (!cellNode) {
                  if (this.getCellHeightRetryCount.fixed > 10)
                    return;
                  this.getCellHeightRetryCount.fixed++;
                  this._updateFixedCellHeight();
                } else {
                  this.virtualCellHeight = cellNode[0].height;
                  this._updateVirtualScroll(this.oldScrollTop);
                }
              });
            }, c$1.delayTime, "updateFixedCellHeightDelay");
          });
        } else {
          this.virtualCellHeight = this.finalFixedCellHeight;
        }
      },
      // cellHeightMode为dynamic时获取每个cell高度
      _updateDynamicCellHeight(list, dataFrom = "bottom") {
        const dataFromTop = dataFrom === "top";
        const heightCacheList = this.virtualHeightCacheList;
        const currentCacheList = dataFromTop ? [] : heightCacheList;
        let listTotalHeight = 0;
        this.$nextTick(() => {
          u$1.delay(async () => {
            for (let i2 = 0; i2 < list.length; i2++) {
              const cellNode = await this._getNodeClientRect(`#zp-id-${list[i2][this.virtualCellIndexKey]}`, this.finalUseInnerList);
              const currentHeight = cellNode ? cellNode[0].height : 0;
              if (!cellNode) {
                if (this.getCellHeightRetryCount.dynamic <= 10) {
                  heightCacheList.splice(heightCacheList.length - i2, i2);
                  this.getCellHeightRetryCount.dynamic++;
                  this._updateDynamicCellHeight(list, dataFrom);
                }
                return;
              }
              const lastHeightCache = currentCacheList.length ? currentCacheList.slice(-1)[0] : null;
              const lastTotalHeight = lastHeightCache ? lastHeightCache.totalHeight : 0;
              currentCacheList.push({
                height: currentHeight,
                lastTotalHeight,
                totalHeight: lastTotalHeight + currentHeight
              });
              if (dataFromTop) {
                listTotalHeight += currentHeight;
              }
            }
            if (dataFromTop && list.length) {
              for (let i2 = 0; i2 < heightCacheList.length; i2++) {
                const heightCacheItem = heightCacheList[i2];
                heightCacheItem.lastTotalHeight += listTotalHeight;
                heightCacheItem.totalHeight += listTotalHeight;
              }
              this.virtualHeightCacheList = currentCacheList.concat(heightCacheList);
            }
            this._updateVirtualScroll(this.oldScrollTop);
          }, c$1.delayTime, "updateDynamicCellHeightDelay");
        });
      },
      // 设置cellItem的index
      _setCellIndex(list, dataFrom = "bottom") {
        let currentItemIndex = 0;
        const cellIndexKey = this.virtualCellIndexKey;
        [Enum.QueryFrom.Refresh, Enum.QueryFrom.Reload].indexOf(this.queryFrom) >= 0 && this._resetDynamicListState();
        if (this.totalData.length) {
          if (dataFrom === "bottom") {
            currentItemIndex = this.realTotalData.length;
            const lastItem = this.realTotalData.length ? this.realTotalData.slice(-1)[0] : null;
            if (lastItem && lastItem[cellIndexKey] !== void 0) {
              currentItemIndex = lastItem[cellIndexKey] + 1;
            }
          } else if (dataFrom === "top") {
            const firstItem = this.realTotalData.length ? this.realTotalData[0] : null;
            if (firstItem && firstItem[cellIndexKey] !== void 0) {
              currentItemIndex = firstItem[cellIndexKey] - list.length;
            }
          }
        } else {
          this._resetDynamicListState();
        }
        for (let i2 = 0; i2 < list.length; i2++) {
          let item = list[i2];
          if (!item || Object.prototype.toString.call(item) !== "[object Object]") {
            item = { item };
          }
          if (item[c$1.listCellIndexUniqueKey]) {
            item = u$1.deepCopy(item);
          }
          item[cellIndexKey] = currentItemIndex + i2;
          item[c$1.listCellIndexUniqueKey] = `${this.virtualListKey}-${item[cellIndexKey]}`;
          list[i2] = item;
        }
        this.getCellHeightRetryCount.dynamic = 0;
        this.cellHeightMode === Enum.CellHeightMode.Dynamic && this._updateDynamicCellHeight(list, dataFrom);
      },
      // 更新scroll滚动（虚拟列表滚动时触发）
      _updateVirtualScroll(scrollTop, scrollDiff = 0) {
        const currentTimeStamp = u$1.getTime();
        scrollTop === 0 && this._resetTopRange();
        if (scrollTop !== 0 && this.virtualScrollTimeStamp && currentTimeStamp - this.virtualScrollTimeStamp <= this.virtualScrollDisTimeStamp) {
          return;
        }
        this.virtualScrollTimeStamp = currentTimeStamp;
        let scrollIndex = 0;
        const cellHeightMode = this.cellHeightMode;
        if (cellHeightMode === Enum.CellHeightMode.Fixed) {
          scrollIndex = parseInt(scrollTop / this.virtualCellHeight) || 0;
          this._updateFixedTopRangeIndex(scrollIndex);
          this._updateFixedBottomRangeIndex(scrollIndex);
        } else if (cellHeightMode === Enum.CellHeightMode.Dynamic) {
          const scrollDirection = scrollDiff > 0 ? "top" : "bottom";
          const rangePageHeight = this.virtualRangePageHeight;
          const topRangePageOffset = scrollTop - rangePageHeight;
          const bottomRangePageOffset = scrollTop + this.finalVirtualPageHeight + rangePageHeight;
          let virtualBottomRangeIndex = 0;
          let virtualPlaceholderBottomHeight = 0;
          let reachedLimitBottom = false;
          const heightCacheList = this.virtualHeightCacheList;
          const lastHeightCache = !!heightCacheList ? heightCacheList.slice(-1)[0] : null;
          let startTopRangeIndex = this.virtualTopRangeIndex;
          if (scrollDirection === "bottom") {
            for (let i2 = startTopRangeIndex; i2 < heightCacheList.length; i2++) {
              const heightCacheItem = heightCacheList[i2];
              if (heightCacheItem && heightCacheItem.totalHeight > topRangePageOffset) {
                this.virtualTopRangeIndex = i2;
                this.virtualPlaceholderTopHeight = heightCacheItem.lastTotalHeight;
                break;
              }
            }
          } else {
            let topRangeMatched = false;
            for (let i2 = startTopRangeIndex; i2 >= 0; i2--) {
              const heightCacheItem = heightCacheList[i2];
              if (heightCacheItem && heightCacheItem.totalHeight < topRangePageOffset) {
                this.virtualTopRangeIndex = i2;
                this.virtualPlaceholderTopHeight = heightCacheItem.lastTotalHeight;
                topRangeMatched = true;
                break;
              }
            }
            !topRangeMatched && this._resetTopRange();
          }
          for (let i2 = this.virtualTopRangeIndex; i2 < heightCacheList.length; i2++) {
            const heightCacheItem = heightCacheList[i2];
            if (heightCacheItem && heightCacheItem.totalHeight > bottomRangePageOffset) {
              virtualBottomRangeIndex = i2;
              virtualPlaceholderBottomHeight = lastHeightCache.totalHeight - heightCacheItem.totalHeight;
              reachedLimitBottom = true;
              break;
            }
          }
          if (!reachedLimitBottom || this.virtualBottomRangeIndex === 0) {
            this.virtualBottomRangeIndex = this.realTotalData.length ? this.realTotalData.length - 1 : this.pageSize;
            this.virtualPlaceholderBottomHeight = 0;
          } else {
            this.virtualBottomRangeIndex = virtualBottomRangeIndex;
            this.virtualPlaceholderBottomHeight = virtualPlaceholderBottomHeight;
          }
          this._updateVirtualList();
        }
      },
      // 更新fixedCell模式下topRangeIndex&placeholderTopHeight
      _updateFixedTopRangeIndex(scrollIndex) {
        let virtualTopRangeIndex = this.virtualCellHeight === 0 ? 0 : scrollIndex - (parseInt(this.finalVirtualPageHeight / this.virtualCellHeight) || 1) * this.preloadPage;
        virtualTopRangeIndex *= this.virtualListCol;
        virtualTopRangeIndex = Math.max(0, virtualTopRangeIndex);
        this.virtualTopRangeIndex = virtualTopRangeIndex;
        this.virtualPlaceholderTopHeight = virtualTopRangeIndex / this.virtualListCol * this.virtualCellHeight;
      },
      // 更新fixedCell模式下bottomRangeIndex&placeholderBottomHeight
      _updateFixedBottomRangeIndex(scrollIndex) {
        let virtualBottomRangeIndex = this.virtualCellHeight === 0 ? this.pageSize : scrollIndex + (parseInt(this.finalVirtualPageHeight / this.virtualCellHeight) || 1) * (this.preloadPage + 1);
        virtualBottomRangeIndex *= this.virtualListCol;
        virtualBottomRangeIndex = Math.min(this.realTotalData.length, virtualBottomRangeIndex);
        this.virtualBottomRangeIndex = virtualBottomRangeIndex;
        this.virtualPlaceholderBottomHeight = (this.realTotalData.length - virtualBottomRangeIndex) * this.virtualCellHeight / this.virtualListCol;
        this._updateVirtualList();
      },
      // 更新virtualList
      _updateVirtualList() {
        const shouldUpdateList = this.updateVirtualListFromDataChange || (this.lastVirtualTopRangeIndex !== this.virtualTopRangeIndex || this.lastVirtualBottomRangeIndex !== this.virtualBottomRangeIndex);
        if (shouldUpdateList) {
          this.updateVirtualListFromDataChange = false;
          this.lastVirtualTopRangeIndex = this.virtualTopRangeIndex;
          this.lastVirtualBottomRangeIndex = this.virtualBottomRangeIndex;
          this.virtualList = this.realTotalData.slice(this.virtualTopRangeIndex, this.virtualBottomRangeIndex + 1);
        }
      },
      // 重置动态cell模式下的高度缓存数据、虚拟列表和滚动状态
      _resetDynamicListState(resetVirtualList = false) {
        this.virtualHeightCacheList = [];
        if (resetVirtualList) {
          this.virtualList = [];
        }
        this.virtualTopRangeIndex = 0;
        this.virtualPlaceholderTopHeight = 0;
      },
      // 重置topRangeIndex和placeholderTopHeight
      _resetTopRange() {
        this.virtualTopRangeIndex = 0;
        this.virtualPlaceholderTopHeight = 0;
        this._updateVirtualList();
      },
      // 检测虚拟列表当前滚动位置，如发现滚动位置不正确则重新计算虚拟列表相关参数(为解决在App中可能出现的长时间进入后台后打开App白屏的问题)
      _checkVirtualListScroll() {
        if (this.finalUseVirtualList) {
          this.$nextTick(() => {
            this._getNodeClientRect(".zp-paging-touch-view").then((node) => {
              const currentTop = node ? node[0].top : 0;
              if (!node || currentTop === this.pagingOrgTop && this.virtualPlaceholderTopHeight !== 0) {
                this._updateVirtualScroll(0);
              }
            });
          });
        }
      },
      // 处理使用内置列表时点击了cell事件
      _innerCellClick(item, index2) {
        this.$emit("innerCellClick", item, index2);
      }
    }
  };
  const systemInfo = uni.getSystemInfoSync();
  const _sfc_main$d = {
    name: "z-paging",
    components: {
      zPagingRefresh,
      zPagingLoadMore,
      zPagingEmptyView: __easycom_0$1
    },
    mixins: [
      commonLayoutModule,
      dataHandleModule,
      i18nModule,
      nvueModule,
      emptyModule,
      refresherModule,
      loadMoreModule,
      loadingModule,
      chatRecordModerModule,
      scrollerModule,
      backToTopModule,
      virtualListModule
    ],
    data() {
      return {
        // --------------静态资源---------------
        base64Arrow: zStatic.base64Arrow,
        base64Flower: zStatic.base64Flower,
        base64BackToTop: zStatic.base64BackToTop,
        // -------------全局数据相关--------------
        // 当前加载类型
        loadingType: Enum.LoadingType.Refresher,
        requestTimeStamp: 0,
        wxsPropType: "",
        renderPropScrollTop: -1,
        checkScrolledToBottomTimeOut: null,
        cacheTopHeight: -1,
        statusBarHeight: systemInfo.statusBarHeight,
        // --------------状态&判断---------------
        insideOfPaging: -1,
        isLoadFailed: false,
        isIos: systemInfo.platform === "ios",
        disabledBounce: false,
        fromCompleteEmit: false,
        disabledCompleteEmit: false,
        pageLaunched: false,
        active: false,
        // ---------------wxs相关---------------
        wxsIsScrollTopInTopRange: true,
        wxsScrollTop: 0,
        wxsPageScrollTop: 0,
        wxsOnPullingDown: false
      };
    },
    props: {
      // 调用complete后延迟处理的时间，单位为毫秒，默认0毫秒，优先级高于minDelay
      delay: {
        type: [Number, String],
        default: u$1.gc("delay", 0)
      },
      // 触发@query后最小延迟处理的时间，单位为毫秒，默认0毫秒，优先级低于delay（假设设置为300毫秒，若分页请求时间小于300毫秒，则在调用complete后延迟[300毫秒-请求时长]；若请求时长大于300毫秒，则不延迟），当show-refresher-when-reload为true或reload(true)时，其最小值为400
      minDelay: {
        type: [Number, String],
        default: u$1.gc("minDelay", 0)
      },
      // 设置z-paging的style，部分平台(如微信小程序)无法直接修改组件的style，可使用此属性代替
      pagingStyle: {
        type: Object,
        default: u$1.gc("pagingStyle", {})
      },
      // z-paging的高度，优先级低于pagingStyle中设置的height；传字符串，如100px、100rpx、100%
      height: {
        type: String,
        default: u$1.gc("height", "")
      },
      // z-paging的宽度，优先级低于pagingStyle中设置的width；传字符串，如100px、100rpx、100%
      width: {
        type: String,
        default: u$1.gc("width", "")
      },
      // z-paging的最大宽度，优先级低于pagingStyle中设置的max-width；传字符串，如100px、100rpx、100%。默认为空，也就是铺满窗口宽度，若设置了特定值则会自动添加margin: 0 auto
      maxWidth: {
        type: String,
        default: u$1.gc("maxWidth", "")
      },
      // z-paging的背景色，优先级低于pagingStyle中设置的background。传字符串，如"#ffffff"
      bgColor: {
        type: String,
        default: u$1.gc("bgColor", "")
      },
      // 设置z-paging的容器(插槽的父view)的style
      pagingContentStyle: {
        type: Object,
        default: u$1.gc("pagingContentStyle", {})
      },
      // z-paging是否自动高度，若自动高度则会自动铺满屏幕
      autoHeight: {
        type: Boolean,
        default: u$1.gc("autoHeight", false)
      },
      // z-paging是否自动高度时，附加的高度，注意添加单位px或rpx，若需要减少高度，则传负数
      autoHeightAddition: {
        type: [Number, String],
        default: u$1.gc("autoHeightAddition", "0px")
      },
      // loading(下拉刷新、上拉加载更多)的主题样式，支持black，white，默认black
      defaultThemeStyle: {
        type: String,
        default: u$1.gc("defaultThemeStyle", "black")
      },
      // z-paging是否使用fixed布局，若使用fixed布局，则z-paging的父view无需固定高度，z-paging高度默认为100%，默认为是(当使用内置scroll-view滚动时有效)
      fixed: {
        type: Boolean,
        default: u$1.gc("fixed", true)
      },
      // 是否开启底部安全区域适配
      safeAreaInsetBottom: {
        type: Boolean,
        default: u$1.gc("safeAreaInsetBottom", false)
      },
      // 开启底部安全区域适配后，是否使用placeholder形式实现，默认为否。为否时滚动区域会自动避开底部安全区域，也就是所有滚动内容都不会挡住底部安全区域，若设置为是，则滚动时滚动内容会挡住底部安全区域，但是当滚动到底部时才会避开底部安全区域
      useSafeAreaPlaceholder: {
        type: Boolean,
        default: u$1.gc("useSafeAreaPlaceholder", false)
      },
      // z-paging bottom的背景色，默认透明，传字符串，如"#ffffff"
      bottomBgColor: {
        type: String,
        default: u$1.gc("bottomBgColor", "")
      },
      // slot="top"的view的z-index，默认为99，仅使用页面滚动时有效
      topZIndex: {
        type: Number,
        default: u$1.gc("topZIndex", 99)
      },
      // z-paging内容容器父view的z-index，默认为1
      superContentZIndex: {
        type: Number,
        default: u$1.gc("superContentZIndex", 1)
      },
      // z-paging内容容器部分的z-index，默认为1
      contentZIndex: {
        type: Number,
        default: u$1.gc("contentZIndex", 1)
      },
      // z-paging二楼的z-index，默认为100
      f2ZIndex: {
        type: Number,
        default: u$1.gc("f2ZIndex", 100)
      },
      // 使用页面滚动时，是否在不满屏时自动填充满屏幕，默认为是
      autoFullHeight: {
        type: Boolean,
        default: u$1.gc("autoFullHeight", true)
      },
      // 是否监听列表触摸方向改变，默认为否
      watchTouchDirectionChange: {
        type: Boolean,
        default: u$1.gc("watchTouchDirectionChange", false)
      },
      // z-paging中布局的单位，默认为rpx
      unit: {
        type: String,
        default: u$1.gc("unit", "rpx")
      }
    },
    created() {
      if (this.createdReload && !this.refresherOnly && this.auto) {
        this._startLoading();
        this.$nextTick(this._preReload);
      }
    },
    mounted() {
      this.active = true;
      this.wxsPropType = u$1.getTime().toString();
      this.renderJsIgnore;
      if (!this.createdReload && !this.refresherOnly && this.auto) {
        u$1.delay(() => this.$nextTick(this._preReload), 0);
      }
      this.finalUseCache && this._setListByLocalCache();
      this.$nextTick(() => {
        this.systemInfo = uni.getSystemInfoSync();
        !this.usePageScroll && this.autoHeight && this._setAutoHeight();
        this.loaded = true;
        u$1.delay(() => {
          this.updateFixedLayout();
          this._updateCachedSuperContentHeight();
        });
      });
      this.updatePageScrollTopHeight();
      this.updatePageScrollBottomHeight();
      this.updateLeftAndRightWidth();
      if (this.finalRefresherEnabled && this.useCustomRefresher) {
        this.$nextTick(() => {
          this.isTouchmoving = true;
        });
      }
      this._onEmit();
      this.finalUseVirtualList && this._virtualListInit();
    },
    destroyed() {
      this._handleUnmounted();
    },
    unmounted() {
      this._handleUnmounted();
    },
    watch: {
      defaultThemeStyle: {
        handler(newVal) {
          if (newVal.length) {
            this.finalRefresherDefaultStyle = newVal;
          }
        },
        immediate: true
      },
      autoHeight(newVal) {
        this.loaded && !this.usePageScroll && this._setAutoHeight(newVal);
      },
      autoHeightAddition(newVal) {
        this.loaded && !this.usePageScroll && this.autoHeight && this._setAutoHeight(newVal);
      }
    },
    computed: {
      // 当前z-paging的内置样式
      finalPagingStyle() {
        const pagingStyle = { ...this.pagingStyle };
        if (!this.systemInfo)
          return pagingStyle;
        const { windowTop, windowBottom } = this;
        if (!this.usePageScroll && this.fixed) {
          if (windowTop && !pagingStyle.top) {
            pagingStyle.top = windowTop + "px";
          }
          if (windowBottom && !pagingStyle.bottom) {
            pagingStyle.bottom = windowBottom + "px";
          }
        }
        if (this.bgColor.length && !pagingStyle["background"]) {
          pagingStyle["background"] = this.bgColor;
        }
        if (this.height.length && !pagingStyle["height"]) {
          pagingStyle["height"] = this.height;
        }
        if (this.width.length && !pagingStyle["width"]) {
          pagingStyle["width"] = this.width;
        }
        if (this.maxWidth.length && !pagingStyle["max-width"]) {
          pagingStyle["max-width"] = this.maxWidth;
          pagingStyle["margin"] = "0 auto";
        }
        return pagingStyle;
      },
      // 当前z-paging内容的样式
      finalPagingContentStyle() {
        if (this.contentZIndex != 1) {
          this.pagingContentStyle["z-index"] = this.contentZIndex;
          this.pagingContentStyle["position"] = "relative";
        }
        return this.pagingContentStyle;
      },
      renderJsIgnore() {
        if (this.usePageScroll && this.useChatRecordMode || !this.refresherEnabled && this.scrollable || !this.useCustomRefresher) {
          this.$nextTick(() => {
            this.renderPropScrollTop = 10;
          });
        }
        return 0;
      },
      windowHeight() {
        if (!this.systemInfo)
          return 0;
        return this.systemInfo.windowHeight || 0;
      },
      windowBottom() {
        if (!this.systemInfo)
          return 0;
        let windowBottom = this.systemInfo.windowBottom || 0;
        if (this.safeAreaInsetBottom && !this.useSafeAreaPlaceholder && !this.useChatRecordMode) {
          windowBottom += this.safeAreaBottom;
        }
        return windowBottom;
      },
      isIosAndH5() {
        return false;
      }
    },
    methods: {
      // 当前版本号
      getVersion() {
        return `z-paging v${c$1.version}`;
      },
      // 设置nvue List的specialEffects
      setSpecialEffects(args) {
        this.setListSpecialEffects(args);
      },
      // 与setSpecialEffects等效，兼容旧版本
      setListSpecialEffects(args) {
        this.nFixFreezing = args && Object.keys(args).length;
        if (this.isIos) {
          this.privateRefresherEnabled = 0;
        }
        !this.usePageScroll && this.$refs["zp-n-list"].setSpecialEffects(args);
      },
      // 当app长时间进入后台后进入前台，因系统内存管理导致app重新加载时，进行一些适配处理
      _handlePageLaunch() {
        if (this.pageLaunched) {
          this.refresherThresholdUpdateTag = 1;
          this.$nextTick(() => {
            this.refresherThresholdUpdateTag = 0;
          });
          this._checkVirtualListScroll();
        }
        this.pageLaunched = true;
      },
      // 使手机发生较短时间的振动（15ms）
      _doVibrateShort() {
        if (this.isIos) {
          const UISelectionFeedbackGenerator = plus.ios.importClass("UISelectionFeedbackGenerator");
          const feedbackGenerator = new UISelectionFeedbackGenerator();
          feedbackGenerator.init();
          setTimeout(() => {
            feedbackGenerator.selectionChanged();
          }, 0);
        } else {
          plus.device.vibrate(15);
        }
      },
      // 设置z-paging高度
      async _setAutoHeight(shouldFullHeight = true, scrollViewNode = null) {
        let heightKey = "min-height";
        heightKey = "min-height";
        try {
          if (shouldFullHeight) {
            let finalScrollViewNode = scrollViewNode || await this._getNodeClientRect(".zp-scroll-view");
            let finalScrollBottomNode = await this._getNodeClientRect(".zp-page-bottom");
            if (finalScrollViewNode) {
              const scrollViewTop = finalScrollViewNode[0].top;
              let scrollViewHeight = this.windowHeight - scrollViewTop;
              scrollViewHeight -= finalScrollBottomNode ? finalScrollBottomNode[0].height : 0;
              const additionHeight = u$1.convertToPx(this.autoHeightAddition);
              const finalHeight = scrollViewHeight + additionHeight - (this.insideMore ? 1 : 0) + "px !important";
              this.$set(this.scrollViewStyle, heightKey, finalHeight);
              this.$set(this.scrollViewInStyle, heightKey, finalHeight);
            }
          } else {
            this.$delete(this.scrollViewStyle, heightKey);
            this.$delete(this.scrollViewInStyle, heightKey);
          }
        } catch (e2) {
        }
      },
      // 组件销毁后续处理
      _handleUnmounted() {
        this.active = false;
        this._offEmit();
        this.useChatRecordMode && uni.offKeyboardHeightChange(this._handleKeyboardHeightChange);
      },
      // 触发更新是否超出页面状态
      _updateInsideOfPaging() {
        this.insideMore && this.insideOfPaging === true && setTimeout(this.doLoadMore, 200);
      },
      // 清除timeout
      _cleanTimeout(timeout2) {
        if (timeout2) {
          clearTimeout(timeout2);
          timeout2 = null;
        }
        return timeout2;
      },
      // 添加全局emit监听
      _onEmit() {
        uni.$on(c$1.errorUpdateKey, (errorMsg) => {
          if (this.loading) {
            if (!!errorMsg) {
              this.customerEmptyViewErrorText = errorMsg;
            }
            this.complete(false).catch(() => {
            });
          }
        });
        uni.$on(c$1.completeUpdateKey, (data) => {
          setTimeout(() => {
            if (this.loading) {
              if (!this.disabledCompleteEmit) {
                const type = data.type || "normal";
                const list = data.list || data;
                const rule = data.rule;
                this.fromCompleteEmit = true;
                switch (type) {
                  case "normal":
                    this.complete(list);
                    break;
                  case "total":
                    this.completeByTotal(list, rule);
                    break;
                  case "nomore":
                    this.completeByNoMore(list, rule);
                    break;
                  case "key":
                    this.completeByKey(list, rule);
                    break;
                }
              } else {
                this.disabledCompleteEmit = false;
              }
            }
          }, 1);
        });
      },
      // 销毁全局emit和listener监听
      _offEmit() {
        uni.$off(c$1.errorUpdateKey);
        uni.$off(c$1.completeUpdateKey);
      }
    }
  };
  const block0 = (Comp) => {
    (Comp.$wxs || (Comp.$wxs = [])).push("pagingWxs");
    (Comp.$wxsModules || (Comp.$wxsModules = {}))["pagingWxs"] = "1bc91ffb";
  };
  const block1 = (Comp) => {
    (Comp.$renderjs || (Comp.$renderjs = [])).push("pagingRenderjs");
    (Comp.$renderjsModules || (Comp.$renderjsModules = {}))["pagingRenderjs"] = "e35e5c7c";
  };
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_z_paging_refresh = vue.resolveComponent("z-paging-refresh");
    const _component_z_paging_load_more = vue.resolveComponent("z-paging-load-more");
    const _component_z_paging_empty_view = resolveEasycom(vue.resolveDynamicComponent("z-paging-empty-view"), __easycom_0$1);
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass({ "z-paging-content": true, "z-paging-content-full": !_ctx.usePageScroll, "z-paging-content-fixed": !_ctx.usePageScroll && _ctx.fixed, "z-paging-content-page": _ctx.usePageScroll, "z-paging-reached-top": _ctx.renderPropScrollTop < 1, "z-paging-use-chat-record-mode": _ctx.useChatRecordMode }),
        style: vue.normalizeStyle([_ctx.finalPagingStyle])
      },
      [
        vue.createCommentVNode(" 二楼view "),
        _ctx.showF2 && _ctx.showRefresherF2 ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 0,
            onTouchmove: _cache[0] || (_cache[0] = vue.withModifiers(() => {
            }, ["stop", "prevent"])),
            class: "zp-f2-content",
            style: vue.normalizeStyle([{ "transform": _ctx.f2Transform, "transition": `transform .2s linear`, "height": _ctx.superContentHeight + "px", "z-index": _ctx.f2ZIndex }])
          },
          [
            vue.renderSlot(_ctx.$slots, "f2", {}, void 0, true)
          ],
          36
          /* STYLE, NEED_HYDRATION */
        )) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode(" 顶部固定的slot "),
        !_ctx.usePageScroll && _ctx.zSlots.top ? vue.renderSlot(_ctx.$slots, "top", { key: 1 }, void 0, true) : _ctx.usePageScroll && _ctx.zSlots.top ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 2,
            class: "zp-page-top",
            onTouchmove: _cache[1] || (_cache[1] = vue.withModifiers(() => {
            }, ["stop", "prevent"])),
            style: vue.normalizeStyle([{ "top": `${_ctx.windowTop}px`, "z-index": _ctx.topZIndex }])
          },
          [
            vue.renderSlot(_ctx.$slots, "top", {}, void 0, true)
          ],
          36
          /* STYLE, NEED_HYDRATION */
        )) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass({ "zp-view-super": true, "zp-scroll-view-super": !_ctx.usePageScroll }),
            style: vue.normalizeStyle([_ctx.finalScrollViewStyle])
          },
          [
            _ctx.zSlots.left ? (vue.openBlock(), vue.createElementBlock(
              "view",
              {
                key: 0,
                class: vue.normalizeClass({ "zp-page-left": true, "zp-absoulte": _ctx.finalIsOldWebView })
              },
              [
                vue.renderSlot(_ctx.$slots, "left", {}, void 0, true)
              ],
              2
              /* CLASS */
            )) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "view",
              {
                class: vue.normalizeClass({ "zp-scroll-view-container": true, "zp-absoulte": _ctx.finalIsOldWebView }),
                style: vue.normalizeStyle([_ctx.scrollViewContainerStyle])
              },
              [
                vue.createElementVNode("scroll-view", {
                  ref: "zp-scroll-view",
                  class: vue.normalizeClass({ "zp-scroll-view": true, "zp-scroll-view-absolute": !_ctx.usePageScroll, "zp-scroll-view-hide-scrollbar": !_ctx.showScrollbar }),
                  style: vue.normalizeStyle([_ctx.chatRecordRotateStyle]),
                  "scroll-top": _ctx.scrollTop,
                  "scroll-x": _ctx.scrollX,
                  "scroll-y": _ctx.finalScrollable,
                  "enable-back-to-top": _ctx.finalEnableBackToTop,
                  "show-scrollbar": _ctx.showScrollbar,
                  "scroll-with-animation": _ctx.finalScrollWithAnimation,
                  "scroll-into-view": _ctx.scrollIntoView,
                  "lower-threshold": _ctx.finalLowerThreshold,
                  "upper-threshold": 5,
                  "refresher-enabled": _ctx.finalRefresherEnabled && !_ctx.useCustomRefresher,
                  "refresher-threshold": _ctx.finalRefresherThreshold,
                  "refresher-default-style": _ctx.finalRefresherDefaultStyle,
                  "refresher-background": _ctx.refresherBackground,
                  "refresher-triggered": _ctx.finalRefresherTriggered,
                  onScroll: _cache[12] || (_cache[12] = (...args) => _ctx._scroll && _ctx._scroll(...args)),
                  onScrolltolower: _cache[13] || (_cache[13] = (...args) => _ctx._onScrollToLower && _ctx._onScrollToLower(...args)),
                  onScrolltoupper: _cache[14] || (_cache[14] = (...args) => _ctx._onScrollToUpper && _ctx._onScrollToUpper(...args)),
                  onRefresherrestore: _cache[15] || (_cache[15] = (...args) => _ctx._onRestore && _ctx._onRestore(...args)),
                  onRefresherrefresh: _cache[16] || (_cache[16] = ($event) => _ctx._onRefresh(true))
                }, [
                  vue.createElementVNode(
                    "view",
                    {
                      class: "zp-paging-touch-view",
                      onTouchstart: _cache[4] || (_cache[4] = (...args) => _ctx.pagingWxs.touchstart && _ctx.pagingWxs.touchstart(...args)),
                      onTouchmove: _cache[5] || (_cache[5] = (...args) => _ctx.pagingWxs.touchmove && _ctx.pagingWxs.touchmove(...args)),
                      onTouchend: _cache[6] || (_cache[6] = (...args) => _ctx.pagingWxs.touchend && _ctx.pagingWxs.touchend(...args)),
                      onTouchcancel: _cache[7] || (_cache[7] = (...args) => _ctx.pagingWxs.touchend && _ctx.pagingWxs.touchend(...args)),
                      onMousedown: _cache[8] || (_cache[8] = (...args) => _ctx.pagingWxs.mousedown && _ctx.pagingWxs.mousedown(...args)),
                      onMousemove: _cache[9] || (_cache[9] = (...args) => _ctx.pagingWxs.mousemove && _ctx.pagingWxs.mousemove(...args)),
                      onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.pagingWxs.mouseup && _ctx.pagingWxs.mouseup(...args)),
                      onMouseleave: _cache[11] || (_cache[11] = (...args) => _ctx.pagingWxs.mouseleave && _ctx.pagingWxs.mouseleave(...args))
                    },
                    [
                      _ctx.finalRefresherFixedBacHeight > 0 ? (vue.openBlock(), vue.createElementBlock(
                        "view",
                        {
                          key: 0,
                          class: "zp-fixed-bac-view",
                          style: vue.normalizeStyle([{ "background": _ctx.refresherFixedBackground, "height": `${_ctx.finalRefresherFixedBacHeight}px` }])
                        },
                        null,
                        4
                        /* STYLE */
                      )) : vue.createCommentVNode("v-if", true),
                      vue.createElementVNode("view", {
                        class: "zp-paging-main",
                        style: vue.normalizeStyle([_ctx.scrollViewInStyle, { "transform": _ctx.finalRefresherTransform, "transition": _ctx.refresherTransition }]),
                        "change:prop": _ctx.pagingWxs.propObserver,
                        prop: vue.wp(_ctx.wxsPropType),
                        "data-refresherThreshold": _ctx.finalRefresherThreshold,
                        "data-refresherF2Enabled": _ctx.refresherF2Enabled,
                        "data-refresherF2Threshold": _ctx.finalRefresherF2Threshold,
                        "data-isIos": _ctx.isIos,
                        "data-loading": _ctx.loading || _ctx.isRefresherInComplete,
                        "data-useChatRecordMode": _ctx.useChatRecordMode,
                        "data-refresherEnabled": _ctx.refresherEnabled,
                        "data-useCustomRefresher": _ctx.useCustomRefresher,
                        "data-pageScrollTop": _ctx.wxsPageScrollTop,
                        "data-scrollTop": _ctx.wxsScrollTop,
                        "data-refresherMaxAngle": _ctx.refresherMaxAngle,
                        "data-refresherNoTransform": _ctx.refresherNoTransform,
                        "data-refresherAecc": _ctx.refresherAngleEnableChangeContinued,
                        "data-usePageScroll": _ctx.usePageScroll,
                        "data-watchTouchDirectionChange": _ctx.watchTouchDirectionChange,
                        "data-oldIsTouchmoving": _ctx.isTouchmoving,
                        "data-refresherOutRate": _ctx.finalRefresherOutRate,
                        "data-refresherPullRate": _ctx.finalRefresherPullRate,
                        "data-hasTouchmove": _ctx.hasTouchmove,
                        "change:renderPropIsIosAndH5": _ctx.pagingRenderjs.renderPropIsIosAndH5Change,
                        renderPropIsIosAndH5: vue.wp(_ctx.isIosAndH5)
                      }, [
                        _ctx.showRefresher ? (vue.openBlock(), vue.createElementBlock(
                          "view",
                          {
                            key: 0,
                            class: "zp-custom-refresher-view",
                            style: vue.normalizeStyle([{ "margin-top": `-${_ctx.finalRefresherThreshold + _ctx.refresherThresholdUpdateTag}px`, "background": _ctx.refresherBackground, "opacity": _ctx.isTouchmoving ? 1 : 0 }])
                          },
                          [
                            vue.createElementVNode(
                              "view",
                              {
                                class: "zp-custom-refresher-container",
                                style: vue.normalizeStyle([{ "height": `${_ctx.finalRefresherThreshold}px`, "background": _ctx.refresherBackground }])
                              },
                              [
                                _ctx.useRefresherStatusBarPlaceholder ? (vue.openBlock(), vue.createElementBlock(
                                  "view",
                                  {
                                    key: 0,
                                    class: "zp-custom-refresher-status-bar-placeholder",
                                    style: vue.normalizeStyle([{ "height": `${_ctx.statusBarHeight}px` }])
                                  },
                                  null,
                                  4
                                  /* STYLE */
                                )) : vue.createCommentVNode("v-if", true),
                                vue.createCommentVNode(" 下拉刷新view "),
                                vue.createElementVNode("view", { class: "zp-custom-refresher-slot-view" }, [
                                  !(_ctx.zSlots.refresherComplete && _ctx.refresherStatus === _ctx.R.Complete) && !(_ctx.zSlots.refresherF2 && _ctx.refresherStatus === _ctx.R.GoF2) ? vue.renderSlot(_ctx.$slots, "refresher", {
                                    key: 0,
                                    refresherStatus: _ctx.refresherStatus
                                  }, void 0, true) : vue.createCommentVNode("v-if", true)
                                ]),
                                _ctx.zSlots.refresherComplete && _ctx.refresherStatus === _ctx.R.Complete ? vue.renderSlot(_ctx.$slots, "refresherComplete", { key: 1 }, void 0, true) : _ctx.zSlots.refresherF2 && _ctx.refresherStatus === _ctx.R.GoF2 ? vue.renderSlot(_ctx.$slots, "refresherF2", { key: 2 }, void 0, true) : !_ctx.showCustomRefresher ? (vue.openBlock(), vue.createBlock(_component_z_paging_refresh, {
                                  key: 3,
                                  ref: "refresh",
                                  class: "zp-custom-refresher-refresh",
                                  style: vue.normalizeStyle([{ "height": `${_ctx.finalRefresherThreshold - _ctx.finalRefresherThresholdPlaceholder}px` }]),
                                  status: _ctx.refresherStatus,
                                  defaultThemeStyle: _ctx.finalRefresherThemeStyle,
                                  defaultText: _ctx.finalRefresherDefaultText,
                                  pullingText: _ctx.finalRefresherPullingText,
                                  refreshingText: _ctx.finalRefresherRefreshingText,
                                  completeText: _ctx.finalRefresherCompleteText,
                                  goF2Text: _ctx.finalRefresherGoF2Text,
                                  defaultImg: _ctx.refresherDefaultImg,
                                  pullingImg: _ctx.refresherPullingImg,
                                  refreshingImg: _ctx.refresherRefreshingImg,
                                  completeImg: _ctx.refresherCompleteImg,
                                  refreshingAnimated: _ctx.refresherRefreshingAnimated,
                                  showUpdateTime: _ctx.showRefresherUpdateTime,
                                  updateTimeKey: _ctx.refresherUpdateTimeKey,
                                  updateTimeTextMap: _ctx.finalRefresherUpdateTimeTextMap,
                                  imgStyle: _ctx.refresherImgStyle,
                                  titleStyle: _ctx.refresherTitleStyle,
                                  updateTimeStyle: _ctx.refresherUpdateTimeStyle,
                                  unit: _ctx.unit
                                }, null, 8, ["style", "status", "defaultThemeStyle", "defaultText", "pullingText", "refreshingText", "completeText", "goF2Text", "defaultImg", "pullingImg", "refreshingImg", "completeImg", "refreshingAnimated", "showUpdateTime", "updateTimeKey", "updateTimeTextMap", "imgStyle", "titleStyle", "updateTimeStyle", "unit"])) : vue.createCommentVNode("v-if", true)
                              ],
                              4
                              /* STYLE */
                            )
                          ],
                          4
                          /* STYLE */
                        )) : vue.createCommentVNode("v-if", true),
                        vue.createElementVNode(
                          "view",
                          {
                            class: "zp-paging-container",
                            style: vue.normalizeStyle([{ justifyContent: _ctx.useChatRecordMode ? "flex-end" : "flex-start" }])
                          },
                          [
                            vue.createCommentVNode(" 全屏Loading "),
                            _ctx.showLoading && _ctx.zSlots.loading && !_ctx.loadingFullFixed ? vue.renderSlot(_ctx.$slots, "loading", { key: 0 }, void 0, true) : vue.createCommentVNode("v-if", true),
                            vue.createCommentVNode(" 主体内容 "),
                            vue.createElementVNode(
                              "view",
                              {
                                class: "zp-paging-container-content",
                                style: vue.normalizeStyle([{ transform: _ctx.virtualPlaceholderTopHeight > 0 ? `translateY(${_ctx.virtualPlaceholderTopHeight}px)` : "none" }, _ctx.finalPagingContentStyle])
                              },
                              [
                                vue.renderSlot(_ctx.$slots, "default", {}, void 0, true),
                                vue.createCommentVNode(" 内置列表&虚拟列表 "),
                                _ctx.finalUseInnerList ? (vue.openBlock(), vue.createElementBlock(
                                  vue.Fragment,
                                  { key: 0 },
                                  [
                                    vue.renderSlot(_ctx.$slots, "header", {}, void 0, true),
                                    vue.createElementVNode(
                                      "view",
                                      {
                                        class: "zp-list-container",
                                        style: vue.normalizeStyle([_ctx.innerListStyle])
                                      },
                                      [
                                        _ctx.finalUseVirtualList ? (vue.openBlock(true), vue.createElementBlock(
                                          vue.Fragment,
                                          { key: 0 },
                                          vue.renderList(_ctx.virtualList, (item, index2) => {
                                            return vue.openBlock(), vue.createElementBlock("view", {
                                              class: "zp-list-cell",
                                              style: vue.normalizeStyle([_ctx.innerCellStyle]),
                                              id: `zp-id-${item[_ctx.virtualCellIndexKey]}`,
                                              key: item["zp_unique_index"],
                                              onClick: ($event) => _ctx._innerCellClick(item, _ctx.virtualTopRangeIndex + index2)
                                            }, [
                                              _ctx.useCompatibilityMode ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, "使用兼容模式请在组件源码z-paging.vue第99行中注释这一行，并打开下面一行注释")) : (vue.openBlock(), vue.createElementBlock(
                                                vue.Fragment,
                                                { key: 1 },
                                                [
                                                  vue.createCommentVNode(' <zp-public-virtual-cell v-if="useCompatibilityMode" :extraData="extraData" :item="item" :index="virtualTopRangeIndex+index" /> '),
                                                  vue.renderSlot(_ctx.$slots, "cell", {
                                                    item,
                                                    index: _ctx.virtualTopRangeIndex + index2
                                                  }, void 0, true)
                                                ],
                                                2112
                                                /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                                              ))
                                            ], 12, ["id", "onClick"]);
                                          }),
                                          128
                                          /* KEYED_FRAGMENT */
                                        )) : (vue.openBlock(true), vue.createElementBlock(
                                          vue.Fragment,
                                          { key: 1 },
                                          vue.renderList(_ctx.realTotalData, (item, index2) => {
                                            return vue.openBlock(), vue.createElementBlock("view", {
                                              class: "zp-list-cell",
                                              key: index2,
                                              onClick: ($event) => _ctx._innerCellClick(item, index2)
                                            }, [
                                              vue.renderSlot(_ctx.$slots, "cell", {
                                                item,
                                                index: index2
                                              }, void 0, true)
                                            ], 8, ["onClick"]);
                                          }),
                                          128
                                          /* KEYED_FRAGMENT */
                                        ))
                                      ],
                                      4
                                      /* STYLE */
                                    ),
                                    vue.renderSlot(_ctx.$slots, "footer", {}, void 0, true)
                                  ],
                                  64
                                  /* STABLE_FRAGMENT */
                                )) : vue.createCommentVNode("v-if", true),
                                vue.createCommentVNode(" 聊天记录模式加载更多loading "),
                                _ctx.useChatRecordMode && _ctx.realTotalData.length >= _ctx.defaultPageSize && (_ctx.loadingStatus !== _ctx.M.NoMore || _ctx.zSlots.chatNoMore) && (_ctx.realTotalData.length || _ctx.showChatLoadingWhenReload && _ctx.showLoading) && !_ctx.isFirstPageAndNoMore ? (vue.openBlock(), vue.createElementBlock(
                                  "view",
                                  {
                                    key: 1,
                                    style: vue.normalizeStyle([_ctx.chatRecordRotateStyle])
                                  },
                                  [
                                    _ctx.loadingStatus === _ctx.M.NoMore && _ctx.zSlots.chatNoMore ? vue.renderSlot(_ctx.$slots, "chatNoMore", { key: 0 }, void 0, true) : (vue.openBlock(), vue.createElementBlock(
                                      vue.Fragment,
                                      { key: 1 },
                                      [
                                        _ctx.zSlots.chatLoading ? vue.renderSlot(_ctx.$slots, "chatLoading", {
                                          key: 0,
                                          loadingMoreStatus: _ctx.loadingStatus
                                        }, void 0, true) : (vue.openBlock(), vue.createBlock(_component_z_paging_load_more, {
                                          key: 1,
                                          onDoClick: _cache[2] || (_cache[2] = ($event) => _ctx._onLoadingMore("click")),
                                          zConfig: _ctx.zLoadMoreConfig
                                        }, null, 8, ["zConfig"]))
                                      ],
                                      64
                                      /* STABLE_FRAGMENT */
                                    ))
                                  ],
                                  4
                                  /* STYLE */
                                )) : vue.createCommentVNode("v-if", true),
                                vue.createCommentVNode(" 虚拟列表底部占位view "),
                                _ctx.useVirtualList ? (vue.openBlock(), vue.createElementBlock(
                                  "view",
                                  {
                                    key: 2,
                                    class: "zp-virtual-placeholder",
                                    style: vue.normalizeStyle([{ height: _ctx.virtualPlaceholderBottomHeight + "px" }])
                                  },
                                  null,
                                  4
                                  /* STYLE */
                                )) : vue.createCommentVNode("v-if", true),
                                vue.createCommentVNode(" 上拉加载更多view "),
                                _ctx.showLoadingMoreDefault ? vue.renderSlot(_ctx.$slots, "loadingMoreDefault", { key: 3 }, void 0, true) : _ctx.showLoadingMoreLoading ? vue.renderSlot(_ctx.$slots, "loadingMoreLoading", { key: 4 }, void 0, true) : _ctx.showLoadingMoreNoMore ? vue.renderSlot(_ctx.$slots, "loadingMoreNoMore", { key: 5 }, void 0, true) : _ctx.showLoadingMoreFail ? vue.renderSlot(_ctx.$slots, "loadingMoreFail", { key: 6 }, void 0, true) : _ctx.showLoadingMoreCustom ? (vue.openBlock(), vue.createBlock(_component_z_paging_load_more, {
                                  key: 7,
                                  onDoClick: _cache[3] || (_cache[3] = ($event) => _ctx._onLoadingMore("click")),
                                  zConfig: _ctx.zLoadMoreConfig
                                }, null, 8, ["zConfig"])) : vue.createCommentVNode("v-if", true),
                                _ctx.safeAreaInsetBottom && _ctx.useSafeAreaPlaceholder && !_ctx.useChatRecordMode ? (vue.openBlock(), vue.createElementBlock(
                                  "view",
                                  {
                                    key: 8,
                                    class: "zp-safe-area-placeholder",
                                    style: vue.normalizeStyle([{ height: _ctx.safeAreaBottom + "px" }])
                                  },
                                  null,
                                  4
                                  /* STYLE */
                                )) : vue.createCommentVNode("v-if", true)
                              ],
                              4
                              /* STYLE */
                            ),
                            vue.createCommentVNode(" 空数据图 "),
                            _ctx.showEmpty ? (vue.openBlock(), vue.createElementBlock(
                              "view",
                              {
                                key: 1,
                                class: vue.normalizeClass({ "zp-empty-view": true, "zp-empty-view-center": _ctx.emptyViewCenter }),
                                style: vue.normalizeStyle([_ctx.emptyViewSuperStyle, _ctx.chatRecordRotateStyle])
                              },
                              [
                                _ctx.zSlots.empty ? vue.renderSlot(_ctx.$slots, "empty", {
                                  key: 0,
                                  isLoadFailed: _ctx.isLoadFailed
                                }, void 0, true) : (vue.openBlock(), vue.createBlock(_component_z_paging_empty_view, {
                                  key: 1,
                                  emptyViewImg: _ctx.finalEmptyViewImg,
                                  emptyViewText: _ctx.finalEmptyViewText,
                                  showEmptyViewReload: _ctx.finalShowEmptyViewReload,
                                  emptyViewReloadText: _ctx.finalEmptyViewReloadText,
                                  isLoadFailed: _ctx.isLoadFailed,
                                  emptyViewStyle: _ctx.emptyViewStyle,
                                  emptyViewTitleStyle: _ctx.emptyViewTitleStyle,
                                  emptyViewImgStyle: _ctx.emptyViewImgStyle,
                                  emptyViewReloadStyle: _ctx.emptyViewReloadStyle,
                                  emptyViewZIndex: _ctx.emptyViewZIndex,
                                  emptyViewFixed: _ctx.emptyViewFixed,
                                  unit: _ctx.unit,
                                  onReload: _ctx._emptyViewReload,
                                  onViewClick: _ctx._emptyViewClick
                                }, null, 8, ["emptyViewImg", "emptyViewText", "showEmptyViewReload", "emptyViewReloadText", "isLoadFailed", "emptyViewStyle", "emptyViewTitleStyle", "emptyViewImgStyle", "emptyViewReloadStyle", "emptyViewZIndex", "emptyViewFixed", "unit", "onReload", "onViewClick"]))
                              ],
                              6
                              /* CLASS, STYLE */
                            )) : vue.createCommentVNode("v-if", true)
                          ],
                          4
                          /* STYLE */
                        )
                      ], 12, ["change:prop", "prop", "data-refresherThreshold", "data-refresherF2Enabled", "data-refresherF2Threshold", "data-isIos", "data-loading", "data-useChatRecordMode", "data-refresherEnabled", "data-useCustomRefresher", "data-pageScrollTop", "data-scrollTop", "data-refresherMaxAngle", "data-refresherNoTransform", "data-refresherAecc", "data-usePageScroll", "data-watchTouchDirectionChange", "data-oldIsTouchmoving", "data-refresherOutRate", "data-refresherPullRate", "data-hasTouchmove", "change:renderPropIsIosAndH5", "renderPropIsIosAndH5"])
                    ],
                    32
                    /* NEED_HYDRATION */
                  )
                ], 46, ["scroll-top", "scroll-x", "scroll-y", "enable-back-to-top", "show-scrollbar", "scroll-with-animation", "scroll-into-view", "lower-threshold", "refresher-enabled", "refresher-threshold", "refresher-default-style", "refresher-background", "refresher-triggered"])
              ],
              6
              /* CLASS, STYLE */
            ),
            _ctx.zSlots.right ? (vue.openBlock(), vue.createElementBlock(
              "view",
              {
                key: 1,
                class: vue.normalizeClass({ "zp-page-right": true, "zp-absoulte zp-right": _ctx.finalIsOldWebView })
              },
              [
                vue.renderSlot(_ctx.$slots, "right", {}, void 0, true)
              ],
              2
              /* CLASS */
            )) : vue.createCommentVNode("v-if", true)
          ],
          6
          /* CLASS, STYLE */
        ),
        vue.createCommentVNode(" 底部固定的slot "),
        vue.createElementVNode(
          "view",
          {
            class: "zp-page-bottom-container",
            style: vue.normalizeStyle({ "background": _ctx.bottomBgColor })
          },
          [
            !_ctx.usePageScroll && _ctx.zSlots.bottom ? vue.renderSlot(_ctx.$slots, "bottom", { key: 0 }, void 0, true) : _ctx.usePageScroll && _ctx.zSlots.bottom ? (vue.openBlock(), vue.createElementBlock(
              "view",
              {
                key: 1,
                class: "zp-page-bottom",
                onTouchmove: _cache[17] || (_cache[17] = vue.withModifiers(() => {
                }, ["stop", "prevent"])),
                style: vue.normalizeStyle([{ "bottom": `${_ctx.windowBottom}px` }])
              },
              [
                vue.renderSlot(_ctx.$slots, "bottom", {}, void 0, true)
              ],
              36
              /* STYLE, NEED_HYDRATION */
            )) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode(" 聊天记录模式底部占位 "),
            _ctx.useChatRecordMode && _ctx.autoAdjustPositionWhenChat ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 2 },
              [
                vue.createElementVNode(
                  "view",
                  {
                    style: vue.normalizeStyle([{ height: _ctx.chatRecordModeSafeAreaBottom + "px" }])
                  },
                  null,
                  4
                  /* STYLE */
                ),
                vue.createElementVNode(
                  "view",
                  {
                    class: "zp-page-bottom-keyboard-placeholder-animate",
                    style: vue.normalizeStyle([{ height: _ctx.keyboardHeight + "px" }])
                  },
                  null,
                  4
                  /* STYLE */
                )
              ],
              64
              /* STABLE_FRAGMENT */
            )) : vue.createCommentVNode("v-if", true)
          ],
          4
          /* STYLE */
        ),
        vue.createCommentVNode(" 点击返回顶部view "),
        _ctx.showBackToTopClass ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 3,
            class: vue.normalizeClass(_ctx.finalBackToTopClass),
            style: vue.normalizeStyle([_ctx.finalBackToTopStyle]),
            onClick: _cache[18] || (_cache[18] = vue.withModifiers((...args) => _ctx._backToTopClick && _ctx._backToTopClick(...args), ["stop"]))
          },
          [
            _ctx.zSlots.backToTop ? vue.renderSlot(_ctx.$slots, "backToTop", { key: 0 }, void 0, true) : (vue.openBlock(), vue.createElementBlock("image", {
              key: 1,
              class: vue.normalizeClass(["zp-back-to-top-img", { "zp-back-to-top-img-inversion": _ctx.useChatRecordMode && !_ctx.backToTopImg.length }]),
              src: _ctx.backToTopImg.length ? _ctx.backToTopImg : _ctx.base64BackToTop
            }, null, 10, ["src"]))
          ],
          6
          /* CLASS, STYLE */
        )) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode(" 全屏Loading(铺满z-paging并固定) "),
        _ctx.showLoading && _ctx.zSlots.loading && _ctx.loadingFullFixed ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 4,
          class: "zp-loading-fixed"
        }, [
          vue.renderSlot(_ctx.$slots, "loading", {}, void 0, true)
        ])) : vue.createCommentVNode("v-if", true)
      ],
      6
      /* CLASS, STYLE */
    );
  }
  if (typeof block0 === "function")
    block0(_sfc_main$d);
  if (typeof block1 === "function")
    block1(_sfc_main$d);
  const __easycom_0 = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$c], ["__scopeId", "data-v-fb5441fe"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/z-paging/components/z-paging/z-paging.vue"]]);
  var dayjs_min = { exports: {} };
  (function(module, exports) {
    !function(t2, e2) {
      module.exports = e2();
    }(commonjsGlobal, function() {
      var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
      } }, m2 = function(t3, e3, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
      }, v2 = { s: m2, z: function(t3) {
        var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
      }, m: function t3(e3, n3) {
        if (e3.date() < n3.date())
          return -t3(n3, e3);
        var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
        return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g2 = "en", D = {};
      D[g2] = M;
      var p2 = "$isDayjsObject", S = function(t3) {
        return t3 instanceof _ || !(!t3 || !t3[p2]);
      }, w = function t3(e3, n3, r3) {
        var i3;
        if (!e3)
          return g2;
        if ("string" == typeof e3) {
          var s3 = e3.toLowerCase();
          D[s3] && (i3 = s3), n3 && (D[s3] = n3, i3 = s3);
          var u3 = e3.split("-");
          if (!i3 && u3.length > 1)
            return t3(u3[0]);
        } else {
          var a3 = e3.name;
          D[a3] = e3, i3 = a3;
        }
        return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
      }, O = function(t3, e3) {
        if (S(t3))
          return t3.clone();
        var n3 = "object" == typeof e3 ? e3 : {};
        return n3.date = t3, n3.args = arguments, new _(n3);
      }, b2 = v2;
      b2.l = w, b2.i = S, b2.w = function(t3, e3) {
        return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
      };
      var _ = function() {
        function M2(t3) {
          this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
        }
        var m3 = M2.prototype;
        return m3.parse = function(t3) {
          this.$d = function(t4) {
            var e3 = t4.date, n3 = t4.utc;
            if (null === e3)
              return /* @__PURE__ */ new Date(NaN);
            if (b2.u(e3))
              return /* @__PURE__ */ new Date();
            if (e3 instanceof Date)
              return new Date(e3);
            if ("string" == typeof e3 && !/Z$/i.test(e3)) {
              var r3 = e3.match($);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
              }
            }
            return new Date(e3);
          }(t3), this.init();
        }, m3.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m3.$utils = function() {
          return b2;
        }, m3.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m3.isSame = function(t3, e3) {
          var n3 = O(t3);
          return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
        }, m3.isAfter = function(t3, e3) {
          return O(t3) < this.startOf(e3);
        }, m3.isBefore = function(t3, e3) {
          return this.endOf(e3) < O(t3);
        }, m3.$g = function(t3, e3, n3) {
          return b2.u(t3) ? this[e3] : this.set(n3, t3);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t3, e3) {
          var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
            var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
            return r3 ? i3 : i3.endOf(a2);
          }, $2 = function(t4, e4) {
            return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
          }, y2 = this.$W, M3 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
          switch (f3) {
            case h2:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c2:
              return r3 ? l3(1, M3) : l3(0, M3 + 1);
            case o2:
              var g3 = this.$locale().weekStart || 0, D2 = (y2 < g3 ? y2 + 7 : y2) - g3;
              return l3(r3 ? m4 - D2 : m4 + (6 - D2), M3);
            case a2:
            case d2:
              return $2(v3 + "Hours", 0);
            case u2:
              return $2(v3 + "Minutes", 1);
            case s2:
              return $2(v3 + "Seconds", 2);
            case i2:
              return $2(v3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m3.$set = function(t3, e3) {
          var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
          if (o3 === c2 || o3 === h2) {
            var y2 = this.clone().set(d2, 1);
            y2.$d[l3]($2), y2.init(), this.$d = y2.set(d2, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l3 && this.$d[l3]($2);
          return this.init(), this;
        }, m3.set = function(t3, e3) {
          return this.clone().$set(t3, e3);
        }, m3.get = function(t3) {
          return this[b2.p(t3)]();
        }, m3.add = function(r3, f3) {
          var d3, l3 = this;
          r3 = Number(r3);
          var $2 = b2.p(f3), y2 = function(t3) {
            var e3 = O(l3);
            return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
          };
          if ($2 === c2)
            return this.set(c2, this.$M + r3);
          if ($2 === h2)
            return this.set(h2, this.$y + r3);
          if ($2 === a2)
            return y2(1);
          if ($2 === o2)
            return y2(7);
          var M3 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M3;
          return b2.w(m4, this);
        }, m3.subtract = function(t3, e3) {
          return this.add(-1 * t3, e3);
        }, m3.format = function(t3) {
          var e3 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
            return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
          }, d3 = function(t4) {
            return b2.s(s3 % 12 || 12, t4, "0");
          }, $2 = f3 || function(t4, e4, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e3.$y).slice(-2);
                case "YYYY":
                  return b2.s(e3.$y, 4, "0");
                case "M":
                  return a3 + 1;
                case "MM":
                  return b2.s(a3 + 1, 2, "0");
                case "MMM":
                  return h3(n3.monthsShort, a3, c3, 3);
                case "MMMM":
                  return h3(c3, a3);
                case "D":
                  return e3.$D;
                case "DD":
                  return b2.s(e3.$D, 2, "0");
                case "d":
                  return String(e3.$W);
                case "dd":
                  return h3(n3.weekdaysMin, e3.$W, o3, 2);
                case "ddd":
                  return h3(n3.weekdaysShort, e3.$W, o3, 3);
                case "dddd":
                  return o3[e3.$W];
                case "H":
                  return String(s3);
                case "HH":
                  return b2.s(s3, 2, "0");
                case "h":
                  return d3(1);
                case "hh":
                  return d3(2);
                case "a":
                  return $2(s3, u3, true);
                case "A":
                  return $2(s3, u3, false);
                case "m":
                  return String(u3);
                case "mm":
                  return b2.s(u3, 2, "0");
                case "s":
                  return String(e3.$s);
                case "ss":
                  return b2.s(e3.$s, 2, "0");
                case "SSS":
                  return b2.s(e3.$ms, 3, "0");
                case "Z":
                  return i3;
              }
              return null;
            }(t4) || i3.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r3, d3, l3) {
          var $2, y2 = this, M3 = b2.p(d3), m4 = O(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D2 = function() {
            return b2.m(y2, m4);
          };
          switch (M3) {
            case h2:
              $2 = D2() / 12;
              break;
            case c2:
              $2 = D2();
              break;
            case f2:
              $2 = D2() / 3;
              break;
            case o2:
              $2 = (g3 - v3) / 6048e5;
              break;
            case a2:
              $2 = (g3 - v3) / 864e5;
              break;
            case u2:
              $2 = g3 / n2;
              break;
            case s2:
              $2 = g3 / e2;
              break;
            case i2:
              $2 = g3 / t2;
              break;
            default:
              $2 = g3;
          }
          return l3 ? $2 : b2.a($2);
        }, m3.daysInMonth = function() {
          return this.endOf(c2).$D;
        }, m3.$locale = function() {
          return D[this.$L];
        }, m3.locale = function(t3, e3) {
          if (!t3)
            return this.$L;
          var n3 = this.clone(), r3 = w(t3, e3, true);
          return r3 && (n3.$L = r3), n3;
        }, m3.clone = function() {
          return b2.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
        k[t3[1]] = function(e3) {
          return this.$g(e3, t3[0], t3[1]);
        };
      }), O.extend = function(t3, e3) {
        return t3.$i || (t3(e3, _, O), t3.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
        return O(1e3 * t3);
      }, O.en = D[g2], O.Ls = D, O.p = {}, O;
    });
  })(dayjs_min);
  function timeFormat$1(dateTime = null, formatStr = "yyyy-mm-dd") {
    let date2;
    if (!dateTime) {
      date2 = /* @__PURE__ */ new Date();
    } else if (/^\d{10}$/.test(dateTime == null ? void 0 : dateTime.toString().trim())) {
      date2 = new Date(dateTime * 1e3);
    } else if (typeof dateTime === "string" && /^\d+$/.test(dateTime.trim())) {
      date2 = new Date(Number(dateTime));
    } else {
      date2 = new Date(typeof dateTime === "string" ? dateTime.replace(/-/g, "/") : dateTime);
    }
    const timeSource = {
      y: date2.getFullYear().toString(),
      // 年
      m: (date2.getMonth() + 1).toString().padStart(2, "0"),
      // 月
      d: date2.getDate().toString().padStart(2, "0"),
      // 日
      h: date2.getHours().toString().padStart(2, "0"),
      // 时
      M: date2.getMinutes().toString().padStart(2, "0"),
      // 分
      s: date2.getSeconds().toString().padStart(2, "0")
      // 秒
      // 有其他格式化字符需求可以继续添加，必须转化成字符串
    };
    for (const key in timeSource) {
      const [ret] = new RegExp(`${key}+`).exec(formatStr) || [];
      if (ret) {
        const beginIndex = key === "y" && ret.length === 2 ? 2 : 0;
        formatStr = formatStr.replace(ret, timeSource[key].slice(beginIndex));
      }
    }
    return formatStr;
  }
  const _imports_1$7 = "/static/icons/search.png";
  const _imports_1$6 = "/static/icons/copy.png";
  const _sfc_main$c = {
    __name: "warehouseMen",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const copyHandle = async (data) => {
        uni.setClipboardData({
          data,
          success: function() {
            uni.showToast({
              title: "Copy Success",
              icon: "none"
            });
          }
        });
      };
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pages2 = vue.ref({
        pageNo: 1,
        pageSize: 10
      });
      const queryList = (page2) => {
        pages2.value.pageNo = page2;
        request({
          url: "/admin-api/storage/local/goods/outbound/page",
          data: pages2.value
        }).then((res) => {
          paging.value.complete(res.list);
          pages2.value.pageNo++;
        });
      };
      const allChecked = vue.ref(false);
      const childBoxChange = (e2) => {
        e2.checked = !e2.checked;
        if (e2.checked) {
          let arr = dataList.value.filter((item) => {
            return item.checked;
          });
          if (arr.length == dataList.value.length) {
            allChecked.value = true;
          } else {
            allChecked.value = false;
          }
        } else {
          allChecked.value = false;
        }
      };
      const parentChange = (e2) => {
        allChecked.value = !allChecked.value;
        dataList.value.forEach((item) => {
          item.checked = allChecked.value;
        });
      };
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { toClipboard, copyHandle, dataList, paging, pages: pages2, queryList, allChecked, childBoxChange, parentChange, changePage, goBack, topNavbar, get request() {
        return request;
      }, get useClipboard() {
        return useClipboard;
      }, get timeFormat() {
        return timeFormat$1;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_z_paging = resolveEasycom(vue.resolveDynamicComponent("z-paging"), __easycom_0);
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "出库管理",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.createElementVNode("image", {
            src: _imports_1$7,
            class: "ww24 hh24"
          })
        ])
      ]),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createVNode(_component_z_paging, {
          ref: "paging",
          modelValue: $setup.dataList,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.dataList = $event),
          onQuery: $setup.queryList,
          fixed: false,
          "use-page-scroll": true,
          "refresher-enabled": false
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "dataItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "flex col_center" }, [
                    vue.createElementVNode("view", null, [
                      vue.createElementVNode("image", {
                        src: item.checked ? "/static/icons/actChe.png" : "/static/icons/invChe.png",
                        class: "ww18 hh18",
                        onClick: ($event) => $setup.childBoxChange(item)
                      }, null, 8, ["src", "onClick"])
                    ]),
                    vue.createElementVNode("view", { class: "ml13 flex1" }, [
                      vue.createElementVNode("view", { class: "between" }, [
                        vue.createElementVNode("view", { class: "f12 colorAf flex col_center" }, [
                          vue.createTextVNode(
                            "包装编号:" + vue.toDisplayString(item.no) + " ",
                            1
                            /* TEXT */
                          ),
                          vue.createElementVNode("image", {
                            src: _imports_1$6,
                            class: "ww14 hh14 ml8",
                            onClick: ($event) => $setup.copyHandle(item.no)
                          }, null, 8, ["onClick"])
                        ]),
                        vue.createElementVNode("view", {
                          onClick: ($event) => $setup.changePage("./warehouseDeatil?id=" + item.id)
                        }, [
                          vue.createElementVNode("image", {
                            src: _imports_2$2,
                            class: "ww24 hh24"
                          })
                        ], 8, ["onClick"])
                      ]),
                      vue.createElementVNode("view", { class: "mt12 goodsBox between" }, [
                        vue.createElementVNode(
                          "view",
                          { class: "f16 text_bold" },
                          vue.toDisplayString(item.storageTypeName),
                          1
                          /* TEXT */
                        ),
                        vue.createElementVNode(
                          "view",
                          { class: "f13" },
                          "x" + vue.toDisplayString(item.num),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "mt12 flex col_center f12 colorAf" }, [
                        vue.createElementVNode(
                          "view",
                          { class: "" },
                          vue.toDisplayString($setup.timeFormat(item.time, "yyyy:mm:dd hh:MM:ss")),
                          1
                          /* TEXT */
                        ),
                        vue.createElementVNode(
                          "view",
                          { class: "ml30" },
                          " 操作者：" + vue.toDisplayString(item.creatorName),
                          1
                          /* TEXT */
                        )
                      ])
                    ])
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue"])
      ]),
      vue.createElementVNode("view", { class: "fixedBot" }, [
        vue.createElementVNode("view", { class: "pdlr12 pb10 between pt4" }, [
          vue.createElementVNode("view", { class: "flex col_center" }, [
            vue.createElementVNode("image", {
              src: $setup.allChecked ? "/static/icons/actChe.png" : "/static/icons/invChe.png",
              class: "ww18 hh18",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.parentChange($setup.allChecked))
            }, null, 8, ["src"]),
            vue.createElementVNode("span", { class: "f14 color7C pl5" }, "全选")
          ]),
          vue.createElementVNode("view", { class: "botBtn center text_white" }, "打印面单")
        ])
      ])
    ]);
  }
  const PagesGdWarehouseMen = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$b], ["__scopeId", "data-v-806aa5b3"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/warehouseMen.vue"]]);
  const _sfc_main$b = {
    __name: "warehouseDeatil",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const showPopCenter = vue.ref(false);
      const popConfirmHandle = () => {
        request({
          url: "/admin-api/storage/local/goods/outbound/cancel",
          data: {
            outboundId: deatilId.value
          },
          methods: "PUT"
        }).then((res) => {
          showPopCenter.value = false;
          uni.showToast({
            title: "取消成功",
            icon: "none"
          });
          uni.navigateTo({
            url: "/"
          });
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const deatilId = vue.ref("");
      onLoad((e2) => {
        if (e2.id) {
          deatilId.value = e2.id;
          getPageDeatil(deatilId.value);
        }
      });
      const pageData = vue.ref({
        itemList: []
      });
      const getPageDeatil = (id) => {
        request({
          url: "/admin-api/storage/local/goods/outbound/detail/" + id,
          method: "GET"
        }).then((res) => {
          pageData.value = res;
          formatAppLog("log", "at pages/gd/warehouseDeatil.vue:65", res);
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { toClipboard, showPopCenter, popConfirmHandle, deatilId, pageData, getPageDeatil, goBack, topNavbar, get request() {
        return request;
      }, get showToast() {
        return showToast;
      }, get useClipboard() {
        return useClipboard;
      }, ref: vue.ref, onMounted: vue.onMounted, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "出库详情",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createElementVNode("view", { class: "topBox pdlr12 pt21 pb16" }, [
          vue.createElementVNode("view", { class: "f14" }, "仓储类型"),
          vue.createElementVNode("view", { class: "mt19 shelfBox center flex-col" }, [
            vue.createElementVNode(
              "view",
              { class: "f20 text_bold colorBlue" },
              vue.toDisplayString($setup.pageData.storageTypeName),
              1
              /* TEXT */
            )
          ])
        ]),
        vue.createElementVNode("view", { class: "mt12 copyBox" }, [
          vue.createElementVNode(
            "view",
            { class: "pb6 f14" },
            " 商品总数 x " + vue.toDisplayString($setup.pageData.itemList.length),
            1
            /* TEXT */
          ),
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.pageData.itemList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: "mt12 between dataItem",
                key: index2
              }, [
                vue.createElementVNode("view", null, [
                  vue.createElementVNode(
                    "view",
                    { class: "f15 text_bold" },
                    vue.toDisplayString(item.categoryName),
                    1
                    /* TEXT */
                  )
                ]),
                vue.createElementVNode(
                  "view",
                  { class: "printBtn f12 center" },
                  " x" + vue.toDisplayString(item.num),
                  1
                  /* TEXT */
                )
              ]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]),
        vue.createElementVNode("view", { class: "fixedBot" }, [
          vue.createElementVNode("view", { class: "girdBtn" }, [
            vue.createElementVNode("view", { class: "botBtn center text_white confirmBtn" }, "打印面单"),
            vue.createElementVNode("view", {
              class: "botBtn cancelBtn center color7C",
              onClick: _cache[0] || (_cache[0] = ($event) => $setup.showPopCenter = true)
            }, "取消出库")
          ])
        ])
      ]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPopCenter,
        "onUpdate:show": _cache[2] || (_cache[2] = ($event) => $setup.showPopCenter = $event),
        round: "",
        style: { "width": "280px" }
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "pt30 pdlr26" }, [
            vue.createElementVNode("view", {
              class: "f15 text_center borderB pb24",
              style: { "line-height": "18px" }
            }, " 取消出库将删除此清单项，相关货品状态变更为“已收货” ")
          ]),
          vue.createElementVNode("view", { class: "pop pdlr20 pdtb16" }, [
            vue.createElementVNode("view", { class: "girdBtn" }, [
              vue.createElementVNode("view", {
                class: "botBtn cancelBtn center color7C",
                onClick: _cache[1] || (_cache[1] = ($event) => $setup.showPopCenter = false)
              }, "取消"),
              vue.createElementVNode("view", {
                class: "botBtn center text_white confirmBtn",
                onClick: $setup.popConfirmHandle
              }, "确认")
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"])
    ]);
  }
  const PagesGdWarehouseDeatil = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$a], ["__scopeId", "data-v-ddef898c"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/warehouseDeatil.vue"]]);
  const _sfc_main$a = {
    __name: "goodsMen",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const copyHandle = async (data) => {
        uni.setClipboardData({
          data,
          success: function() {
            uni.showToast({
              title: "Copy Success",
              icon: "none"
            });
          }
        });
      };
      const tabActive = vue.ref(0);
      const changeHandle = (e2) => {
        tabActive.value = e2;
        paging.value.clean();
        queryList(1);
      };
      const tabsList = vue.ref([]);
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pages2 = vue.ref({
        pageNo: 1,
        pageSize: 10,
        status: 0
        // status:tabsList.value[tabActive.value].type
      });
      const getTypeList = () => {
        request({
          url: "/admin-api/storage/local/goods/status-list"
        }).then((res) => {
          tabsList.value = res;
          queryList(1);
        });
      };
      getTypeList();
      const queryList = (page2) => {
        pages2.value.status = tabsList.value[tabActive.value].type;
        pages2.value.pageNo = page2;
        request({
          url: "/admin-api/storage/local/goods/page",
          data: pages2.value
        }).then((res) => {
          pages2.value.pageNo++;
          paging.value.complete(res.list);
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { toClipboard, copyHandle, tabActive, changeHandle, tabsList, dataList, paging, pages: pages2, getTypeList, queryList, goBack, topNavbar, get request() {
        return request;
      }, ref: vue.ref, get useClipboard() {
        return useClipboard;
      }, get timeFormat() {
        return timeFormat$1;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_z_paging = resolveEasycom(vue.resolveDynamicComponent("z-paging"), __easycom_0);
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Management",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      $setup.tabsList.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, [
        vue.createElementVNode("view", { class: "flex tabListEl" }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.tabsList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: vue.normalizeClass(["tabItem", $setup.tabActive == index2 ? "actTabItem" : ""]),
                key: index2,
                onClick: ($event) => $setup.changeHandle(index2)
              }, vue.toDisplayString(item.name), 11, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createVNode(_component_z_paging, {
          ref: "paging",
          modelValue: $setup.dataList,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.dataList = $event),
          onQuery: $setup.queryList,
          fixed: false,
          "use-page-scroll": true,
          "refresher-enabled": false,
          auto: false
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "dataItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "between" }, [
                    vue.createElementVNode("view", { class: "f12 colorAf flex col_center" }, [
                      vue.createTextVNode(
                        "订单流水号:" + vue.toDisplayString(item.orderNo) + " ",
                        1
                        /* TEXT */
                      ),
                      vue.createElementVNode("image", {
                        src: _imports_1$6,
                        class: "ww14 hh14 ml8",
                        onClick: ($event) => $setup.copyHandle(item.orderNo)
                      }, null, 8, ["onClick"])
                    ]),
                    vue.createElementVNode(
                      "view",
                      {
                        class: vue.normalizeClass(["f11 rightEl center", item.status == 1 ? "Received" : item.status == 2 ? "Warehoused" : "Outbound"])
                      },
                      vue.toDisplayString(item.statusInfo),
                      3
                      /* TEXT, CLASS */
                    )
                  ]),
                  vue.createElementVNode("view", { class: "mt12 goodsBox between" }, [
                    vue.createElementVNode(
                      "view",
                      { class: "f16 text_bold" },
                      vue.toDisplayString(item.categoryName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "f13" },
                      "x" + vue.toDisplayString(item.num),
                      1
                      /* TEXT */
                    )
                  ]),
                  vue.createElementVNode("view", { class: "mt12 between f12 colorAf" }, [
                    vue.createElementVNode(
                      "view",
                      { class: "" },
                      vue.toDisplayString($setup.timeFormat(item.time, "yyyy:mm:dd hh:MM:ss")),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "ml30" },
                      " 操作人：" + vue.toDisplayString(item.operatorName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode("view", { class: "printBtn f12 center" }, " 打印面单 ")
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue"])
      ])
    ]);
  }
  const PagesGdGoodsMen = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$9], ["__scopeId", "data-v-0481e2b6"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/goodsMen.vue"]]);
  const _sfc_main$9 = {
    __name: "goodsList",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const copyHandle = async (data) => {
        uni.setClipboardData({
          data,
          success: function() {
            uni.showToast({
              title: "Copy Success",
              icon: "none"
            });
          }
        });
      };
      const tabActive = vue.ref(0);
      const changeHandle = (e2) => {
        tabActive.value = e2;
        pages2.value.status = tabsList.value[e2].type;
        paging.value.clean();
        queryList(1);
      };
      const tabsList = vue.ref([]);
      const getType = () => {
        request({
          url: "/admin-api/storage/overseas/goods/status-list"
        }).then((res) => {
          tabsList.value = res;
        });
      };
      getType();
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pages2 = vue.ref({
        pageNo: 1,
        pageSize: 10,
        status: 0
      });
      const queryList = (page2) => {
        pages2.value.pageNo = page2;
        request({
          url: "/admin-api/storage/overseas/goods/page",
          data: pages2.value
        }).then((res) => {
          paging.value.complete(res.list);
          pages2.value.pageNo++;
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      queryList(1);
      const __returned__ = { toClipboard, copyHandle, tabActive, changeHandle, tabsList, getType, dataList, paging, pages: pages2, queryList, goBack, topNavbar, get request() {
        return request;
      }, get showToast() {
        return showToast;
      }, get useClipboard() {
        return useClipboard;
      }, get timeFormat() {
        return timeFormat$1;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_z_paging = resolveEasycom(vue.resolveDynamicComponent("z-paging"), __easycom_0);
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Management",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createCommentVNode(' <van-tabs v-model:active="tabActive" shrink swipeable title-active-color="#3178FC"\r\n			title-inactive-color="#AFAFAF" color="#3178FC" line-width="20" line-height="4" @change="changeHandle"\r\n			style="background: #fff;">\r\n			<van-tab v-for="(item,index) in tabsList" :title="item.name" :key="index">\r\n\r\n			</van-tab>\r\n		</van-tabs> '),
      $setup.tabsList.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, [
        vue.createElementVNode("view", { class: "flex tabListEl" }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.tabsList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: vue.normalizeClass(["tabItem", $setup.tabActive == index2 ? "actTabItem" : ""]),
                key: index2,
                onClick: ($event) => $setup.changeHandle(index2)
              }, vue.toDisplayString(item.name), 11, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createVNode(_component_z_paging, {
          ref: "paging",
          modelValue: $setup.dataList,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.dataList = $event),
          onQuery: $setup.queryList,
          fixed: false,
          "use-page-scroll": true,
          "refresher-enabled": false,
          auto: false
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "dataItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "between" }, [
                    vue.createElementVNode("view", { class: "f12 colorAf flex col_center" }, [
                      vue.createTextVNode(
                        "ID:" + vue.toDisplayString(item.orderNo) + " ",
                        1
                        /* TEXT */
                      ),
                      vue.createElementVNode("image", {
                        src: _imports_1$6,
                        class: "ww14 hh14 ml8",
                        onClick: ($event) => $setup.copyHandle(item.orderNo)
                      }, null, 8, ["onClick"])
                    ]),
                    vue.createElementVNode(
                      "view",
                      {
                        class: vue.normalizeClass(["f11 rightEl center", item.status == 1 ? "Received" : item.status == 2 ? "Warehoused" : "Outbound"])
                      },
                      vue.toDisplayString($setup.tabsList[item.status].name),
                      3
                      /* TEXT, CLASS */
                    )
                  ]),
                  vue.createElementVNode("view", { class: "mt12 goodsBox between" }, [
                    vue.createElementVNode(
                      "view",
                      { class: "f16 text_bold" },
                      vue.toDisplayString(item.categoryName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "f13" },
                      "x" + vue.toDisplayString(item.num),
                      1
                      /* TEXT */
                    )
                  ]),
                  item.status == 2 ? (vue.openBlock(), vue.createElementBlock(
                    "view",
                    {
                      key: 0,
                      class: "mt12"
                    },
                    vue.toDisplayString(item.shelf + "-" + item.floor),
                    1
                    /* TEXT */
                  )) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("view", { class: "mt12 flex col_center f12 colorAf" }, [
                    vue.createElementVNode(
                      "view",
                      { class: "" },
                      vue.toDisplayString($setup.timeFormat(item.time, "yyyy:mm:dd hh:MM:ss")),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "ml30" },
                      " Operator：" + vue.toDisplayString(item.operatorName),
                      1
                      /* TEXT */
                    )
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue"])
      ])
    ]);
  }
  const PagesHomeGoodsList = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$8], ["__scopeId", "data-v-6a88c941"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/goodsList.vue"]]);
  const HWHJStore = defineStore("HWHJStore", {
    // 推荐使用 完整类型推断的箭头函数
    state: () => {
      return {
        // 所有这些属性都将自动推断其类型
        LAYERSLIST: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        default_shelf: [],
        warehouseList: [],
        PICKCODE: "",
        USERGOODS: [],
        NOW_VERCODE: "",
        USERSUCCESSGOODS: []
        //用户成功收货的列表
      };
    },
    actions: {}
  });
  const _imports_0 = "/static/icons/back_white.png";
  const _imports_1$5 = "/static/icons/info.png";
  const _sfc_main$8 = {
    __name: "scanCode",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        locale,
        t: t2
      } = useI18n();
      const GDHPStoreInfo = GDHPStore();
      const HWHJStoreInfo = HWHJStore();
      const showPop = vue.ref(false);
      const cameraId = vue.ref(0);
      const list = vue.ref([]);
      const getCameras = () => {
        if (type.value == 4) {
          uni.scanCode({
            scanType: ["qrCode"],
            success(res) {
              inpVal.value = res.result;
              formatAppLog("log", "at pages/home/scanCode.vue:95", res.result);
              popComfirm();
            },
            fail(e2) {
              formatAppLog("log", "at pages/home/scanCode.vue:99", e2);
            }
          });
        } else {
          uni.scanCode({
            scanType: ["barCode", "qrCode", "datamatrix"],
            success: function(res) {
              inpVal.value = res.result;
              formatAppLog("log", "at pages/home/scanCode.vue:107", res.result);
              popComfirm();
            },
            complete() {
              formatAppLog("log", "at pages/home/scanCode.vue:111", "扫面完成");
            }
          });
        }
      };
      const type = vue.ref(0);
      onLoad((e2) => {
        if (e2.type) {
          type.value = e2.type;
          getCameras();
        }
      });
      const inpVal = vue.ref("");
      const popComfirm = () => {
        if (type.value == 1) {
          hwRecHandle("/pages/home/receiveSuccess", inpVal.value);
        } else if (type.value == 2) {
          vertifyShelf("/pages/home/warehouse", inpVal.value);
        } else if (type.value == 3) {
          hwWarehouseHandle("/pages/home/warehouse", inpVal.value);
        } else if (type.value == 4) {
          hwCollect("/pages/collect/index", inpVal.value);
        } else if (type.value == 5) {
          hwUserGet("/pages/collect/index", inpVal.value);
        } else if (type.value == 6) {
          gdShouhuo("/pages/gd/recive", inpVal.value);
        } else if (type.value == 7) {
          gdChuku("/pages/gd/warehouse", inpVal.value);
        }
        showPop.value = false;
      };
      const hwUserGet = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/pickup",
          data: {
            orderNo: val
          },
          methods: "PUT"
        }).then((res) => {
          uni.showToast({
            title: HWHJStoreInfo.$state.NOW_VERCODE + " Delivery successful",
            icon: "none"
          });
          HWHJStoreInfo.$state.USERSUCCESSGOODS.push(HWHJStoreInfo.$state.NOW_VERCODE);
          if (HWHJStoreInfo.$state.USERSUCCESSGOODS.length == HWHJStoreInfo.$state.USERGOODS.length) {
            uni.navigateTo({
              url: "../collect/collectSuccess"
            });
          } else {
            uni.navigateTo({
              url: "../collect/index"
            });
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const hwCollect = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/pickup-goods-list/" + val
        }).then((res) => {
          HWHJStoreInfo.$state.PICKCODE = val;
          HWHJStoreInfo.$state.USERGOODS = res;
          uni.navigateTo({
            url: "../collect/index"
          });
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const hwWarehouseHandle = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/get-info/" + val
        }).then((res) => {
          if (HWHJStoreInfo.$state.warehouseList.findIndexOf(res) == -1) {
            HWHJStoreInfo.$state.warehouseList.push(res);
            uni.navigateTo({
              url: url2
            });
          } else {
            uni.showToast({
              title: "Please do not scan again",
              icon: "none"
            });
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const vertifyShelf = (url2, val) => {
        let arr = val.split("-");
        request({
          url: "/admin-api/storage/overseas/goods-location/exist",
          data: {
            shelf: arr[0],
            floor: arr[1]
          }
        }).then((res) => {
          if (res) {
            HWHJStoreInfo.$state.default_shelf = arr;
            uni.navigateTo({
              url: "./warehouse"
            });
          } else {
            uni.showToast({
              title: "Container does not exist",
              icon: "none"
            });
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const gdShouhuo = (url2, val) => {
        request({
          url: "/admin-api/storage/local/goods/receive",
          data: {
            supplierLogisticsNo: val
          },
          methods: "POST"
        }).then((res) => {
          uni.showToast({
            title: "收货成功",
            icon: "none"
          });
          changePage(url2, val);
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const gdChuku = (url2, val) => {
        let storageType;
        try {
          storageType = GDHPStoreInfo.$state.outboundList[0].storageType;
        } catch (e2) {
        }
        request({
          url: "/admin-api/storage/local/goods/get-for-outbound",
          data: {
            orderNo: val,
            storageType
          }
        }).then((res) => {
          if (!GDHPStoreInfo.$state.outboundList.some((item) => item.orderNo == res.orderNo)) {
            GDHPStoreInfo.addToList(res);
          } else {
            uni.showToast({
              title: "该商品已添加",
              icon: "none"
            });
          }
          changePage(url2, inpVal.value);
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const hwRecHandle = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/receive",
          data: {
            orderNo: val
          },
          methods: "POST"
        }).then((res) => {
          GDHPStoreInfo.$state.reviceObj = res;
          changePage(url2, val);
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "error"
          });
          getCameras();
        });
      };
      const hwWareHandle = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/receive",
          data: {
            orderNo: val
          },
          methods: "POST"
        }).then((res) => {
          GDHPStoreInfo.$state.reviceObj = res;
          changePage(url2, val);
        });
      };
      const changePage = (url2, code2) => {
        uni.navigateTo({
          url: url2 + "?code=" + code2
        });
      };
      const goBack = () => {
        uni.navigateTo({
          url: "../tab/index"
        });
      };
      const __returned__ = { locale, t: t2, GDHPStoreInfo, HWHJStoreInfo, showPop, cameraId, list, getCameras, type, inpVal, popComfirm, hwUserGet, hwCollect, hwWarehouseHandle, vertifyShelf, gdShouhuo, gdChuku, hwRecHandle, hwWareHandle, changePage, goBack, get request() {
        return request;
      }, get showToast() {
        return showToast;
      }, get onLoad() {
        return onLoad;
      }, get useI18n() {
        return useI18n;
      }, ref: vue.ref, get GDHPStore() {
        return GDHPStore;
      }, get HWHJStore() {
        return HWHJStore;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10 topNav" }, [
        vue.createElementVNode("view", { onClick: $setup.goBack }, [
          vue.createElementVNode("image", {
            src: _imports_0,
            class: "ww24 hh24"
          })
        ]),
        vue.createElementVNode(
          "view",
          { class: "text_white text_bold f17" },
          vue.toDisplayString($setup.t("home.h_a1")),
          1
          /* TEXT */
        ),
        vue.createElementVNode("view", { class: "ww24" })
      ]),
      vue.createElementVNode("view", { class: "sectionview" }, [
        vue.createElementVNode("view", {
          id: "qr-reader",
          style: { "width": "100%", "height": "550px" }
        })
      ]),
      $setup.type == 1 || $setup.type == 5 ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 0,
          class: "centerWord pdlr35 f13 text_white text_center"
        },
        vue.toDisplayString($setup.t("home.h_a2")),
        1
        /* TEXT */
      )) : vue.createCommentVNode("v-if", true),
      $setup.type == 2 ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 1,
          class: "centerWord pdlr35 f13 text_white text_center"
        },
        vue.toDisplayString($setup.t("home.h_a3")),
        1
        /* TEXT */
      )) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(' v-if="type != 4" '),
      vue.createElementVNode("view", { class: "botBtn center" }, [
        vue.createElementVNode("view", {
          class: "inpEl mt24 flex col_center",
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.showPop = true)
        }, [
          vue.createElementVNode("image", {
            src: _imports_1$5,
            class: "ww24 hh24"
          }),
          vue.createElementVNode(
            "view",
            { class: "colorAf ml12" },
            vue.toDisplayString($setup.t("home.h_a4")),
            1
            /* TEXT */
          )
        ])
      ]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPop,
        "onUpdate:show": _cache[2] || (_cache[2] = ($event) => $setup.showPop = $event),
        round: "",
        style: vue.normalizeStyle({ padding: "30px 20px", width: "calc(100vw - 90px)" }),
        closeable: true
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", null, [
            vue.createElementVNode(
              "view",
              { class: "text_bold text_center f17" },
              vue.toDisplayString($setup.t("home.h_a5")),
              1
              /* TEXT */
            ),
            vue.createElementVNode(
              "view",
              {
                class: "mt16 f11 colorAf text_center",
                style: { "line-height": "13px" }
              },
              vue.toDisplayString($setup.type != 2 ? $setup.t("home.h_a6") : $setup.t("home.h_a7")),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", {
              class: "inpEl mt30 flex col_center",
              style: { "width": "calc(100% - 20px)", "background": "#F1F1F3" }
            }, [
              vue.createElementVNode("image", {
                src: _imports_1$5,
                class: "ww24 hh24"
              }),
              vue.withDirectives(vue.createElementVNode("input", {
                type: "text",
                class: "ml8",
                placeholder: $setup.t("home.h_a4"),
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.inpVal = $event)
              }, null, 8, ["placeholder"]), [
                [vue.vModelText, $setup.inpVal]
              ])
            ]),
            vue.createElementVNode(
              "view",
              {
                class: "btns f14 text_white",
                onClick: $setup.popComfirm
              },
              vue.toDisplayString($setup.t("setting.s_s6")),
              1
              /* TEXT */
            )
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show", "style"])
    ]);
  }
  const PagesHomeScanCode = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$7], ["__scopeId", "data-v-dbed8a33"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/scanCode.vue"]]);
  const _imports_1$4 = "/static/icons/smallScan.png";
  const _sfc_main$7 = {
    __name: "receiveSuccess",
    setup(__props, { expose: __expose }) {
      __expose();
      const GDHPStoreInfo = GDHPStore();
      const scanVal = vue.ref(0);
      onLoad((e2) => {
        if (e2.code) {
          scanVal.value = e2.code;
        }
      });
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const pageData = vue.computed(() => {
        return GDHPStoreInfo.$state.reviceObj;
      });
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { GDHPStoreInfo, scanVal, changePage, pageData, goBack, onMounted: vue.onMounted, topNavbar, get showToast() {
        return showToast;
      }, get GDHPStore() {
        return GDHPStore;
      }, get request() {
        return request;
      }, get onLoad() {
        return onLoad;
      }, ref: vue.ref, computed: vue.computed };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10" }, [
        vue.createElementVNode("view", { class: "ww50" }),
        vue.createElementVNode("view", { class: "text_bold f17" }, "Receiving"),
        vue.createElementVNode("view", {
          class: "color999 ww50 f14",
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("/pages/tab/index"))
        }, "Return")
      ]),
      vue.createElementVNode("view", { class: "pdlr20 mt73" }, [
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("image", {
            src: _imports_0$1,
            style: { "width": "69px", "height": "94px" }
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f20 text_bold mt20" }, " Succeeded "),
        vue.createElementVNode("view", {
          class: "colorAf pdlr35 f12 mt8 text_center",
          style: { "line-height": "18px" }
        }, " The current product has been successfully warehoused "),
        vue.createElementVNode("view", { class: "resBox" }, [
          vue.createElementVNode("view", { class: "between flex1" }, [
            vue.createElementVNode(
              "view",
              { class: "f15 text_bold" },
              vue.toDisplayString($setup.pageData.categoryName),
              1
              /* TEXT */
            ),
            vue.createElementVNode(
              "view",
              { class: "f12" },
              "x" + vue.toDisplayString($setup.pageData.num),
              1
              /* TEXT */
            )
          ])
        ]),
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("view", {
            class: "center botBtn",
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.changePage("./scanCode?type=1"))
          }, [
            vue.createElementVNode("image", {
              src: _imports_1$4,
              class: "ww24 hh24"
            }),
            vue.createElementVNode("view", { class: "f14 ml8" }, " Continue ")
          ])
        ])
      ])
    ]);
  }
  const PagesHomeReceiveSuccess = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$6], ["__scopeId", "data-v-dabd1912"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/receiveSuccess.vue"]]);
  const _imports_3$1 = "/static/icons/upload.png";
  const _sfc_main$6 = {
    __name: "warehouse",
    setup(__props, { expose: __expose }) {
      __expose();
      const HWHJStoreInfo = HWHJStore();
      const cancelHandle = () => {
        HWHJStoreInfo.$state.warehouseList = [];
        uni.navigateTo({
          url: "/pages/tab/index"
        });
      };
      const goodsList = vue.computed(() => {
        return HWHJStoreInfo.$state.warehouseList;
      });
      const shelfVal = vue.ref([1]);
      const columns = vue.ref([]);
      const showPicker = vue.ref(false);
      const confirmShelfHandle = (e2) => {
        HWHJStoreInfo.$state.default_shelf[1] = e2.selectedValues[0];
        showPicker.value = false;
      };
      const deleteHandle = (item, index2) => {
        HWHJStoreInfo.$state.warehouseList.splice(index2, 1);
      };
      const uploadGoods = () => {
        const orderNoList = goodsList.value.map((item) => {
          return item.orderNo;
        });
        request({
          url: "/admin-api/storage/overseas/goods/batch-put-on-shelf",
          data: {
            shelf: default_shelfVal.value[0],
            floor: default_shelfVal.value[1],
            orderNoList
          },
          methods: "PUT"
        }).then((res) => {
          showToast("Batch success");
          changePage("./wareSuccess");
        }).catch((e2) => {
          showToast(e2.msg);
        });
      };
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const default_shelfVal = vue.computed(() => {
        return HWHJStoreInfo.$state.default_shelf;
      });
      const layersList = vue.ref([]);
      const getClassList = () => {
        request({
          url: "/admin-api/storage/overseas/goods-location/floor-list/" + default_shelfVal.value[0]
        }).then((res) => {
          layersList.value = res.floorList.map((item) => {
            return {
              name: item,
              value: item
            };
          });
        });
      };
      getClassList();
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { HWHJStoreInfo, cancelHandle, goodsList, shelfVal, columns, showPicker, confirmShelfHandle, deleteHandle, uploadGoods, changePage, default_shelfVal, layersList, getClassList, goBack, topNavbar, get request() {
        return request;
      }, get HWHJStore() {
        return HWHJStore;
      }, get showToast() {
        return showToast;
      }, ref: vue.ref, computed: vue.computed };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_picker = vue.resolveComponent("van-picker");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Warehousing",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.createElementVNode("view", {
            class: "color999 f14",
            onClick: $setup.cancelHandle
          }, "Cancel")
        ])
      ]),
      vue.createElementVNode("view", { class: "pdlr12 pt12" }, [
        vue.createElementVNode("view", { class: "topBox pdlr12 pt21 pb16" }, [
          vue.createElementVNode("view", { class: "f16" }, [
            vue.createElementVNode("span", { class: "colorFc" }, "*"),
            vue.createTextVNode(" Shelf")
          ]),
          vue.createElementVNode("view", {
            class: "mt19 shelfBox center flex-col",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.showPicker = true)
          }, [
            vue.createElementVNode(
              "view",
              { class: "f24 text_bold" },
              "Shelf " + vue.toDisplayString($setup.default_shelfVal[0]) + "- Layer " + vue.toDisplayString($setup.default_shelfVal[1]),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", { class: "mt4 f15 color7C" }, "current shelf")
          ])
        ]),
        vue.createElementVNode("view", { class: "mt12 botBox" }, [
          vue.createElementVNode("view", { class: "between" }, [
            vue.createElementVNode("view", { class: "f16 text_bold" }, "Goods"),
            vue.createElementVNode("view", {
              class: "rightBtn flex col_center f12",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.changePage("./scanCode?type=3"))
            }, [
              vue.createElementVNode("image", {
                src: _imports_1$8,
                class: "ww24 hh24"
              }),
              vue.createTextVNode(" Scan ")
            ])
          ]),
          vue.createElementVNode("view", { class: "goodsBox" }, [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.goodsList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "between goodsItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "flex col_center" }, [
                    vue.createElementVNode(
                      "view",
                      null,
                      vue.toDisplayString(item.categoryName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "pl15" },
                      "X" + vue.toDisplayString(item.num),
                      1
                      /* TEXT */
                    )
                  ]),
                  vue.createElementVNode("image", {
                    src: _imports_2$1,
                    class: "ww24 hh24",
                    onClick: ($event) => $setup.deleteHandle(item, index2)
                  }, null, 8, ["onClick"])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ]),
        $setup.goodsList.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "btns f14 text_white center",
          onClick: $setup.uploadGoods
        }, [
          vue.createElementVNode("image", {
            src: _imports_3$1,
            class: "ww24 hh24"
          }),
          vue.createTextVNode(),
          vue.createElementVNode("view", { class: "ml8" }, "Batch Warehousing")
        ])) : vue.createCommentVNode("v-if", true)
      ]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPicker,
        "onUpdate:show": _cache[4] || (_cache[4] = ($event) => $setup.showPicker = $event),
        round: "",
        position: "bottom"
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_van_picker, {
            modelValue: $setup.shelfVal,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.shelfVal = $event),
            title: "Layers",
            columns: $setup.layersList,
            "confirm-button-text": "Confirm",
            "cancel-button-text": "Cancel",
            onConfirm: $setup.confirmShelfHandle,
            "columns-field-names": { text: "name" },
            onCancel: _cache[3] || (_cache[3] = ($event) => $setup.showPicker = false)
          }, null, 8, ["modelValue", "columns"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createElementVNode("view", { style: { "height": "50px" } })
    ]);
  }
  const PagesHomeWarehouse = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$5], ["__scopeId", "data-v-48e114f6"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/warehouse.vue"]]);
  const _imports_1$3 = "/static/icons/r_back.png";
  const _sfc_main$5 = {
    __name: "wareSuccess",
    setup(__props, { expose: __expose }) {
      __expose();
      const scanVal = vue.ref(0);
      onLoad((e2) => {
        if (e2.code) {
          scanVal.value = e2.code;
        }
      });
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const changeTabPage = (url2) => {
        uni.switchTab({
          url: url2
        });
      };
      const __returned__ = { scanVal, changePage, changeTabPage, onMounted: vue.onMounted, topNavbar, get showToast() {
        return showToast;
      }, ref: vue.ref, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10" }, [
        vue.createElementVNode("view", { class: "ww50" }),
        vue.createElementVNode("view", { class: "text_bold f17" }, "Receiving"),
        vue.createElementVNode("view", { class: "color999 f14 ww50" })
      ]),
      vue.createElementVNode("view", { class: "pdlr20 mt73" }, [
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("image", {
            src: _imports_0$1,
            style: { "width": "69px", "height": "94px" }
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f20 text_bold mt20" }, " Succeeded "),
        vue.createElementVNode("view", {
          class: "colorAf pdlr35 f12 mt8 text_center",
          style: { "line-height": "18px" }
        }, [
          vue.createTextVNode(" Warehousing on "),
          vue.createElementVNode("span", { class: "colorBlue text_bold" }, " shelf 1- layer 1"),
          vue.createTextVNode(" is successful Please place the goods at this position ")
        ]),
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("view", {
            class: "center botBtn",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("/pages/tab/index"))
          }, [
            vue.createElementVNode("image", {
              src: _imports_1$3,
              class: "ww24 hh24"
            }),
            vue.createElementVNode("view", { class: "f14 ml8" }, " Return ")
          ])
        ])
      ])
    ]);
  }
  const PagesHomeWareSuccess = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$4], ["__scopeId", "data-v-1a124ae9"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/wareSuccess.vue"]]);
  const _imports_1$2 = "/static/icons/add.png";
  const _sfc_main$4 = {
    __name: "index",
    setup(__props, { expose: __expose }) {
      __expose();
      const shelfList = vue.ref([]);
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const checkShelf = (item) => {
        uni.navigateTo({
          url: "./deatil?item=" + item
        });
      };
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pages2 = vue.ref({
        pageNo: 1,
        pageSize: 10
      });
      const queryList = (page2) => {
        pages2.value.pageNo = page2;
        request({
          url: "/admin-api/storage/overseas/goods-location/shelf-page",
          data: pages2.value
        }).then((res) => {
          paging.value.complete(res.list);
          pages2.value.pageNo++;
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { shelfList, changePage, checkShelf, dataList, paging, pages: pages2, queryList, goBack, get request() {
        return request;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_z_paging = resolveEasycom(vue.resolveDynamicComponent("z-paging"), __easycom_0);
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Shelf",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.createElementVNode("view", {
            class: "flex col_center",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("./add"))
          }, [
            vue.createElementVNode("image", {
              src: _imports_1$2,
              class: "ww24 hh24"
            }),
            vue.createTextVNode(),
            vue.createElementVNode("view", { class: "ml4 f14" }, "Compile")
          ])
        ])
      ]),
      vue.createElementVNode("view", { class: "pdlr12 pt12" }, [
        vue.createVNode(_component_z_paging, {
          ref: "paging",
          modelValue: $setup.dataList,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.dataList = $event),
          onQuery: $setup.queryList,
          fixed: false,
          "use-page-scroll": true,
          "refresher-enabled": false
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", { class: "shelfItem between" }, [
                  vue.createElementVNode(
                    "view",
                    {
                      class: vue.normalizeClass(["hasBeforeLine f16 text_bold", index2 % 3 == 0 ? "borderBlue" : index2 % 3 == 1 ? "borderGreen" : "borderOrange"])
                    },
                    " Shelf " + vue.toDisplayString(item),
                    3
                    /* TEXT, CLASS */
                  ),
                  vue.createElementVNode("view", {
                    class: "color7C f12 flex col_center",
                    onClick: ($event) => $setup.checkShelf(item)
                  }, [
                    vue.createTextVNode(" Check "),
                    vue.createElementVNode("image", {
                      src: _imports_2$2,
                      class: "ww24 hh24"
                    })
                  ], 8, ["onClick"])
                ]);
              }),
              256
              /* UNKEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue"])
      ])
    ]);
  }
  const PagesShelfIndex = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$3], ["__scopeId", "data-v-bb118f84"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/shelf/index.vue"]]);
  const _imports_1$1 = "/static/icons/b_down.png";
  const _imports_1 = "/static/icons/blue_add.png";
  const _imports_2 = "/static/icons/rt_delete.png";
  const _sfc_main$3 = {
    __name: "add",
    setup(__props, { expose: __expose }) {
      __expose();
      const HWHJStoreDeatil = HWHJStore();
      const shelfVal = vue.ref([0]);
      const layerVal = vue.ref([0]);
      const showPickerShelf = vue.ref(false);
      const confirmShelfHandle = (e2) => {
        shelfVal.value = e2.selectedValues;
        showPickerShelf.value = false;
      };
      const showPickerLayer = vue.ref(false);
      const confirmLayerHandle = (e2) => {
        if (layerList.value.length > 0) {
          layerList.value.forEach((item, index2) => {
            if (item.value == Number(e2.selectedValues[0])) {
              layerList.value.splice(index2, 1);
            }
          });
          choLayerList.value.push(e2.selectedValues[0]);
          choLayerList.value.sort((a2, b2) => a2 - b2);
          if (layerList.value.length > 0) {
            layerVal.value = [layerList.value[0].name];
          }
        }
        showPickerLayer.value = false;
      };
      const deleteItem = (item, ind) => {
        let obj = {
          name: item,
          value: item
        };
        layerList.value.push(obj);
        layerList.value.sort((a2, b2) => a2.value - b2.value);
        choLayerList.value.splice(ind, 1);
      };
      const choLayerList = vue.ref([]);
      const shelfList = vue.ref([]);
      const layerListStatic = HWHJStoreDeatil.LAYERSLIST;
      const layerList = vue.ref([]);
      const getShelfList = () => {
        request({
          url: "/admin-api/storage/overseas/goods-location/new-shelf-list/"
        }).then((res) => {
          shelfList.value = res.map((item) => {
            return {
              name: item,
              value: item
            };
          });
          layerList.value = layerListStatic.map((item) => {
            return {
              name: item,
              value: item
            };
          });
          shelfVal.value = [shelfList.value[0].name];
        });
      };
      getShelfList();
      const confirmAddHandle = () => {
        if (choLayerList.value.length == 0)
          return;
        let floorList = choLayerList.value;
        request({
          url: "/admin-api/storage/overseas/goods-location/create-shelf",
          data: {
            shelf: shelfVal.value[0],
            floorList
          },
          methods: "POST"
        }).then((res) => {
          uni.showToast({
            title: "Add success",
            icon: "none"
          });
          uni.navigateTo({
            url: "./index"
          });
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { HWHJStoreDeatil, shelfVal, layerVal, showPickerShelf, confirmShelfHandle, showPickerLayer, confirmLayerHandle, deleteItem, choLayerList, shelfList, layerListStatic, layerList, getShelfList, confirmAddHandle, goBack, get request() {
        return request;
      }, get HWHJStore() {
        return HWHJStore;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_picker = vue.resolveComponent("van-picker");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Compile",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt20 pdlr12" }, [
        vue.createElementVNode("view", { class: "between" }, [
          vue.createElementVNode("view", { class: "f16 text_bold" }, "New Shelves"),
          vue.createElementVNode("view", { class: "colorAf f12" }, "Please complete the required fields")
        ]),
        vue.createElementVNode("view", { class: "mt20 shelfBox between" }, [
          vue.createElementVNode("view", { class: "f15" }, [
            vue.createElementVNode("span", { class: "colorFc" }, "*"),
            vue.createTextVNode(" Shelf ")
          ]),
          vue.createElementVNode("view", {
            class: "flex col_center",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.showPickerShelf = true)
          }, [
            vue.createTextVNode(
              vue.toDisplayString($setup.shelfVal[0]) + " ",
              1
              /* TEXT */
            ),
            vue.createElementVNode("image", {
              src: _imports_1$1,
              class: "ww24 hh24"
            })
          ])
        ]),
        vue.createElementVNode("view", { class: "mt47" }, [
          vue.createElementVNode("view", { class: "between" }, [
            vue.createElementVNode("view", null, "Layers"),
            vue.createElementVNode("view", {
              class: "flex col_center f12",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.showPickerLayer = true)
            }, [
              vue.createElementVNode("image", {
                src: _imports_1,
                class: "ww12 hh12"
              }),
              vue.createElementVNode("view", { class: "ml6 colorBlue" }, "Add")
            ])
          ])
        ]),
        vue.createElementVNode("view", { class: "layersBox mt27" }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.choLayerList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", { class: "layersItem between" }, [
                vue.createElementVNode("view", { class: "f15" }, "Layer"),
                vue.createElementVNode("view", { class: "flex col_center" }, [
                  vue.createElementVNode(
                    "view",
                    { class: "mr5" },
                    vue.toDisplayString(item),
                    1
                    /* TEXT */
                  ),
                  vue.createElementVNode("image", {
                    src: _imports_1$1,
                    class: "ww24 hh24"
                  })
                ]),
                vue.createElementVNode("view", {
                  class: "deleteIcon",
                  onClick: vue.withModifiers(($event) => $setup.deleteItem(item, index2), ["stop"])
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_2,
                    class: "ww14 hh14"
                  })
                ], 8, ["onClick"])
              ]);
            }),
            256
            /* UNKEYED_FRAGMENT */
          ))
        ])
      ]),
      vue.createCommentVNode(" shelf "),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPickerShelf,
        "onUpdate:show": _cache[4] || (_cache[4] = ($event) => $setup.showPickerShelf = $event),
        round: "",
        position: "bottom"
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_van_picker, {
            modelValue: $setup.shelfVal,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.shelfVal = $event),
            title: "Shelf",
            columns: $setup.shelfList,
            "confirm-button-text": "Confirm",
            "cancel-button-text": "Cancel",
            onConfirm: $setup.confirmShelfHandle,
            "columns-field-names": { text: "name" },
            onCancel: _cache[3] || (_cache[3] = ($event) => $setup.showPickerShelf = false)
          }, null, 8, ["modelValue", "columns"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPickerLayer,
        "onUpdate:show": _cache[7] || (_cache[7] = ($event) => $setup.showPickerLayer = $event),
        round: "",
        position: "bottom"
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_van_picker, {
            modelValue: $setup.layerVal,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $setup.layerVal = $event),
            title: "Layers",
            columns: $setup.layerList,
            "confirm-button-text": "Confirm",
            "cancel-button-text": "Cancel",
            onConfirm: $setup.confirmLayerHandle,
            "columns-field-names": { text: "name" },
            onCancel: _cache[6] || (_cache[6] = ($event) => $setup.showPickerLayer = false)
          }, null, 8, ["modelValue", "columns"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createElementVNode("view", { class: "fixedBot" }, [
        vue.createElementVNode("view", { class: "girdBtn" }, [
          vue.createElementVNode("view", {
            class: "botBtn cancelBtn center color7C",
            onClick: $setup.goBack
          }, "Cancel"),
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["botBtn center text_white confirmBtn", $setup.choLayerList.length == 0 ? "disabledBtn" : ""]),
              onClick: $setup.confirmAddHandle
            },
            " Confirm",
            2
            /* CLASS */
          )
        ])
      ])
    ]);
  }
  const PagesShelfAdd = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2], ["__scopeId", "data-v-465b5518"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/shelf/add.vue"]]);
  const props = {
    props: {
      //二维码内容
      value: {
        type: [String, Number]
      },
      //选项
      options: {
        type: Object,
        default: () => {
          return {};
        }
      },
      //二维码大小
      size: {
        type: [String, Number],
        default: 200
      },
      //导出的文件类型
      fileType: {
        type: String,
        default: "png"
      },
      //是否初始化组件后就开始生成
      start: {
        type: Boolean,
        default: true
      },
      //是否数据发生改变自动重绘
      auto: {
        type: Boolean,
        default: true
      },
      //隐藏组件
      hide: {
        type: Boolean,
        default: false
      },
      /**
       * canvas 类型，微信小程序默认使用2d，非2d微信官方已放弃维护，问题比较多
       * 注意：微信小程序type2d手机上正常，PC上微信内打开小程序toDataURL报错，看后期微信官方团队会不会做兼容，不兼容的话只能在自行判断在PC使用非2d，或者直接提示用户请在手机上操作，微信团队的海报中心小程序就是这么做的
       */
      type: {
        type: String,
        default: () => {
          return "normal";
        }
      },
      //队列绘制，主要针对NVue端
      queue: {
        type: Boolean,
        default: false
      },
      //是否队列加载图片，可减少canvas发起的网络资源请求，节省服务器资源
      isQueueLoadImage: {
        type: Boolean,
        default: false
      },
      //loading态
      loading: {
        type: Boolean,
        default: void 0
      },
      //H5保存即自动下载（在支持的环境下），默认false为仅弹层提示用户需要长按图片保存，不会自动下载
      h5SaveIsDownload: {
        type: Boolean,
        default: false
      },
      //H5下载名称
      h5DownloadName: {
        type: String,
        default: "uvQRCode"
      },
      // H5保存二维码时候是否显示提示
      h5SaveTip: {
        type: Boolean,
        default: true
      }
    }
  };
  const mpMixin = {};
  function email(value) {
    return /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/.test(value);
  }
  function mobile(value) {
    return /^1([3589]\d|4[5-9]|6[1-2,4-7]|7[0-8])\d{8}$/.test(value);
  }
  function url(value) {
    return /^((https|http|ftp|rtsp|mms):\/\/)(([0-9a-zA-Z_!~*'().&=+$%-]+: )?[0-9a-zA-Z_!~*'().&=+$%-]+@)?(([0-9]{1,3}.){3}[0-9]{1,3}|([0-9a-zA-Z_!~*'()-]+.)*([0-9a-zA-Z][0-9a-zA-Z-]{0,61})?[0-9a-zA-Z].[a-zA-Z]{2,6})(:[0-9]{1,4})?((\/?)|(\/[0-9a-zA-Z_!~*'().;?:@&=+$,%#-]+)+\/?)$/.test(value);
  }
  function date(value) {
    if (!value)
      return false;
    if (number(value))
      value = +value;
    return !/Invalid|NaN/.test(new Date(value).toString());
  }
  function dateISO(value) {
    return /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
  }
  function number(value) {
    return /^[\+-]?(\d+\.?\d*|\.\d+|\d\.\d+e\+\d+)$/.test(value);
  }
  function string(value) {
    return typeof value === "string";
  }
  function digits(value) {
    return /^\d+$/.test(value);
  }
  function idCard(value) {
    return /^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$/.test(
      value
    );
  }
  function carNo(value) {
    const xreg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}(([0-9]{5}[DF]$)|([DF][A-HJ-NP-Z0-9][0-9]{4}$))/;
    const creg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]{1}$/;
    if (value.length === 7) {
      return creg.test(value);
    }
    if (value.length === 8) {
      return xreg.test(value);
    }
    return false;
  }
  function amount(value) {
    return /^[1-9]\d*(,\d{3})*(\.\d{1,2})?$|^0\.\d{1,2}$/.test(value);
  }
  function chinese(value) {
    const reg = /^[\u4e00-\u9fa5]+$/gi;
    return reg.test(value);
  }
  function letter(value) {
    return /^[a-zA-Z]*$/.test(value);
  }
  function enOrNum(value) {
    const reg = /^[0-9a-zA-Z]*$/g;
    return reg.test(value);
  }
  function contains(value, param) {
    return value.indexOf(param) >= 0;
  }
  function range$1(value, param) {
    return value >= param[0] && value <= param[1];
  }
  function rangeLength(value, param) {
    return value.length >= param[0] && value.length <= param[1];
  }
  function landline(value) {
    const reg = /^\d{3,4}-\d{7,8}(-\d{3,4})?$/;
    return reg.test(value);
  }
  function empty(value) {
    switch (typeof value) {
      case "undefined":
        return true;
      case "string":
        if (value.replace(/(^[ \t\n\r]*)|([ \t\n\r]*$)/g, "").length == 0)
          return true;
        break;
      case "boolean":
        if (!value)
          return true;
        break;
      case "number":
        if (value === 0 || isNaN(value))
          return true;
        break;
      case "object":
        if (value === null || value.length === 0)
          return true;
        for (const i2 in value) {
          return false;
        }
        return true;
    }
    return false;
  }
  function jsonString(value) {
    if (typeof value === "string") {
      try {
        const obj = JSON.parse(value);
        if (typeof obj === "object" && obj) {
          return true;
        }
        return false;
      } catch (e2) {
        return false;
      }
    }
    return false;
  }
  function array(value) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(value);
    }
    return Object.prototype.toString.call(value) === "[object Array]";
  }
  function object(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function code(value, len = 6) {
    return new RegExp(`^\\d{${len}}$`).test(value);
  }
  function func(value) {
    return typeof value === "function";
  }
  function promise(value) {
    return object(value) && func(value.then) && func(value.catch);
  }
  function image(value) {
    const newValue = value.split("?")[0];
    const IMAGE_REGEXP2 = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg)/i;
    return IMAGE_REGEXP2.test(newValue);
  }
  function video(value) {
    const VIDEO_REGEXP = /\.(mp4|mpg|mpeg|dat|asf|avi|rm|rmvb|mov|wmv|flv|mkv|m3u8)/i;
    return VIDEO_REGEXP.test(value);
  }
  function regExp(o2) {
    return o2 && Object.prototype.toString.call(o2) === "[object RegExp]";
  }
  const test = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    amount,
    array,
    carNo,
    chinese,
    code,
    contains,
    date,
    dateISO,
    digits,
    email,
    empty,
    enOrNum,
    func,
    idCard,
    image,
    jsonString,
    landline,
    letter,
    mobile,
    number,
    object,
    promise,
    range: range$1,
    rangeLength,
    regExp,
    string,
    url,
    video
  }, Symbol.toStringTag, { value: "Module" }));
  function strip(num, precision = 15) {
    return +parseFloat(Number(num).toPrecision(precision));
  }
  function digitLength(num) {
    const eSplit = num.toString().split(/[eE]/);
    const len = (eSplit[0].split(".")[1] || "").length - +(eSplit[1] || 0);
    return len > 0 ? len : 0;
  }
  function float2Fixed(num) {
    if (num.toString().indexOf("e") === -1) {
      return Number(num.toString().replace(".", ""));
    }
    const dLen = digitLength(num);
    return dLen > 0 ? strip(Number(num) * Math.pow(10, dLen)) : Number(num);
  }
  function checkBoundary(num) {
    {
      if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {
        formatAppLog("warn", "at node_modules/@climblee/uv-ui/libs/function/digit.js:45", `${num} 超出了精度限制，结果可能不正确`);
      }
    }
  }
  function iteratorOperation(arr, operation) {
    const [num1, num2, ...others] = arr;
    let res = operation(num1, num2);
    others.forEach((num) => {
      res = operation(res, num);
    });
    return res;
  }
  function times(...nums) {
    if (nums.length > 2) {
      return iteratorOperation(nums, times);
    }
    const [num1, num2] = nums;
    const num1Changed = float2Fixed(num1);
    const num2Changed = float2Fixed(num2);
    const baseNum = digitLength(num1) + digitLength(num2);
    const leftValue = num1Changed * num2Changed;
    checkBoundary(leftValue);
    return leftValue / Math.pow(10, baseNum);
  }
  function divide(...nums) {
    if (nums.length > 2) {
      return iteratorOperation(nums, divide);
    }
    const [num1, num2] = nums;
    const num1Changed = float2Fixed(num1);
    const num2Changed = float2Fixed(num2);
    checkBoundary(num1Changed);
    checkBoundary(num2Changed);
    return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
  }
  function round(num, ratio) {
    const base = Math.pow(10, ratio);
    let result = divide(Math.round(Math.abs(times(num, base))), base);
    if (num < 0 && result !== 0) {
      result = times(result, -1);
    }
    return result;
  }
  function range(min = 0, max = 0, value = 0) {
    return Math.max(min, Math.min(max, Number(value)));
  }
  function getPx(value, unit = false) {
    if (number(value)) {
      return unit ? `${value}px` : Number(value);
    }
    if (/(rpx|upx)$/.test(value)) {
      return unit ? `${uni.upx2px(parseInt(value))}px` : Number(uni.upx2px(parseInt(value)));
    }
    return unit ? `${parseInt(value)}px` : parseInt(value);
  }
  function sleep(value = 30) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, value);
    });
  }
  function os() {
    return uni.getSystemInfoSync().platform.toLowerCase();
  }
  function sys() {
    return uni.getSystemInfoSync();
  }
  function random(min, max) {
    if (min >= 0 && max > 0 && max >= min) {
      const gab = max - min + 1;
      return Math.floor(Math.random() * gab + min);
    }
    return 0;
  }
  function guid(len = 32, firstU = true, radix = null) {
    const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
    const uuid = [];
    radix = radix || chars.length;
    if (len) {
      for (let i2 = 0; i2 < len; i2++)
        uuid[i2] = chars[0 | Math.random() * radix];
    } else {
      let r2;
      uuid[8] = uuid[13] = uuid[18] = uuid[23] = "-";
      uuid[14] = "4";
      for (let i2 = 0; i2 < 36; i2++) {
        if (!uuid[i2]) {
          r2 = 0 | Math.random() * 16;
          uuid[i2] = chars[i2 == 19 ? r2 & 3 | 8 : r2];
        }
      }
    }
    if (firstU) {
      uuid.shift();
      return `u${uuid.join("")}`;
    }
    return uuid.join("");
  }
  function $parent(name2 = void 0) {
    let parent = this.$parent;
    while (parent) {
      if (parent.$options && parent.$options.name !== name2) {
        parent = parent.$parent;
      } else {
        return parent;
      }
    }
    return false;
  }
  function addStyle(customStyle, target = "object") {
    if (empty(customStyle) || typeof customStyle === "object" && target === "object" || target === "string" && typeof customStyle === "string") {
      return customStyle;
    }
    if (target === "object") {
      customStyle = trim(customStyle);
      const styleArray = customStyle.split(";");
      const style = {};
      for (let i2 = 0; i2 < styleArray.length; i2++) {
        if (styleArray[i2]) {
          const item = styleArray[i2].split(":");
          style[trim(item[0])] = trim(item[1]);
        }
      }
      return style;
    }
    let string2 = "";
    for (const i2 in customStyle) {
      const key = i2.replace(/([A-Z])/g, "-$1").toLowerCase();
      string2 += `${key}:${customStyle[i2]};`;
    }
    return trim(string2);
  }
  function addUnit(value = "auto", unit = ((_b) => (_b = ((_a) => (_a = uni == null ? void 0 : uni.$uv) == null ? void 0 : _a.config)()) == null ? void 0 : _b.unit)() ? ((_d) => (_d = ((_c) => (_c = uni == null ? void 0 : uni.$uv) == null ? void 0 : _c.config)()) == null ? void 0 : _d.unit)() : "px") {
    value = String(value);
    return number(value) ? `${value}${unit}` : value;
  }
  function deepClone(obj, cache2 = /* @__PURE__ */ new WeakMap()) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (cache2.has(obj))
      return cache2.get(obj);
    let clone;
    if (obj instanceof Date) {
      clone = new Date(obj.getTime());
    } else if (obj instanceof RegExp) {
      clone = new RegExp(obj);
    } else if (obj instanceof Map) {
      clone = new Map(Array.from(obj, ([key, value]) => [key, deepClone(value, cache2)]));
    } else if (obj instanceof Set) {
      clone = new Set(Array.from(obj, (value) => deepClone(value, cache2)));
    } else if (Array.isArray(obj)) {
      clone = obj.map((value) => deepClone(value, cache2));
    } else if (Object.prototype.toString.call(obj) === "[object Object]") {
      clone = Object.create(Object.getPrototypeOf(obj));
      cache2.set(obj, clone);
      for (const [key, value] of Object.entries(obj)) {
        clone[key] = deepClone(value, cache2);
      }
    } else {
      clone = Object.assign({}, obj);
    }
    cache2.set(obj, clone);
    return clone;
  }
  function deepMerge(target = {}, source = {}) {
    target = deepClone(target);
    if (typeof target !== "object" || target === null || typeof source !== "object" || source === null)
      return target;
    const merged = Array.isArray(target) ? target.slice() : Object.assign({}, target);
    for (const prop in source) {
      if (!source.hasOwnProperty(prop))
        continue;
      const sourceValue = source[prop];
      const targetValue = merged[prop];
      if (sourceValue instanceof Date) {
        merged[prop] = new Date(sourceValue);
      } else if (sourceValue instanceof RegExp) {
        merged[prop] = new RegExp(sourceValue);
      } else if (sourceValue instanceof Map) {
        merged[prop] = new Map(sourceValue);
      } else if (sourceValue instanceof Set) {
        merged[prop] = new Set(sourceValue);
      } else if (typeof sourceValue === "object" && sourceValue !== null) {
        merged[prop] = deepMerge(targetValue, sourceValue);
      } else {
        merged[prop] = sourceValue;
      }
    }
    return merged;
  }
  function error(err) {
    {
      formatAppLog("error", "at node_modules/@climblee/uv-ui/libs/function/index.js:250", `uvui提示：${err}`);
    }
  }
  function randomArray(array2 = []) {
    return array2.sort(() => Math.random() - 0.5);
  }
  if (!String.prototype.padStart) {
    String.prototype.padStart = function(maxLength, fillString = " ") {
      if (Object.prototype.toString.call(fillString) !== "[object String]") {
        throw new TypeError(
          "fillString must be String"
        );
      }
      const str = this;
      if (str.length >= maxLength)
        return String(str);
      const fillLength = maxLength - str.length;
      let times2 = Math.ceil(fillLength / fillString.length);
      while (times2 >>= 1) {
        fillString += fillString;
        if (times2 === 1) {
          fillString += fillString;
        }
      }
      return fillString.slice(0, fillLength) + str;
    };
  }
  function timeFormat(dateTime = null, formatStr = "yyyy-mm-dd") {
    let date2;
    if (!dateTime) {
      date2 = /* @__PURE__ */ new Date();
    } else if (/^\d{10}$/.test(dateTime == null ? void 0 : dateTime.toString().trim())) {
      date2 = new Date(dateTime * 1e3);
    } else if (typeof dateTime === "string" && /^\d+$/.test(dateTime.trim())) {
      date2 = new Date(Number(dateTime));
    } else if (typeof dateTime === "string" && dateTime.includes("-") && !dateTime.includes("T")) {
      date2 = new Date(dateTime.replace(/-/g, "/"));
    } else {
      date2 = new Date(dateTime);
    }
    const timeSource = {
      "y": date2.getFullYear().toString(),
      // 年
      "m": (date2.getMonth() + 1).toString().padStart(2, "0"),
      // 月
      "d": date2.getDate().toString().padStart(2, "0"),
      // 日
      "h": date2.getHours().toString().padStart(2, "0"),
      // 时
      "M": date2.getMinutes().toString().padStart(2, "0"),
      // 分
      "s": date2.getSeconds().toString().padStart(2, "0")
      // 秒
      // 有其他格式化字符需求可以继续添加，必须转化成字符串
    };
    for (const key in timeSource) {
      const [ret] = new RegExp(`${key}+`).exec(formatStr) || [];
      if (ret) {
        const beginIndex = key === "y" && ret.length === 2 ? 2 : 0;
        formatStr = formatStr.replace(ret, timeSource[key].slice(beginIndex));
      }
    }
    return formatStr;
  }
  function timeFrom(timestamp = null, format2 = "yyyy-mm-dd") {
    if (timestamp == null)
      timestamp = Number(/* @__PURE__ */ new Date());
    timestamp = parseInt(timestamp);
    if (timestamp.toString().length == 10)
      timestamp *= 1e3;
    let timer = (/* @__PURE__ */ new Date()).getTime() - timestamp;
    timer = parseInt(timer / 1e3);
    let tips = "";
    switch (true) {
      case timer < 300:
        tips = "刚刚";
        break;
      case (timer >= 300 && timer < 3600):
        tips = `${parseInt(timer / 60)}分钟前`;
        break;
      case (timer >= 3600 && timer < 86400):
        tips = `${parseInt(timer / 3600)}小时前`;
        break;
      case (timer >= 86400 && timer < 2592e3):
        tips = `${parseInt(timer / 86400)}天前`;
        break;
      default:
        if (format2 === false) {
          if (timer >= 2592e3 && timer < 365 * 86400) {
            tips = `${parseInt(timer / (86400 * 30))}个月前`;
          } else {
            tips = `${parseInt(timer / (86400 * 365))}年前`;
          }
        } else {
          tips = timeFormat(timestamp, format2);
        }
    }
    return tips;
  }
  function trim(str, pos = "both") {
    str = String(str);
    if (pos == "both") {
      return str.replace(/^\s+|\s+$/g, "");
    }
    if (pos == "left") {
      return str.replace(/^\s*/, "");
    }
    if (pos == "right") {
      return str.replace(/(\s*$)/g, "");
    }
    if (pos == "all") {
      return str.replace(/\s+/g, "");
    }
    return str;
  }
  function queryParams(data = {}, isPrefix = true, arrayFormat = "brackets") {
    const prefix = isPrefix ? "?" : "";
    const _result = [];
    if (["indices", "brackets", "repeat", "comma"].indexOf(arrayFormat) == -1)
      arrayFormat = "brackets";
    for (const key in data) {
      const value = data[key];
      if (["", void 0, null].indexOf(value) >= 0) {
        continue;
      }
      if (value.constructor === Array) {
        switch (arrayFormat) {
          case "indices":
            for (let i2 = 0; i2 < value.length; i2++) {
              _result.push(`${key}[${i2}]=${value[i2]}`);
            }
            break;
          case "brackets":
            value.forEach((_value) => {
              _result.push(`${key}[]=${_value}`);
            });
            break;
          case "repeat":
            value.forEach((_value) => {
              _result.push(`${key}=${_value}`);
            });
            break;
          case "comma":
            let commaStr = "";
            value.forEach((_value) => {
              commaStr += (commaStr ? "," : "") + _value;
            });
            _result.push(`${key}=${commaStr}`);
            break;
          default:
            value.forEach((_value) => {
              _result.push(`${key}[]=${_value}`);
            });
        }
      } else {
        _result.push(`${key}=${value}`);
      }
    }
    return _result.length ? prefix + _result.join("&") : "";
  }
  function toast(title, duration = 2e3) {
    uni.showToast({
      title: String(title),
      icon: "none",
      duration
    });
  }
  function type2icon(type = "success", fill = false) {
    if (["primary", "info", "error", "warning", "success"].indexOf(type) == -1)
      type = "success";
    let iconName = "";
    switch (type) {
      case "primary":
        iconName = "info-circle";
        break;
      case "info":
        iconName = "info-circle";
        break;
      case "error":
        iconName = "close-circle";
        break;
      case "warning":
        iconName = "error-circle";
        break;
      case "success":
        iconName = "checkmark-circle";
        break;
      default:
        iconName = "checkmark-circle";
    }
    if (fill)
      iconName += "-fill";
    return iconName;
  }
  function priceFormat(number2, decimals = 0, decimalPoint = ".", thousandsSeparator = ",") {
    number2 = `${number2}`.replace(/[^0-9+-Ee.]/g, "");
    const n2 = !isFinite(+number2) ? 0 : +number2;
    const prec = !isFinite(+decimals) ? 0 : Math.abs(decimals);
    const sep = typeof thousandsSeparator === "undefined" ? "," : thousandsSeparator;
    const dec = typeof decimalPoint === "undefined" ? "." : decimalPoint;
    let s2 = "";
    s2 = (prec ? round(n2, prec) + "" : `${Math.round(n2)}`).split(".");
    const re = /(-?\d+)(\d{3})/;
    while (re.test(s2[0])) {
      s2[0] = s2[0].replace(re, `$1${sep}$2`);
    }
    if ((s2[1] || "").length < prec) {
      s2[1] = s2[1] || "";
      s2[1] += new Array(prec - s2[1].length + 1).join("0");
    }
    return s2.join(dec);
  }
  function getDuration(value, unit = true) {
    const valueNum = parseInt(value);
    if (unit) {
      if (/s$/.test(value))
        return value;
      return value > 30 ? `${value}ms` : `${value}s`;
    }
    if (/ms$/.test(value))
      return valueNum;
    if (/s$/.test(value))
      return valueNum > 30 ? valueNum : valueNum * 1e3;
    return valueNum;
  }
  function padZero(value) {
    return `00${value}`.slice(-2);
  }
  function formValidate(instance2, event) {
    const formItem = $parent.call(instance2, "uv-form-item");
    const form = $parent.call(instance2, "uv-form");
    if (formItem && form) {
      form.validateField(formItem.prop, () => {
      }, event);
    }
  }
  function getProperty(obj, key) {
    if (!obj) {
      return;
    }
    if (typeof key !== "string" || key === "") {
      return "";
    }
    if (key.indexOf(".") !== -1) {
      const keys = key.split(".");
      let firstObj = obj[keys[0]] || {};
      for (let i2 = 1; i2 < keys.length; i2++) {
        if (firstObj) {
          firstObj = firstObj[keys[i2]];
        }
      }
      return firstObj;
    }
    return obj[key];
  }
  function setProperty(obj, key, value) {
    if (!obj) {
      return;
    }
    const inFn = function(_obj, keys, v2) {
      if (keys.length === 1) {
        _obj[keys[0]] = v2;
        return;
      }
      while (keys.length > 1) {
        const k = keys[0];
        if (!_obj[k] || typeof _obj[k] !== "object") {
          _obj[k] = {};
        }
        keys.shift();
        inFn(_obj[k], keys, v2);
      }
    };
    if (typeof key !== "string" || key === "")
      ;
    else if (key.indexOf(".") !== -1) {
      const keys = key.split(".");
      inFn(obj, keys, value);
    } else {
      obj[key] = value;
    }
  }
  function page() {
    var _a;
    const pages2 = getCurrentPages();
    const route2 = (_a = pages2[pages2.length - 1]) == null ? void 0 : _a.route;
    return `/${route2 ? route2 : ""}`;
  }
  function pages() {
    const pages2 = getCurrentPages();
    return pages2;
  }
  function getHistoryPage(back = 0) {
    const pages2 = getCurrentPages();
    const len = pages2.length;
    return pages2[len - 1 + back];
  }
  function setConfig({
    props: props2 = {},
    config: config2 = {},
    color = {},
    zIndex = {}
  }) {
    const {
      deepMerge: deepMerge2
    } = uni.$uv;
    uni.$uv.config = deepMerge2(uni.$uv.config, config2);
    uni.$uv.props = deepMerge2(uni.$uv.props, props2);
    uni.$uv.color = deepMerge2(uni.$uv.color, color);
    uni.$uv.zIndex = deepMerge2(uni.$uv.zIndex, zIndex);
  }
  const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    $parent,
    addStyle,
    addUnit,
    deepClone,
    deepMerge,
    error,
    formValidate,
    getDuration,
    getHistoryPage,
    getProperty,
    getPx,
    guid,
    os,
    padZero,
    page,
    pages,
    priceFormat,
    queryParams,
    random,
    randomArray,
    range,
    setConfig,
    setProperty,
    sleep,
    sys,
    timeFormat,
    timeFrom,
    toast,
    trim,
    type2icon
  }, Symbol.toStringTag, { value: "Module" }));
  class Router {
    constructor() {
      this.config = {
        type: "navigateTo",
        url: "",
        delta: 1,
        // navigateBack页面后退时,回退的层数
        params: {},
        // 传递的参数
        animationType: "pop-in",
        // 窗口动画,只在APP有效
        animationDuration: 300,
        // 窗口动画持续时间,单位毫秒,只在APP有效
        intercept: false,
        // 是否需要拦截
        events: {}
        // 页面间通信接口，用于监听被打开页面发送到当前页面的数据。hbuilderx 2.8.9+ 开始支持。
      };
      this.route = this.route.bind(this);
    }
    // 判断url前面是否有"/"，如果没有则加上，否则无法跳转
    addRootPath(url2) {
      return url2[0] === "/" ? url2 : `/${url2}`;
    }
    // 整合路由参数
    mixinParam(url2, params) {
      url2 = url2 && this.addRootPath(url2);
      let query = "";
      if (/.*\/.*\?.*=.*/.test(url2)) {
        query = queryParams(params, false);
        return url2 += `&${query}`;
      }
      query = queryParams(params);
      return url2 += query;
    }
    // 对外的方法名称
    async route(options = {}, params = {}) {
      let mergeConfig = {};
      if (typeof options === "string") {
        mergeConfig.url = this.mixinParam(options, params);
        mergeConfig.type = "navigateTo";
      } else {
        mergeConfig = deepMerge(this.config, options);
        mergeConfig.url = this.mixinParam(options.url, options.params);
      }
      if (mergeConfig.url === page())
        return;
      if (params.intercept) {
        mergeConfig.intercept = params.intercept;
      }
      mergeConfig.params = params;
      mergeConfig = deepMerge(this.config, mergeConfig);
      if (typeof mergeConfig.intercept === "function") {
        const isNext = await new Promise((resolve, reject) => {
          mergeConfig.intercept(mergeConfig, resolve);
        });
        isNext && this.openPage(mergeConfig);
      } else {
        this.openPage(mergeConfig);
      }
    }
    // 执行路由跳转
    openPage(config2) {
      const {
        url: url2,
        type,
        delta,
        animationType,
        animationDuration,
        events
      } = config2;
      if (config2.type == "navigateTo" || config2.type == "to") {
        uni.navigateTo({
          url: url2,
          animationType,
          animationDuration,
          events
        });
      }
      if (config2.type == "redirectTo" || config2.type == "redirect") {
        uni.redirectTo({
          url: url2
        });
      }
      if (config2.type == "switchTab" || config2.type == "tab") {
        uni.switchTab({
          url: url2
        });
      }
      if (config2.type == "reLaunch" || config2.type == "launch") {
        uni.reLaunch({
          url: url2
        });
      }
      if (config2.type == "navigateBack" || config2.type == "back") {
        uni.navigateBack({
          delta
        });
      }
    }
  }
  const route = new Router().route;
  let timeout = null;
  function debounce(func2, wait2 = 500, immediate = false) {
    if (timeout !== null)
      clearTimeout(timeout);
    if (immediate) {
      const callNow = !timeout;
      timeout = setTimeout(() => {
        timeout = null;
      }, wait2);
      if (callNow)
        typeof func2 === "function" && func2();
    } else {
      timeout = setTimeout(() => {
        typeof func2 === "function" && func2();
      }, wait2);
    }
  }
  let flag;
  function throttle(func2, wait2 = 500, immediate = true) {
    if (immediate) {
      if (!flag) {
        flag = true;
        typeof func2 === "function" && func2();
        setTimeout(() => {
          flag = false;
        }, wait2);
      }
    } else if (!flag) {
      flag = true;
      setTimeout(() => {
        flag = false;
        typeof func2 === "function" && func2();
      }, wait2);
    }
  }
  const mixin = {
    // 定义每个组件都可能需要用到的外部样式以及类名
    props: {
      // 每个组件都有的父组件传递的样式，可以为字符串或者对象形式
      customStyle: {
        type: [Object, String],
        default: () => ({})
      },
      customClass: {
        type: String,
        default: ""
      },
      // 跳转的页面路径
      url: {
        type: String,
        default: ""
      },
      // 页面跳转的类型
      linkType: {
        type: String,
        default: "navigateTo"
      }
    },
    data() {
      return {};
    },
    onLoad() {
      this.$uv.getRect = this.$uvGetRect;
    },
    created() {
      this.$uv.getRect = this.$uvGetRect;
    },
    computed: {
      $uv() {
        var _a, _b;
        return {
          ...index,
          test,
          route,
          debounce,
          throttle,
          unit: (_b = (_a = uni == null ? void 0 : uni.$uv) == null ? void 0 : _a.config) == null ? void 0 : _b.unit
        };
      },
      /**
       * 生成bem规则类名
       * 由于微信小程序，H5，nvue之间绑定class的差异，无法通过:class="[bem()]"的形式进行同用
       * 故采用如下折中做法，最后返回的是数组（一般平台）或字符串（支付宝和字节跳动平台），类似['a', 'b', 'c']或'a b c'的形式
       * @param {String} name 组件名称
       * @param {Array} fixed 一直会存在的类名
       * @param {Array} change 会根据变量值为true或者false而出现或者隐藏的类名
       * @returns {Array|string}
       */
      bem() {
        return function(name2, fixed, change) {
          const prefix = `uv-${name2}--`;
          const classes = {};
          if (fixed) {
            fixed.map((item) => {
              classes[prefix + this[item]] = true;
            });
          }
          if (change) {
            change.map((item) => {
              this[item] ? classes[prefix + item] = this[item] : delete classes[prefix + item];
            });
          }
          return Object.keys(classes);
        };
      }
    },
    methods: {
      // 跳转某一个页面
      openPage(urlKey = "url") {
        const url2 = this[urlKey];
        if (url2) {
          uni[this.linkType]({
            url: url2
          });
        }
      },
      // 查询节点信息
      // 目前此方法在支付宝小程序中无法获取组件跟接点的尺寸，为支付宝的bug(2020-07-21)
      // 解决办法为在组件根部再套一个没有任何作用的view元素
      $uvGetRect(selector, all) {
        return new Promise((resolve) => {
          uni.createSelectorQuery().in(this)[all ? "selectAll" : "select"](selector).boundingClientRect((rect) => {
            if (all && Array.isArray(rect) && rect.length) {
              resolve(rect);
            }
            if (!all && rect) {
              resolve(rect);
            }
          }).exec();
        });
      },
      getParentData(parentName = "") {
        if (!this.parent)
          this.parent = {};
        this.parent = this.$uv.$parent.call(this, parentName);
        if (this.parent.children) {
          this.parent.children.indexOf(this) === -1 && this.parent.children.push(this);
        }
        if (this.parent && this.parentData) {
          Object.keys(this.parentData).map((key) => {
            this.parentData[key] = this.parent[key];
          });
        }
      },
      // 阻止事件冒泡
      preventEvent(e2) {
        e2 && typeof e2.stopPropagation === "function" && e2.stopPropagation();
      },
      // 空操作
      noop(e2) {
        this.preventEvent(e2);
      }
    },
    onReachBottom() {
      uni.$emit("uvOnReachBottom");
    },
    beforeDestroy() {
      if (this.parent && array(this.parent.children)) {
        const childrenList = this.parent.children;
        childrenList.map((child, index2) => {
          if (child === this) {
            childrenList.splice(index2, 1);
          }
        });
      }
    },
    // 兼容vue3
    unmounted() {
      if (this.parent && array(this.parent.children)) {
        const childrenList = this.parent.children;
        childrenList.map((child, index2) => {
          if (child === this) {
            childrenList.splice(index2, 1);
          }
        });
      }
    }
  };
  function o(o2) {
    this.mode = r.MODE_8BIT_BYTE, this.data = o2;
  }
  function e(o2, e2) {
    this.typeNumber = o2, this.errorCorrectLevel = e2, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = new Array();
  }
  o.prototype = { getLength: function(o2) {
    return this.data.length;
  }, write: function(o2) {
    for (var e2 = 0; e2 < this.data.length; e2++)
      o2.put(this.data.charCodeAt(e2), 8);
  } }, e.prototype = { addData: function(e2) {
    var r2 = new o(e2);
    this.dataList.push(r2), this.dataCache = null;
  }, isDark: function(o2, e2) {
    if (o2 < 0 || this.moduleCount <= o2 || e2 < 0 || this.moduleCount <= e2)
      throw new Error(o2 + "," + e2);
    return this.modules[o2][e2];
  }, getModuleCount: function() {
    return this.moduleCount;
  }, make: function() {
    if (this.typeNumber < 1) {
      var o2 = 1;
      for (o2 = 1; o2 < 40; o2++) {
        for (var e2 = v.getRSBlocks(o2, this.errorCorrectLevel), r2 = new p(), t2 = 0, i2 = 0; i2 < e2.length; i2++)
          t2 += e2[i2].dataCount;
        for (i2 = 0; i2 < this.dataList.length; i2++) {
          var n2 = this.dataList[i2];
          r2.put(n2.mode, 4), r2.put(n2.getLength(), h.getLengthInBits(n2.mode, o2)), n2.write(r2);
        }
        if (r2.getLengthInBits() <= 8 * t2)
          break;
      }
      this.typeNumber = o2;
    }
    this.makeImpl(false, this.getBestMaskPattern());
  }, makeImpl: function(o2, r2) {
    this.moduleCount = 4 * this.typeNumber + 17, this.modules = new Array(this.moduleCount);
    for (var t2 = 0; t2 < this.moduleCount; t2++) {
      this.modules[t2] = new Array(this.moduleCount);
      for (var i2 = 0; i2 < this.moduleCount; i2++)
        this.modules[t2][i2] = null;
    }
    this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(o2, r2), this.typeNumber >= 7 && this.setupTypeNumber(o2), null == this.dataCache && (this.dataCache = e.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, r2);
  }, setupPositionProbePattern: function(o2, e2) {
    for (var r2 = -1; r2 <= 7; r2++)
      if (!(o2 + r2 <= -1 || this.moduleCount <= o2 + r2))
        for (var t2 = -1; t2 <= 7; t2++)
          e2 + t2 <= -1 || this.moduleCount <= e2 + t2 || (this.modules[o2 + r2][e2 + t2] = 0 <= r2 && r2 <= 6 && (0 == t2 || 6 == t2) || 0 <= t2 && t2 <= 6 && (0 == r2 || 6 == r2) || 2 <= r2 && r2 <= 4 && 2 <= t2 && t2 <= 4);
  }, getBestMaskPattern: function() {
    for (var o2 = 0, e2 = 0, r2 = 0; r2 < 8; r2++) {
      this.makeImpl(true, r2);
      var t2 = h.getLostPoint(this);
      (0 == r2 || o2 > t2) && (o2 = t2, e2 = r2);
    }
    return e2;
  }, createMovieClip: function(o2, e2, r2) {
    var t2 = o2.createEmptyMovieClip(e2, r2);
    this.make();
    for (var i2 = 0; i2 < this.modules.length; i2++)
      for (var n2 = 1 * i2, a2 = 0; a2 < this.modules[i2].length; a2++) {
        var d2 = 1 * a2;
        this.modules[i2][a2] && (t2.beginFill(0, 100), t2.moveTo(d2, n2), t2.lineTo(d2 + 1, n2), t2.lineTo(d2 + 1, n2 + 1), t2.lineTo(d2, n2 + 1), t2.endFill());
      }
    return t2;
  }, setupTimingPattern: function() {
    for (var o2 = 8; o2 < this.moduleCount - 8; o2++)
      null == this.modules[o2][6] && (this.modules[o2][6] = o2 % 2 == 0);
    for (var e2 = 8; e2 < this.moduleCount - 8; e2++)
      null == this.modules[6][e2] && (this.modules[6][e2] = e2 % 2 == 0);
  }, setupPositionAdjustPattern: function() {
    for (var o2 = h.getPatternPosition(this.typeNumber), e2 = 0; e2 < o2.length; e2++)
      for (var r2 = 0; r2 < o2.length; r2++) {
        var t2 = o2[e2], i2 = o2[r2];
        if (null == this.modules[t2][i2])
          for (var n2 = -2; n2 <= 2; n2++)
            for (var a2 = -2; a2 <= 2; a2++)
              this.modules[t2 + n2][i2 + a2] = -2 == n2 || 2 == n2 || -2 == a2 || 2 == a2 || 0 == n2 && 0 == a2;
      }
  }, setupTypeNumber: function(o2) {
    for (var e2 = h.getBCHTypeNumber(this.typeNumber), r2 = 0; r2 < 18; r2++) {
      var t2 = !o2 && 1 == (e2 >> r2 & 1);
      this.modules[Math.floor(r2 / 3)][r2 % 3 + this.moduleCount - 8 - 3] = t2;
    }
    for (r2 = 0; r2 < 18; r2++) {
      t2 = !o2 && 1 == (e2 >> r2 & 1);
      this.modules[r2 % 3 + this.moduleCount - 8 - 3][Math.floor(r2 / 3)] = t2;
    }
  }, setupTypeInfo: function(o2, e2) {
    for (var r2 = this.errorCorrectLevel << 3 | e2, t2 = h.getBCHTypeInfo(r2), i2 = 0; i2 < 15; i2++) {
      var n2 = !o2 && 1 == (t2 >> i2 & 1);
      i2 < 6 ? this.modules[i2][8] = n2 : i2 < 8 ? this.modules[i2 + 1][8] = n2 : this.modules[this.moduleCount - 15 + i2][8] = n2;
    }
    for (i2 = 0; i2 < 15; i2++) {
      n2 = !o2 && 1 == (t2 >> i2 & 1);
      i2 < 8 ? this.modules[8][this.moduleCount - i2 - 1] = n2 : i2 < 9 ? this.modules[8][15 - i2 - 1 + 1] = n2 : this.modules[8][15 - i2 - 1] = n2;
    }
    this.modules[this.moduleCount - 8][8] = !o2;
  }, mapData: function(o2, e2) {
    for (var r2 = -1, t2 = this.moduleCount - 1, i2 = 7, n2 = 0, a2 = this.moduleCount - 1; a2 > 0; a2 -= 2)
      for (6 == a2 && a2--; ; ) {
        for (var d2 = 0; d2 < 2; d2++)
          if (null == this.modules[t2][a2 - d2]) {
            var u2 = false;
            n2 < o2.length && (u2 = 1 == (o2[n2] >>> i2 & 1)), h.getMask(e2, t2, a2 - d2) && (u2 = !u2), this.modules[t2][a2 - d2] = u2, -1 == --i2 && (n2++, i2 = 7);
          }
        if ((t2 += r2) < 0 || this.moduleCount <= t2) {
          t2 -= r2, r2 = -r2;
          break;
        }
      }
  } }, e.PAD0 = 236, e.PAD1 = 17, e.createData = function(o2, r2, t2) {
    for (var i2 = v.getRSBlocks(o2, r2), n2 = new p(), a2 = 0; a2 < t2.length; a2++) {
      var d2 = t2[a2];
      n2.put(d2.mode, 4), n2.put(d2.getLength(), h.getLengthInBits(d2.mode, o2)), d2.write(n2);
    }
    var u2 = 0;
    for (a2 = 0; a2 < i2.length; a2++)
      u2 += i2[a2].dataCount;
    if (n2.getLengthInBits() > 8 * u2)
      throw new Error("code length overflow. (" + n2.getLengthInBits() + ">" + 8 * u2 + ")");
    for (n2.getLengthInBits() + 4 <= 8 * u2 && n2.put(0, 4); n2.getLengthInBits() % 8 != 0; )
      n2.putBit(false);
    for (; !(n2.getLengthInBits() >= 8 * u2 || (n2.put(e.PAD0, 8), n2.getLengthInBits() >= 8 * u2)); )
      n2.put(e.PAD1, 8);
    return e.createBytes(n2, i2);
  }, e.createBytes = function(o2, e2) {
    for (var r2 = 0, t2 = 0, i2 = 0, n2 = new Array(e2.length), a2 = new Array(e2.length), d2 = 0; d2 < e2.length; d2++) {
      var u2 = e2[d2].dataCount, s2 = e2[d2].totalCount - u2;
      t2 = Math.max(t2, u2), i2 = Math.max(i2, s2), n2[d2] = new Array(u2);
      for (var g2 = 0; g2 < n2[d2].length; g2++)
        n2[d2][g2] = 255 & o2.buffer[g2 + r2];
      r2 += u2;
      var l2 = h.getErrorCorrectPolynomial(s2), c2 = new f(n2[d2], l2.getLength() - 1).mod(l2);
      a2[d2] = new Array(l2.getLength() - 1);
      for (g2 = 0; g2 < a2[d2].length; g2++) {
        var m2 = g2 + c2.getLength() - a2[d2].length;
        a2[d2][g2] = m2 >= 0 ? c2.get(m2) : 0;
      }
    }
    var v2 = 0;
    for (g2 = 0; g2 < e2.length; g2++)
      v2 += e2[g2].totalCount;
    var p2 = new Array(v2), C2 = 0;
    for (g2 = 0; g2 < t2; g2++)
      for (d2 = 0; d2 < e2.length; d2++)
        g2 < n2[d2].length && (p2[C2++] = n2[d2][g2]);
    for (g2 = 0; g2 < i2; g2++)
      for (d2 = 0; d2 < e2.length; d2++)
        g2 < a2[d2].length && (p2[C2++] = a2[d2][g2]);
    return p2;
  };
  for (var r = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 }, t = { L: 1, M: 0, Q: 3, H: 2 }, i = 0, n = 1, a = 2, d = 3, u = 4, s = 5, g = 6, l = 7, h = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1335, G18: 7973, G15_MASK: 21522, getBCHTypeInfo: function(o2) {
    for (var e2 = o2 << 10; h.getBCHDigit(e2) - h.getBCHDigit(h.G15) >= 0; )
      e2 ^= h.G15 << h.getBCHDigit(e2) - h.getBCHDigit(h.G15);
    return (o2 << 10 | e2) ^ h.G15_MASK;
  }, getBCHTypeNumber: function(o2) {
    for (var e2 = o2 << 12; h.getBCHDigit(e2) - h.getBCHDigit(h.G18) >= 0; )
      e2 ^= h.G18 << h.getBCHDigit(e2) - h.getBCHDigit(h.G18);
    return o2 << 12 | e2;
  }, getBCHDigit: function(o2) {
    for (var e2 = 0; 0 != o2; )
      e2++, o2 >>>= 1;
    return e2;
  }, getPatternPosition: function(o2) {
    return h.PATTERN_POSITION_TABLE[o2 - 1];
  }, getMask: function(o2, e2, r2) {
    switch (o2) {
      case i:
        return (e2 + r2) % 2 == 0;
      case n:
        return e2 % 2 == 0;
      case a:
        return r2 % 3 == 0;
      case d:
        return (e2 + r2) % 3 == 0;
      case u:
        return (Math.floor(e2 / 2) + Math.floor(r2 / 3)) % 2 == 0;
      case s:
        return e2 * r2 % 2 + e2 * r2 % 3 == 0;
      case g:
        return (e2 * r2 % 2 + e2 * r2 % 3) % 2 == 0;
      case l:
        return (e2 * r2 % 3 + (e2 + r2) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + o2);
    }
  }, getErrorCorrectPolynomial: function(o2) {
    for (var e2 = new f([1], 0), r2 = 0; r2 < o2; r2++)
      e2 = e2.multiply(new f([1, c.gexp(r2)], 0));
    return e2;
  }, getLengthInBits: function(o2, e2) {
    if (1 <= e2 && e2 < 10)
      switch (o2) {
        case r.MODE_NUMBER:
          return 10;
        case r.MODE_ALPHA_NUM:
          return 9;
        case r.MODE_8BIT_BYTE:
        case r.MODE_KANJI:
          return 8;
        default:
          throw new Error("mode:" + o2);
      }
    else if (e2 < 27)
      switch (o2) {
        case r.MODE_NUMBER:
          return 12;
        case r.MODE_ALPHA_NUM:
          return 11;
        case r.MODE_8BIT_BYTE:
          return 16;
        case r.MODE_KANJI:
          return 10;
        default:
          throw new Error("mode:" + o2);
      }
    else {
      if (!(e2 < 41))
        throw new Error("type:" + e2);
      switch (o2) {
        case r.MODE_NUMBER:
          return 14;
        case r.MODE_ALPHA_NUM:
          return 13;
        case r.MODE_8BIT_BYTE:
          return 16;
        case r.MODE_KANJI:
          return 12;
        default:
          throw new Error("mode:" + o2);
      }
    }
  }, getLostPoint: function(o2) {
    for (var e2 = o2.getModuleCount(), r2 = 0, t2 = 0; t2 < e2; t2++)
      for (var i2 = 0; i2 < e2; i2++) {
        for (var n2 = 0, a2 = o2.isDark(t2, i2), d2 = -1; d2 <= 1; d2++)
          if (!(t2 + d2 < 0 || e2 <= t2 + d2))
            for (var u2 = -1; u2 <= 1; u2++)
              i2 + u2 < 0 || e2 <= i2 + u2 || 0 == d2 && 0 == u2 || a2 == o2.isDark(t2 + d2, i2 + u2) && n2++;
        n2 > 5 && (r2 += 3 + n2 - 5);
      }
    for (t2 = 0; t2 < e2 - 1; t2++)
      for (i2 = 0; i2 < e2 - 1; i2++) {
        var s2 = 0;
        o2.isDark(t2, i2) && s2++, o2.isDark(t2 + 1, i2) && s2++, o2.isDark(t2, i2 + 1) && s2++, o2.isDark(t2 + 1, i2 + 1) && s2++, 0 != s2 && 4 != s2 || (r2 += 3);
      }
    for (t2 = 0; t2 < e2; t2++)
      for (i2 = 0; i2 < e2 - 6; i2++)
        o2.isDark(t2, i2) && !o2.isDark(t2, i2 + 1) && o2.isDark(t2, i2 + 2) && o2.isDark(t2, i2 + 3) && o2.isDark(t2, i2 + 4) && !o2.isDark(t2, i2 + 5) && o2.isDark(t2, i2 + 6) && (r2 += 40);
    for (i2 = 0; i2 < e2; i2++)
      for (t2 = 0; t2 < e2 - 6; t2++)
        o2.isDark(t2, i2) && !o2.isDark(t2 + 1, i2) && o2.isDark(t2 + 2, i2) && o2.isDark(t2 + 3, i2) && o2.isDark(t2 + 4, i2) && !o2.isDark(t2 + 5, i2) && o2.isDark(t2 + 6, i2) && (r2 += 40);
    var g2 = 0;
    for (i2 = 0; i2 < e2; i2++)
      for (t2 = 0; t2 < e2; t2++)
        o2.isDark(t2, i2) && g2++;
    return r2 += 10 * (Math.abs(100 * g2 / e2 / e2 - 50) / 5);
  } }, c = { glog: function(o2) {
    if (o2 < 1)
      throw new Error("glog(" + o2 + ")");
    return c.LOG_TABLE[o2];
  }, gexp: function(o2) {
    for (; o2 < 0; )
      o2 += 255;
    for (; o2 >= 256; )
      o2 -= 255;
    return c.EXP_TABLE[o2];
  }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) }, m = 0; m < 8; m++)
    c.EXP_TABLE[m] = 1 << m;
  for (m = 8; m < 256; m++)
    c.EXP_TABLE[m] = c.EXP_TABLE[m - 4] ^ c.EXP_TABLE[m - 5] ^ c.EXP_TABLE[m - 6] ^ c.EXP_TABLE[m - 8];
  for (m = 0; m < 255; m++)
    c.LOG_TABLE[c.EXP_TABLE[m]] = m;
  function f(o2, e2) {
    if (null == o2.length)
      throw new Error(o2.length + "/" + e2);
    for (var r2 = 0; r2 < o2.length && 0 == o2[r2]; )
      r2++;
    this.num = new Array(o2.length - r2 + e2);
    for (var t2 = 0; t2 < o2.length - r2; t2++)
      this.num[t2] = o2[t2 + r2];
  }
  function v(o2, e2) {
    this.totalCount = o2, this.dataCount = e2;
  }
  function p() {
    this.buffer = new Array(), this.length = 0;
  }
  function C(o2) {
    return o2.setFillStyle = o2.setFillStyle || function(e2) {
      o2.fillStyle = e2;
    }, o2.setFontSize = o2.setFontSize || function(e2) {
      o2.font = `${e2}px`;
    }, o2.setTextAlign = o2.setTextAlign || function(e2) {
      o2.textAlign = e2;
    }, o2.setTextBaseline = o2.setTextBaseline || function(e2) {
      o2.textBaseline = e2;
    }, o2.setGlobalAlpha = o2.setGlobalAlpha || function(e2) {
      o2.globalAlpha = e2;
    }, o2.setStrokeStyle = o2.setStrokeStyle || function(e2) {
      o2.strokeStyle = e2;
    }, o2.setShadow = o2.setShadow || function(e2, r2, t2, i2) {
      o2.shadowOffsetX = e2, o2.shadowOffsetY = r2, o2.shadowBlur = t2, o2.shadowColor = i2;
    }, o2.draw = o2.draw || function(o3, e2) {
      e2 && e2();
    }, o2.clearRect = o2.clearRect || function(e2, r2, t2, i2) {
      o2.draw(false);
    }, o2;
  }
  function b(o2, e2) {
    var r2 = this.data = "", t2 = this.size = 200;
    this.useDynamicSize = false, this.dynamicSize = t2;
    var i2 = this.typeNumber = -1;
    this.errorCorrectLevel = b.errorCorrectLevel.H;
    var n2 = this.margin = 0;
    this.areaColor = "#FFFFFF", this.backgroundColor = "rgba(255,255,255,0)", this.backgroundImageSrc = void 0;
    var a2 = this.backgroundImageWidth = void 0, d2 = this.backgroundImageHeight = void 0, u2 = this.backgroundImageX = void 0, s2 = this.backgroundImageY = void 0;
    this.backgroundImageAlpha = 1, this.backgroundImageBorderRadius = 0;
    var g2 = this.backgroundPadding = 0;
    this.foregroundColor = "#000000", this.foregroundImageSrc = void 0;
    var l2 = this.foregroundImageWidth = void 0, h2 = this.foregroundImageHeight = void 0, c2 = this.foregroundImageX = void 0, m2 = this.foregroundImageY = void 0, f2 = this.foregroundImagePadding = 0;
    this.foregroundImageBackgroundColor = "#FFFFFF";
    var v2 = this.foregroundImageBorderRadius = 0, p2 = this.foregroundImageShadowOffsetX = 0, k = this.foregroundImageShadowOffsetY = 0, y = this.foregroundImageShadowBlur = 0;
    this.foregroundImageShadowColor = "#808080";
    var w = this.foregroundPadding = 0, I = this.positionProbeBackgroundColor = void 0, B = this.positionProbeForegroundColor = void 0, S = this.separatorColor = void 0, P = this.positionAdjustBackgroundColor = void 0, L = this.positionAdjustForegroundColor = void 0, D = this.timingBackgroundColor = void 0, A = this.timingForegroundColor = void 0, E = this.typeNumberBackgroundColor = void 0, T = this.typeNumberForegroundColor = void 0, N = this.darkBlockColor = void 0;
    this.base = void 0, this.modules = [], this.moduleCount = 0, this.drawModules = [];
    var M = this.canvasContext = void 0;
    this.loadImage, this.drawReserve = false, this.isMaked = false, Object.defineProperties(this, { data: { get() {
      if ("" === r2 || void 0 === r2)
        throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", "[uQRCode]: data must be set!"), new b.Error("data must be set!");
      return r2;
    }, set(o3) {
      r2 = String(o3);
    } }, size: { get: () => t2, set(o3) {
      t2 = Number(o3);
    } }, typeNumber: { get: () => i2, set(o3) {
      i2 = Number(o3);
    } }, margin: { get: () => n2, set(o3) {
      n2 = Number(o3);
    } }, backgroundImageWidth: { get() {
      return void 0 === a2 ? this.dynamicSize : this.useDynamicSize ? this.dynamicSize / this.size * a2 : a2;
    }, set(o3) {
      a2 = Number(o3);
    } }, backgroundImageHeight: { get() {
      return void 0 === d2 ? this.dynamicSize : this.useDynamicSize ? this.dynamicSize / this.size * d2 : d2;
    }, set(o3) {
      d2 = Number(o3);
    } }, backgroundImageX: { get() {
      return void 0 === u2 ? 0 : this.useDynamicSize ? this.dynamicSize / this.size * u2 : u2;
    }, set(o3) {
      u2 = Number(o3);
    } }, backgroundImageY: { get() {
      return void 0 === s2 ? 0 : this.useDynamicSize ? this.dynamicSize / this.size * s2 : s2;
    }, set(o3) {
      s2 = Number(o3);
    } }, backgroundPadding: { get: () => g2, set(o3) {
      g2 = o3 > 1 ? 1 : o3 < 0 ? 0 : o3;
    } }, foregroundImageWidth: { get() {
      return void 0 === l2 ? (this.dynamicSize - 2 * this.margin) / 4 : this.useDynamicSize ? this.dynamicSize / this.size * l2 : l2;
    }, set(o3) {
      l2 = Number(o3);
    } }, foregroundImageHeight: { get() {
      return void 0 === h2 ? (this.dynamicSize - 2 * this.margin) / 4 : this.useDynamicSize ? this.dynamicSize / this.size * h2 : h2;
    }, set(o3) {
      h2 = Number(o3);
    } }, foregroundImageX: { get() {
      return void 0 === c2 ? this.dynamicSize / 2 - this.foregroundImageWidth / 2 : this.useDynamicSize ? this.dynamicSize / this.size * c2 : c2;
    }, set(o3) {
      c2 = Number(o3);
    } }, foregroundImageY: { get() {
      return void 0 === m2 ? this.dynamicSize / 2 - this.foregroundImageHeight / 2 : this.useDynamicSize ? this.dynamicSize / this.size * m2 : m2;
    }, set(o3) {
      m2 = Number(o3);
    } }, foregroundImagePadding: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * f2 : f2;
    }, set(o3) {
      f2 = Number(o3);
    } }, foregroundImageBorderRadius: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * v2 : v2;
    }, set(o3) {
      v2 = Number(o3);
    } }, foregroundImageShadowOffsetX: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * p2 : p2;
    }, set(o3) {
      p2 = Number(o3);
    } }, foregroundImageShadowOffsetY: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * k : k;
    }, set(o3) {
      k = Number(o3);
    } }, foregroundImageShadowBlur: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * y : y;
    }, set(o3) {
      y = Number(o3);
    } }, foregroundPadding: { get: () => w, set(o3) {
      w = o3 > 1 ? 1 : o3 < 0 ? 0 : o3;
    } }, positionProbeBackgroundColor: { get() {
      return I || this.backgroundColor;
    }, set(o3) {
      I = o3;
    } }, positionProbeForegroundColor: { get() {
      return B || this.foregroundColor;
    }, set(o3) {
      B = o3;
    } }, separatorColor: { get() {
      return S || this.backgroundColor;
    }, set(o3) {
      S = o3;
    } }, positionAdjustBackgroundColor: { get() {
      return P || this.backgroundColor;
    }, set(o3) {
      P = o3;
    } }, positionAdjustForegroundColor: { get() {
      return L || this.foregroundColor;
    }, set(o3) {
      L = o3;
    } }, timingBackgroundColor: { get() {
      return D || this.backgroundColor;
    }, set(o3) {
      D = o3;
    } }, timingForegroundColor: { get() {
      return A || this.foregroundColor;
    }, set(o3) {
      A = o3;
    } }, typeNumberBackgroundColor: { get() {
      return E || this.backgroundColor;
    }, set(o3) {
      E = o3;
    } }, typeNumberForegroundColor: { get() {
      return T || this.foregroundColor;
    }, set(o3) {
      T = o3;
    } }, darkBlockColor: { get() {
      return N || this.foregroundColor;
    }, set(o3) {
      N = o3;
    } }, canvasContext: { get() {
      if (void 0 === M)
        throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", "[uQRCode]: use drawCanvas, you need to set the canvasContext!"), new b.Error("use drawCanvas, you need to set the canvasContext!");
      return M;
    }, set(o3) {
      M = C(o3);
    } } }), b.plugins.forEach((o3) => o3(b, this, false)), o2 && this.setOptions(o2), e2 && (this.canvasContext = C(e2));
  }
  f.prototype = { get: function(o2) {
    return this.num[o2];
  }, getLength: function() {
    return this.num.length;
  }, multiply: function(o2) {
    for (var e2 = new Array(this.getLength() + o2.getLength() - 1), r2 = 0; r2 < this.getLength(); r2++)
      for (var t2 = 0; t2 < o2.getLength(); t2++)
        e2[r2 + t2] ^= c.gexp(c.glog(this.get(r2)) + c.glog(o2.get(t2)));
    return new f(e2, 0);
  }, mod: function(o2) {
    if (this.getLength() - o2.getLength() < 0)
      return this;
    for (var e2 = c.glog(this.get(0)) - c.glog(o2.get(0)), r2 = new Array(this.getLength()), t2 = 0; t2 < this.getLength(); t2++)
      r2[t2] = this.get(t2);
    for (t2 = 0; t2 < o2.getLength(); t2++)
      r2[t2] ^= c.gexp(c.glog(o2.get(t2)) + e2);
    return new f(r2, 0).mod(o2);
  } }, v.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], v.getRSBlocks = function(o2, e2) {
    var r2 = v.getRsBlockTable(o2, e2);
    if (null == r2)
      throw new Error("bad rs block @ typeNumber:" + o2 + "/errorCorrectLevel:" + e2);
    for (var t2 = r2.length / 3, i2 = new Array(), n2 = 0; n2 < t2; n2++)
      for (var a2 = r2[3 * n2 + 0], d2 = r2[3 * n2 + 1], u2 = r2[3 * n2 + 2], s2 = 0; s2 < a2; s2++)
        i2.push(new v(d2, u2));
    return i2;
  }, v.getRsBlockTable = function(o2, e2) {
    switch (e2) {
      case t.L:
        return v.RS_BLOCK_TABLE[4 * (o2 - 1) + 0];
      case t.M:
        return v.RS_BLOCK_TABLE[4 * (o2 - 1) + 1];
      case t.Q:
        return v.RS_BLOCK_TABLE[4 * (o2 - 1) + 2];
      case t.H:
        return v.RS_BLOCK_TABLE[4 * (o2 - 1) + 3];
      default:
        return;
    }
  }, p.prototype = { get: function(o2) {
    var e2 = Math.floor(o2 / 8);
    return 1 == (this.buffer[e2] >>> 7 - o2 % 8 & 1);
  }, put: function(o2, e2) {
    for (var r2 = 0; r2 < e2; r2++)
      this.putBit(1 == (o2 >>> e2 - r2 - 1 & 1));
  }, getLengthInBits: function() {
    return this.length;
  }, putBit: function(o2) {
    var e2 = Math.floor(this.length / 8);
    this.buffer.length <= e2 && this.buffer.push(0), o2 && (this.buffer[e2] |= 128 >>> this.length % 8), this.length++;
  } }, e.errorCorrectLevel = t, b.errorCorrectLevel = e.errorCorrectLevel, b.Error = function(o2) {
    this.errMsg = "[uQRCode]: " + o2;
  }, b.plugins = [], b.use = function(o2) {
    "function" == typeof o2 && b.plugins.push(o2);
  }, b.prototype.loadImage = function(o2) {
    return Promise.resolve(o2);
  }, b.prototype.setOptions = function(o2) {
    var e2, r2, t2, i2, n2, a2, d2, u2, s2, g2, l2, h2, c2, m2, f2, v2, p2, C2, b2, k, y, w, I, B, S, P, L, D, A, E, T, N, M, z, R, _, O, F, x, H, X, Y, j, W, G, K, Q, U, $, J, q, V, Z, oo, eo, ro;
    o2 && (Object.keys(o2).forEach((e3) => {
      this[e3] = o2[e3];
    }), function(o3 = {}, e3 = {}, r3 = false) {
      let t3;
      t3 = r3 ? o3 : { ...o3 };
      for (let o4 in e3) {
        var i3 = e3[o4];
        null != i3 && (i3.constructor == Object ? t3[o4] = this.deepReplace(t3[o4], i3) : i3.constructor != String || i3 ? t3[o4] = i3 : t3[o4] = t3[o4]);
      }
    }(this, { data: o2.data || o2.text, size: o2.size, useDynamicSize: o2.useDynamicSize, typeNumber: o2.typeNumber, errorCorrectLevel: o2.errorCorrectLevel, margin: o2.margin, areaColor: o2.areaColor, backgroundColor: o2.backgroundColor || (null === (e2 = o2.background) || void 0 === e2 ? void 0 : e2.color), backgroundImageSrc: o2.backgroundImageSrc || (null === (r2 = o2.background) || void 0 === r2 || null === (t2 = r2.image) || void 0 === t2 ? void 0 : t2.src), backgroundImageWidth: o2.backgroundImageWidth || (null === (i2 = o2.background) || void 0 === i2 || null === (n2 = i2.image) || void 0 === n2 ? void 0 : n2.width), backgroundImageHeight: o2.backgroundImageHeight || (null === (a2 = o2.background) || void 0 === a2 || null === (d2 = a2.image) || void 0 === d2 ? void 0 : d2.height), backgroundImageX: o2.backgroundImageX || (null === (u2 = o2.background) || void 0 === u2 || null === (s2 = u2.image) || void 0 === s2 ? void 0 : s2.x), backgroundImageY: o2.backgroundImageY || (null === (g2 = o2.background) || void 0 === g2 || null === (l2 = g2.image) || void 0 === l2 ? void 0 : l2.y), backgroundImageAlpha: o2.backgroundImageAlpha || (null === (h2 = o2.background) || void 0 === h2 || null === (c2 = h2.image) || void 0 === c2 ? void 0 : c2.alpha), backgroundImageBorderRadius: o2.backgroundImageBorderRadius || (null === (m2 = o2.background) || void 0 === m2 || null === (f2 = m2.image) || void 0 === f2 ? void 0 : f2.borderRadius), backgroundPadding: o2.backgroundPadding, foregroundColor: o2.foregroundColor || (null === (v2 = o2.foreground) || void 0 === v2 ? void 0 : v2.color), foregroundImageSrc: o2.foregroundImageSrc || (null === (p2 = o2.foreground) || void 0 === p2 || null === (C2 = p2.image) || void 0 === C2 ? void 0 : C2.src), foregroundImageWidth: o2.foregroundImageWidth || (null === (b2 = o2.foreground) || void 0 === b2 || null === (k = b2.image) || void 0 === k ? void 0 : k.width), foregroundImageHeight: o2.foregroundImageHeight || (null === (y = o2.foreground) || void 0 === y || null === (w = y.image) || void 0 === w ? void 0 : w.height), foregroundImageX: o2.foregroundImageX || (null === (I = o2.foreground) || void 0 === I || null === (B = I.image) || void 0 === B ? void 0 : B.x), foregroundImageY: o2.foregroundImageY || (null === (S = o2.foreground) || void 0 === S || null === (P = S.image) || void 0 === P ? void 0 : P.y), foregroundImagePadding: o2.foregroundImagePadding || (null === (L = o2.foreground) || void 0 === L || null === (D = L.image) || void 0 === D ? void 0 : D.padding), foregroundImageBackgroundColor: o2.foregroundImageBackgroundColor || (null === (A = o2.foreground) || void 0 === A || null === (E = A.image) || void 0 === E ? void 0 : E.backgroundColor), foregroundImageBorderRadius: o2.foregroundImageBorderRadius || (null === (T = o2.foreground) || void 0 === T || null === (N = T.image) || void 0 === N ? void 0 : N.borderRadius), foregroundImageShadowOffsetX: o2.foregroundImageShadowOffsetX || (null === (M = o2.foreground) || void 0 === M || null === (z = M.image) || void 0 === z ? void 0 : z.shadowOffsetX), foregroundImageShadowOffsetY: o2.foregroundImageShadowOffsetY || (null === (R = o2.foreground) || void 0 === R || null === (_ = R.image) || void 0 === _ ? void 0 : _.shadowOffsetY), foregroundImageShadowBlur: o2.foregroundImageShadowBlur || (null === (O = o2.foreground) || void 0 === O || null === (F = O.image) || void 0 === F ? void 0 : F.shadowBlur), foregroundImageShadowColor: o2.foregroundImageShadowColor || (null === (x = o2.foreground) || void 0 === x || null === (H = x.image) || void 0 === H ? void 0 : H.shadowColor), foregroundPadding: o2.foregroundPadding, positionProbeBackgroundColor: o2.positionProbeBackgroundColor || (null === (X = o2.positionProbe) || void 0 === X ? void 0 : X.backgroundColor) || (null === (Y = o2.positionDetection) || void 0 === Y ? void 0 : Y.backgroundColor), positionProbeForegroundColor: o2.positionProbeForegroundColor || (null === (j = o2.positionProbe) || void 0 === j ? void 0 : j.foregroundColor) || (null === (W = o2.positionDetection) || void 0 === W ? void 0 : W.foregroundColor), separatorColor: o2.separatorColor || (null === (G = o2.separator) || void 0 === G ? void 0 : G.color), positionAdjustBackgroundColor: o2.positionAdjustBackgroundColor || (null === (K = o2.positionAdjust) || void 0 === K ? void 0 : K.backgroundColor) || (null === (Q = o2.alignment) || void 0 === Q ? void 0 : Q.backgroundColor), positionAdjustForegroundColor: o2.positionAdjustForegroundColor || (null === (U = o2.positionAdjust) || void 0 === U ? void 0 : U.foregroundColor) || (null === ($ = o2.alignment) || void 0 === $ ? void 0 : $.foregroundColor), timingBackgroundColor: o2.timingBackgroundColor || (null === (J = o2.timing) || void 0 === J ? void 0 : J.backgroundColor), timingForegroundColor: o2.timingForegroundColor || (null === (q = o2.timing) || void 0 === q ? void 0 : q.foregroundColor), typeNumberBackgroundColor: o2.typeNumberBackgroundColor || (null === (V = o2.typeNumber) || void 0 === V ? void 0 : V.backgroundColor) || (null === (Z = o2.versionInformation) || void 0 === Z ? void 0 : Z.backgroundColor), typeNumberForegroundColor: o2.typeNumberForegroundColor || (null === (oo = o2.typeNumber) || void 0 === oo ? void 0 : oo.foregroundColor) || (null === (eo = o2.versionInformation) || void 0 === eo ? void 0 : eo.foregroundColor), darkBlockColor: o2.darkBlockColor || (null === (ro = o2.darkBlock) || void 0 === ro ? void 0 : ro.color) }, true));
  }, b.prototype.make = function() {
    let { foregroundColor: o2, backgroundColor: r2, typeNumber: t2, errorCorrectLevel: i2, data: n2, size: a2, margin: d2, useDynamicSize: u2 } = this;
    if (o2 === r2)
      throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", "[uQRCode]: foregroundColor and backgroundColor cannot be the same!"), new b.Error("foregroundColor and backgroundColor cannot be the same!");
    var s2 = new e(t2, i2);
    s2.addData(function(o3) {
      o3 = o3.toString();
      for (var e2, r3 = "", t3 = 0; t3 < o3.length; t3++)
        (e2 = o3.charCodeAt(t3)) >= 1 && e2 <= 127 ? r3 += o3.charAt(t3) : e2 > 2047 ? (r3 += String.fromCharCode(224 | e2 >> 12 & 15), r3 += String.fromCharCode(128 | e2 >> 6 & 63), r3 += String.fromCharCode(128 | e2 >> 0 & 63)) : (r3 += String.fromCharCode(192 | e2 >> 6 & 31), r3 += String.fromCharCode(128 | e2 >> 0 & 63));
      return r3;
    }(n2)), s2.make(), this.base = s2, this.typeNumber = s2.typeNumber, this.modules = s2.modules, this.moduleCount = s2.moduleCount, this.dynamicSize = u2 ? Math.ceil((a2 - 2 * d2) / s2.moduleCount) * s2.moduleCount + 2 * d2 : a2, function(o3) {
      let { dynamicSize: e2, margin: r3, backgroundColor: t3, backgroundPadding: i3, foregroundColor: n3, foregroundPadding: a3, modules: d3, moduleCount: u3 } = o3, s3 = (e2 - 2 * r3) / u3, g2 = s3, l2 = 0;
      i3 > 0 && (l2 = g2 * i3 / 2, g2 -= 2 * l2);
      let h2 = s3, c2 = 0;
      a3 > 0 && (c2 = h2 * a3 / 2, h2 -= 2 * c2);
      for (var m2 = 0; m2 < u3; m2++)
        for (var f2 = 0; f2 < u3; f2++) {
          var v2 = f2 * s3 + r3, p2 = m2 * s3 + r3;
          if (d3[m2][f2]) {
            var C2 = c2, b2 = v2 + c2, k = p2 + c2, y = h2, w = h2;
            d3[m2][f2] = { type: ["foreground"], color: n3, isBlack: true, isDrawn: false, destX: v2, destY: p2, destWidth: s3, destHeight: s3, x: b2, y: k, width: y, height: w, paddingTop: C2, paddingRight: C2, paddingBottom: C2, paddingLeft: C2 };
          } else
            C2 = l2, b2 = v2 + l2, k = p2 + l2, y = g2, w = g2, d3[m2][f2] = { type: ["background"], color: t3, isBlack: false, isDrawn: false, destX: v2, destY: p2, destWidth: s3, destHeight: s3, x: b2, y: k, width: y, height: w, paddingTop: C2, paddingRight: C2, paddingBottom: C2, paddingLeft: C2 };
        }
    }(this), function(o3) {
      let { modules: e2, moduleCount: r3, positionProbeBackgroundColor: t3, positionProbeForegroundColor: i3 } = o3, n3 = r3 - 7;
      [[0, 0, 1], [1, 0, 1], [2, 0, 1], [3, 0, 1], [4, 0, 1], [5, 0, 1], [6, 0, 1], [0, 1, 1], [1, 1, 0], [2, 1, 0], [3, 1, 0], [4, 1, 0], [5, 1, 0], [6, 1, 1], [0, 2, 1], [1, 2, 0], [2, 2, 1], [3, 2, 1], [4, 2, 1], [5, 2, 0], [6, 2, 1], [0, 3, 1], [1, 3, 0], [2, 3, 1], [3, 3, 1], [4, 3, 1], [5, 3, 0], [6, 3, 1], [0, 4, 1], [1, 4, 0], [2, 4, 1], [3, 4, 1], [4, 4, 1], [5, 4, 0], [6, 4, 1], [0, 5, 1], [1, 5, 0], [2, 5, 0], [3, 5, 0], [4, 5, 0], [5, 5, 0], [6, 5, 1], [0, 6, 1], [1, 6, 1], [2, 6, 1], [3, 6, 1], [4, 6, 1], [5, 6, 1], [6, 6, 1]].forEach((o4) => {
        var r4 = e2[o4[0]][o4[1]], a3 = e2[o4[0] + n3][o4[1]], d3 = e2[o4[0]][o4[1] + n3];
        d3.type.push("positionProbe"), a3.type.push("positionProbe"), r4.type.push("positionProbe"), r4.color = 1 == o4[2] ? i3 : t3, a3.color = 1 == o4[2] ? i3 : t3, d3.color = 1 == o4[2] ? i3 : t3;
      });
    }(this), function(o3) {
      let { modules: e2, moduleCount: r3, separatorColor: t3 } = o3;
      [[7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7], [0, 7], [1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]].forEach((o4) => {
        var i3 = e2[o4[0]][o4[1]], n3 = e2[r3 - o4[0] - 1][o4[1]], a3 = e2[o4[0]][r3 - o4[1] - 1];
        a3.type.push("separator"), n3.type.push("separator"), i3.type.push("separator"), i3.color = t3, n3.color = t3, a3.color = t3;
      });
    }(this), function(o3) {
      let { typeNumber: e2, modules: r3, moduleCount: t3, foregroundColor: i3, backgroundColor: n3, positionAdjustForegroundColor: a3, positionAdjustBackgroundColor: d3, timingForegroundColor: u3, timingBackgroundColor: s3 } = o3;
      const g2 = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]][e2 - 1];
      if (g2) {
        const o4 = [[-2, -2, 1], [-1, -2, 1], [0, -2, 1], [1, -2, 1], [2, -2, 1], [-2, -1, 1], [-1, -1, 0], [0, -1, 0], [1, -1, 0], [2, -1, 1], [-2, 0, 1], [-1, 0, 0], [0, 0, 1], [1, 0, 0], [2, 0, 1], [-2, 1, 1], [-1, 1, 0], [0, 1, 0], [1, 1, 0], [2, 1, 1], [-2, 2, 1], [-1, 2, 1], [0, 2, 1], [1, 2, 1], [2, 2, 1]], e3 = g2.length;
        for (let l2 = 0; l2 < e3; l2++)
          for (let h2 = 0; h2 < e3; h2++) {
            let { x: e4, y: c2 } = { x: g2[l2], y: g2[h2] };
            e4 < 9 && c2 < 9 || e4 > t3 - 9 - 1 && c2 < 9 || c2 > t3 - 9 - 1 && e4 < 9 || o4.forEach((o5) => {
              var t4 = r3[e4 + o5[0]][c2 + o5[1]];
              t4.type.push("positionAdjust"), t4.type.includes("timing") ? 1 == o5[2] ? t4.color = a3 == i3 ? u3 : a3 : t4.color = a3 == i3 && d3 == n3 ? s3 : d3 : t4.color = 1 == o5[2] ? a3 : d3;
            });
          }
      }
    }(this), function(o3) {
      let { modules: e2, moduleCount: r3, timingForegroundColor: t3, timingBackgroundColor: i3 } = o3, n3 = r3 - 16;
      for (let o4 = 0; o4 < n3; o4++) {
        var a3 = e2[6][8 + o4], d3 = e2[8 + o4][6];
        a3.type.push("timing"), d3.type.push("timing"), a3.color = 1 & o4 ^ 1 ? t3 : i3, d3.color = 1 & o4 ^ 1 ? t3 : i3;
      }
    }(this), function(o3) {
      let { modules: e2, moduleCount: r3, darkBlockColor: t3 } = o3;
      var i3 = e2[r3 - 7 - 1][8];
      i3.type.push("darkBlock"), i3.color = t3;
    }(this), function(o3) {
      let { typeNumber: e2, modules: r3, moduleCount: t3, typeNumberBackgroundColor: i3, typeNumberForegroundColor: n3 } = o3;
      if (e2 < 7)
        return r3;
      const a3 = [0, 0, 0, 0, 0, 0, 0, "000111110010010100", "001000010110111100", "001001101010011001", "001010010011010011", "001011101111110110", "001100011101100010", "001101100001000111", "001110011000001101", "001111100100101000", "010000101101111000", "010001010001011101", "010010101000010111", "010011010100110010", "010100100110100110", "010101011010000011", "010110100011001001", "010111011111101100", "011000111011000100", "011001000111100001", "011010111110101011", "011011000010001110", "011100110000011010", "011101001100111111", "011110110101110101", "011111001001010000", "100000100111010101", "100001011011110000", "100010100010111010", "100011011110011111", "100100101100001011", "100101010000101110", "100110101001100100", "100111010101000001", "101000110001101001"];
      let d3 = a3[e2] + a3[e2], u3 = [t3 - 11, t3 - 10, t3 - 9];
      [[5, u3[2]], [5, u3[1]], [5, u3[0]], [4, u3[2]], [4, u3[1]], [4, u3[0]], [3, u3[2]], [3, u3[1]], [3, u3[0]], [2, u3[2]], [2, u3[1]], [2, u3[0]], [1, u3[2]], [1, u3[1]], [1, u3[0]], [0, u3[2]], [0, u3[1]], [0, u3[0]], [u3[2], 5], [u3[1], 5], [u3[0], 5], [u3[2], 4], [u3[1], 4], [u3[0], 4], [u3[2], 3], [u3[1], 3], [u3[0], 3], [u3[2], 2], [u3[1], 2], [u3[0], 2], [u3[2], 1], [u3[1], 1], [u3[0], 1], [u3[2], 0], [u3[1], 0], [u3[0], 0]].forEach((o4, e3) => {
        var t4 = r3[o4[0]][o4[1]];
        t4.type.push("typeNumber"), t4.color = "1" == d3[e3] ? n3 : i3;
      });
    }(this), this.isMaked = true, this.drawModules = [];
  }, b.prototype.getDrawModules = function() {
    if (this.drawModules && this.drawModules.length > 0)
      return this.drawModules;
    let o2 = this.drawModules = [], { modules: e2, moduleCount: r2, dynamicSize: t2, areaColor: i2, backgroundImageSrc: n2, backgroundImageX: a2, backgroundImageY: d2, backgroundImageWidth: u2, backgroundImageHeight: s2, backgroundImageAlpha: g2, backgroundImageBorderRadius: l2, foregroundImageSrc: h2, foregroundImageX: c2, foregroundImageY: m2, foregroundImageWidth: f2, foregroundImageHeight: v2, foregroundImagePadding: p2, foregroundImageBackgroundColor: C2, foregroundImageBorderRadius: b2, foregroundImageShadowOffsetX: k, foregroundImageShadowOffsetY: y, foregroundImageShadowBlur: w, foregroundImageShadowColor: I } = this;
    i2 && o2.push({ name: "area", type: "area", color: i2, x: 0, y: 0, width: t2, height: t2 }), n2 && o2.push({ name: "backgroundImage", type: "image", imageSrc: n2, mappingName: "backgroundImageSrc", x: a2, y: d2, width: u2, height: s2, alpha: g2, borderRadius: l2 });
    for (var B = 0; B < r2; B++)
      for (var S = 0; S < r2; S++) {
        var P = e2[B][S];
        P.isDrawn || (P.type.includes("foreground") ? o2.push({ name: "foreground", type: "tile", color: P.color, destX: P.destX, destY: P.destY, destWidth: P.destWidth, destHeight: P.destHeight, x: P.x, y: P.y, width: P.width, height: P.height, paddingTop: P.paddingTop, paddingRight: P.paddingRight, paddingBottom: P.paddingBottom, paddingLeft: P.paddingLeft, rowIndex: B, colIndex: S }) : o2.push({ name: "background", type: "tile", color: P.color, destX: P.destX, destY: P.destY, destWidth: P.destWidth, destHeight: P.destHeight, x: P.x, y: P.y, width: P.width, height: P.height, paddingTop: P.paddingTop, paddingRight: P.paddingRight, paddingBottom: P.paddingBottom, paddingLeft: P.paddingLeft, rowIndex: B, colIndex: S }), P.isDrawn = true);
      }
    return h2 && o2.push({ name: "foregroundImage", type: "image", imageSrc: h2, mappingName: "foregroundImageSrc", x: c2, y: m2, width: f2, height: v2, padding: p2, backgroundColor: C2, borderRadius: b2, shadowOffsetX: k, shadowOffsetY: y, shadowBlur: w, shadowColor: I }), o2;
  }, b.prototype.isBlack = function(o2, e2) {
    var r2 = this.moduleCount;
    return !(0 > o2 || 0 > e2 || o2 >= r2 || e2 >= r2) && this.modules[o2][e2].isBlack;
  }, b.prototype.drawCanvas = function() {
    let { isMaked: o2, canvasContext: e2, useDynamicSize: r2, dynamicSize: t2, foregroundColor: i2, foregroundPadding: n2, backgroundColor: a2, backgroundPadding: d2, drawReserve: u2, margin: s2 } = this;
    if (!o2)
      return formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", "[uQRCode]: please execute the make method first!"), Promise.reject(new b.Error("please execute the make method first!"));
    let g2 = this.getDrawModules(), l2 = async (o3, r3) => {
      try {
        e2.clearRect(0, 0, t2, t2), e2.draw(false);
        for (var i3 = 0; i3 < g2.length; i3++) {
          var n3 = g2[i3];
          switch (e2.save(), n3.type) {
            case "area":
              e2.setFillStyle(n3.color), e2.fillRect(n3.x, n3.y, n3.width, n3.height);
              break;
            case "tile":
              var a3 = n3.x, d3 = n3.y, s3 = n3.width, l3 = n3.height;
              e2.setFillStyle(n3.color), e2.fillRect(a3, d3, s3, l3);
              break;
            case "image":
              if ("backgroundImage" === n3.name) {
                a3 = Math.round(n3.x), d3 = Math.round(n3.y), s3 = Math.round(n3.width), l3 = Math.round(n3.height);
                s3 < 2 * (c2 = Math.round(n3.borderRadius)) && (c2 = s3 / 2), l3 < 2 * c2 && (c2 = l3 / 2), e2.setGlobalAlpha(n3.alpha), c2 > 0 && (e2.beginPath(), e2.moveTo(a3 + c2, d3), e2.arcTo(a3 + s3, d3, a3 + s3, d3 + l3, c2), e2.arcTo(a3 + s3, d3 + l3, a3, d3 + l3, c2), e2.arcTo(a3, d3 + l3, a3, d3, c2), e2.arcTo(a3, d3, a3 + s3, d3, c2), e2.closePath(), e2.setStrokeStyle("rgba(0,0,0,0)"), e2.stroke(), e2.clip());
                try {
                  var h2 = await this.loadImage(n3.imageSrc);
                  e2.drawImage(h2, a3, d3, s3, l3);
                } catch (o4) {
                  throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", `[uQRCode]: ${n3.mappingName} invalid!`), new b.Error(`${n3.mappingName} invalid!`);
                }
              } else if ("foregroundImage" === n3.name) {
                a3 = Math.round(n3.x), d3 = Math.round(n3.y), s3 = Math.round(n3.width), l3 = Math.round(n3.height);
                var c2, m2 = Math.round(n3.padding);
                s3 < 2 * (c2 = Math.round(n3.borderRadius)) && (c2 = s3 / 2), l3 < 2 * c2 && (c2 = l3 / 2);
                var f2 = a3 - m2, v2 = d3 - m2, p2 = s3 + 2 * m2, C2 = l3 + 2 * m2, k = Math.round(p2 / s3 * c2);
                p2 < 2 * k && (k = p2 / 2), C2 < 2 * k && (k = C2 / 2), e2.save(), e2.setShadow(n3.shadowOffsetX, n3.shadowOffsetY, n3.shadowBlur, n3.shadowColor), k > 0 ? (e2.beginPath(), e2.moveTo(f2 + k, v2), e2.arcTo(f2 + p2, v2, f2 + p2, v2 + C2, k), e2.arcTo(f2 + p2, v2 + C2, f2, v2 + C2, k), e2.arcTo(f2, v2 + C2, f2, v2, k), e2.arcTo(f2, v2, f2 + p2, v2, k), e2.closePath(), e2.setFillStyle(n3.backgroundColor), e2.fill()) : (e2.setFillStyle(n3.backgroundColor), e2.fillRect(f2, v2, p2, C2)), e2.restore(), e2.save(), k > 0 ? (e2.beginPath(), e2.moveTo(f2 + k, v2), e2.arcTo(f2 + p2, v2, f2 + p2, v2 + C2, k), e2.arcTo(f2 + p2, v2 + C2, f2, v2 + C2, k), e2.arcTo(f2, v2 + C2, f2, v2, k), e2.arcTo(f2, v2, f2 + p2, v2, k), e2.closePath(), e2.setFillStyle(m2 > 0 ? n3.backgroundColor : "rgba(0,0,0,0)"), e2.fill()) : (e2.setFillStyle(m2 > 0 ? n3.backgroundColor : "rgba(0,0,0,0)"), e2.fillRect(f2, v2, p2, C2)), e2.restore(), c2 > 0 && (e2.beginPath(), e2.moveTo(a3 + c2, d3), e2.arcTo(a3 + s3, d3, a3 + s3, d3 + l3, c2), e2.arcTo(a3 + s3, d3 + l3, a3, d3 + l3, c2), e2.arcTo(a3, d3 + l3, a3, d3, c2), e2.arcTo(a3, d3, a3 + s3, d3, c2), e2.closePath(), e2.setStrokeStyle("rgba(0,0,0,0)"), e2.stroke(), e2.clip());
                try {
                  h2 = await this.loadImage(n3.imageSrc);
                  e2.drawImage(h2, a3, d3, s3, l3);
                } catch (o4) {
                  throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", `[uQRCode]: ${n3.mappingName} invalid!`), new b.Error(`${n3.mappingName} invalid!`);
                }
              }
          }
          u2 && e2.draw(true), e2.restore();
        }
        e2.draw(true), setTimeout(o3, 150);
      } catch (o4) {
        if (!(o4 instanceof b.Error))
          throw o4;
        r3(o4);
      }
    };
    return new Promise((o3, e3) => {
      l2(o3, e3);
    });
  }, b.prototype.draw = function() {
    return this.drawCanvas();
  }, b.prototype.register = function(o2) {
    o2 && o2(b, this, true);
  };
  function Queue() {
    let waitingQueue = this.waitingQueue = [];
    let isRunning = this.isRunning = false;
    function execute(task, resolve, reject) {
      task().then((data) => {
        resolve(data);
      }).catch((e2) => {
        reject(e2);
      }).finally(() => {
        if (waitingQueue.length) {
          const next = waitingQueue.shift();
          execute(next.task, next.resolve, next.reject);
        } else {
          isRunning = false;
        }
      });
    }
    this.exec = function(task) {
      return new Promise((resolve, reject) => {
        if (isRunning) {
          waitingQueue.push({
            task,
            resolve,
            reject
          });
        } else {
          isRunning = true;
          execute(task, resolve, reject);
        }
      });
    };
  }
  const queueDraw = new Queue();
  const queueLoadImage = new Queue();
  const cacheImageList = [];
  let instance = null;
  const _sfc_main$2 = {
    name: "uv-qrcode",
    mixins: [mpMixin, mixin, props],
    emits: ["click", "change", "complete"],
    data() {
      return {
        canvasId: "",
        canvas: void 0,
        canvasType: void 0,
        canvasContext: void 0,
        makeDelegate: void 0,
        drawDelegate: void 0,
        toTempFilePathDelegate: void 0,
        makeExecuted: false,
        makeing: false,
        drawing: false,
        isError: false,
        error: void 0,
        isH5Save: false,
        tempFilePath: "",
        templateOptions: {
          size: 0,
          width: 0,
          // 组件宽度
          height: 0,
          canvasWidth: 0,
          // canvas宽度
          canvasHeight: 0,
          canvasTransform: "",
          canvasDisplay: false
        },
        uqrcodeOptions: {
          data: ""
        },
        plugins: [],
        makeingPattern: [
          [
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true]
          ],
          [
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, true, true, true, false, true, true, true],
            [true, true, true, true, true, true, false, true, true, true],
            [true, true, true, true, true, true, false, true, true, true]
          ],
          [
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, true, true, true, true, false, false, false],
            [true, true, true, true, true, true, true, false, false, false],
            [true, true, true, true, true, true, true, false, false, false],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true]
          ],
          [
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true]
          ]
        ]
      };
    },
    watch: {
      type: {
        handler(val) {
          const types = ["2d"];
          if (types.includes(val)) {
            this.canvasType = val;
          } else {
            this.canvasType = void 0;
          }
        },
        immediate: true
      },
      value: {
        handler() {
          if (this.auto) {
            this.remake();
          }
        }
      },
      size: {
        handler() {
          if (this.auto) {
            this.remake();
          }
        }
      },
      options: {
        handler() {
          if (this.auto) {
            this.remake();
          }
        },
        deep: true
      },
      makeing: {
        handler(val) {
          if (!val) {
            if (typeof this.toTempFilePathDelegate === "function") {
              this.toTempFilePathDelegate();
            }
          }
        }
      }
    },
    created() {
      this.canvasId = this.$uv.guid();
    },
    mounted() {
      this.templateOptions.size = this.$uv.getPx(this.size);
      this.templateOptions.width = this.templateOptions.size;
      this.templateOptions.height = this.templateOptions.size;
      this.templateOptions.canvasWidth = this.templateOptions.size;
      this.templateOptions.canvasHeight = this.templateOptions.size;
      if (this.canvasType == "2d") {
        this.templateOptions.canvasTransform = `scale(${this.templateOptions.size / this.templateOptions.canvasWidth}, ${this.templateOptions.size / this.templateOptions.canvasHeight})`;
      } else {
        this.templateOptions.canvasTransform = `scale(${this.templateOptions.size / this.templateOptions.canvasWidth}, ${this.templateOptions.size / this.templateOptions.canvasHeight})`;
      }
      if (this.start) {
        this.$nextTick(() => {
          this.make();
        });
      }
    },
    methods: {
      /**
       * 获取模板选项
       */
      getTemplateOptions() {
        var size = this.$uv.getPx(this.size);
        return deepReplace(this.templateOptions, {
          size,
          width: size,
          height: size
        });
      },
      /**
       * 获取插件选项
       */
      getUqrcodeOptions() {
        return deepReplace(this.options, {
          data: String(this.value),
          size: Number(this.templateOptions.size)
        });
      },
      /**
       * 重置画布
       */
      resetCanvas(callback) {
        this.templateOptions.canvasDisplay = false;
        this.$nextTick(() => {
          this.templateOptions.canvasDisplay = true;
          this.$nextTick(() => {
            callback && callback();
          });
        });
      },
      /**
       * 绘制二维码
       */
      async draw(callback = {}, isDrawDelegate = false) {
        if (typeof callback.success != "function") {
          callback.success = () => {
          };
        }
        if (typeof callback.fail != "function") {
          callback.fail = () => {
          };
        }
        if (typeof callback.complete != "function") {
          callback.complete = () => {
          };
        }
        if (this.drawing) {
          if (!isDrawDelegate) {
            this.drawDelegate = () => {
              this.draw(callback, true);
            };
            return;
          }
        } else {
          this.drawing = true;
        }
        if (!this.canvasId) {
          formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:325", "[uQRCode]: canvasId must be set!");
          this.isError = true;
          this.drawing = false;
          callback.fail({
            errMsg: "[uQRCode]: canvasId must be set!"
          });
          callback.complete({
            errMsg: "[uQRCode]: canvasId must be set!"
          });
          return;
        }
        if (!this.value) {
          formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:337", "[uQRCode]: value must be set!");
          this.isError = true;
          this.drawing = false;
          callback.fail({
            errMsg: "[uQRCode]: value must be set!"
          });
          callback.complete({
            errMsg: "[uQRCode]: value must be set!"
          });
          return;
        }
        this.templateOptions = this.getTemplateOptions();
        this.uqrcodeOptions = this.getUqrcodeOptions();
        if (typeof this.uqrcodeOptions.errorCorrectLevel === "string") {
          this.uqrcodeOptions.errorCorrectLevel = b.errorCorrectLevel[this.uqrcodeOptions.errorCorrectLevel];
        }
        if (typeof this.options.useDynamicSize === "undefined") {
          this.uqrcodeOptions.useDynamicSize = true;
        }
        const qr = instance = new b();
        this.plugins.forEach((p2) => qr.register(p2.plugin));
        qr.setOptions(this.uqrcodeOptions);
        qr.make();
        let canvasContext = null;
        if (this.canvasType === "2d") {
          canvasContext = this.canvasContext = uni.createCanvasContext(this.canvasId, this);
          this.templateOptions.canvasWidth = qr.dynamicSize;
          this.templateOptions.canvasHeight = qr.dynamicSize;
          this.templateOptions.canvasTransform = `scale(${this.templateOptions.size / this.templateOptions.canvasWidth}, ${this.templateOptions.size / this.templateOptions.canvasHeight})`;
          qr.loadImage = this.getLoadImage(function(src) {
            return new Promise((resolve, reject) => {
              if (src.startsWith("http")) {
                uni.getImageInfo({
                  src,
                  success: (res) => {
                    resolve(res.path);
                  },
                  fail: (err) => {
                    reject(err);
                  }
                });
              } else {
                if (src.startsWith(".")) {
                  formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:448", "[uQRCode]: 本地图片路径仅支持绝对路径！");
                  throw new Error("[uQRCode]: local image path only supports absolute path!");
                } else {
                  resolve(src);
                }
              }
            });
          });
        } else {
          canvasContext = this.canvasContext = uni.createCanvasContext(this.canvasId, this);
          this.templateOptions.canvasWidth = qr.dynamicSize;
          this.templateOptions.canvasHeight = qr.dynamicSize;
          this.templateOptions.canvasTransform = `scale(${this.templateOptions.size / this.templateOptions.canvasWidth}, ${this.templateOptions.size / this.templateOptions.canvasHeight})`;
          qr.loadImage = this.getLoadImage(function(src) {
            return new Promise((resolve, reject) => {
              if (src.startsWith("http")) {
                uni.getImageInfo({
                  src,
                  success: (res) => {
                    resolve(res.path);
                  },
                  fail: (err) => {
                    reject(err);
                  }
                });
              } else {
                if (src.startsWith(".")) {
                  formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:481", "[uQRCode]: 本地图片路径仅支持绝对路径！");
                  throw new Error("[uQRCode]: local image path only supports absolute path!");
                } else {
                  resolve(src);
                }
              }
            });
          });
        }
        qr.canvasContext = canvasContext;
        setTimeout(() => {
          var plugin = this.plugins.find((p2) => p2.name == qr.style);
          var drawCanvasName = plugin ? plugin.drawCanvas : "drawCanvas";
          var drawCanvas;
          if (this.queue) {
            drawCanvas = () => queueDraw.exec(() => qr[drawCanvasName]());
          } else {
            drawCanvas = () => qr[drawCanvasName]();
          }
          drawCanvas().then(() => {
            if (this.drawDelegate) {
              let delegate = this.drawDelegate;
              this.drawDelegate = void 0;
              delegate();
            } else {
              this.drawing = false;
              callback.success();
            }
          }).catch((err) => {
            formatAppLog("log", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:553", err);
            if (this.drawDelegate) {
              let delegate = this.drawDelegate;
              this.drawDelegate = void 0;
              delegate();
            } else {
              this.drawing = false;
              this.isError = true;
              callback.fail(err);
            }
          }).finally(() => {
            callback.complete();
          });
        }, 300);
      },
      /**
       * 生成二维码
       */
      make(callback = {}) {
        this.makeExecuted = true;
        this.makeing = true;
        this.isError = false;
        if (typeof callback.success != "function") {
          callback.success = () => {
          };
        }
        if (typeof callback.fail != "function") {
          callback.fail = () => {
          };
        }
        if (typeof callback.complete != "function") {
          callback.complete = () => {
          };
        }
        this.resetCanvas(() => {
          clearTimeout(this.makeDelegate);
          this.makeDelegate = setTimeout(() => {
            this.draw({
              success: () => {
                setTimeout(() => {
                  callback.success();
                  this.complete(true);
                }, 300);
              },
              fail: (err) => {
                callback.fail(err);
                this.error = err;
                this.complete(false, err.errMsg);
              },
              complete: () => {
                callback.complete();
                this.makeing = false;
              }
            });
          }, 300);
        });
      },
      /**
       * 重新生成
       */
      remake(callback) {
        this.$emit("change");
        this.make(callback);
      },
      /**
       * 生成完成
       */
      complete(success = true, errMsg = "") {
        if (success) {
          this.$emit("complete", {
            success
          });
        } else {
          this.$emit("complete", {
            success,
            errMsg
          });
        }
      },
      /**
       * 导出临时路径
       */
      toTempFilePath(callback = {}) {
        if (typeof callback.success != "function") {
          callback.success = () => {
          };
        }
        if (typeof callback.fail != "function") {
          callback.fail = () => {
          };
        }
        if (typeof callback.complete != "function") {
          callback.complete = () => {
          };
        }
        if (!this.makeExecuted) {
          formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:648", "[uQRCode]: make() 方法从未调用！请先成功调用 make() 后再进行操作。");
          var err = {
            errMsg: "[uQRCode]: make() method has never been executed! please execute make() successfully before operating."
          };
          callback.fail(err);
          callback.complete(err);
          return;
        }
        if (this.isError) {
          callback.fail(this.error);
          callback.complete(this.error);
          return;
        }
        if (this.makeing) {
          this.toTempFilePathDelegate = () => {
            this.toTempFilePath(callback);
          };
          return;
        } else {
          this.toTempFilePathDelegate = null;
        }
        if (this.canvasType === "2d")
          ;
        else {
          uni.canvasToTempFilePath(
            {
              canvasId: this.canvasId,
              fileType: this.fileType,
              width: Number(this.templateOptions.canvasWidth),
              height: Number(this.templateOptions.canvasHeight),
              destWidth: Number(this.templateOptions.size),
              destHeight: Number(this.templateOptions.size),
              success: (res) => {
                callback.success(res);
              },
              fail: (err2) => {
                callback.fail(err2);
              },
              complete: () => {
                callback.complete();
              }
            },
            this
          );
        }
      },
      /**
       * 保存
       */
      save(callback = {}) {
        if (typeof callback.success != "function") {
          callback.success = () => {
          };
        }
        if (typeof callback.fail != "function") {
          callback.fail = () => {
          };
        }
        if (typeof callback.complete != "function") {
          callback.complete = () => {
          };
        }
        this.toTempFilePath({
          success: (res) => {
            if (this.canvasType === "2d")
              ;
            else {
              uni.saveImageToPhotosAlbum({
                filePath: res.tempFilePath,
                success: (res1) => {
                  callback.success(res1);
                },
                fail: (err1) => {
                  callback.fail(err1);
                },
                complete: () => {
                  callback.complete();
                }
              });
            }
          },
          fail: (err) => {
            callback.fail(err);
            callback.complete(err);
          }
        });
      },
      /**
       * 注册click事件
       */
      onClick(e2) {
        this.$emit("click", e2);
      },
      /**
       * 获取实例
       */
      getInstance() {
        return instance;
      },
      /**
       * 注册扩展，组件仅支持注册type为style的drawCanvas扩展
       * @param {Object} plugin
       */
      registerStyle(plugin) {
        if (plugin.Type != "style") {
          formatAppLog("warn", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:850", "[uQRCode]: registerStyle 仅支持注册 style 类型的扩展！");
          return {
            errMsg: "registerStyle 仅支持注册 style 类型的扩展！"
          };
        }
        if (typeof plugin === "function") {
          this.plugins.push({
            plugin,
            name: plugin.Name,
            drawCanvas: plugin.DrawCanvas
          });
        }
      },
      getLoadImage(loadImage) {
        var that = this;
        if (typeof loadImage == "function") {
          return function(src) {
            if (that.isQueueLoadImage) {
              return queueLoadImage.exec(() => {
                return new Promise((resolve, reject) => {
                  setTimeout(() => {
                    const cache2 = cacheImageList.find((x) => x.src == src);
                    if (cache2) {
                      resolve(cache2.img);
                    } else {
                      loadImage(src).then((img) => {
                        cacheImageList.push({
                          src,
                          img
                        });
                        resolve(img);
                      }).catch((err) => {
                        reject(err);
                      });
                    }
                  }, 10);
                });
              });
            } else {
              return loadImage(src);
            }
          };
        } else {
          return function(src) {
            return Promise.resolve(src);
          };
        }
      }
    }
  };
  function deepReplace(o2 = {}, r2 = {}, c2 = false) {
    let obj;
    if (c2) {
      obj = o2;
    } else {
      obj = {
        ...o2
      };
    }
    for (let k in r2) {
      var vr = r2[k];
      if (vr != void 0) {
        if (vr.constructor == Object) {
          obj[k] = this.deepReplace(obj[k], vr);
        } else if (vr.constructor == String && !vr) {
          obj[k] = obj[k];
        } else {
          obj[k] = vr;
        }
      }
    }
    return obj;
  }
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["uqrcode", { "uqrcode-hide": _ctx.hide }]),
        style: vue.normalizeStyle({ width: `${$data.templateOptions.width}px`, height: `${$data.templateOptions.height}px` })
      },
      [
        vue.createElementVNode("view", { class: "uqrcode-canvas-wrapper" }, [
          vue.createCommentVNode(" 画布 "),
          $data.templateOptions.canvasDisplay ? (vue.openBlock(), vue.createElementBlock("canvas", {
            key: 0,
            class: "uqrcode-canvas",
            id: $data.canvasId,
            "canvas-id": $data.canvasId,
            type: $data.canvasType,
            style: vue.normalizeStyle({
              width: `${$data.templateOptions.canvasWidth}px`,
              height: `${$data.templateOptions.canvasHeight}px`,
              transform: $data.templateOptions.canvasTransform
            }),
            onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
          }, null, 12, ["id", "canvas-id", "type"])) : vue.createCommentVNode("v-if", true),
          vue.createCommentVNode(" nvue用gcanvas ")
        ]),
        vue.createCommentVNode(" 加载效果 "),
        (_ctx.loading === void 0 || !_ctx.loading ? $data.makeing : _ctx.loading) ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "uqrcode-makeing"
        }, [
          vue.renderSlot(_ctx.$slots, "loading", {}, () => [
            vue.createElementVNode(
              "image",
              {
                class: "uqrcode-makeing-image",
                style: vue.normalizeStyle({ width: `${$data.templateOptions.size / 4}px`, height: `${$data.templateOptions.size / 4}px` }),
                src: "data:image/gif;base64,R0lGODlhAAEAAfIEAOHh4SSsWuDg4N3d3f///wAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDYuMC1jMDAyIDc5LjE2NDQ4OCwgMjAyMC8wNy8xMC0yMjowNjo1MyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjAgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjAyODhGMzM4RDEwMTExRUM4MDhCRkVBQkE2QUZDQzkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjAyODhGMzM5RDEwMTExRUM4MDhCRkVBQkE2QUZDQzkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDI4OEYzMzZEMTAxMTFFQzgwOEJGRUFCQTZBRkNDOTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4OEYzMzdEMTAxMTFFQzgwOEJGRUFCQTZBRkNDOTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4B//79/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vby7urm4t7a1tLOysbCvrq2sq6qpqKempaSjoqGgn56dnJuamZiXlpWUk5KRkI+OjYyLiomIh4aFhIOCgYB/fn18e3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwrKikoJyYlJCMiISAfHh0cGxoZGBcWFRQTEhEQDw4NDAsKCQgHBgUEAwIBAAAh+QQFFAAEACwAAAAAAAEAAQAD/0i63P4wykmrvTjrzbv/YCiOZGmeaKqubOu+cCzPdG3feK7vfO//wKBwSCwaj8ikcslsOp/QqHRKrVqv2Kx2y+16v+CweEwum8/otHrNbrvf8Lh8Tq/b7/i8fs/v+/+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanigCqq6ytrieusbISAbW2t7i5uru8vb66bLLCrLDDw7S/ycrLzLXBxsLF0LHIzdbXzc/Trybb1BHY4eK92t6r0uaq1ePs4+Xp6PDg7fTh7+bx+PP1/Mz33vkA7utH0Ne/bQERDizIMNfBaQkhLmxIMcBDaBExTqzI8P+isYwfN3Ik6PFYt3TnRI7kVzLaSZQA1q0s2HLWS5QyZ/ar+a0ETHUqdbLjyc3nz5xC6RFtBdIkhKQ01/yMeVPeU6g7pR6tqu8q1npLiXEV6PVru7ApjcJEquyEPa1rxyosm83EWzVTm7qk688uNrRA1eIMatDvNcBUBVt9cJdEYzR55Urku8ztX7iDFXdlfLnE4zORNZPlfNiwNcR6bVJua7ou3q2i55I+3brv67ixJ8927bhzmtAkgDv4HIJ4GeEikDMw/oH5GOUgoCtw3oF6GOkesFvfsP0L9g7afY/o7uU7h/ClPYsHDTt4++Hri8c//j55/eXzm+d/fj96/+n/+1UX4HX/ZVcgeRggyIV5G6BHmycMauAgb5xEmMGEtnViIQYYVvbJhhd0yBqEBYJ34ICUgGiBiMmAomIFLP7iYonnnZiehjQ2aOODOE7l449MERbVai1iBuSRO67EVpG3IenkYvDptKSMRj5pZUhENjRlYU1e6aVqu420JTlVfmlmYGFyNCYviJ2ZWZoVrblLm25uFuVMcgJTZp1X5gmWkGzuyeeTfioF6JyCDopkoWcdqmeXilrJ6FCOOpRopD9O6k6luNCJ6V5wUqSpRZd+mqSYnN7iqalFhaplqrasyqpYWXYEqzOlzmpnA0mNKquuiblqa61kQgrsqWreSqqx/8e+eaeSyqIi7bTUVmvttdhmq+223Hbr7bejCCDuuOSWa+656Kar7rrnSjDAu/DGK++89NZr77340vsru/z2224E+QYs8MAEw7uvvwj3627BDDfM8MEJR5zuwg5XbHG9EEusMbkUX+zxxRlvvHHHH5f8cK4ip+wvySa3HHDIKifMsss0Y4xyzDijO3PNPBt8c85Aj7tzzzzDHPS6QxNNs9FHTwyw0lAPwHTT/0IQNdRTU11u0ld/nLXWQj/dddE/g50y12Nb/LXZaKft8Npgt+32ycyafbTccxMMt9Z45y3w3lT37Xe+qEnGruDxzihxalU/ULHiETNuLuI+k7i44f9Ii013j5Fjri7l70Ius+dOW/32hxpLvrXmBYuOsOocs6436pfndrjsA7u+Muk64/437Z3bnrnpDeuuMO+NO/A48KML/7nvLzP/OvKTQ0+49Ls7X7rjp1sevHu1c1889sdr3zvxm1eYOvWro986+fzCHrb7s3vfPPjfK9895/ePMLL1+DKe3c6Hv/fZb4DPM5++4IfA9hWwfvxrIAH9tz/1STCBD8wdAy8oNfYlboMXlF/oQChBEXbwgByMnQLnJcAUmrCFHDTh4FhYNrZ5cIY2q5sLb4hDGuowhjzs4Qd/GMIgCnGERCyhEY8IOAxS8IgVZE8Kk2cfKI4viQ2UIRPAaxi3JQqxiXcDoBXtVbgVOlB/YzTgb9ZnRhWKL40axCIVQ/A/+sExgFwU1wvFeMchrjF8T8xfA/oYxz8Kko5sfCMh71XGDJZPkYvMoSH7V8VDLiCS15Nj9do4P0hiUl6NDCQlGfBJRoLrlKhMpSpXycpWuvKVsIylLGdJy1ra8pa4zKUud8nLXvryl8AMpjCHScxiGvOYyEymMpfJzGY685nQjKY0p0nNalrzmtjMpja3yc1uevOb4AynOMdJhwQAACH5BAUUAAQALDIAMgCcAJwAAAP/KLrcTjDKSWt0OFsIuv9gKI5kaZ6Ztq1s6iorKs90/apsTt1pbP/AIA+mK16Gj41wyWwan8ikpUmtRp/GaMNn7Xq3WJ2Wwf2arWHxmDg9u6np3JpdeduX8da8fO8j83xXSn6EQ4CDa4GFi2CHO3uIjJJkjo+JkZOTlZZjipmFmxNzAp6ffqESo6Wmd6hHl22sjK4ckLGyoLSqmLh9tAS7t72+urZ1QL+LycacNcuEz528M9HErsHHP9WtxbDZNtt24YbTMuNu5zerJulm7S7rJe9e8zjfzt2n+VrxJPVo+wQJo/GvSsFG9wgGFLeQ3EBqDdFFVFcOxUEnE1/0G3GR/0lHOs0UXss10ltIiCX1peRX8cRHIS83iniJLVRNUcgyfonZkp1Oej/tnTT3K87NSkdfgSuaJukhp8ByMsUCNQ/UIFPDVDXKDKe2rFC6IhWrFB/YIlubkq319awak5uuSnWrB+5Yu2VF0pUpBZXctnt7jhqMl63KhMMIU3z4hm9ixY4xMn6sGENkj4IpVyaVuctlzdImn/kMWiDixp1L/z08VPVm0lhTuw59WqLo2YNhz22NO7dsOL9789ANmLfwwlGhBT8Obzke58wtQ499O/qf6bu9WvddHWj37RqxF9cOHrky8ZvTs/wOkH2IwPDjy59Pv779+/jz69/Pv7////8ABijggAQWaOCBCCao4FQDNOjggxBGKOGEFFZooYQrBKDhhhx26OGHIIYo4ogfXmjiiSim6GCGJLbo4oswaqjijDTSyGKMOOYYY4089ljhjToGKWSJPhZpJJBDJimkkUz2iKSSUO7Y5JQqPhnllSRSqeWJVmLpJZFbhjlhl1+WKaOYaEJIpplfpulmg2uyieWbbsYpZ5R0pmnnnUrmieaefA7pp5iABhrkoGEWamiOiG6p6KJSNjrlo5C+KCmVlFba4qWTbqCpl5w2memnIvLIkwVB6mdqUBh6qqOqNZ5aQar5rbpSiqMGAKuNrEaY664zykoBrfjZ6lesruYIbJX/vaqZLI7L4trsg7/WiuytKFZb7LXH8orqq9Z6222wz8YYbbbTrlgujOdymS6c677YronCTkDsfcbaxO2w4G4rrr7/2tsvvvvGVbAE99qXr8EBIzywwgc7srDDyoZLLrbufluxv6EOUFTC9XWsLi0g0ycyvCQ/HPLJH6tsMsu/lDzfyR7H7PLMMKe8McEit7wzxD3b/PPKQesMrcWh+kxqnzm7sjSeTaPyNJQ0Kz31oVGHcnWSVQu9tY5dG/01jmE7PTbYWW9yNtpFm712pDQ3HMHbZEf8lN0E0A03sxjTG6/eIU4sMd6AW4q3VYQXvunhXMkNgeKLOw6I4I9DPiLlGZMnbnngjKsl+ealdq6V5qB7iDnin5f+YQIAIfkEBRQABAAsMgAyAJwAnAAAA/84utxOMMpJa3Q4Wyi6/2AojmRpnpm2rWzqKisqz3T9qmxO3Wls/8AgD6YrXoaPjXDJbBqfyKSlSa1Gn8Zow2fterdYnZbB/ZqtYfGYOD27qencml1525fx1rx87yPzfFdKfoRDgINrgYWLYIc7e4iMkmSOj4mRk5OVlmOKmYWbE3MDnp9+oRKjpaZ3qEeXbayMrhyQsbKgtKqYuH20BLu3vb66tnVAv4vJxpw1y4TPnbwz0cSuwcc/1a3FsNk223bhhtMy427nN6sm6WbtLusl717zON/O3af5WvEk9Wj7BAmj8a9KwUb3CAYUt5DcQGoN0UVUVw7FQScTX/QbcZH/SUc6zRReyzXSW0iIJfWl5FfxxEchLzeKeIktVE1RyDJ+idmSnU56P+2dNPcrzs1KR1+BK5om6SGnwHIyxQI1D9QgU8NUNcoMp7asULoiFasUH9giW5uSrfX1rBqTm65KdasH7li7ZUXSlSkFldy2e3uOGoyXrcqEwwhTfPiGb2LFjjEyfqwYQ2SPgilXJpW5y2XN0iaf+QxaIOLGnUv/PTxU9WbSWFO7Dn1aoujZg2HPbY07t2w4v3vz0A2Yt/DCUaEFPw5vOR7nzC1Dj307+p/pu71a910daPftGrEX1w4euTLxm9Oz/A6QfYjA8OPLn0+/vv37+PPr38+/v////wAGKOCABBZo4IEIJqjgVAE06OCDEEYo4YQUVmihhMQBoOGGHHbo4YcghsjhhSSWaOKJDmYo4oostqghijDGGKOKLtZo44sy5qgjhTTe6OOKOwYpZAA9/mikh0MmKWORRzYJgJJQnsikk0ZGaeWFU1Lp45VcTpilljZ2KeaDX4Lp4pholmkmi2iOqeaaIrYp5ptwgihnl3TWieSdV+ap54h8WunnnzgGCuWghBoaJaJ/KnooeoTW6KiSjOo5aZKV1pnjL5tCp1+nroBaG4ufLkmLqMaJWOqMp5rqXoerwsipq6OuGCuKs7L6Koe3StmqrrWqmh+qmxCbipG9mpirrP+eDktrKMbmVWOyJS6La7P4RXuItsn5SC2J1vq664bfYvkrs+NqWK6F4SqL7X3c5sHtketW2G6179oXbxzzIusssNA+S56N9fJ47rXpAlCwlweLG2yIC7fJU7aXkhnUhxGnebGHGbu5Maz/Vkzkx7yGXPHE8IrcIMr6qjzySgSbfCnL9bn8sl/+UqwyTZHeaDPPPUvqMtBBt/gzyUVvOTTSSYe5NMxNr3k01FGDOTXOVWv6NNZZS721TV3DaXO/YZu5bxpkl63l2WGkrbaTbGPh9ttHxv3E3HT/aLcReOfts8CV9O230AAXC7i0gxOOLiqCJ87m4dtC3q3jThceuOQElP+YAAAh+QQFFAAEACwyADIAnACcAAAD/xi63E4wyklrdDhbOLr/YCiOZGmKWcpsbEuoMHvOdG17sOruVJ7Kt6Aw6NPwjq/iYzNsOkvKJXIXbQCfWGx1NaVuFdesWPgFd13lQHjMpqXP6PK6TSe94ay7pc6HyvEbehV9hCGCgBOHE4WMHYqIEI8RjYySiJYElIWYeJiahJxwnp98oWejpHSmXaipbKtTra5isEiys1p/kIm6g7hjtUe3v03BPMM0uxTFvcpJX3M1zhLM0NORzYtD1xxDxl7We9vc1Vvcz+ZM49flVefIM+ftUe/Z1OvT80r14b5C8t7sQYJ3AiAZgZcQZsLnTF8RfunE/SMXsJ8zgiYMElHYSf9hE403vsWxqG0iu4oRp2EsAdKGyBYrSbSs8TKPR4bKHPqA6E6dyXwoe16LOWKmG46ibv5sGJQeN6IijM6oGUhpkHMdSe6CGgJrUq0Drd7wegppWbDdlpIFl/KiWBtrY5ll9VZaXGFz5aJdqPZu1b1Z25a86petUJV1kxUeKXhr4niLYaaZTFmKP03RjlbePDkzIc8nOIt+3Ae0idGonUrE7HNj6tc6WlMy7Qe2bcvLSNG2c7v3gt1tgKPw7Vv4GOMgiBeX3Qj5B+W9nWOR7gi6bepOsFu/zpyR9u2vsX/srhn8aPE47x00f578Z/eh2bdfPRv+afmi0fed1BQ/VzH/3/lXmX6E0eeSgAPaV0eACP6XBXaRRSjhhBRWaOGFGGao4YYcdujhhyCGKOKIJJZo4okopqjiimQB4OKLMMYo44w01mjjjTMSKMCOPPbo449ABinkkDgWaeSROOpI5JJMNonkk1BGqaSTVFYZ5ZVY3jillVx2meWXSG7p5Zhkgmmmi2KWqeaZbBqZ5ppwtilnjG/GaeecbNZ55554Yqknn4D2eeSfgRYqaI2EGqrooS8muiijkDr6KKSCSjoppXNaeimmeSq46aec2qgpqKH66SmpqJYKwKipqjroqa3yKVWSsP64oaknSVmrj7deOauWu/bYq665QgmhhrgCRexl/1UOayxFy+bGpbNP/ipqsDxSGya0zxropLavFlsttjuC6ya343rbpLlFWosouQKwS6u426rLpLzA0hsus1Tie62+59q7pL/vAtwuvATT6K7CCCPrK7r18vutw9Hm9LDARCacI8T7SmulxjIuvDHGQ4JMJ8cBS7wuxa6GjPK9LLcMo8i2xiwzmi8PbPPNNPO6s8w9C/tzy0FnO7SrRZd7tKpJx7t0qU2bzGjUT4fadKxYn2xw1lwfvHXXYDP8ddhkN5pz2WhfjTbQZ68dttpuM9123De7PDbddZvJatZUk4x3xbsk6/Hfa/atMuGCWww4f4gXPrfYhzferbKTDy554hmBXxz55R0rXvlgnGvO1OJphS665+luTncCADs="
              },
              null,
              4
              /* STYLE */
            )
          ], true)
        ])) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode(" 错误处理 "),
        $data.isError ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 1,
          class: "uqrcode-error",
          onClick: _cache[1] || (_cache[1] = (...args) => $options.onClick && $options.onClick(...args))
        }, [
          vue.renderSlot(_ctx.$slots, "error", { error: $data.error }, () => [
            vue.createElementVNode(
              "text",
              { class: "uqrcode-error-message" },
              vue.toDisplayString($data.error.errMsg),
              1
              /* TEXT */
            )
          ], true)
        ])) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode(" H5保存提示 ")
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const uvQrcode = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$1], ["__scopeId", "data-v-6fbe98c8"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue"]]);
  const _imports_3 = "/static/icons/downLoad.png";
  const _imports_4 = "/static/icons/closeIcon.png";
  const _sfc_main$1 = {
    __name: "deatil",
    setup(__props, { expose: __expose }) {
      __expose();
      const HWHJStoreDeatil = HWHJStore();
      const shelfVal = vue.ref(0);
      const layersList = vue.ref([]);
      const deletePopInd = vue.ref({});
      const showPopCenter = vue.ref(false);
      const deleteHandle = (index2) => {
        deletePopInd.value = index2;
        showPopCenter.value = true;
      };
      const confirmDeleteHandle = () => {
        request({
          url: "/admin-api/storage/overseas/goods-location/delete-floor?shelf=" + shelfVal.value + "&floor=" + layersList.value[deletePopInd.value],
          methods: "DELETE"
        }).then((res) => {
          uni.showToast({
            title: "Delete success",
            icon: "none"
          });
          getClassList();
          showPopCenter.value = false;
        });
      };
      const popObj = vue.ref({});
      const showCenter = vue.ref(false);
      const qrCodeData = vue.ref("");
      const showQrCode = (item) => {
        qrCodeData.value = shelfVal.value + "-" + item;
        popObj.value = item;
        showCenter.value = true;
      };
      const qrcodeRef = vue.ref("");
      const qrCodeComplete = (res) => {
        formatAppLog("log", "at pages/shelf/deatil.vue:63", qrcodeRef.value);
        formatAppLog("log", "at pages/shelf/deatil.vue:64", "生成成功");
      };
      const qrCodeBase64 = vue.ref("");
      const downloadHandle = () => {
        qrcodeRef.value.save({
          success: (res) => {
            uni.showToast({
              title: "Save Success",
              icon: "none"
            });
          }
        });
      };
      onLoad((e2) => {
        if (e2.item) {
          shelfVal.value = e2.item;
          getClassList();
        }
      });
      const getClassList = () => {
        request({
          url: "/admin-api/storage/overseas/goods-location/floor-list/" + shelfVal.value
        }).then((res) => {
          layersList.value = res.floorList.sort((a2, b2) => a2 - b2);
          let arr = findDifferentValues(layerListStatic, res.floorList);
          layerList.value = arr.map((item) => {
            return {
              name: item,
              value: item
            };
          });
        });
      };
      function findDifferentValues(arr1, arr2) {
        return [
          ...arr1.filter((item) => !arr2.includes(item)),
          ...arr2.filter((item) => !arr1.includes(item))
        ];
      }
      const layerVal = vue.ref([0]);
      const layerListStatic = HWHJStoreDeatil.LAYERSLIST;
      const layerList = vue.ref([]);
      const showPickerLayer = vue.ref(false);
      const confirmLayerHandle = (e2) => {
        request({
          url: "/admin-api/storage/overseas/goods-location/create-floor",
          methods: "POST",
          data: {
            shelf: shelfVal.value,
            floor: layerList.value[0].name
          }
        }).then((res) => {
          uni.showToast({
            title: "Add success",
            icon: "none"
          });
          getClassList();
          showPickerLayer.value = false;
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { HWHJStoreDeatil, shelfVal, layersList, deletePopInd, showPopCenter, deleteHandle, confirmDeleteHandle, popObj, showCenter, qrCodeData, showQrCode, qrcodeRef, qrCodeComplete, qrCodeBase64, downloadHandle, getClassList, findDifferentValues, layerVal, layerListStatic, layerList, showPickerLayer, confirmLayerHandle, goBack, get request() {
        return request;
      }, get HWHJStore() {
        return HWHJStore;
      }, onMounted: vue.onMounted, uvQrcode, ref: vue.ref, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_overlay = vue.resolveComponent("van-overlay");
    const _component_van_picker = vue.resolveComponent("van-picker");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Details",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "pdlr12 mt20" }, [
        vue.createElementVNode("view", { class: "topBox" }, [
          vue.createElementVNode("view", {
            class: "mt19 shelfBox center flex-col",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.showPicker = true)
          }, [
            vue.createElementVNode(
              "view",
              { class: "f24 text_bold" },
              "Shelf " + vue.toDisplayString($setup.shelfVal),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", { class: "mt4 f15 color7C" }, "current shelf")
          ])
        ]),
        vue.createElementVNode("view", { class: "mt35 botBox" }, [
          vue.createElementVNode("view", { class: "between" }, [
            vue.createElementVNode("view", { class: "f16 text_bold" }, "Layers"),
            vue.createElementVNode("view", {
              class: "flex col_center f12",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.showPickerLayer = true)
            }, [
              vue.createElementVNode("image", {
                src: _imports_1,
                class: "ww12 hh12"
              }),
              vue.createElementVNode("view", { class: "ml6 colorBlue" }, "Add")
            ])
          ]),
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.layersList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", { class: "between goodsItem" }, [
                vue.createElementVNode("view", { class: "flex col_center" }, [
                  vue.createElementVNode(
                    "view",
                    { class: "f15 text_bold" },
                    vue.toDisplayString($setup.shelfVal + "-" + item),
                    1
                    /* TEXT */
                  )
                ]),
                vue.createElementVNode("view", {
                  class: "f13 colorBlue",
                  onClick: ($event) => $setup.showQrCode(item)
                }, " QR Code ", 8, ["onClick"]),
                vue.createElementVNode("view", {
                  class: "deleteIcon",
                  onClick: ($event) => $setup.deleteHandle(index2)
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_2,
                    class: "ww14 hh14"
                  })
                ], 8, ["onClick"])
              ]);
            }),
            256
            /* UNKEYED_FRAGMENT */
          ))
        ])
      ]),
      vue.createElementVNode("view", { style: { "height": "50px" } }),
      vue.createVNode(_component_van_overlay, { show: $setup.showCenter }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "center flex_col pdtb30 codeBoxEl" }, [
            vue.createElementVNode("div", { id: "imgNode" }, [
              vue.createElementVNode(
                "view",
                { class: "f22 text_bold text_center" },
                vue.toDisplayString($setup.shelfVal + "-" + $setup.popObj),
                1
                /* TEXT */
              ),
              vue.createElementVNode("view", { class: "f14 color7C mt4 text_center" }, "current shelf"),
              vue.createCommentVNode(' <image :src="qrCodeBase64" style="width:200px;height:200px" /> '),
              vue.createElementVNode("view", { class: "qrimg mgtb20" }, [
                vue.createVNode($setup["uvQrcode"], {
                  ref: "qrcodeRef",
                  size: "150px",
                  value: $setup.qrCodeData,
                  onComplete: $setup.qrCodeComplete
                }, null, 8, ["value"])
              ])
            ]),
            vue.createElementVNode("view", {
              class: "codeBtn f14 text_white center",
              onClick: $setup.downloadHandle
            }, [
              vue.createElementVNode("image", {
                src: _imports_3,
                class: "ww25 hh24"
              }),
              vue.createTextVNode(" Download ")
            ]),
            vue.createElementVNode("view", {
              class: "closeIconEl",
              onClick: _cache[2] || (_cache[2] = ($event) => $setup.showCenter = false)
            }, [
              vue.createElementVNode("image", {
                src: _imports_4,
                class: "ww24 hh24"
              })
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPickerLayer,
        "onUpdate:show": _cache[5] || (_cache[5] = ($event) => $setup.showPickerLayer = $event),
        round: "",
        position: "bottom"
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_van_picker, {
            modelValue: $setup.layerVal,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.layerVal = $event),
            title: "Layers",
            columns: $setup.layerList,
            "confirm-button-text": "Confirm",
            "cancel-button-text": "Cancel",
            onConfirm: $setup.confirmLayerHandle,
            "columns-field-names": { text: "name" },
            onCancel: _cache[4] || (_cache[4] = ($event) => $setup.showPickerLayer = false)
          }, null, 8, ["modelValue", "columns"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPopCenter,
        "onUpdate:show": _cache[7] || (_cache[7] = ($event) => $setup.showPopCenter = $event),
        round: "",
        style: { "width": "280px" }
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "pt30 pdlr26" }, [
            vue.createElementVNode("view", {
              class: "f15 text_center borderB pb24",
              style: { "line-height": "18px" }
            }, " Are you sure you want to delete the current layer number? ")
          ]),
          vue.createElementVNode("view", { class: "pdlr20" }, [
            vue.createElementVNode("view", { class: "girdBtn pop" }, [
              vue.createElementVNode("view", {
                class: "botBtn cancelBtn center color7C",
                onClick: _cache[6] || (_cache[6] = ($event) => $setup.showPopCenter = false)
              }, "Cancel"),
              vue.createElementVNode("view", {
                class: "botBtn center text_white confirmBtn",
                onClick: $setup.confirmDeleteHandle
              }, "Confirm")
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"])
    ]);
  }
  const PagesShelfDeatil = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-71d48cec"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/shelf/deatil.vue"]]);
  __definePage("pages/tab/index", PagesTabIndex);
  __definePage("pages/home/login", PagesHomeLogin);
  __definePage("pages/setting/index", PagesSettingIndex);
  __definePage("pages/setting/updatePwd", PagesSettingUpdatePwd);
  __definePage("pages/gd/recive", PagesGdRecive);
  __definePage("pages/gd/reciveSuccess", PagesGdReciveSuccess);
  __definePage("pages/gd/warehouse", PagesGdWarehouse);
  __definePage("pages/gd/warehouseSuccess", PagesGdWarehouseSuccess);
  __definePage("pages/gd/warehouseMen", PagesGdWarehouseMen);
  __definePage("pages/gd/warehouseDeatil", PagesGdWarehouseDeatil);
  __definePage("pages/gd/goodsMen", PagesGdGoodsMen);
  __definePage("pages/home/goodsList", PagesHomeGoodsList);
  __definePage("pages/home/scanCode", PagesHomeScanCode);
  __definePage("pages/home/receiveSuccess", PagesHomeReceiveSuccess);
  __definePage("pages/home/warehouse", PagesHomeWarehouse);
  __definePage("pages/home/wareSuccess", PagesHomeWareSuccess);
  __definePage("pages/shelf/index", PagesShelfIndex);
  __definePage("pages/shelf/add", PagesShelfAdd);
  __definePage("pages/shelf/deatil", PagesShelfDeatil);
  const _sfc_main = {
    onLaunch: function() {
      formatAppLog("log", "at App.vue:4", "App Launch");
    },
    onShow: function() {
      formatAppLog("log", "at App.vue:7", "App Show");
    },
    onHide: function() {
      formatAppLog("log", "at App.vue:11", "App Hide");
    }
  };
  const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/App.vue"]]);
  const en = {
    paging: {
      lmdt: "Click to load more",
      lmlt: "Loading...",
      lmnmt: "No more",
      lmft: "Load failed, click to reload",
      evt: "No data~",
      evrt: "Reload",
      evet: "Sorry, loading failed"
    },
    login: {
      l1: "Hello",
      l2: "Welcome to login [Warehouse Management Portal]",
      l3: "Phone Number",
      l4: "Please enter your phone number",
      l5: "Password",
      l6: "Please enter your password",
      l7: "Login"
    },
    setting: {
      s_t1: "Password",
      s_s1: "Set",
      s_s2: "Change Password",
      s_s3: "Log Out",
      s_s4: "Are you sure you want to log out of the current account?",
      s_s5: "Cancel",
      s_s6: "Confirm",
      s_s7: "Account",
      s_s8: "Old password",
      s_s9: "Please enter",
      s_s10: "New password",
      s_j1: "Update Success"
    },
    home: {
      h_h1: " Overseas ",
      h_h2: "Warehouse",
      h_h3: "Welcome to log in ",
      h_h4: "Failed to enable camera",
      h_a1: "Scan",
      h_a2: "Put the “logistics tracking number” in the box and it will be automatically scanned",
      h_a3: `Please scan the 'shelf layer number' first so that it can be used to place the goods`,
      h_a4: "Manual Input",
      h_a5: "Input",
      h_a6: "Please manually input the 'logistics order number' to query the order",
      h_a7: "Please enter the container number(for example:1-1)",
      h_a8: "Scan code failed"
    }
  };
  const zh = {
    paging: {
      lmdt: "点击加载更多",
      lmlt: "加载中...",
      lmnmt: "没有更多了",
      lmft: "加载失败，点击重新加载",
      evt: "没有数据~",
      evrt: "重新加载",
      evet: "抱歉，加载失败"
    },
    login: {
      l1: "你好",
      l2: "欢迎登录 [仓储管理端]",
      l3: "手机号码",
      l4: "请输入您的手机号码",
      l5: "密码",
      l6: "请输入您的密码",
      l7: "登录"
    },
    setting: {
      s_t1: "密码",
      s_s1: "设置",
      s_s2: "更改密码",
      s_s3: "登出",
      s_s4: "您确定要登出当前账户吗？",
      s_s5: "取消",
      s_s6: "确认",
      s_s7: "账户",
      s_s8: "旧密码",
      s_s9: "请输入",
      s_s10: "新密码",
      s_j1: "更新成功"
    },
    home: {
      h_h1: "国内",
      h_h2: "仓库",
      h_h3: "欢迎登录",
      h_h4: "启用相机失败",
      h_a1: "扫描",
      h_a2: "将“物流追踪号”放入框中，它将自动被扫描",
      h_a3: "请先扫描‘货架层号’，以便用于放置货物",
      h_a4: "手动输入",
      h_a5: "输入",
      h_a6: "请手动输入‘物流订单号’以查询订单",
      h_a7: "请输入集装箱号（例如：1-1）",
      h_a8: "扫描码失败"
    }
  };
  let lang;
  uni.getStorageSync("language");
  try {
    lang = uni.getStorageSync("language");
    if (!uni.getStorageSync("language")) {
      uni.setStorageSync("language", "en");
    }
  } catch (e2) {
  }
  const i18n = createI18n({
    locale: lang || "en",
    // 语言标识
    globalInjection: true,
    // 全局注入,可以直接使用$t
    legacy: false,
    messages: {
      en,
      zh
    }
  });
  uni.$zp = {
    config: {
      //配置分页默认pageSize为15
      "loading-more-default-text": i18n.global.t("paging.lmdt"),
      "loading-more-loading-text": i18n.global.t("paging.lmlt"),
      "loading-more-no-more-text": i18n.global.t("paging.lmnmt"),
      "loading-more-fail-text": i18n.global.t("paging.lmft"),
      "empty-view-text": i18n.global.t("paging.evt"),
      "empty-view-reload-text": i18n.global.t("paging.evrt"),
      "empty-view-error-text": i18n.global.t("paging.evet"),
      "loading-more-loading-icon-type": "circle"
    }
  };
  const pinia = createPinia();
  function createApp() {
    const app = vue.createVueApp(App);
    app.use(stdin_default);
    app.use(i18n);
    app.use(pinia);
    return {
      app
    };
  }
  const { app: __app__, Vuex: __Vuex__, Pinia: __Pinia__ } = createApp();
  uni.Vuex = __Vuex__;
  uni.Pinia = __Pinia__;
  __app__.provide("__globalStyles", __uniConfig.styles);
  __app__._component.mpType = "app";
  __app__._component.render = () => {
  };
  __app__.mount("#app");
})(Vue, uni.VueShared);
