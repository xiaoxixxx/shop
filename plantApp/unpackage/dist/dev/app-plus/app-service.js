if (typeof Promise !== "undefined" && !Promise.prototype.finally) {
  Promise.prototype.finally = function(callback) {
    const promise = this.constructor;
    return this.then(
      (value) => promise.resolve(callback()).then(() => value),
      (reason) => promise.resolve(callback()).then(() => {
        throw reason;
      })
    );
  };
}
;
if (typeof uni !== "undefined" && uni && uni.requireGlobal) {
  const global2 = uni.requireGlobal();
  ArrayBuffer = global2.ArrayBuffer;
  Int8Array = global2.Int8Array;
  Uint8Array = global2.Uint8Array;
  Uint8ClampedArray = global2.Uint8ClampedArray;
  Int16Array = global2.Int16Array;
  Uint16Array = global2.Uint16Array;
  Int32Array = global2.Int32Array;
  Uint32Array = global2.Uint32Array;
  Float32Array = global2.Float32Array;
  Float64Array = global2.Float64Array;
  BigInt64Array = global2.BigInt64Array;
  BigUint64Array = global2.BigUint64Array;
}
;
if (uni.restoreGlobal) {
  uni.restoreGlobal(Vue, weex, plus, setTimeout, clearTimeout, setInterval, clearInterval);
}
(function(vue, shared) {
  "use strict";
  const ON_LOAD = "onLoad";
  function formatAppLog(type, filename, ...args) {
    if (uni.__log__) {
      uni.__log__(type, filename, ...args);
    } else {
      console[type].apply(console, [...args, filename]);
    }
  }
  function resolveEasycom(component, easycom) {
    return typeof component === "string" ? easycom : component;
  }
  const createHook = (lifecycle) => (hook, target = vue.getCurrentInstance()) => {
    !vue.isInSSRComponentSetup && vue.injectHook(lifecycle, hook, target);
  };
  const onLoad = /* @__PURE__ */ createHook(ON_LOAD);
  /*!
    * @intlify/shared v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const inBrowser$2 = typeof window !== "undefined";
  let mark;
  let measure;
  {
    const perf2 = inBrowser$2 && window.performance;
    if (perf2 && perf2.mark && perf2.measure && perf2.clearMarks && perf2.clearMeasures) {
      mark = (tag) => perf2.mark(tag);
      measure = (name2, startTag, endTag) => {
        perf2.measure(name2, startTag, endTag);
        perf2.clearMarks(startTag);
        perf2.clearMarks(endTag);
      };
    }
  }
  const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
  function format$2(message, ...args) {
    if (args.length === 1 && isObject$3(args[0])) {
      args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
      args = {};
    }
    return message.replace(RE_ARGS, (match, identifier) => {
      return args.hasOwnProperty(identifier) ? args[identifier] : "";
    });
  }
  const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  const makeSymbol = (name2) => hasSymbol ? Symbol(name2) : name2;
  const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
  const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
  const isNumber = (val) => typeof val === "number" && isFinite(val);
  const isDate$1 = (val) => toTypeString(val) === "[object Date]";
  const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
  const isEmptyObject = (val) => isPlainObject$1(val) && Object.keys(val).length === 0;
  function warn(msg, err) {
    if (typeof console !== "undefined") {
      console.warn(`[intlify] ` + msg);
      if (err) {
        console.warn(err.stack);
      }
    }
  }
  const assign$2 = Object.assign;
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function escapeHtml(rawText) {
    return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  function hasOwn$2(obj, key) {
    return hasOwnProperty$3.call(obj, key);
  }
  const isArray = Array.isArray;
  const isFunction$1 = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isBoolean = (val) => typeof val === "boolean";
  const isObject$3 = (val) => (
    // eslint-disable-line
    val !== null && typeof val === "object"
  );
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
  const toDisplayString = (val) => {
    return val == null ? "" : isArray(val) || isPlainObject$1(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
  };
  const RANGE = 2;
  function generateCodeFrame(source, start2 = 0, end2 = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i2 = 0; i2 < lines.length; i2++) {
      count += lines[i2].length + 1;
      if (count >= start2) {
        for (let j = i2 - RANGE; j <= i2 + RANGE || end2 > count; j++) {
          if (j < 0 || j >= lines.length)
            continue;
          const line = j + 1;
          res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j]}`);
          const lineLength = lines[j].length;
          if (j === i2) {
            const pad = start2 - (count - lineLength) + 1;
            const length = Math.max(1, end2 > count ? lineLength - pad : end2 - start2);
            res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
          } else if (j > i2) {
            if (end2 > count) {
              const length = Math.max(Math.min(end2 - count, lineLength), 1);
              res.push(`   |  ` + "^".repeat(length));
            }
            count += lineLength + 1;
          }
        }
        break;
      }
    }
    return res.join("\n");
  }
  function createEmitter() {
    const events = /* @__PURE__ */ new Map();
    const emitter = {
      events,
      on(event, handler) {
        const handlers = events.get(event);
        const added = handlers && handlers.push(handler);
        if (!added) {
          events.set(event, [handler]);
        }
      },
      off(event, handler) {
        const handlers = events.get(event);
        if (handlers) {
          handlers.splice(handlers.indexOf(handler) >>> 0, 1);
        }
      },
      emit(event, payload) {
        (events.get(event) || []).slice().map((handler) => handler(payload));
        (events.get("*") || []).slice().map((handler) => handler(event, payload));
      }
    };
    return emitter;
  }
  /*!
    * @intlify/message-resolver v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function hasOwn$1(obj, key) {
    return hasOwnProperty$2.call(obj, key);
  }
  const isObject$2 = (val) => (
    // eslint-disable-line
    val !== null && typeof val === "object"
  );
  const pathStateMachine = [];
  pathStateMachine[
    0
    /* BEFORE_PATH */
  ] = {
    [
      "w"
      /* WORKSPACE */
    ]: [
      0
      /* BEFORE_PATH */
    ],
    [
      "i"
      /* IDENT */
    ]: [
      3,
      0
      /* APPEND */
    ],
    [
      "["
      /* LEFT_BRACKET */
    ]: [
      4
      /* IN_SUB_PATH */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: [
      7
      /* AFTER_PATH */
    ]
  };
  pathStateMachine[
    1
    /* IN_PATH */
  ] = {
    [
      "w"
      /* WORKSPACE */
    ]: [
      1
      /* IN_PATH */
    ],
    [
      "."
      /* DOT */
    ]: [
      2
      /* BEFORE_IDENT */
    ],
    [
      "["
      /* LEFT_BRACKET */
    ]: [
      4
      /* IN_SUB_PATH */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: [
      7
      /* AFTER_PATH */
    ]
  };
  pathStateMachine[
    2
    /* BEFORE_IDENT */
  ] = {
    [
      "w"
      /* WORKSPACE */
    ]: [
      2
      /* BEFORE_IDENT */
    ],
    [
      "i"
      /* IDENT */
    ]: [
      3,
      0
      /* APPEND */
    ],
    [
      "0"
      /* ZERO */
    ]: [
      3,
      0
      /* APPEND */
    ]
  };
  pathStateMachine[
    3
    /* IN_IDENT */
  ] = {
    [
      "i"
      /* IDENT */
    ]: [
      3,
      0
      /* APPEND */
    ],
    [
      "0"
      /* ZERO */
    ]: [
      3,
      0
      /* APPEND */
    ],
    [
      "w"
      /* WORKSPACE */
    ]: [
      1,
      1
      /* PUSH */
    ],
    [
      "."
      /* DOT */
    ]: [
      2,
      1
      /* PUSH */
    ],
    [
      "["
      /* LEFT_BRACKET */
    ]: [
      4,
      1
      /* PUSH */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: [
      7,
      1
      /* PUSH */
    ]
  };
  pathStateMachine[
    4
    /* IN_SUB_PATH */
  ] = {
    [
      "'"
      /* SINGLE_QUOTE */
    ]: [
      5,
      0
      /* APPEND */
    ],
    [
      '"'
      /* DOUBLE_QUOTE */
    ]: [
      6,
      0
      /* APPEND */
    ],
    [
      "["
      /* LEFT_BRACKET */
    ]: [
      4,
      2
      /* INC_SUB_PATH_DEPTH */
    ],
    [
      "]"
      /* RIGHT_BRACKET */
    ]: [
      1,
      3
      /* PUSH_SUB_PATH */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* ELSE */
    ]: [
      4,
      0
      /* APPEND */
    ]
  };
  pathStateMachine[
    5
    /* IN_SINGLE_QUOTE */
  ] = {
    [
      "'"
      /* SINGLE_QUOTE */
    ]: [
      4,
      0
      /* APPEND */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* ELSE */
    ]: [
      5,
      0
      /* APPEND */
    ]
  };
  pathStateMachine[
    6
    /* IN_DOUBLE_QUOTE */
  ] = {
    [
      '"'
      /* DOUBLE_QUOTE */
    ]: [
      4,
      0
      /* APPEND */
    ],
    [
      "o"
      /* END_OF_FAIL */
    ]: 8,
    [
      "l"
      /* ELSE */
    ]: [
      6,
      0
      /* APPEND */
    ]
  };
  const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function isLiteral(exp) {
    return literalValueRE.test(exp);
  }
  function stripQuotes(str) {
    const a2 = str.charCodeAt(0);
    const b2 = str.charCodeAt(str.length - 1);
    return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
  }
  function getPathCharType(ch) {
    if (ch === void 0 || ch === null) {
      return "o";
    }
    const code2 = ch.charCodeAt(0);
    switch (code2) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return ch;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function formatSubPath(path) {
    const trimmed = path.trim();
    if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
      return false;
    }
    return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
  }
  function parse$1(path) {
    const keys = [];
    let index2 = -1;
    let mode = 0;
    let subPathDepth = 0;
    let c2;
    let key;
    let newChar;
    let type;
    let transition;
    let action;
    let typeMap;
    const actions = [];
    actions[
      0
      /* APPEND */
    ] = () => {
      if (key === void 0) {
        key = newChar;
      } else {
        key += newChar;
      }
    };
    actions[
      1
      /* PUSH */
    ] = () => {
      if (key !== void 0) {
        keys.push(key);
        key = void 0;
      }
    };
    actions[
      2
      /* INC_SUB_PATH_DEPTH */
    ] = () => {
      actions[
        0
        /* APPEND */
      ]();
      subPathDepth++;
    };
    actions[
      3
      /* PUSH_SUB_PATH */
    ] = () => {
      if (subPathDepth > 0) {
        subPathDepth--;
        mode = 4;
        actions[
          0
          /* APPEND */
        ]();
      } else {
        subPathDepth = 0;
        if (key === void 0) {
          return false;
        }
        key = formatSubPath(key);
        if (key === false) {
          return false;
        } else {
          actions[
            1
            /* PUSH */
          ]();
        }
      }
    };
    function maybeUnescapeQuote() {
      const nextChar = path[index2 + 1];
      if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
        index2++;
        newChar = "\\" + nextChar;
        actions[
          0
          /* APPEND */
        ]();
        return true;
      }
    }
    while (mode !== null) {
      index2++;
      c2 = path[index2];
      if (c2 === "\\" && maybeUnescapeQuote()) {
        continue;
      }
      type = getPathCharType(c2);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap[
        "l"
        /* ELSE */
      ] || 8;
      if (transition === 8) {
        return;
      }
      mode = transition[0];
      if (transition[1] !== void 0) {
        action = actions[transition[1]];
        if (action) {
          newChar = c2;
          if (action() === false) {
            return;
          }
        }
      }
      if (mode === 7) {
        return keys;
      }
    }
  }
  const cache = /* @__PURE__ */ new Map();
  function resolveValue(obj, path) {
    if (!isObject$2(obj)) {
      return null;
    }
    let hit = cache.get(path);
    if (!hit) {
      hit = parse$1(path);
      if (hit) {
        cache.set(path, hit);
      }
    }
    if (!hit) {
      return null;
    }
    const len = hit.length;
    let last = obj;
    let i2 = 0;
    while (i2 < len) {
      const val = last[hit[i2]];
      if (val === void 0) {
        return null;
      }
      last = val;
      i2++;
    }
    return last;
  }
  function handleFlatJson(obj) {
    if (!isObject$2(obj)) {
      return obj;
    }
    for (const key in obj) {
      if (!hasOwn$1(obj, key)) {
        continue;
      }
      if (!key.includes(
        "."
        /* DOT */
      )) {
        if (isObject$2(obj[key])) {
          handleFlatJson(obj[key]);
        }
      } else {
        const subKeys = key.split(
          "."
          /* DOT */
        );
        const lastIndex = subKeys.length - 1;
        let currentObj = obj;
        for (let i2 = 0; i2 < lastIndex; i2++) {
          if (!(subKeys[i2] in currentObj)) {
            currentObj[subKeys[i2]] = {};
          }
          currentObj = currentObj[subKeys[i2]];
        }
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
        if (isObject$2(currentObj[subKeys[lastIndex]])) {
          handleFlatJson(currentObj[subKeys[lastIndex]]);
        }
      }
    }
    return obj;
  }
  /*!
    * @intlify/runtime v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const DEFAULT_MODIFIER = (str) => str;
  const DEFAULT_MESSAGE = (ctx) => "";
  const DEFAULT_MESSAGE_DATA_TYPE = "text";
  const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : values.join("");
  const DEFAULT_INTERPOLATE = toDisplayString;
  function pluralDefault(choice, choicesLength) {
    choice = Math.abs(choice);
    if (choicesLength === 2) {
      return choice ? choice > 1 ? 1 : 0 : 1;
    }
    return choice ? Math.min(choice, 2) : 0;
  }
  function getPluralIndex(options) {
    const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
    return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
  }
  function normalizeNamed(pluralIndex, props2) {
    if (!props2.count) {
      props2.count = pluralIndex;
    }
    if (!props2.n) {
      props2.n = pluralIndex;
    }
  }
  function createMessageContext(options = {}) {
    const locale = options.locale;
    const pluralIndex = getPluralIndex(options);
    const pluralRule = isObject$3(options.pluralRules) && isString(locale) && isFunction$1(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
    const orgPluralRule = isObject$3(options.pluralRules) && isString(locale) && isFunction$1(options.pluralRules[locale]) ? pluralDefault : void 0;
    const plural = (messages2) => messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
    const _list = options.list || [];
    const list = (index2) => _list[index2];
    const _named = options.named || {};
    isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
    const named = (key) => _named[key];
    function message(key) {
      const msg = isFunction$1(options.messages) ? options.messages(key) : isObject$3(options.messages) ? options.messages[key] : false;
      return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
    }
    const _modifier = (name2) => options.modifiers ? options.modifiers[name2] : DEFAULT_MODIFIER;
    const normalize = isPlainObject$1(options.processor) && isFunction$1(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
    const interpolate = isPlainObject$1(options.processor) && isFunction$1(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
    const type = isPlainObject$1(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
    const ctx = {
      [
        "list"
        /* LIST */
      ]: list,
      [
        "named"
        /* NAMED */
      ]: named,
      [
        "plural"
        /* PLURAL */
      ]: plural,
      [
        "linked"
        /* LINKED */
      ]: (key, modifier) => {
        const msg = message(key)(ctx);
        return isString(modifier) ? _modifier(modifier)(msg) : msg;
      },
      [
        "message"
        /* MESSAGE */
      ]: message,
      [
        "type"
        /* TYPE */
      ]: type,
      [
        "interpolate"
        /* INTERPOLATE */
      ]: interpolate,
      [
        "normalize"
        /* NORMALIZE */
      ]: normalize
    };
    return ctx;
  }
  /*!
    * @intlify/message-compiler v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const errorMessages$2 = {
    // tokenizer error messages
    [
      0
      /* EXPECTED_TOKEN */
    ]: `Expected token: '{0}'`,
    [
      1
      /* INVALID_TOKEN_IN_PLACEHOLDER */
    ]: `Invalid token in placeholder: '{0}'`,
    [
      2
      /* UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER */
    ]: `Unterminated single quote in placeholder`,
    [
      3
      /* UNKNOWN_ESCAPE_SEQUENCE */
    ]: `Unknown escape sequence: \\{0}`,
    [
      4
      /* INVALID_UNICODE_ESCAPE_SEQUENCE */
    ]: `Invalid unicode escape sequence: {0}`,
    [
      5
      /* UNBALANCED_CLOSING_BRACE */
    ]: `Unbalanced closing brace`,
    [
      6
      /* UNTERMINATED_CLOSING_BRACE */
    ]: `Unterminated closing brace`,
    [
      7
      /* EMPTY_PLACEHOLDER */
    ]: `Empty placeholder`,
    [
      8
      /* NOT_ALLOW_NEST_PLACEHOLDER */
    ]: `Not allowed nest placeholder`,
    [
      9
      /* INVALID_LINKED_FORMAT */
    ]: `Invalid linked format`,
    // parser error messages
    [
      10
      /* MUST_HAVE_MESSAGES_IN_PLURAL */
    ]: `Plural must have messages`,
    [
      11
      /* UNEXPECTED_EMPTY_LINKED_MODIFIER */
    ]: `Unexpected empty linked modifier`,
    [
      12
      /* UNEXPECTED_EMPTY_LINKED_KEY */
    ]: `Unexpected empty linked key`,
    [
      13
      /* UNEXPECTED_LEXICAL_ANALYSIS */
    ]: `Unexpected lexical analysis in token: '{0}'`
  };
  function createCompileError(code2, loc, options = {}) {
    const { domain, messages: messages2, args } = options;
    const msg = format$2((messages2 || errorMessages$2)[code2] || "", ...args || []);
    const error2 = new SyntaxError(String(msg));
    error2.code = code2;
    if (loc) {
      error2.location = loc;
    }
    error2.domain = domain;
    return error2;
  }
  /*!
    * @intlify/devtools-if v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const IntlifyDevToolsHooks = {
    I18nInit: "i18n:init",
    FunctionTranslate: "function:translate"
  };
  /*!
    * @intlify/core-base v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  let devtools = null;
  function setDevToolsHook(hook) {
    devtools = hook;
  }
  function initI18nDevTools(i18n2, version2, meta) {
    devtools && devtools.emit(IntlifyDevToolsHooks.I18nInit, {
      timestamp: Date.now(),
      i18n: i18n2,
      version: version2,
      meta
    });
  }
  const translateDevTools = /* @__PURE__ */ createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);
  function createDevToolsHook(hook) {
    return (payloads) => devtools && devtools.emit(hook, payloads);
  }
  const warnMessages$1 = {
    [
      0
      /* NOT_FOUND_KEY */
    ]: `Not found '{key}' key in '{locale}' locale messages.`,
    [
      1
      /* FALLBACK_TO_TRANSLATE */
    ]: `Fall back to translate '{key}' key with '{target}' locale.`,
    [
      2
      /* CANNOT_FORMAT_NUMBER */
    ]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
    [
      3
      /* FALLBACK_TO_NUMBER_FORMAT */
    ]: `Fall back to number format '{key}' key with '{target}' locale.`,
    [
      4
      /* CANNOT_FORMAT_DATE */
    ]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
    [
      5
      /* FALLBACK_TO_DATE_FORMAT */
    ]: `Fall back to datetime format '{key}' key with '{target}' locale.`
  };
  function getWarnMessage$1(code2, ...args) {
    return format$2(warnMessages$1[code2], ...args);
  }
  const VERSION$1 = "9.1.9";
  const NOT_REOSLVED = -1;
  const MISSING_RESOLVE_VALUE = "";
  function getDefaultLinkedModifiers() {
    return {
      upper: (val) => isString(val) ? val.toUpperCase() : val,
      lower: (val) => isString(val) ? val.toLowerCase() : val,
      // prettier-ignore
      capitalize: (val) => isString(val) ? `${val.charAt(0).toLocaleUpperCase()}${val.substr(1)}` : val
    };
  }
  let _compiler;
  let _additionalMeta = null;
  const setAdditionalMeta = (meta) => {
    _additionalMeta = meta;
  };
  const getAdditionalMeta = () => _additionalMeta;
  let _cid = 0;
  function createCoreContext(options = {}) {
    const version2 = isString(options.version) ? options.version : VERSION$1;
    const locale = isString(options.locale) ? options.locale : "en-US";
    const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
    const messages2 = isPlainObject$1(options.messages) ? options.messages : { [locale]: {} };
    const datetimeFormats = isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [locale]: {} };
    const numberFormats = isPlainObject$1(options.numberFormats) ? options.numberFormats : { [locale]: {} };
    const modifiers = assign$2({}, options.modifiers || {}, getDefaultLinkedModifiers());
    const pluralRules = options.pluralRules || {};
    const missing = isFunction$1(options.missing) ? options.missing : null;
    const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    const fallbackFormat = !!options.fallbackFormat;
    const unresolving = !!options.unresolving;
    const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    const processor = isPlainObject$1(options.processor) ? options.processor : null;
    const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    const escapeParameter = !!options.escapeParameter;
    const messageCompiler = isFunction$1(options.messageCompiler) ? options.messageCompiler : _compiler;
    const onWarn = isFunction$1(options.onWarn) ? options.onWarn : warn;
    const internalOptions = options;
    const __datetimeFormatters = isObject$3(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
    const __numberFormatters = isObject$3(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
    const __meta = isObject$3(internalOptions.__meta) ? internalOptions.__meta : {};
    _cid++;
    const context = {
      version: version2,
      cid: _cid,
      locale,
      fallbackLocale,
      messages: messages2,
      datetimeFormats,
      numberFormats,
      modifiers,
      pluralRules,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackFormat,
      unresolving,
      postTranslation,
      processor,
      warnHtmlMessage,
      escapeParameter,
      messageCompiler,
      onWarn,
      __datetimeFormatters,
      __numberFormatters,
      __meta
    };
    {
      context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : void 0;
    }
    {
      initI18nDevTools(context, version2, __meta);
    }
    return context;
  }
  function isTranslateFallbackWarn(fallback, key) {
    return fallback instanceof RegExp ? fallback.test(key) : fallback;
  }
  function isTranslateMissingWarn(missing, key) {
    return missing instanceof RegExp ? missing.test(key) : missing;
  }
  function handleMissing(context, key, locale, missingWarn, type) {
    const { missing, onWarn } = context;
    {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("missing", {
          locale,
          key,
          type,
          groupId: `${type}:${key}`
        });
      }
    }
    if (missing !== null) {
      const ret = missing(context, locale, key, type);
      return isString(ret) ? ret : key;
    } else {
      if (isTranslateMissingWarn(missingWarn, key)) {
        onWarn(getWarnMessage$1(0, { key, locale }));
      }
      return key;
    }
  }
  function getLocaleChain(ctx, fallback, start2) {
    const context = ctx;
    if (!context.__localeChainCache) {
      context.__localeChainCache = /* @__PURE__ */ new Map();
    }
    let chain = context.__localeChainCache.get(start2);
    if (!chain) {
      chain = [];
      let block = [start2];
      while (isArray(block)) {
        block = appendBlockToChain(chain, block, fallback);
      }
      const defaults = isArray(fallback) ? fallback : isPlainObject$1(fallback) ? fallback["default"] ? fallback["default"] : null : fallback;
      block = isString(defaults) ? [defaults] : defaults;
      if (isArray(block)) {
        appendBlockToChain(chain, block, false);
      }
      context.__localeChainCache.set(start2, chain);
    }
    return chain;
  }
  function appendBlockToChain(chain, block, blocks) {
    let follow = true;
    for (let i2 = 0; i2 < block.length && isBoolean(follow); i2++) {
      const locale = block[i2];
      if (isString(locale)) {
        follow = appendLocaleToChain(chain, block[i2], blocks);
      }
    }
    return follow;
  }
  function appendLocaleToChain(chain, locale, blocks) {
    let follow;
    const tokens = locale.split("-");
    do {
      const target = tokens.join("-");
      follow = appendItemToChain(chain, target, blocks);
      tokens.splice(-1, 1);
    } while (tokens.length && follow === true);
    return follow;
  }
  function appendItemToChain(chain, target, blocks) {
    let follow = false;
    if (!chain.includes(target)) {
      follow = true;
      if (target) {
        follow = target[target.length - 1] !== "!";
        const locale = target.replace(/!/g, "");
        chain.push(locale);
        if ((isArray(blocks) || isPlainObject$1(blocks)) && blocks[locale]) {
          follow = blocks[locale];
        }
      }
    }
    return follow;
  }
  function updateFallbackLocale(ctx, locale, fallback) {
    const context = ctx;
    context.__localeChainCache = /* @__PURE__ */ new Map();
    getLocaleChain(ctx, fallback, locale);
  }
  function createCoreError(code2) {
    return createCompileError(code2, null, { messages: errorMessages$1 });
  }
  const errorMessages$1 = {
    [
      14
      /* INVALID_ARGUMENT */
    ]: "Invalid arguments",
    [
      15
      /* INVALID_DATE_ARGUMENT */
    ]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
    [
      16
      /* INVALID_ISO_DATE_ARGUMENT */
    ]: "The argument provided is not a valid ISO date string"
  };
  const NOOP_MESSAGE_FUNCTION = () => "";
  const isMessageFunction = (val) => isFunction$1(val);
  function translate(context, ...args) {
    const { fallbackFormat, postTranslation, unresolving, fallbackLocale, messages: messages2 } = context;
    const [key, options] = parseTranslateArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
    const resolvedMessage = !!options.resolvedMessage;
    const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : key : fallbackFormat ? key : "";
    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
    const locale = isString(options.locale) ? options.locale : context.locale;
    escapeParameter && escapeParams(options);
    let [format2, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
      key,
      locale,
      messages2[locale] || {}
    ];
    let cacheBaseKey = key;
    if (!resolvedMessage && !(isString(format2) || isMessageFunction(format2))) {
      if (enableDefaultMsg) {
        format2 = defaultMsgOrKey;
        cacheBaseKey = format2;
      }
    }
    if (!resolvedMessage && (!(isString(format2) || isMessageFunction(format2)) || !isString(targetLocale))) {
      return unresolving ? NOT_REOSLVED : key;
    }
    if (isString(format2) && context.messageCompiler == null) {
      warn(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${key}'.`);
      return key;
    }
    let occurred = false;
    const errorDetector = () => {
      occurred = true;
    };
    const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, errorDetector) : format2;
    if (occurred) {
      return format2;
    }
    const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
    const msgContext = createMessageContext(ctxOptions);
    const messaged = evaluateMessage(context, msg, msgContext);
    const ret = postTranslation ? postTranslation(messaged) : messaged;
    {
      const payloads = {
        timestamp: Date.now(),
        key: isString(key) ? key : isMessageFunction(format2) ? format2.key : "",
        locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
        format: isString(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
        message: ret
      };
      payloads.meta = assign$2({}, context.__meta, getAdditionalMeta() || {});
      translateDevTools(payloads);
    }
    return ret;
  }
  function escapeParams(options) {
    if (isArray(options.list)) {
      options.list = options.list.map((item) => isString(item) ? escapeHtml(item) : item);
    } else if (isObject$3(options.named)) {
      Object.keys(options.named).forEach((key) => {
        if (isString(options.named[key])) {
          options.named[key] = escapeHtml(options.named[key]);
        }
      });
    }
  }
  function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
    const { messages: messages2, onWarn } = context;
    const locales = getLocaleChain(context, fallbackLocale, locale);
    let message = {};
    let targetLocale;
    let format2 = null;
    let from = locale;
    let to = null;
    const type = "translate";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = to = locales[i2];
      if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
        onWarn(getWarnMessage$1(1, {
          key,
          target: targetLocale
        }));
      }
      if (locale !== targetLocale) {
        const emitter = context.__v_emitter;
        if (emitter) {
          emitter.emit("fallback", {
            type,
            key,
            from,
            to,
            groupId: `${type}:${key}`
          });
        }
      }
      message = messages2[targetLocale] || {};
      let start2 = null;
      let startTag;
      let endTag;
      if (inBrowser$2) {
        start2 = window.performance.now();
        startTag = "intlify-message-resolve-start";
        endTag = "intlify-message-resolve-end";
        mark && mark(startTag);
      }
      if ((format2 = resolveValue(message, key)) === null) {
        format2 = message[key];
      }
      if (inBrowser$2) {
        const end2 = window.performance.now();
        const emitter = context.__v_emitter;
        if (emitter && start2 && format2) {
          emitter.emit("message-resolve", {
            type: "message-resolve",
            key,
            message: format2,
            time: end2 - start2,
            groupId: `${type}:${key}`
          });
        }
        if (startTag && endTag && mark && measure) {
          mark(endTag);
          measure("intlify message resolve", startTag, endTag);
        }
      }
      if (isString(format2) || isFunction$1(format2))
        break;
      const missingRet = handleMissing(context, key, targetLocale, missingWarn, type);
      if (missingRet !== key) {
        format2 = missingRet;
      }
      from = to;
    }
    return [format2, targetLocale, message];
  }
  function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, errorDetector) {
    const { messageCompiler, warnHtmlMessage } = context;
    if (isMessageFunction(format2)) {
      const msg2 = format2;
      msg2.locale = msg2.locale || targetLocale;
      msg2.key = msg2.key || key;
      return msg2;
    }
    let start2 = null;
    let startTag;
    let endTag;
    if (inBrowser$2) {
      start2 = window.performance.now();
      startTag = "intlify-message-compilation-start";
      endTag = "intlify-message-compilation-end";
      mark && mark(startTag);
    }
    const msg = messageCompiler(format2, getCompileOptions(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, errorDetector));
    if (inBrowser$2) {
      const end2 = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start2) {
        emitter.emit("message-compilation", {
          type: "message-compilation",
          message: format2,
          time: end2 - start2,
          groupId: `${"translate"}:${key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message compilation", startTag, endTag);
      }
    }
    msg.locale = targetLocale;
    msg.key = key;
    msg.source = format2;
    return msg;
  }
  function evaluateMessage(context, msg, msgCtx) {
    let start2 = null;
    let startTag;
    let endTag;
    if (inBrowser$2) {
      start2 = window.performance.now();
      startTag = "intlify-message-evaluation-start";
      endTag = "intlify-message-evaluation-end";
      mark && mark(startTag);
    }
    const messaged = msg(msgCtx);
    if (inBrowser$2) {
      const end2 = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start2) {
        emitter.emit("message-evaluation", {
          type: "message-evaluation",
          value: messaged,
          time: end2 - start2,
          groupId: `${"translate"}:${msg.key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message evaluation", startTag, endTag);
      }
    }
    return messaged;
  }
  function parseTranslateArgs(...args) {
    const [arg1, arg2, arg3] = args;
    const options = {};
    if (!isString(arg1) && !isNumber(arg1) && !isMessageFunction(arg1)) {
      throw createCoreError(
        14
        /* INVALID_ARGUMENT */
      );
    }
    const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
    if (isNumber(arg2)) {
      options.plural = arg2;
    } else if (isString(arg2)) {
      options.default = arg2;
    } else if (isPlainObject$1(arg2) && !isEmptyObject(arg2)) {
      options.named = arg2;
    } else if (isArray(arg2)) {
      options.list = arg2;
    }
    if (isNumber(arg3)) {
      options.plural = arg3;
    } else if (isString(arg3)) {
      options.default = arg3;
    } else if (isPlainObject$1(arg3)) {
      assign$2(options, arg3);
    }
    return [key, options];
  }
  function getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {
    return {
      warnHtmlMessage,
      onError: (err) => {
        errorDetector && errorDetector(err);
        {
          const message = `Message compilation error: ${err.message}`;
          const codeFrame = err.location && generateCodeFrame(source, err.location.start.offset, err.location.end.offset);
          const emitter = context.__v_emitter;
          if (emitter) {
            emitter.emit("compile-error", {
              message: source,
              error: err.message,
              start: err.location && err.location.start.offset,
              end: err.location && err.location.end.offset,
              groupId: `${"translate"}:${key}`
            });
          }
          console.error(codeFrame ? `${message}
${codeFrame}` : message);
        }
      },
      onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
    };
  }
  function getMessageContextOptions(context, locale, message, options) {
    const { modifiers, pluralRules } = context;
    const resolveMessage = (key) => {
      const val = resolveValue(message, key);
      if (isString(val)) {
        let occurred = false;
        const errorDetector = () => {
          occurred = true;
        };
        const msg = compileMessageFormat(context, key, locale, val, key, errorDetector);
        return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
      } else if (isMessageFunction(val)) {
        return val;
      } else {
        return NOOP_MESSAGE_FUNCTION;
      }
    };
    const ctxOptions = {
      locale,
      modifiers,
      pluralRules,
      messages: resolveMessage
    };
    if (context.processor) {
      ctxOptions.processor = context.processor;
    }
    if (options.list) {
      ctxOptions.list = options.list;
    }
    if (options.named) {
      ctxOptions.named = options.named;
    }
    if (isNumber(options.plural)) {
      ctxOptions.pluralIndex = options.plural;
    }
    return ctxOptions;
  }
  const intlDefined = typeof Intl !== "undefined";
  const Availabilities = {
    dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== "undefined",
    numberFormat: intlDefined && typeof Intl.NumberFormat !== "undefined"
  };
  function datetime(context, ...args) {
    const { datetimeFormats, unresolving, fallbackLocale, onWarn } = context;
    const { __datetimeFormatters } = context;
    if (!Availabilities.dateTimeFormat) {
      onWarn(getWarnMessage$1(
        4
        /* CANNOT_FORMAT_DATE */
      ));
      return MISSING_RESOLVE_VALUE;
    }
    const [key, value, options, overrides] = parseDateTimeArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale = isString(options.locale) ? options.locale : context.locale;
    const locales = getLocaleChain(context, fallbackLocale, locale);
    if (!isString(key) || key === "") {
      return new Intl.DateTimeFormat(locale).format(value);
    }
    let datetimeFormat = {};
    let targetLocale;
    let format2 = null;
    let from = locale;
    let to = null;
    const type = "datetime format";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = to = locales[i2];
      if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
        onWarn(getWarnMessage$1(5, {
          key,
          target: targetLocale
        }));
      }
      if (locale !== targetLocale) {
        const emitter = context.__v_emitter;
        if (emitter) {
          emitter.emit("fallback", {
            type,
            key,
            from,
            to,
            groupId: `${type}:${key}`
          });
        }
      }
      datetimeFormat = datetimeFormats[targetLocale] || {};
      format2 = datetimeFormat[key];
      if (isPlainObject$1(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
      from = to;
    }
    if (!isPlainObject$1(format2) || !isString(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __datetimeFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.DateTimeFormat(targetLocale, assign$2({}, format2, overrides));
      __datetimeFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  function parseDateTimeArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    let options = {};
    let overrides = {};
    let value;
    if (isString(arg1)) {
      if (!/\d{4}-\d{2}-\d{2}(T.*)?/.test(arg1)) {
        throw createCoreError(
          16
          /* INVALID_ISO_DATE_ARGUMENT */
        );
      }
      value = new Date(arg1);
      try {
        value.toISOString();
      } catch (e2) {
        throw createCoreError(
          16
          /* INVALID_ISO_DATE_ARGUMENT */
        );
      }
    } else if (isDate$1(arg1)) {
      if (isNaN(arg1.getTime())) {
        throw createCoreError(
          15
          /* INVALID_DATE_ARGUMENT */
        );
      }
      value = arg1;
    } else if (isNumber(arg1)) {
      value = arg1;
    } else {
      throw createCoreError(
        14
        /* INVALID_ARGUMENT */
      );
    }
    if (isString(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$1(arg2)) {
      options = arg2;
    }
    if (isString(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$1(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$1(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearDateTimeFormat(ctx, locale, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale}__${key}`;
      if (!context.__datetimeFormatters.has(id)) {
        continue;
      }
      context.__datetimeFormatters.delete(id);
    }
  }
  function number$1(context, ...args) {
    const { numberFormats, unresolving, fallbackLocale, onWarn } = context;
    const { __numberFormatters } = context;
    if (!Availabilities.numberFormat) {
      onWarn(getWarnMessage$1(
        2
        /* CANNOT_FORMAT_NUMBER */
      ));
      return MISSING_RESOLVE_VALUE;
    }
    const [key, value, options, overrides] = parseNumberArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale = isString(options.locale) ? options.locale : context.locale;
    const locales = getLocaleChain(context, fallbackLocale, locale);
    if (!isString(key) || key === "") {
      return new Intl.NumberFormat(locale).format(value);
    }
    let numberFormat = {};
    let targetLocale;
    let format2 = null;
    let from = locale;
    let to = null;
    const type = "number format";
    for (let i2 = 0; i2 < locales.length; i2++) {
      targetLocale = to = locales[i2];
      if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
        onWarn(getWarnMessage$1(3, {
          key,
          target: targetLocale
        }));
      }
      if (locale !== targetLocale) {
        const emitter = context.__v_emitter;
        if (emitter) {
          emitter.emit("fallback", {
            type,
            key,
            from,
            to,
            groupId: `${type}:${key}`
          });
        }
      }
      numberFormat = numberFormats[targetLocale] || {};
      format2 = numberFormat[key];
      if (isPlainObject$1(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
      from = to;
    }
    if (!isPlainObject$1(format2) || !isString(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __numberFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.NumberFormat(targetLocale, assign$2({}, format2, overrides));
      __numberFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  function parseNumberArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    let options = {};
    let overrides = {};
    if (!isNumber(arg1)) {
      throw createCoreError(
        14
        /* INVALID_ARGUMENT */
      );
    }
    const value = arg1;
    if (isString(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$1(arg2)) {
      options = arg2;
    }
    if (isString(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$1(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$1(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearNumberFormat(ctx, locale, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale}__${key}`;
      if (!context.__numberFormatters.has(id)) {
        continue;
      }
      context.__numberFormatters.delete(id);
    }
  }
  function getDevtoolsGlobalHook$1() {
    return getTarget$1().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget$1() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  }
  const isProxyAvailable$1 = typeof Proxy === "function";
  const HOOK_SETUP$1 = "devtools-plugin:setup";
  const HOOK_PLUGIN_SETTINGS_SET$1 = "plugin:settings:set";
  let ApiProxy$1 = class ApiProxy {
    constructor(plugin, hook) {
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      const defaultSettings = {};
      if (plugin.settings) {
        for (const id in plugin.settings) {
          const item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
      let currentSettings = { ...defaultSettings };
      try {
        const raw = localStorage.getItem(localSettingsSaveId);
        const data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e2) {
      }
      this.fallbacks = {
        getSettings() {
          return currentSettings;
        },
        setSettings(value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e2) {
          }
          currentSettings = value;
        }
      };
      hook.on(HOOK_PLUGIN_SETTINGS_SET$1, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
      this.proxiedOn = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target.on[prop];
          } else {
            return (...args) => {
              this.onQueue.push({
                method: prop,
                args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target[prop];
          } else if (prop === "on") {
            return this.proxiedOn;
          } else if (Object.keys(this.fallbacks).includes(prop)) {
            return (...args) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: () => {
                }
              });
              return this.fallbacks[prop](...args);
            };
          } else {
            return (...args) => {
              return new Promise((resolve) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve
                });
              });
            };
          }
        }
      });
    }
    async setRealTarget(target) {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(await this.target[item.method](...item.args));
      }
    }
  };
  function setupDevtoolsPlugin$1(pluginDescriptor, setupFn) {
    const target = getTarget$1();
    const hook = getDevtoolsGlobalHook$1();
    const enableProxy = isProxyAvailable$1 && pluginDescriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP$1, pluginDescriptor, setupFn);
    } else {
      const proxy = enableProxy ? new ApiProxy$1(pluginDescriptor, hook) : null;
      const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor,
        setupFn,
        proxy
      });
      if (proxy)
        setupFn(proxy.proxiedTarget);
    }
  }
  /*!
    * @intlify/vue-devtools v9.1.9
    * (c) 2021 kazuya kawaguchi
    * Released under the MIT License.
    */
  const VueDevToolsLabels = {
    [
      "vue-devtools-plugin-vue-i18n"
      /* PLUGIN */
    ]: "Vue I18n devtools",
    [
      "vue-i18n-resource-inspector"
      /* CUSTOM_INSPECTOR */
    ]: "I18n Resources",
    [
      "vue-i18n-timeline"
      /* TIMELINE */
    ]: "Vue I18n"
  };
  const VueDevToolsPlaceholders = {
    [
      "vue-i18n-resource-inspector"
      /* CUSTOM_INSPECTOR */
    ]: "Search for scopes ..."
  };
  const VueDevToolsTimelineColors = {
    [
      "vue-i18n-timeline"
      /* TIMELINE */
    ]: 16764185
  };
  /*!
    * vue-i18n v9.1.9
    * (c) 2022 kazuya kawaguchi
    * Released under the MIT License.
    */
  const VERSION = "9.1.9";
  function initFeatureFlags() {
    let needWarn = false;
    {
      needWarn = true;
    }
    if (needWarn) {
      console.warn(`You are running the esm-bundler build of vue-i18n. It is recommended to configure your bundler to explicitly replace feature flag globals with boolean literals to get proper tree-shaking in the final bundle.`);
    }
  }
  const warnMessages = {
    [
      6
      /* FALLBACK_TO_ROOT */
    ]: `Fall back to {type} '{key}' with root locale.`,
    [
      7
      /* NOT_SUPPORTED_PRESERVE */
    ]: `Not supported 'preserve'.`,
    [
      8
      /* NOT_SUPPORTED_FORMATTER */
    ]: `Not supported 'formatter'.`,
    [
      9
      /* NOT_SUPPORTED_PRESERVE_DIRECTIVE */
    ]: `Not supported 'preserveDirectiveContent'.`,
    [
      10
      /* NOT_SUPPORTED_GET_CHOICE_INDEX */
    ]: `Not supported 'getChoiceIndex'.`,
    [
      11
      /* COMPONENT_NAME_LEGACY_COMPATIBLE */
    ]: `Component name legacy compatible: '{name}' -> 'i18n'`,
    [
      12
      /* NOT_FOUND_PARENT_SCOPE */
    ]: `Not found parent scope. use the global scope.`
  };
  function getWarnMessage(code2, ...args) {
    return format$2(warnMessages[code2], ...args);
  }
  function createI18nError(code2, ...args) {
    return createCompileError(code2, null, { messages: errorMessages, args });
  }
  const errorMessages = {
    [
      14
      /* UNEXPECTED_RETURN_TYPE */
    ]: "Unexpected return type in composer",
    [
      15
      /* INVALID_ARGUMENT */
    ]: "Invalid argument",
    [
      16
      /* MUST_BE_CALL_SETUP_TOP */
    ]: "Must be called at the top of a `setup` function",
    [
      17
      /* NOT_INSLALLED */
    ]: "Need to install with `app.use` function",
    [
      22
      /* UNEXPECTED_ERROR */
    ]: "Unexpected error",
    [
      18
      /* NOT_AVAILABLE_IN_LEGACY_MODE */
    ]: "Not available in legacy mode",
    [
      19
      /* REQUIRED_VALUE */
    ]: `Required in value: {0}`,
    [
      20
      /* INVALID_VALUE */
    ]: `Invalid value`,
    [
      21
      /* CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN */
    ]: `Cannot setup vue-devtools plugin`
  };
  const DEVTOOLS_META = "__INTLIFY_META__";
  const TransrateVNodeSymbol = makeSymbol("__transrateVNode");
  const DatetimePartsSymbol = makeSymbol("__datetimeParts");
  const NumberPartsSymbol = makeSymbol("__numberParts");
  const EnableEmitter = makeSymbol("__enableEmitter");
  const DisableEmitter = makeSymbol("__disableEmitter");
  const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
  const InejctWithOption = makeSymbol("__injectWithOption");
  let composerID = 0;
  function defineCoreMissingHandler(missing) {
    return (ctx, locale, key, type) => {
      return missing(locale, key, vue.getCurrentInstance() || void 0, type);
    };
  }
  function getLocaleMessages(locale, options) {
    const { messages: messages2, __i18n } = options;
    const ret = isPlainObject$1(messages2) ? messages2 : isArray(__i18n) ? {} : { [locale]: {} };
    if (isArray(__i18n)) {
      __i18n.forEach(({ locale: locale2, resource }) => {
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy$1(resource, ret[locale2]);
        } else {
          deepCopy$1(resource, ret);
        }
      });
    }
    if (options.flatJson) {
      for (const key in ret) {
        if (hasOwn$2(ret, key)) {
          handleFlatJson(ret[key]);
        }
      }
    }
    return ret;
  }
  const isNotObjectOrIsArray = (val) => !isObject$3(val) || isArray(val);
  function deepCopy$1(src, des) {
    if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
      throw createI18nError(
        20
        /* INVALID_VALUE */
      );
    }
    for (const key in src) {
      if (hasOwn$2(src, key)) {
        if (isNotObjectOrIsArray(src[key]) || isNotObjectOrIsArray(des[key])) {
          des[key] = src[key];
        } else {
          deepCopy$1(src[key], des[key]);
        }
      }
    }
  }
  const getMetaInfo = () => {
    const instance2 = vue.getCurrentInstance();
    return instance2 && instance2.type[DEVTOOLS_META] ? { [DEVTOOLS_META]: instance2.type[DEVTOOLS_META] } : null;
  };
  function createComposer(options = {}) {
    const { __root } = options;
    const _isGlobal = __root === void 0;
    let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
    const _locale = vue.ref(
      // prettier-ignore
      __root && _inheritLocale ? __root.locale.value : isString(options.locale) ? options.locale : "en-US"
    );
    const _fallbackLocale = vue.ref(
      // prettier-ignore
      __root && _inheritLocale ? __root.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
    );
    const _messages = vue.ref(getLocaleMessages(_locale.value, options));
    const _datetimeFormats = vue.ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = vue.ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
    let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    let _fallbackFormat = !!options.fallbackFormat;
    let _missing = isFunction$1(options.missing) ? options.missing : null;
    let _runtimeMissing = isFunction$1(options.missing) ? defineCoreMissingHandler(options.missing) : null;
    let _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    let _warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    let _escapeParameter = !!options.escapeParameter;
    const _modifiers = __root ? __root.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
    let _pluralRules = options.pluralRules || __root && __root.pluralRules;
    let _context;
    function getCoreContext() {
      return createCoreContext({
        version: VERSION,
        locale: _locale.value,
        fallbackLocale: _fallbackLocale.value,
        messages: _messages.value,
        messageCompiler: function compileToFunction(source) {
          return (ctx) => {
            return ctx.normalize([source]);
          };
        },
        datetimeFormats: _datetimeFormats.value,
        numberFormats: _numberFormats.value,
        modifiers: _modifiers,
        pluralRules: _pluralRules,
        missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
        missingWarn: _missingWarn,
        fallbackWarn: _fallbackWarn,
        fallbackFormat: _fallbackFormat,
        unresolving: true,
        postTranslation: _postTranslation === null ? void 0 : _postTranslation,
        warnHtmlMessage: _warnHtmlMessage,
        escapeParameter: _escapeParameter,
        __datetimeFormatters: isPlainObject$1(_context) ? _context.__datetimeFormatters : void 0,
        __numberFormatters: isPlainObject$1(_context) ? _context.__numberFormatters : void 0,
        __v_emitter: isPlainObject$1(_context) ? _context.__v_emitter : void 0,
        __meta: { framework: "vue" }
      });
    }
    _context = getCoreContext();
    updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
    function trackReactivityValues() {
      return [
        _locale.value,
        _fallbackLocale.value,
        _messages.value,
        _datetimeFormats.value,
        _numberFormats.value
      ];
    }
    const locale = vue.computed({
      get: () => _locale.value,
      set: (val) => {
        _locale.value = val;
        _context.locale = _locale.value;
      }
    });
    const fallbackLocale = vue.computed({
      get: () => _fallbackLocale.value,
      set: (val) => {
        _fallbackLocale.value = val;
        _context.fallbackLocale = _fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, val);
      }
    });
    const messages2 = vue.computed(() => _messages.value);
    const datetimeFormats = vue.computed(() => _datetimeFormats.value);
    const numberFormats = vue.computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
      return isFunction$1(_postTranslation) ? _postTranslation : null;
    }
    function setPostTranslationHandler(handler) {
      _postTranslation = handler;
      _context.postTranslation = handler;
    }
    function getMissingHandler() {
      return _missing;
    }
    function setMissingHandler(handler) {
      if (handler !== null) {
        _runtimeMissing = defineCoreMissingHandler(handler);
      }
      _missing = handler;
      _context.missing = _runtimeMissing;
    }
    function isResolvedTranslateMessage(type, arg) {
      return type !== "translate" || !!arg.resolvedMessage === false;
    }
    function wrapWithDeps(fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) {
      trackReactivityValues();
      let ret;
      {
        try {
          setAdditionalMeta(getMetaInfo());
          ret = fn(_context);
        } finally {
          setAdditionalMeta(null);
        }
      }
      if (isNumber(ret) && ret === NOT_REOSLVED) {
        const [key, arg2] = argumentParser();
        if (__root && isString(key) && isResolvedTranslateMessage(warnType, arg2)) {
          if (_fallbackRoot && (isTranslateFallbackWarn(_fallbackWarn, key) || isTranslateMissingWarn(_missingWarn, key))) {
            warn(getWarnMessage(6, {
              key,
              type: warnType
            }));
          }
          {
            const { __v_emitter: emitter } = _context;
            if (emitter && _fallbackRoot) {
              emitter.emit("fallback", {
                type: warnType,
                key,
                to: "global",
                groupId: `${warnType}:${key}`
              });
            }
          }
        }
        return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
      } else if (successCondition(ret)) {
        return ret;
      } else {
        throw createI18nError(
          14
          /* UNEXPECTED_RETURN_TYPE */
        );
      }
    }
    function t2(...args) {
      return wrapWithDeps((context) => translate(context, ...args), () => parseTranslateArgs(...args), "translate", (root) => root.t(...args), (key) => key, (val) => isString(val));
    }
    function rt(...args) {
      const [arg1, arg2, arg3] = args;
      if (arg3 && !isObject$3(arg3)) {
        throw createI18nError(
          15
          /* INVALID_ARGUMENT */
        );
      }
      return t2(...[arg1, arg2, assign$2({ resolvedMessage: true }, arg3 || {})]);
    }
    function d2(...args) {
      return wrapWithDeps((context) => datetime(context, ...args), () => parseDateTimeArgs(...args), "datetime format", (root) => root.d(...args), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
    }
    function n2(...args) {
      return wrapWithDeps((context) => number$1(context, ...args), () => parseNumberArgs(...args), "number format", (root) => root.n(...args), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
    }
    function normalize(values) {
      return values.map((val) => isString(val) ? vue.createVNode(vue.Text, null, val, 0) : val);
    }
    const interpolate = (val) => val;
    const processor = {
      normalize,
      interpolate,
      type: "vnode"
    };
    function transrateVNode(...args) {
      return wrapWithDeps(
        (context) => {
          let ret;
          const _context2 = context;
          try {
            _context2.processor = processor;
            ret = translate(_context2, ...args);
          } finally {
            _context2.processor = null;
          }
          return ret;
        },
        () => parseTranslateArgs(...args),
        "translate",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (root) => root[TransrateVNodeSymbol](...args),
        (key) => [vue.createVNode(vue.Text, null, key, 0)],
        (val) => isArray(val)
      );
    }
    function numberParts(...args) {
      return wrapWithDeps(
        (context) => number$1(context, ...args),
        () => parseNumberArgs(...args),
        "number format",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (root) => root[NumberPartsSymbol](...args),
        () => [],
        (val) => isString(val) || isArray(val)
      );
    }
    function datetimeParts(...args) {
      return wrapWithDeps(
        (context) => datetime(context, ...args),
        () => parseDateTimeArgs(...args),
        "datetime format",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (root) => root[DatetimePartsSymbol](...args),
        () => [],
        (val) => isString(val) || isArray(val)
      );
    }
    function setPluralRules(rules) {
      _pluralRules = rules;
      _context.pluralRules = _pluralRules;
    }
    function te(key, locale2) {
      const targetLocale = isString(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      return resolveValue(message, key) !== null;
    }
    function resolveMessages(key) {
      let messages22 = null;
      const locales = getLocaleChain(_context, _fallbackLocale.value, _locale.value);
      for (let i2 = 0; i2 < locales.length; i2++) {
        const targetLocaleMessages = _messages.value[locales[i2]] || {};
        const messageValue = resolveValue(targetLocaleMessages, key);
        if (messageValue != null) {
          messages22 = messageValue;
          break;
        }
      }
      return messages22;
    }
    function tm(key) {
      const messages22 = resolveMessages(key);
      return messages22 != null ? messages22 : __root ? __root.tm(key) || {} : {};
    }
    function getLocaleMessage(locale2) {
      return _messages.value[locale2] || {};
    }
    function setLocaleMessage(locale2, message) {
      _messages.value[locale2] = message;
      _context.messages = _messages.value;
    }
    function mergeLocaleMessage(locale2, message) {
      _messages.value[locale2] = _messages.value[locale2] || {};
      deepCopy$1(message, _messages.value[locale2]);
      _context.messages = _messages.value;
    }
    function getDateTimeFormat(locale2) {
      return _datetimeFormats.value[locale2] || {};
    }
    function setDateTimeFormat(locale2, format2) {
      _datetimeFormats.value[locale2] = format2;
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale2, format2);
    }
    function mergeDateTimeFormat(locale2, format2) {
      _datetimeFormats.value[locale2] = assign$2(_datetimeFormats.value[locale2] || {}, format2);
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale2, format2);
    }
    function getNumberFormat(locale2) {
      return _numberFormats.value[locale2] || {};
    }
    function setNumberFormat(locale2, format2) {
      _numberFormats.value[locale2] = format2;
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale2, format2);
    }
    function mergeNumberFormat(locale2, format2) {
      _numberFormats.value[locale2] = assign$2(_numberFormats.value[locale2] || {}, format2);
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale2, format2);
    }
    composerID++;
    if (__root) {
      vue.watch(__root.locale, (val) => {
        if (_inheritLocale) {
          _locale.value = val;
          _context.locale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
      vue.watch(__root.fallbackLocale, (val) => {
        if (_inheritLocale) {
          _fallbackLocale.value = val;
          _context.fallbackLocale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
    }
    const composer = {
      id: composerID,
      locale,
      fallbackLocale,
      get inheritLocale() {
        return _inheritLocale;
      },
      set inheritLocale(val) {
        _inheritLocale = val;
        if (val && __root) {
          _locale.value = __root.locale.value;
          _fallbackLocale.value = __root.fallbackLocale.value;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      },
      get availableLocales() {
        return Object.keys(_messages.value).sort();
      },
      messages: messages2,
      datetimeFormats,
      numberFormats,
      get modifiers() {
        return _modifiers;
      },
      get pluralRules() {
        return _pluralRules || {};
      },
      get isGlobal() {
        return _isGlobal;
      },
      get missingWarn() {
        return _missingWarn;
      },
      set missingWarn(val) {
        _missingWarn = val;
        _context.missingWarn = _missingWarn;
      },
      get fallbackWarn() {
        return _fallbackWarn;
      },
      set fallbackWarn(val) {
        _fallbackWarn = val;
        _context.fallbackWarn = _fallbackWarn;
      },
      get fallbackRoot() {
        return _fallbackRoot;
      },
      set fallbackRoot(val) {
        _fallbackRoot = val;
      },
      get fallbackFormat() {
        return _fallbackFormat;
      },
      set fallbackFormat(val) {
        _fallbackFormat = val;
        _context.fallbackFormat = _fallbackFormat;
      },
      get warnHtmlMessage() {
        return _warnHtmlMessage;
      },
      set warnHtmlMessage(val) {
        _warnHtmlMessage = val;
        _context.warnHtmlMessage = val;
      },
      get escapeParameter() {
        return _escapeParameter;
      },
      set escapeParameter(val) {
        _escapeParameter = val;
        _context.escapeParameter = val;
      },
      t: t2,
      rt,
      d: d2,
      n: n2,
      te,
      tm,
      getLocaleMessage,
      setLocaleMessage,
      mergeLocaleMessage,
      getDateTimeFormat,
      setDateTimeFormat,
      mergeDateTimeFormat,
      getNumberFormat,
      setNumberFormat,
      mergeNumberFormat,
      getPostTranslationHandler,
      setPostTranslationHandler,
      getMissingHandler,
      setMissingHandler,
      [TransrateVNodeSymbol]: transrateVNode,
      [NumberPartsSymbol]: numberParts,
      [DatetimePartsSymbol]: datetimeParts,
      [SetPluralRulesSymbol]: setPluralRules,
      [InejctWithOption]: options.__injectWithOption
      // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    {
      composer[EnableEmitter] = (emitter) => {
        _context.__v_emitter = emitter;
      };
      composer[DisableEmitter] = () => {
        _context.__v_emitter = void 0;
      };
    }
    return composer;
  }
  function convertComposerOptions(options) {
    const locale = isString(options.locale) ? options.locale : "en-US";
    const fallbackLocale = isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
    const missing = isFunction$1(options.missing) ? options.missing : void 0;
    const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
    const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
    const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    const fallbackFormat = !!options.formatFallbackMessages;
    const modifiers = isPlainObject$1(options.modifiers) ? options.modifiers : {};
    const pluralizationRules = options.pluralizationRules;
    const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : void 0;
    const warnHtmlMessage = isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
    const escapeParameter = !!options.escapeParameterHtml;
    const inheritLocale = isBoolean(options.sync) ? options.sync : true;
    if (options.formatter) {
      warn(getWarnMessage(
        8
        /* NOT_SUPPORTED_FORMATTER */
      ));
    }
    if (options.preserveDirectiveContent) {
      warn(getWarnMessage(
        9
        /* NOT_SUPPORTED_PRESERVE_DIRECTIVE */
      ));
    }
    let messages2 = options.messages;
    if (isPlainObject$1(options.sharedMessages)) {
      const sharedMessages = options.sharedMessages;
      const locales = Object.keys(sharedMessages);
      messages2 = locales.reduce((messages22, locale2) => {
        const message = messages22[locale2] || (messages22[locale2] = {});
        assign$2(message, sharedMessages[locale2]);
        return messages22;
      }, messages2 || {});
    }
    const { __i18n, __root, __injectWithOption } = options;
    const datetimeFormats = options.datetimeFormats;
    const numberFormats = options.numberFormats;
    const flatJson = options.flatJson;
    return {
      locale,
      fallbackLocale,
      messages: messages2,
      flatJson,
      datetimeFormats,
      numberFormats,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackRoot,
      fallbackFormat,
      modifiers,
      pluralRules: pluralizationRules,
      postTranslation,
      warnHtmlMessage,
      escapeParameter,
      inheritLocale,
      __i18n,
      __root,
      __injectWithOption
    };
  }
  function createVueI18n(options = {}) {
    const composer = createComposer(convertComposerOptions(options));
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        warn(getWarnMessage(
          8
          /* NOT_SUPPORTED_FORMATTER */
        ));
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
        warn(getWarnMessage(
          8
          /* NOT_SUPPORTED_FORMATTER */
        ));
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        warn(getWarnMessage(
          9
          /* NOT_SUPPORTED_PRESERVE_DIRECTIVE */
        ));
        return true;
      },
      set preserveDirectiveContent(val) {
        warn(getWarnMessage(
          9
          /* NOT_SUPPORTED_PRESERVE_DIRECTIVE */
        ));
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(
            15
            /* INVALID_ARGUMENT */
          );
        }
        const key = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return composer.t(key, list || named || {}, options2);
      },
      rt(...args) {
        return composer.rt(...args);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(
            15
            /* INVALID_ARGUMENT */
          );
        }
        const key = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isNumber(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isString(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return composer.t(key, list || named || {}, options2);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return composer.d(...args);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      // n
      n(...args) {
        return composer.n(...args);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        warn(getWarnMessage(
          10
          /* NOT_SUPPORTED_GET_CHOICE_INDEX */
        ));
        return -1;
      },
      // for internal
      __onComponentInstanceCreated(target) {
        const { componentInstanceCreatedListener } = options;
        if (componentInstanceCreatedListener) {
          componentInstanceCreatedListener(target, vueI18n);
        }
      }
    };
    {
      vueI18n.__enableEmitter = (emitter) => {
        const __composer = composer;
        __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
      };
      vueI18n.__disableEmitter = () => {
        const __composer = composer;
        __composer[DisableEmitter] && __composer[DisableEmitter]();
      };
    }
    return vueI18n;
  }
  const baseFormatProps = {
    tag: {
      type: [String, Object]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: (val) => val === "parent" || val === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };
  const Translation = {
    /* eslint-disable */
    name: "i18n-t",
    props: assign$2({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [Number, String],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        validator: (val) => isNumber(val) || !isNaN(val)
      }
    }, baseFormatProps),
    /* eslint-enable */
    setup(props2, context) {
      const { slots, attrs } = context;
      const i18n2 = props2.i18n || useI18n({
        useScope: props2.scope,
        __useComponent: true
      });
      const keys = Object.keys(slots).filter((key) => key !== "_");
      return () => {
        const options = {};
        if (props2.locale) {
          options.locale = props2.locale;
        }
        if (props2.plural !== void 0) {
          options.plural = isString(props2.plural) ? +props2.plural : props2.plural;
        }
        const arg = getInterpolateArg(context, keys);
        const children = i18n2[TransrateVNodeSymbol](props2.keypath, arg, options);
        const assignedAttrs = assign$2({}, attrs);
        return isString(props2.tag) ? vue.h(props2.tag, assignedAttrs, children) : isObject$3(props2.tag) ? vue.h(props2.tag, assignedAttrs, children) : vue.h(vue.Fragment, assignedAttrs, children);
      };
    }
  };
  function getInterpolateArg({ slots }, keys) {
    if (keys.length === 1 && keys[0] === "default") {
      return slots.default ? slots.default() : [];
    } else {
      return keys.reduce((arg, key) => {
        const slot = slots[key];
        if (slot) {
          arg[key] = slot();
        }
        return arg;
      }, {});
    }
  }
  function renderFormatter(props2, context, slotKeys, partFormatter) {
    const { slots, attrs } = context;
    return () => {
      const options = { part: true };
      let overrides = {};
      if (props2.locale) {
        options.locale = props2.locale;
      }
      if (isString(props2.format)) {
        options.key = props2.format;
      } else if (isObject$3(props2.format)) {
        if (isString(props2.format.key)) {
          options.key = props2.format.key;
        }
        overrides = Object.keys(props2.format).reduce((options2, prop) => {
          return slotKeys.includes(prop) ? assign$2({}, options2, { [prop]: props2.format[prop] }) : options2;
        }, {});
      }
      const parts = partFormatter(...[props2.value, options, overrides]);
      let children = [options.key];
      if (isArray(parts)) {
        children = parts.map((part, index2) => {
          const slot = slots[part.type];
          return slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
        });
      } else if (isString(parts)) {
        children = [parts];
      }
      const assignedAttrs = assign$2({}, attrs);
      return isString(props2.tag) ? vue.h(props2.tag, assignedAttrs, children) : isObject$3(props2.tag) ? vue.h(props2.tag, assignedAttrs, children) : vue.h(vue.Fragment, assignedAttrs, children);
    };
  }
  const NUMBER_FORMAT_KEYS = [
    "localeMatcher",
    "style",
    "unit",
    "unitDisplay",
    "currency",
    "currencyDisplay",
    "useGrouping",
    "numberingSystem",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "notation",
    "formatMatcher"
  ];
  const NumberFormat = {
    /* eslint-disable */
    name: "i18n-n",
    props: assign$2({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    setup(props2, context) {
      const i18n2 = props2.i18n || useI18n({ useScope: "parent", __useComponent: true });
      return renderFormatter(props2, context, NUMBER_FORMAT_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[NumberPartsSymbol](...args)
      ));
    }
  };
  const DATETIME_FORMAT_KEYS = [
    "dateStyle",
    "timeStyle",
    "fractionalSecondDigits",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "localeMatcher",
    "timeZone",
    "hour12",
    "hourCycle",
    "formatMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName"
  ];
  const DatetimeFormat = {
    /* eslint-disable */
    name: "i18n-d",
    props: assign$2({
      value: {
        type: [Number, Date],
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    setup(props2, context) {
      const i18n2 = props2.i18n || useI18n({ useScope: "parent", __useComponent: true });
      return renderFormatter(props2, context, DATETIME_FORMAT_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[DatetimePartsSymbol](...args)
      ));
    }
  };
  function getComposer$2(i18n2, instance2) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      return i18nInternal.__getInstance(instance2) || i18n2.global;
    } else {
      const vueI18n = i18nInternal.__getInstance(instance2);
      return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
    }
  }
  function vTDirective(i18n2) {
    const bind = (el, { instance: instance2, value, modifiers }) => {
      if (!instance2 || !instance2.$) {
        throw createI18nError(
          22
          /* UNEXPECTED_ERROR */
        );
      }
      const composer = getComposer$2(i18n2, instance2.$);
      if (modifiers.preserve) {
        warn(getWarnMessage(
          7
          /* NOT_SUPPORTED_PRESERVE */
        ));
      }
      const parsedValue = parseValue(value);
      el.textContent = composer.t(...makeParams(parsedValue));
    };
    return {
      beforeMount: bind,
      beforeUpdate: bind
    };
  }
  function parseValue(value) {
    if (isString(value)) {
      return { path: value };
    } else if (isPlainObject$1(value)) {
      if (!("path" in value)) {
        throw createI18nError(19, "path");
      }
      return value;
    } else {
      throw createI18nError(
        20
        /* INVALID_VALUE */
      );
    }
  }
  function makeParams(value) {
    const { path, locale, args, choice, plural } = value;
    const options = {};
    const named = args || {};
    if (isString(locale)) {
      options.locale = locale;
    }
    if (isNumber(choice)) {
      options.plural = choice;
    }
    if (isNumber(plural)) {
      options.plural = plural;
    }
    return [path, named, options];
  }
  function apply(app, i18n2, ...options) {
    const pluginOptions = isPlainObject$1(options[0]) ? options[0] : {};
    const useI18nComponentName = !!pluginOptions.useI18nComponentName;
    const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
    if (globalInstall && useI18nComponentName) {
      warn(getWarnMessage(11, {
        name: Translation.name
      }));
    }
    if (globalInstall) {
      app.component(!useI18nComponentName ? Translation.name : "i18n", Translation);
      app.component(NumberFormat.name, NumberFormat);
      app.component(DatetimeFormat.name, DatetimeFormat);
    }
    app.directive("t", vTDirective(i18n2));
  }
  const VUE_I18N_COMPONENT_TYPES = "vue-i18n: composer properties";
  let devtoolsApi;
  async function enableDevTools(app, i18n2) {
    return new Promise((resolve, reject) => {
      try {
        setupDevtoolsPlugin$1({
          id: "vue-devtools-plugin-vue-i18n",
          label: VueDevToolsLabels[
            "vue-devtools-plugin-vue-i18n"
            /* PLUGIN */
          ],
          packageName: "vue-i18n",
          homepage: "https://vue-i18n.intlify.dev",
          logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
          componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
          app
        }, (api) => {
          devtoolsApi = api;
          api.on.visitComponentTree(({ componentInstance, treeNode }) => {
            updateComponentTreeTags(componentInstance, treeNode, i18n2);
          });
          api.on.inspectComponent(({ componentInstance, instanceData }) => {
            if (componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
              if (i18n2.mode === "legacy") {
                if (componentInstance.vnode.el.__VUE_I18N__ !== i18n2.global.__composer) {
                  inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
                }
              } else {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            }
          });
          api.addInspector({
            id: "vue-i18n-resource-inspector",
            label: VueDevToolsLabels[
              "vue-i18n-resource-inspector"
              /* CUSTOM_INSPECTOR */
            ],
            icon: "language",
            treeFilterPlaceholder: VueDevToolsPlaceholders[
              "vue-i18n-resource-inspector"
              /* CUSTOM_INSPECTOR */
            ]
          });
          api.on.getInspectorTree((payload) => {
            if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
              registerScope(payload, i18n2);
            }
          });
          api.on.getInspectorState((payload) => {
            if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
              inspectScope(payload, i18n2);
            }
          });
          api.on.editInspectorState((payload) => {
            if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
              editScope(payload, i18n2);
            }
          });
          api.addTimelineLayer({
            id: "vue-i18n-timeline",
            label: VueDevToolsLabels[
              "vue-i18n-timeline"
              /* TIMELINE */
            ],
            color: VueDevToolsTimelineColors[
              "vue-i18n-timeline"
              /* TIMELINE */
            ]
          });
          resolve(true);
        });
      } catch (e2) {
        console.error(e2);
        reject(false);
      }
    });
  }
  function updateComponentTreeTags(instance2, treeNode, i18n2) {
    const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    if (instance2 && instance2.vnode.el.__VUE_I18N__) {
      if (instance2.vnode.el.__VUE_I18N__ !== global2) {
        const label = instance2.type.name || instance2.type.displayName || instance2.type.__file;
        const tag = {
          label: `i18n (${label} Scope)`,
          textColor: 0,
          backgroundColor: 16764185
        };
        treeNode.tags.push(tag);
      }
    }
  }
  function inspectComposer(instanceData, composer) {
    const type = VUE_I18N_COMPONENT_TYPES;
    instanceData.state.push({
      type,
      key: "locale",
      editable: true,
      value: composer.locale.value
    });
    instanceData.state.push({
      type,
      key: "availableLocales",
      editable: false,
      value: composer.availableLocales
    });
    instanceData.state.push({
      type,
      key: "fallbackLocale",
      editable: true,
      value: composer.fallbackLocale.value
    });
    instanceData.state.push({
      type,
      key: "inheritLocale",
      editable: true,
      value: composer.inheritLocale
    });
    instanceData.state.push({
      type,
      key: "messages",
      editable: false,
      value: getLocaleMessageValue(composer.messages.value)
    });
    instanceData.state.push({
      type,
      key: "datetimeFormats",
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: "numberFormats",
      editable: false,
      value: composer.numberFormats.value
    });
  }
  function getLocaleMessageValue(messages2) {
    const value = {};
    Object.keys(messages2).forEach((key) => {
      const v2 = messages2[key];
      if (isFunction$1(v2) && "source" in v2) {
        value[key] = getMessageFunctionDetails(v2);
      } else if (isObject$3(v2)) {
        value[key] = getLocaleMessageValue(v2);
      } else {
        value[key] = v2;
      }
    });
    return value;
  }
  const ESC = {
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "&": "&amp;"
  };
  function escape(s2) {
    return s2.replace(/[<>"&]/g, escapeChar);
  }
  function escapeChar(a2) {
    return ESC[a2] || a2;
  }
  function getMessageFunctionDetails(func2) {
    const argString = func2.source ? `("${escape(func2.source)}")` : `(?)`;
    return {
      _custom: {
        type: "function",
        display: `<span></span> ${argString}`
      }
    };
  }
  function registerScope(payload, i18n2) {
    payload.rootNodes.push({
      id: "global",
      label: "Global Scope"
    });
    const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    for (const [keyInstance, instance2] of i18n2.__instances) {
      const composer = i18n2.mode === "composition" ? instance2 : instance2.__composer;
      if (global2 === composer) {
        continue;
      }
      const label = keyInstance.type.name || keyInstance.type.displayName || keyInstance.type.__file;
      payload.rootNodes.push({
        id: composer.id.toString(),
        label: `${label} Scope`
      });
    }
  }
  function getComposer$1(nodeId, i18n2) {
    if (nodeId === "global") {
      return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    } else {
      const instance2 = Array.from(i18n2.__instances.values()).find((item) => item.id.toString() === nodeId);
      if (instance2) {
        return i18n2.mode === "composition" ? instance2 : instance2.__composer;
      } else {
        return null;
      }
    }
  }
  function inspectScope(payload, i18n2) {
    const composer = getComposer$1(payload.nodeId, i18n2);
    if (composer) {
      payload.state = makeScopeInspectState(composer);
    }
  }
  function makeScopeInspectState(composer) {
    const state = {};
    const localeType = "Locale related info";
    const localeStates = [
      {
        type: localeType,
        key: "locale",
        editable: true,
        value: composer.locale.value
      },
      {
        type: localeType,
        key: "fallbackLocale",
        editable: true,
        value: composer.fallbackLocale.value
      },
      {
        type: localeType,
        key: "availableLocales",
        editable: false,
        value: composer.availableLocales
      },
      {
        type: localeType,
        key: "inheritLocale",
        editable: true,
        value: composer.inheritLocale
      }
    ];
    state[localeType] = localeStates;
    const localeMessagesType = "Locale messages info";
    const localeMessagesStates = [
      {
        type: localeMessagesType,
        key: "messages",
        editable: false,
        value: getLocaleMessageValue(composer.messages.value)
      }
    ];
    state[localeMessagesType] = localeMessagesStates;
    const datetimeFormatsType = "Datetime formats info";
    const datetimeFormatsStates = [
      {
        type: datetimeFormatsType,
        key: "datetimeFormats",
        editable: false,
        value: composer.datetimeFormats.value
      }
    ];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = "Datetime formats info";
    const numberFormatsStates = [
      {
        type: numberFormatsType,
        key: "numberFormats",
        editable: false,
        value: composer.numberFormats.value
      }
    ];
    state[numberFormatsType] = numberFormatsStates;
    return state;
  }
  function addTimelineEvent(event, payload) {
    if (devtoolsApi) {
      let groupId;
      if (payload && "groupId" in payload) {
        groupId = payload.groupId;
        delete payload.groupId;
      }
      devtoolsApi.addTimelineEvent({
        layerId: "vue-i18n-timeline",
        event: {
          title: event,
          groupId,
          time: Date.now(),
          meta: {},
          data: payload || {},
          logType: event === "compile-error" ? "error" : event === "fallback" || event === "missing" ? "warning" : "default"
        }
      });
    }
  }
  function editScope(payload, i18n2) {
    const composer = getComposer$1(payload.nodeId, i18n2);
    if (composer) {
      const [field] = payload.path;
      if (field === "locale" && isString(payload.state.value)) {
        composer.locale.value = payload.state.value;
      } else if (field === "fallbackLocale" && (isString(payload.state.value) || isArray(payload.state.value) || isObject$3(payload.state.value))) {
        composer.fallbackLocale.value = payload.state.value;
      } else if (field === "inheritLocale" && isBoolean(payload.state.value)) {
        composer.inheritLocale = payload.state.value;
      }
    }
  }
  function defineMixin(vuei18n, composer, i18n2) {
    return {
      beforeCreate() {
        const instance2 = vue.getCurrentInstance();
        if (!instance2) {
          throw createI18nError(
            22
            /* UNEXPECTED_ERROR */
          );
        }
        const options = this.$options;
        if (options.i18n) {
          const optionsI18n = options.i18n;
          if (options.__i18n) {
            optionsI18n.__i18n = options.__i18n;
          }
          optionsI18n.__root = composer;
          if (this === this.$root) {
            this.$i18n = mergeToRoot(vuei18n, optionsI18n);
          } else {
            optionsI18n.__injectWithOption = true;
            this.$i18n = createVueI18n(optionsI18n);
          }
        } else if (options.__i18n) {
          if (this === this.$root) {
            this.$i18n = mergeToRoot(vuei18n, options);
          } else {
            this.$i18n = createVueI18n({
              __i18n: options.__i18n,
              __injectWithOption: true,
              __root: composer
            });
          }
        } else {
          this.$i18n = vuei18n;
        }
        vuei18n.__onComponentInstanceCreated(this.$i18n);
        i18n2.__setInstance(instance2, this.$i18n);
        this.$t = (...args) => this.$i18n.t(...args);
        this.$rt = (...args) => this.$i18n.rt(...args);
        this.$tc = (...args) => this.$i18n.tc(...args);
        this.$te = (key, locale) => this.$i18n.te(key, locale);
        this.$d = (...args) => this.$i18n.d(...args);
        this.$n = (...args) => this.$i18n.n(...args);
        this.$tm = (key) => this.$i18n.tm(key);
      },
      mounted() {
        {
          this.$el.__VUE_I18N__ = this.$i18n.__composer;
          const emitter = this.__v_emitter = createEmitter();
          const _vueI18n = this.$i18n;
          _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          emitter.on("*", addTimelineEvent);
        }
      },
      beforeUnmount() {
        const instance2 = vue.getCurrentInstance();
        if (!instance2) {
          throw createI18nError(
            22
            /* UNEXPECTED_ERROR */
          );
        }
        {
          if (this.__v_emitter) {
            this.__v_emitter.off("*", addTimelineEvent);
            delete this.__v_emitter;
          }
          const _vueI18n = this.$i18n;
          _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();
          delete this.$el.__VUE_I18N__;
        }
        delete this.$t;
        delete this.$rt;
        delete this.$tc;
        delete this.$te;
        delete this.$d;
        delete this.$n;
        delete this.$tm;
        i18n2.__deleteInstance(instance2);
        delete this.$i18n;
      }
    };
  }
  function mergeToRoot(root, options) {
    root.locale = options.locale || root.locale;
    root.fallbackLocale = options.fallbackLocale || root.fallbackLocale;
    root.missing = options.missing || root.missing;
    root.silentTranslationWarn = options.silentTranslationWarn || root.silentFallbackWarn;
    root.silentFallbackWarn = options.silentFallbackWarn || root.silentFallbackWarn;
    root.formatFallbackMessages = options.formatFallbackMessages || root.formatFallbackMessages;
    root.postTranslation = options.postTranslation || root.postTranslation;
    root.warnHtmlInMessage = options.warnHtmlInMessage || root.warnHtmlInMessage;
    root.escapeParameterHtml = options.escapeParameterHtml || root.escapeParameterHtml;
    root.sync = options.sync || root.sync;
    root.__composer[SetPluralRulesSymbol](options.pluralizationRules || root.pluralizationRules);
    const messages2 = getLocaleMessages(root.locale, {
      messages: options.messages,
      __i18n: options.__i18n
    });
    Object.keys(messages2).forEach((locale) => root.mergeLocaleMessage(locale, messages2[locale]));
    if (options.datetimeFormats) {
      Object.keys(options.datetimeFormats).forEach((locale) => root.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
    }
    if (options.numberFormats) {
      Object.keys(options.numberFormats).forEach((locale) => root.mergeNumberFormat(locale, options.numberFormats[locale]));
    }
    return root;
  }
  function createI18n(options = {}) {
    const __legacyMode = isBoolean(options.legacy) ? options.legacy : true;
    const __globalInjection = !!options.globalInjection;
    const __instances = /* @__PURE__ */ new Map();
    const __global = __legacyMode ? createVueI18n(options) : createComposer(options);
    const symbol = makeSymbol("vue-i18n");
    const i18n2 = {
      // mode
      get mode() {
        return __legacyMode ? "legacy" : "composition";
      },
      // install plugin
      async install(app, ...options2) {
        {
          app.__VUE_I18N__ = i18n2;
        }
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n2);
        if (!__legacyMode && __globalInjection) {
          injectGlobalFields(app, i18n2.global);
        }
        {
          apply(app, i18n2, ...options2);
        }
        if (__legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        {
          const ret = await enableDevTools(app, i18n2);
          if (!ret) {
            throw createI18nError(
              21
              /* CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN */
            );
          }
          const emitter = createEmitter();
          if (__legacyMode) {
            const _vueI18n = __global;
            _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          } else {
            const _composer = __global;
            _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
          }
          emitter.on("*", addTimelineEvent);
        }
      },
      // global accessor
      get global() {
        return __global;
      },
      // @internal
      __instances,
      // @internal
      __getInstance(component) {
        return __instances.get(component) || null;
      },
      // @internal
      __setInstance(component, instance2) {
        __instances.set(component, instance2);
      },
      // @internal
      __deleteInstance(component) {
        __instances.delete(component);
      }
    };
    return i18n2;
  }
  function useI18n(options = {}) {
    const instance2 = vue.getCurrentInstance();
    if (instance2 == null) {
      throw createI18nError(
        16
        /* MUST_BE_CALL_SETUP_TOP */
      );
    }
    if (!instance2.appContext.app.__VUE_I18N_SYMBOL__) {
      throw createI18nError(
        17
        /* NOT_INSLALLED */
      );
    }
    const i18n2 = vue.inject(instance2.appContext.app.__VUE_I18N_SYMBOL__);
    if (!i18n2) {
      throw createI18nError(
        22
        /* UNEXPECTED_ERROR */
      );
    }
    const global2 = i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    const scope = isEmptyObject(options) ? "__i18n" in instance2.type ? "local" : "global" : !options.useScope ? "local" : options.useScope;
    if (scope === "global") {
      let messages2 = isObject$3(options.messages) ? options.messages : {};
      if ("__i18nGlobal" in instance2.type) {
        messages2 = getLocaleMessages(global2.locale.value, {
          messages: messages2,
          __i18n: instance2.type.__i18nGlobal
        });
      }
      const locales = Object.keys(messages2);
      if (locales.length) {
        locales.forEach((locale) => {
          global2.mergeLocaleMessage(locale, messages2[locale]);
        });
      }
      if (isObject$3(options.datetimeFormats)) {
        const locales2 = Object.keys(options.datetimeFormats);
        if (locales2.length) {
          locales2.forEach((locale) => {
            global2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
          });
        }
      }
      if (isObject$3(options.numberFormats)) {
        const locales2 = Object.keys(options.numberFormats);
        if (locales2.length) {
          locales2.forEach((locale) => {
            global2.mergeNumberFormat(locale, options.numberFormats[locale]);
          });
        }
      }
      return global2;
    }
    if (scope === "parent") {
      let composer2 = getComposer(i18n2, instance2, options.__useComponent);
      if (composer2 == null) {
        {
          warn(getWarnMessage(
            12
            /* NOT_FOUND_PARENT_SCOPE */
          ));
        }
        composer2 = global2;
      }
      return composer2;
    }
    if (i18n2.mode === "legacy") {
      throw createI18nError(
        18
        /* NOT_AVAILABLE_IN_LEGACY_MODE */
      );
    }
    const i18nInternal = i18n2;
    let composer = i18nInternal.__getInstance(instance2);
    if (composer == null) {
      const type = instance2.type;
      const composerOptions = assign$2({}, options);
      if (type.__i18n) {
        composerOptions.__i18n = type.__i18n;
      }
      if (global2) {
        composerOptions.__root = global2;
      }
      composer = createComposer(composerOptions);
      setupLifeCycle(i18nInternal, instance2, composer);
      i18nInternal.__setInstance(instance2, composer);
    }
    return composer;
  }
  function getComposer(i18n2, target, useComponent = false) {
    let composer = null;
    const root = target.root;
    let current2 = target.parent;
    while (current2 != null) {
      const i18nInternal = i18n2;
      if (i18n2.mode === "composition") {
        composer = i18nInternal.__getInstance(current2);
      } else {
        const vueI18n = i18nInternal.__getInstance(current2);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
        }
        if (useComponent && composer && !composer[InejctWithOption]) {
          composer = null;
        }
      }
      if (composer != null) {
        break;
      }
      if (root === current2) {
        break;
      }
      current2 = current2.parent;
    }
    return composer;
  }
  function setupLifeCycle(i18n2, target, composer) {
    let emitter = null;
    vue.onMounted(() => {
      if (target.vnode.el) {
        target.vnode.el.__VUE_I18N__ = composer;
        emitter = createEmitter();
        const _composer = composer;
        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
        emitter.on("*", addTimelineEvent);
      }
    }, target);
    vue.onUnmounted(() => {
      if (target.vnode.el && target.vnode.el.__VUE_I18N__) {
        emitter && emitter.off("*", addTimelineEvent);
        const _composer = composer;
        _composer[DisableEmitter] && _composer[DisableEmitter]();
        delete target.vnode.el.__VUE_I18N__;
      }
      i18n2.__deleteInstance(target);
    }, target);
  }
  const globalExportProps = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ];
  const globalExportMethods = ["t", "rt", "d", "n", "tm"];
  function injectGlobalFields(app, composer) {
    const i18n2 = /* @__PURE__ */ Object.create(null);
    globalExportProps.forEach((prop) => {
      const desc = Object.getOwnPropertyDescriptor(composer, prop);
      if (!desc) {
        throw createI18nError(
          22
          /* UNEXPECTED_ERROR */
        );
      }
      const wrap = vue.isRef(desc.value) ? {
        get() {
          return desc.value.value;
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        set(val) {
          desc.value.value = val;
        }
      } : {
        get() {
          return desc.get && desc.get();
        }
      };
      Object.defineProperty(i18n2, prop, wrap);
    });
    app.config.globalProperties.$i18n = i18n2;
    globalExportMethods.forEach((method) => {
      const desc = Object.getOwnPropertyDescriptor(composer, method);
      if (!desc || !desc.value) {
        throw createI18nError(
          22
          /* UNEXPECTED_ERROR */
        );
      }
      Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
    });
  }
  {
    initFeatureFlags();
  }
  {
    const target = getGlobalThis();
    target.__INTLIFY__ = true;
    setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const _imports_0$3 = "/static/icons/settingIcon.png";
  const _imports_1$b = "/static/banner.png";
  const _export_sfc = (sfc, props2) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props2) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$p = {
    __name: "index",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        t: t2
      } = useI18n();
      const listItem = vue.computed(() => {
        return [
          {
            name: "Receiving",
            url: "../home/scanCode?type=1",
            icon: "/static/l1.png"
          },
          {
            name: "Warehousing",
            url: "../home/scanCode?type=2",
            icon: "/static/l2.png"
          },
          {
            name: "Collect",
            url: "../home/scanCode?type=4",
            icon: "/static/l3.png"
          },
          {
            name: "Goods Management",
            url: "../home/goodsList",
            icon: "/static/l4.png"
          },
          {
            name: "Shelf Management",
            url: "../shelf/index",
            icon: "/static/l5.png"
          }
        ];
      });
      const listItemGD = vue.computed(() => {
        return [
          {
            name: "",
            url: "../home/scanCode?type=6",
            icon: "/static/ll1.png"
          },
          {
            name: "",
            url: "../home/scanCode?type=7",
            icon: "/static/ll2.png"
          },
          {
            name: "",
            url: "../gd/warehouseMen",
            icon: "/static/ll3.png"
          },
          {
            name: "",
            url: "../gd/goodsMen",
            icon: "/static/ll4.png"
          }
        ];
      });
      const menuList = vue.ref([]);
      if (uni.getStorageSync("staffType")) {
        menuList.value = listItem.value;
      } else {
        menuList.value = listItemGD.value;
      }
      menuList.value = listItem.value.concat(listItemGD.value);
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const username = uni.getStorageSync("username");
      vue.onMounted(() => {
        if (!uni.getStorageSync("token")) {
          uni.clearStorage();
          uni.navigateTo({
            url: "/pages/home/login"
          });
        }
      });
      const __returned__ = { t: t2, listItem, listItemGD, menuList, changePage, username, ref: vue.ref, computed: vue.computed, onMounted: vue.onMounted, get onLoad() {
        return onLoad;
      }, get useI18n() {
        return useI18n;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "" }, [
      vue.createElementVNode("view", { class: "" }, [
        vue.createElementVNode("view", { class: "between mt10 pdlr12" }, [
          vue.createElementVNode("view", { class: "ww24" }),
          vue.createElementVNode(
            "view",
            { class: "text_center text_bold f17" },
            vue.toDisplayString($setup.t("home.h_h2")),
            1
            /* TEXT */
          ),
          vue.createElementVNode("view", {
            class: "ww24",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("../setting/index"))
          }, [
            vue.createElementVNode("image", {
              src: _imports_0$3,
              class: "ww24 hh24"
            })
          ])
        ]),
        vue.createElementVNode(
          "view",
          { class: "text_center color7C f11 mt5" },
          vue.toDisplayString($setup.t("home.h_h3") + " " + $setup.username),
          1
          /* TEXT */
        ),
        vue.createElementVNode("view", { class: "pdlr12 mt17" }, [
          vue.createElementVNode("view", null, [
            vue.createElementVNode("image", {
              src: _imports_1$b,
              style: { "width": "100%", "height": "110px" }
            })
          ]),
          vue.createElementVNode(
            "view",
            { class: "hasBeforeLine mt30 text_bold f16" },
            vue.toDisplayString($setup.t("home.h_h1")),
            1
            /* TEXT */
          ),
          vue.createElementVNode("view", { class: "gridBox" }, [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.menuList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "gridItem center flex-col",
                  onClick: ($event) => $setup.changePage(item.url),
                  key: index2
                }, [
                  vue.createElementVNode("view", null, [
                    vue.createElementVNode("image", {
                      src: item.icon,
                      class: "ww50 hh48"
                    }, null, 8, ["src"])
                  ]),
                  vue.createElementVNode(
                    "view",
                    { class: "mt12 f12 word" },
                    vue.toDisplayString(item.name),
                    1
                    /* TEXT */
                  )
                ], 8, ["onClick"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ])
      ])
    ]);
  }
  const PagesTabIndex = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$o], ["__scopeId", "data-v-ae0729d5"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/tab/index.vue"]]);
  function noop$1() {
  }
  const extend = Object.assign;
  const inBrowser$1 = typeof window !== "undefined";
  const isObject$1 = (val) => val !== null && typeof val === "object";
  const isDef = (val) => val !== void 0 && val !== null;
  const isFunction = (val) => typeof val === "function";
  const isPromise$1 = (val) => isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
  const isDate = (val) => Object.prototype.toString.call(val) === "[object Date]" && !Number.isNaN(val.getTime());
  function isMobile(value) {
    value = value.replace(/[^-|\d]/g, "");
    return /^((\+86)|(86))?(1)\d{10}$/.test(value) || /^0[0-9-]{10,13}$/.test(value);
  }
  const isNumeric = (val) => typeof val === "number" || /^\d+(\.\d+)?$/.test(val);
  const isIOS$1 = () => inBrowser$1 ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : false;
  function get(object2, path) {
    const keys = path.split(".");
    let result = object2;
    keys.forEach((key) => {
      var _a;
      result = isObject$1(result) ? (_a = result[key]) != null ? _a : "" : "";
    });
    return result;
  }
  function pick(obj, keys, ignoreUndefined) {
    return keys.reduce(
      (ret, key) => {
        if (!ignoreUndefined || obj[key] !== void 0) {
          ret[key] = obj[key];
        }
        return ret;
      },
      {}
    );
  }
  const isSameValue = (newValue, oldValue) => JSON.stringify(newValue) === JSON.stringify(oldValue);
  const toArray = (item) => Array.isArray(item) ? item : [item];
  const flat = (arr) => arr.reduce((acc, val) => acc.concat(val), []);
  const unknownProp = null;
  const numericProp = [Number, String];
  const truthProp = {
    type: Boolean,
    default: true
  };
  const makeRequiredProp = (type) => ({
    type,
    required: true
  });
  const makeArrayProp = () => ({
    type: Array,
    default: () => []
  });
  const makeNumberProp = (defaultVal) => ({
    type: Number,
    default: defaultVal
  });
  const makeNumericProp = (defaultVal) => ({
    type: numericProp,
    default: defaultVal
  });
  const makeStringProp = (defaultVal) => ({
    type: String,
    default: defaultVal
  });
  var inBrowser = typeof window !== "undefined";
  function raf(fn) {
    return inBrowser ? requestAnimationFrame(fn) : -1;
  }
  function cancelRaf(id) {
    if (inBrowser) {
      cancelAnimationFrame(id);
    }
  }
  function doubleRaf(fn) {
    raf(() => raf(fn));
  }
  var isWindow = (val) => val === window;
  var makeDOMRect = (width2, height2) => ({
    top: 0,
    left: 0,
    right: width2,
    bottom: height2,
    width: width2,
    height: height2
  });
  var useRect = (elementOrRef) => {
    const element = vue.unref(elementOrRef);
    if (isWindow(element)) {
      const width2 = element.innerWidth;
      const height2 = element.innerHeight;
      return makeDOMRect(width2, height2);
    }
    if (element == null ? void 0 : element.getBoundingClientRect) {
      return element.getBoundingClientRect();
    }
    return makeDOMRect(0, 0);
  };
  function useToggle(defaultValue = false) {
    const state = vue.ref(defaultValue);
    const toggle = (value = !state.value) => {
      state.value = value;
    };
    return [state, toggle];
  }
  function useParent(key) {
    const parent = vue.inject(key, null);
    if (parent) {
      const instance2 = vue.getCurrentInstance();
      const { link, unlink, internalChildren } = parent;
      link(instance2);
      vue.onUnmounted(() => unlink(instance2));
      const index2 = vue.computed(() => internalChildren.indexOf(instance2));
      return {
        parent,
        index: index2
      };
    }
    return {
      parent: null,
      index: vue.ref(-1)
    };
  }
  function flattenVNodes(children) {
    const result = [];
    const traverse = (children2) => {
      if (Array.isArray(children2)) {
        children2.forEach((child) => {
          var _a;
          if (vue.isVNode(child)) {
            result.push(child);
            if ((_a = child.component) == null ? void 0 : _a.subTree) {
              result.push(child.component.subTree);
              traverse(child.component.subTree.children);
            }
            if (child.children) {
              traverse(child.children);
            }
          }
        });
      }
    };
    traverse(children);
    return result;
  }
  var findVNodeIndex = (vnodes, vnode) => {
    const index2 = vnodes.indexOf(vnode);
    if (index2 === -1) {
      return vnodes.findIndex(
        (item) => vnode.key !== void 0 && vnode.key !== null && item.type === vnode.type && item.key === vnode.key
      );
    }
    return index2;
  };
  function sortChildren(parent, publicChildren, internalChildren) {
    const vnodes = flattenVNodes(parent.subTree.children);
    internalChildren.sort(
      (a2, b2) => findVNodeIndex(vnodes, a2.vnode) - findVNodeIndex(vnodes, b2.vnode)
    );
    const orderedPublicChildren = internalChildren.map((item) => item.proxy);
    publicChildren.sort((a2, b2) => {
      const indexA = orderedPublicChildren.indexOf(a2);
      const indexB = orderedPublicChildren.indexOf(b2);
      return indexA - indexB;
    });
  }
  function useChildren(key) {
    const publicChildren = vue.reactive([]);
    const internalChildren = vue.reactive([]);
    const parent = vue.getCurrentInstance();
    const linkChildren = (value) => {
      const link = (child) => {
        if (child.proxy) {
          internalChildren.push(child);
          publicChildren.push(child.proxy);
          sortChildren(parent, publicChildren, internalChildren);
        }
      };
      const unlink = (child) => {
        const index2 = internalChildren.indexOf(child);
        publicChildren.splice(index2, 1);
        internalChildren.splice(index2, 1);
      };
      vue.provide(
        key,
        Object.assign(
          {
            link,
            unlink,
            children: publicChildren,
            internalChildren
          },
          value
        )
      );
    };
    return {
      children: publicChildren,
      linkChildren
    };
  }
  var SECOND = 1e3;
  var MINUTE = 60 * SECOND;
  var HOUR = 60 * MINUTE;
  var DAY = 24 * HOUR;
  function parseTime(time) {
    const days = Math.floor(time / DAY);
    const hours = Math.floor(time % DAY / HOUR);
    const minutes = Math.floor(time % HOUR / MINUTE);
    const seconds = Math.floor(time % MINUTE / SECOND);
    const milliseconds = Math.floor(time % SECOND);
    return {
      total: time,
      days,
      hours,
      minutes,
      seconds,
      milliseconds
    };
  }
  function isSameSecond(time1, time2) {
    return Math.floor(time1 / 1e3) === Math.floor(time2 / 1e3);
  }
  function useCountDown(options) {
    let rafId;
    let endTime;
    let counting;
    let deactivated;
    const remain = vue.ref(options.time);
    const current2 = vue.computed(() => parseTime(remain.value));
    const pause = () => {
      counting = false;
      cancelRaf(rafId);
    };
    const getCurrentRemain = () => Math.max(endTime - Date.now(), 0);
    const setRemain = (value) => {
      var _a, _b;
      remain.value = value;
      (_a = options.onChange) == null ? void 0 : _a.call(options, current2.value);
      if (value === 0) {
        pause();
        (_b = options.onFinish) == null ? void 0 : _b.call(options);
      }
    };
    const microTick = () => {
      rafId = raf(() => {
        if (counting) {
          setRemain(getCurrentRemain());
          if (remain.value > 0) {
            microTick();
          }
        }
      });
    };
    const macroTick = () => {
      rafId = raf(() => {
        if (counting) {
          const remainRemain = getCurrentRemain();
          if (!isSameSecond(remainRemain, remain.value) || remainRemain === 0) {
            setRemain(remainRemain);
          }
          if (remain.value > 0) {
            macroTick();
          }
        }
      });
    };
    const tick = () => {
      if (!inBrowser) {
        return;
      }
      if (options.millisecond) {
        microTick();
      } else {
        macroTick();
      }
    };
    const start2 = () => {
      if (!counting) {
        endTime = Date.now() + remain.value;
        counting = true;
        tick();
      }
    };
    const reset = (totalTime = options.time) => {
      pause();
      remain.value = totalTime;
    };
    vue.onBeforeUnmount(pause);
    vue.onActivated(() => {
      if (deactivated) {
        counting = true;
        deactivated = false;
        tick();
      }
    });
    vue.onDeactivated(() => {
      if (counting) {
        pause();
        deactivated = true;
      }
    });
    return {
      start: start2,
      pause,
      reset,
      current: current2
    };
  }
  function onMountedOrActivated(hook) {
    let mounted;
    vue.onMounted(() => {
      hook();
      vue.nextTick(() => {
        mounted = true;
      });
    });
    vue.onActivated(() => {
      if (mounted) {
        hook();
      }
    });
  }
  function useEventListener(type, listener, options = {}) {
    if (!inBrowser) {
      return;
    }
    const { target = window, passive: passive2 = false, capture = false } = options;
    let cleaned = false;
    let attached;
    const add = (target2) => {
      if (cleaned) {
        return;
      }
      const element = vue.unref(target2);
      if (element && !attached) {
        element.addEventListener(type, listener, {
          capture,
          passive: passive2
        });
        attached = true;
      }
    };
    const remove = (target2) => {
      if (cleaned) {
        return;
      }
      const element = vue.unref(target2);
      if (element && attached) {
        element.removeEventListener(type, listener, capture);
        attached = false;
      }
    };
    vue.onUnmounted(() => remove(target));
    vue.onDeactivated(() => remove(target));
    onMountedOrActivated(() => add(target));
    let stopWatch;
    if (vue.isRef(target)) {
      stopWatch = vue.watch(target, (val, oldVal) => {
        remove(oldVal);
        add(val);
      });
    }
    return () => {
      stopWatch == null ? void 0 : stopWatch();
      remove(target);
      cleaned = true;
    };
  }
  function useClickAway(target, listener, options = {}) {
    if (!inBrowser) {
      return;
    }
    const { eventName = "click" } = options;
    const onClick = (event) => {
      const targets = Array.isArray(target) ? target : [target];
      const isClickAway = targets.every((item) => {
        const element = vue.unref(item);
        return element && !element.contains(event.target);
      });
      if (isClickAway) {
        listener(event);
      }
    };
    useEventListener(eventName, onClick, { target: document });
  }
  var width;
  var height;
  function useWindowSize() {
    if (!width) {
      width = vue.ref(0);
      height = vue.ref(0);
      if (inBrowser) {
        const update = () => {
          width.value = window.innerWidth;
          height.value = window.innerHeight;
        };
        update();
        window.addEventListener("resize", update, { passive: true });
        window.addEventListener("orientationchange", update, { passive: true });
      }
    }
    return { width, height };
  }
  var overflowScrollReg = /scroll|auto|overlay/i;
  var defaultRoot = inBrowser ? window : void 0;
  function isElement$1(node) {
    const ELEMENT_NODE_TYPE = 1;
    return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
  }
  function getScrollParent$1(el, root = defaultRoot) {
    let node = el;
    while (node && node !== root && isElement$1(node)) {
      const { overflowY } = window.getComputedStyle(node);
      if (overflowScrollReg.test(overflowY)) {
        return node;
      }
      node = node.parentNode;
    }
    return root;
  }
  function useScrollParent(el, root = defaultRoot) {
    const scrollParent = vue.ref();
    vue.onMounted(() => {
      if (el.value) {
        scrollParent.value = getScrollParent$1(el.value, root);
      }
    });
    return scrollParent;
  }
  var visibility;
  function usePageVisibility() {
    if (!visibility) {
      visibility = vue.ref("visible");
      if (inBrowser) {
        const update = () => {
          visibility.value = document.hidden ? "hidden" : "visible";
        };
        update();
        window.addEventListener("visibilitychange", update);
      }
    }
    return visibility;
  }
  var CUSTOM_FIELD_INJECTION_KEY = Symbol("van-field");
  function useCustomFieldValue(customValue) {
    const field = vue.inject(CUSTOM_FIELD_INJECTION_KEY, null);
    if (field && !field.customValue.value) {
      field.customValue.value = customValue;
      vue.watch(customValue, () => {
        field.resetValidation();
        field.validateWithTrigger("onChange");
      });
    }
  }
  function getScrollTop(el) {
    const top2 = "scrollTop" in el ? el.scrollTop : el.pageYOffset;
    return Math.max(top2, 0);
  }
  function setScrollTop(el, value) {
    if ("scrollTop" in el) {
      el.scrollTop = value;
    } else {
      el.scrollTo(el.scrollX, value);
    }
  }
  function getRootScrollTop() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  }
  function setRootScrollTop(value) {
    setScrollTop(window, value);
    setScrollTop(document.body, value);
  }
  function getElementTop(el, scroller) {
    if (el === window) {
      return 0;
    }
    const scrollTop = scroller ? getScrollTop(scroller) : getRootScrollTop();
    return useRect(el).top + scrollTop;
  }
  const isIOS = isIOS$1();
  function resetScroll() {
    if (isIOS) {
      setRootScrollTop(getRootScrollTop());
    }
  }
  const stopPropagation = (event) => event.stopPropagation();
  function preventDefault(event, isStopPropagation) {
    if (typeof event.cancelable !== "boolean" || event.cancelable) {
      event.preventDefault();
    }
    if (isStopPropagation) {
      stopPropagation(event);
    }
  }
  function isHidden(elementRef) {
    const el = vue.unref(elementRef);
    if (!el) {
      return false;
    }
    const style = window.getComputedStyle(el);
    const hidden = style.display === "none";
    const parentHidden = el.offsetParent === null && style.position !== "fixed";
    return hidden || parentHidden;
  }
  const { width: windowWidth, height: windowHeight } = useWindowSize();
  function isContainingBlock(el) {
    const css = window.getComputedStyle(el);
    return css.transform !== "none" || css.perspective !== "none" || ["transform", "perspective", "filter"].some(
      (value) => (css.willChange || "").includes(value)
    );
  }
  function getContainingBlock$1(el) {
    let node = el.parentElement;
    while (node) {
      if (node && node.tagName !== "HTML" && node.tagName !== "BODY" && isContainingBlock(node)) {
        return node;
      }
      node = node.parentElement;
    }
    return null;
  }
  function addUnit$2(value) {
    if (isDef(value)) {
      return isNumeric(value) ? `${value}px` : String(value);
    }
    return void 0;
  }
  function getSizeStyle(originSize) {
    if (isDef(originSize)) {
      if (Array.isArray(originSize)) {
        return {
          width: addUnit$2(originSize[0]),
          height: addUnit$2(originSize[1])
        };
      }
      const size = addUnit$2(originSize);
      return {
        width: size,
        height: size
      };
    }
  }
  function getZIndexStyle(zIndex) {
    const style = {};
    if (zIndex !== void 0) {
      style.zIndex = +zIndex;
    }
    return style;
  }
  let rootFontSize;
  function getRootFontSize() {
    if (!rootFontSize) {
      const doc = document.documentElement;
      const fontSize = doc.style.fontSize || window.getComputedStyle(doc).fontSize;
      rootFontSize = parseFloat(fontSize);
    }
    return rootFontSize;
  }
  function convertRem(value) {
    value = value.replace(/rem/g, "");
    return +value * getRootFontSize();
  }
  function convertVw(value) {
    value = value.replace(/vw/g, "");
    return +value * windowWidth.value / 100;
  }
  function convertVh(value) {
    value = value.replace(/vh/g, "");
    return +value * windowHeight.value / 100;
  }
  function unitToPx(value) {
    if (typeof value === "number") {
      return value;
    }
    if (inBrowser$1) {
      if (value.includes("rem")) {
        return convertRem(value);
      }
      if (value.includes("vw")) {
        return convertVw(value);
      }
      if (value.includes("vh")) {
        return convertVh(value);
      }
    }
    return parseFloat(value);
  }
  const camelizeRE = /-(\w)/g;
  const camelize = (str) => str.replace(camelizeRE, (_, c2) => c2.toUpperCase());
  const kebabCase = (str) => str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
  function padZero$1(num, targetLength = 2) {
    let str = num + "";
    while (str.length < targetLength) {
      str = "0" + str;
    }
    return str;
  }
  const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
  function trimExtraChar(value, char, regExp2) {
    const index2 = value.indexOf(char);
    if (index2 === -1) {
      return value;
    }
    if (char === "-" && index2 !== 0) {
      return value.slice(0, index2);
    }
    return value.slice(0, index2 + 1) + value.slice(index2).replace(regExp2, "");
  }
  function formatNumber(value, allowDot = true, allowMinus = true) {
    if (allowDot) {
      value = trimExtraChar(value, ".", /\./g);
    } else {
      value = value.split(".")[0];
    }
    if (allowMinus) {
      value = trimExtraChar(value, "-", /-/g);
    } else {
      value = value.replace(/-/, "");
    }
    const regExp2 = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
    return value.replace(regExp2, "");
  }
  function addNumber(num1, num2) {
    const cardinal = 10 ** 10;
    return Math.round((num1 + num2) * cardinal) / cardinal;
  }
  const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
  function assignKey(to, from, key) {
    const val = from[key];
    if (!isDef(val)) {
      return;
    }
    if (!hasOwnProperty$1.call(to, key) || !isObject$1(val)) {
      to[key] = val;
    } else {
      to[key] = deepAssign(Object(to[key]), val);
    }
  }
  function deepAssign(to, from) {
    Object.keys(from).forEach((key) => {
      assignKey(to, from, key);
    });
    return to;
  }
  var stdin_default$1T = {
    name: "",
    tel: "",
    save: "",
    clear: "",
    cancel: "",
    confirm: "",
    delete: "",
    loading: "...",
    noCoupon: "",
    nameEmpty: "",
    addContact: "",
    telInvalid: "",
    vanCalendar: {
      end: "",
      start: "",
      title: "",
      weekdays: ["", "", "", "", "", "", ""],
      monthTitle: (year, month) => `${year}${month}`,
      rangePrompt: (maxRange) => ` ${maxRange} `
    },
    vanCascader: {
      select: ""
    },
    vanPagination: {
      prev: "",
      next: ""
    },
    vanPullRefresh: {
      pulling: "...",
      loosing: "..."
    },
    vanSubmitBar: {
      label: ":"
    },
    vanCoupon: {
      unlimited: "",
      discount: (discount) => `${discount}`,
      condition: (condition) => `${condition}`
    },
    vanCouponCell: {
      title: "",
      count: (count) => `${count}`
    },
    vanCouponList: {
      exchange: "",
      close: "",
      enable: "",
      disabled: "",
      placeholder: ""
    },
    vanAddressEdit: {
      area: "",
      areaEmpty: "",
      addressEmpty: "",
      addressDetail: "",
      defaultAddress: ""
    },
    vanAddressList: {
      add: ""
    }
  };
  const lang$1 = vue.ref("zh-CN");
  const messages$1 = vue.reactive({
    "zh-CN": stdin_default$1T
  });
  const Locale = {
    messages() {
      return messages$1[lang$1.value];
    },
    use(newLang, newMessages) {
      lang$1.value = newLang;
      this.add({ [newLang]: newMessages });
    },
    add(newMessages = {}) {
      deepAssign(messages$1, newMessages);
    }
  };
  var stdin_default$1S = Locale;
  function createTranslate(name2) {
    const prefix = camelize(name2) + ".";
    return (path, ...args) => {
      const messages2 = stdin_default$1S.messages();
      const message = get(messages2, prefix + path) || get(messages2, path);
      return isFunction(message) ? message(...args) : message;
    };
  }
  function genBem(name2, mods) {
    if (!mods) {
      return "";
    }
    if (typeof mods === "string") {
      return ` ${name2}--${mods}`;
    }
    if (Array.isArray(mods)) {
      return mods.reduce(
        (ret, item) => ret + genBem(name2, item),
        ""
      );
    }
    return Object.keys(mods).reduce(
      (ret, key) => ret + (mods[key] ? genBem(name2, key) : ""),
      ""
    );
  }
  function createBEM(name2) {
    return (el, mods) => {
      if (el && typeof el !== "string") {
        mods = el;
        el = "";
      }
      el = el ? `${name2}__${el}` : name2;
      return `${el}${genBem(el, mods)}`;
    };
  }
  function createNamespace(name2) {
    const prefixedName = `van-${name2}`;
    return [
      prefixedName,
      createBEM(prefixedName),
      createTranslate(prefixedName)
    ];
  }
  const BORDER = "van-hairline";
  const BORDER_TOP = `${BORDER}--top`;
  const BORDER_LEFT = `${BORDER}--left`;
  const BORDER_RIGHT = `${BORDER}--right`;
  const BORDER_BOTTOM = `${BORDER}--bottom`;
  const BORDER_SURROUND = `${BORDER}--surround`;
  const BORDER_TOP_BOTTOM = `${BORDER}--top-bottom`;
  const BORDER_UNSET_TOP_BOTTOM = `${BORDER}-unset--top-bottom`;
  const HAPTICS_FEEDBACK = "van-haptics-feedback";
  const FORM_KEY = Symbol("van-form");
  const LONG_PRESS_START_TIME = 500;
  const TAP_OFFSET = 5;
  function callInterceptor(interceptor2, {
    args = [],
    done,
    canceled,
    error: error2
  }) {
    if (interceptor2) {
      const returnVal = interceptor2.apply(null, args);
      if (isPromise$1(returnVal)) {
        returnVal.then((value) => {
          if (value) {
            done();
          } else if (canceled) {
            canceled();
          }
        }).catch(error2 || noop$1);
      } else if (returnVal) {
        done();
      } else if (canceled) {
        canceled();
      }
    } else {
      done();
    }
  }
  function withInstall(options) {
    options.install = (app) => {
      const { name: name2 } = options;
      if (name2) {
        app.component(name2, options);
        app.component(camelize(`-${name2}`), options);
      }
    };
    return options;
  }
  function closest(arr, target) {
    return arr.reduce(
      (pre, cur) => Math.abs(pre - target) < Math.abs(cur - target) ? pre : cur
    );
  }
  const POPUP_TOGGLE_KEY = Symbol();
  function onPopupReopen(callback) {
    const popupToggleStatus = vue.inject(POPUP_TOGGLE_KEY, null);
    if (popupToggleStatus) {
      vue.watch(popupToggleStatus, (show) => {
        if (show) {
          callback();
        }
      });
    }
  }
  const useHeight = (element, withSafeArea) => {
    const height2 = vue.ref();
    const setHeight = () => {
      height2.value = useRect(element).height;
    };
    vue.onMounted(() => {
      vue.nextTick(setHeight);
      if (withSafeArea) {
        for (let i2 = 1; i2 <= 3; i2++) {
          setTimeout(setHeight, 100 * i2);
        }
      }
    });
    onPopupReopen(() => vue.nextTick(setHeight));
    vue.watch([windowWidth, windowHeight], setHeight);
    return height2;
  };
  function usePlaceholder(contentRef, bem2) {
    const height2 = useHeight(contentRef, true);
    return (renderContent) => vue.createVNode("div", {
      "class": bem2("placeholder"),
      "style": {
        height: height2.value ? `${height2.value}px` : void 0
      }
    }, [renderContent()]);
  }
  const [name$1K, bem$1F] = createNamespace("action-bar");
  const ACTION_BAR_KEY = Symbol(name$1K);
  const actionBarProps = {
    placeholder: Boolean,
    safeAreaInsetBottom: truthProp
  };
  var stdin_default$1R = vue.defineComponent({
    name: name$1K,
    props: actionBarProps,
    setup(props2, {
      slots
    }) {
      const root = vue.ref();
      const renderPlaceholder = usePlaceholder(root, bem$1F);
      const {
        linkChildren
      } = useChildren(ACTION_BAR_KEY);
      linkChildren();
      const renderActionBar = () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "class": [bem$1F(), {
            "van-safe-area-bottom": props2.safeAreaInsetBottom
          }]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
      return () => {
        if (props2.placeholder) {
          return renderPlaceholder(renderActionBar);
        }
        return renderActionBar();
      };
    }
  });
  const ActionBar = withInstall(stdin_default$1R);
  function useExpose(apis) {
    const instance2 = vue.getCurrentInstance();
    if (instance2) {
      extend(instance2.proxy, apis);
    }
  }
  const routeProps = {
    to: [String, Object],
    url: String,
    replace: Boolean
  };
  function route$1({
    to,
    url: url2,
    replace,
    $router: router
  }) {
    if (to && router) {
      router[replace ? "replace" : "push"](to);
    } else if (url2) {
      replace ? location.replace(url2) : location.href = url2;
    }
  }
  function useRoute() {
    const vm = vue.getCurrentInstance().proxy;
    return () => route$1(vm);
  }
  const [name$1J, bem$1E] = createNamespace("badge");
  const badgeProps = {
    dot: Boolean,
    max: numericProp,
    tag: makeStringProp("div"),
    color: String,
    offset: Array,
    content: numericProp,
    showZero: truthProp,
    position: makeStringProp("top-right")
  };
  var stdin_default$1Q = vue.defineComponent({
    name: name$1J,
    props: badgeProps,
    setup(props2, {
      slots
    }) {
      const hasContent = () => {
        if (slots.content) {
          return true;
        }
        const {
          content,
          showZero
        } = props2;
        return isDef(content) && content !== "" && (showZero || content !== 0 && content !== "0");
      };
      const renderContent = () => {
        const {
          dot,
          max,
          content
        } = props2;
        if (!dot && hasContent()) {
          if (slots.content) {
            return slots.content();
          }
          if (isDef(max) && isNumeric(content) && +content > +max) {
            return `${max}+`;
          }
          return content;
        }
      };
      const getOffsetWithMinusString = (val) => val.startsWith("-") ? val.replace("-", "") : `-${val}`;
      const style = vue.computed(() => {
        const style2 = {
          background: props2.color
        };
        if (props2.offset) {
          const [x, y] = props2.offset;
          const {
            position
          } = props2;
          const [offsetY, offsetX] = position.split("-");
          if (slots.default) {
            if (typeof y === "number") {
              style2[offsetY] = addUnit$2(offsetY === "top" ? y : -y);
            } else {
              style2[offsetY] = offsetY === "top" ? addUnit$2(y) : getOffsetWithMinusString(y);
            }
            if (typeof x === "number") {
              style2[offsetX] = addUnit$2(offsetX === "left" ? x : -x);
            } else {
              style2[offsetX] = offsetX === "left" ? addUnit$2(x) : getOffsetWithMinusString(x);
            }
          } else {
            style2.marginTop = addUnit$2(y);
            style2.marginLeft = addUnit$2(x);
          }
        }
        return style2;
      });
      const renderBadge = () => {
        if (hasContent() || props2.dot) {
          return vue.createVNode("div", {
            "class": bem$1E([props2.position, {
              dot: props2.dot,
              fixed: !!slots.default
            }]),
            "style": style.value
          }, [renderContent()]);
        }
      };
      return () => {
        if (slots.default) {
          const {
            tag
          } = props2;
          return vue.createVNode(tag, {
            "class": bem$1E("wrapper")
          }, {
            default: () => [slots.default(), renderBadge()]
          });
        }
        return renderBadge();
      };
    }
  });
  const Badge = withInstall(stdin_default$1Q);
  let globalZIndex = 2e3;
  const useGlobalZIndex = () => ++globalZIndex;
  const setGlobalZIndex = (val) => {
    globalZIndex = val;
  };
  const [name$1I, bem$1D] = createNamespace("config-provider");
  const CONFIG_PROVIDER_KEY = Symbol(name$1I);
  const configProviderProps = {
    tag: makeStringProp("div"),
    theme: makeStringProp("light"),
    zIndex: Number,
    themeVars: Object,
    themeVarsDark: Object,
    themeVarsLight: Object,
    themeVarsScope: makeStringProp("local"),
    iconPrefix: String
  };
  function insertDash(str) {
    return str.replace(/([a-zA-Z])(\d)/g, "$1-$2");
  }
  function mapThemeVarsToCSSVars(themeVars) {
    const cssVars = {};
    Object.keys(themeVars).forEach((key) => {
      const formattedKey = insertDash(kebabCase(key));
      cssVars[`--van-${formattedKey}`] = themeVars[key];
    });
    return cssVars;
  }
  function syncThemeVarsOnRoot(newStyle = {}, oldStyle = {}) {
    Object.keys(newStyle).forEach((key) => {
      if (newStyle[key] !== oldStyle[key]) {
        document.documentElement.style.setProperty(key, newStyle[key]);
      }
    });
    Object.keys(oldStyle).forEach((key) => {
      if (!newStyle[key]) {
        document.documentElement.style.removeProperty(key);
      }
    });
  }
  var stdin_default$1P = vue.defineComponent({
    name: name$1I,
    props: configProviderProps,
    setup(props2, {
      slots
    }) {
      const style = vue.computed(() => mapThemeVarsToCSSVars(extend({}, props2.themeVars, props2.theme === "dark" ? props2.themeVarsDark : props2.themeVarsLight)));
      if (inBrowser$1) {
        const addTheme = () => {
          document.documentElement.classList.add(`van-theme-${props2.theme}`);
        };
        const removeTheme = (theme = props2.theme) => {
          document.documentElement.classList.remove(`van-theme-${theme}`);
        };
        vue.watch(() => props2.theme, (newVal, oldVal) => {
          if (oldVal) {
            removeTheme(oldVal);
          }
          addTheme();
        }, {
          immediate: true
        });
        vue.onActivated(addTheme);
        vue.onDeactivated(removeTheme);
        vue.onBeforeUnmount(removeTheme);
        vue.watch(style, (newStyle, oldStyle) => {
          if (props2.themeVarsScope === "global") {
            syncThemeVarsOnRoot(newStyle, oldStyle);
          }
        });
        vue.watch(() => props2.themeVarsScope, (newScope, oldScope) => {
          if (oldScope === "global") {
            syncThemeVarsOnRoot({}, style.value);
          }
          if (newScope === "global") {
            syncThemeVarsOnRoot(style.value, {});
          }
        });
        if (props2.themeVarsScope === "global") {
          syncThemeVarsOnRoot(style.value, {});
        }
      }
      vue.provide(CONFIG_PROVIDER_KEY, props2);
      vue.watchEffect(() => {
        if (props2.zIndex !== void 0) {
          setGlobalZIndex(props2.zIndex);
        }
      });
      return () => vue.createVNode(props2.tag, {
        "class": bem$1D(),
        "style": props2.themeVarsScope === "local" ? style.value : void 0
      }, {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      });
    }
  });
  const [name$1H, bem$1C] = createNamespace("icon");
  const isImage$1 = (name2) => name2 == null ? void 0 : name2.includes("/");
  const iconProps = {
    dot: Boolean,
    tag: makeStringProp("i"),
    name: String,
    size: numericProp,
    badge: numericProp,
    color: String,
    badgeProps: Object,
    classPrefix: String
  };
  var stdin_default$1O = vue.defineComponent({
    name: name$1H,
    props: iconProps,
    setup(props2, {
      slots
    }) {
      const config2 = vue.inject(CONFIG_PROVIDER_KEY, null);
      const classPrefix = vue.computed(() => props2.classPrefix || (config2 == null ? void 0 : config2.iconPrefix) || bem$1C());
      return () => {
        const {
          tag,
          dot,
          name: name2,
          size,
          badge,
          color
        } = props2;
        const isImageIcon = isImage$1(name2);
        return vue.createVNode(Badge, vue.mergeProps({
          "dot": dot,
          "tag": tag,
          "class": [classPrefix.value, isImageIcon ? "" : `${classPrefix.value}-${name2}`],
          "style": {
            color,
            fontSize: addUnit$2(size)
          },
          "content": badge
        }, props2.badgeProps), {
          default: () => {
            var _a;
            return [(_a = slots.default) == null ? void 0 : _a.call(slots), isImageIcon && vue.createVNode("img", {
              "class": bem$1C("image"),
              "src": name2
            }, null)];
          }
        });
      };
    }
  });
  const Icon = withInstall(stdin_default$1O);
  var stdin_default$1N = Icon;
  const [name$1G, bem$1B] = createNamespace("loading");
  const SpinIcon = Array(12).fill(null).map((_, index2) => vue.createVNode("i", {
    "class": bem$1B("line", String(index2 + 1))
  }, null));
  const CircularIcon = vue.createVNode("svg", {
    "class": bem$1B("circular"),
    "viewBox": "25 25 50 50"
  }, [vue.createVNode("circle", {
    "cx": "50",
    "cy": "50",
    "r": "20",
    "fill": "none"
  }, null)]);
  const loadingProps = {
    size: numericProp,
    type: makeStringProp("circular"),
    color: String,
    vertical: Boolean,
    textSize: numericProp,
    textColor: String
  };
  var stdin_default$1M = vue.defineComponent({
    name: name$1G,
    props: loadingProps,
    setup(props2, {
      slots
    }) {
      const spinnerStyle = vue.computed(() => extend({
        color: props2.color
      }, getSizeStyle(props2.size)));
      const renderIcon = () => {
        const DefaultIcon = props2.type === "spinner" ? SpinIcon : CircularIcon;
        return vue.createVNode("span", {
          "class": bem$1B("spinner", props2.type),
          "style": spinnerStyle.value
        }, [slots.icon ? slots.icon() : DefaultIcon]);
      };
      const renderText = () => {
        var _a;
        if (slots.default) {
          return vue.createVNode("span", {
            "class": bem$1B("text"),
            "style": {
              fontSize: addUnit$2(props2.textSize),
              color: (_a = props2.textColor) != null ? _a : props2.color
            }
          }, [slots.default()]);
        }
      };
      return () => {
        const {
          type,
          vertical
        } = props2;
        return vue.createVNode("div", {
          "class": bem$1B([type, {
            vertical
          }]),
          "aria-live": "polite",
          "aria-busy": true
        }, [renderIcon(), renderText()]);
      };
    }
  });
  const Loading = withInstall(stdin_default$1M);
  const [name$1F, bem$1A] = createNamespace("button");
  const buttonProps = extend({}, routeProps, {
    tag: makeStringProp("button"),
    text: String,
    icon: String,
    type: makeStringProp("default"),
    size: makeStringProp("normal"),
    color: String,
    block: Boolean,
    plain: Boolean,
    round: Boolean,
    square: Boolean,
    loading: Boolean,
    hairline: Boolean,
    disabled: Boolean,
    iconPrefix: String,
    nativeType: makeStringProp("button"),
    loadingSize: numericProp,
    loadingText: String,
    loadingType: String,
    iconPosition: makeStringProp("left")
  });
  var stdin_default$1L = vue.defineComponent({
    name: name$1F,
    props: buttonProps,
    emits: ["click"],
    setup(props2, {
      emit,
      slots
    }) {
      const route2 = useRoute();
      const renderLoadingIcon = () => {
        if (slots.loading) {
          return slots.loading();
        }
        return vue.createVNode(Loading, {
          "size": props2.loadingSize,
          "type": props2.loadingType,
          "class": bem$1A("loading")
        }, null);
      };
      const renderIcon = () => {
        if (props2.loading) {
          return renderLoadingIcon();
        }
        if (slots.icon) {
          return vue.createVNode("div", {
            "class": bem$1A("icon")
          }, [slots.icon()]);
        }
        if (props2.icon) {
          return vue.createVNode(Icon, {
            "name": props2.icon,
            "class": bem$1A("icon"),
            "classPrefix": props2.iconPrefix
          }, null);
        }
      };
      const renderText = () => {
        let text;
        if (props2.loading) {
          text = props2.loadingText;
        } else {
          text = slots.default ? slots.default() : props2.text;
        }
        if (text) {
          return vue.createVNode("span", {
            "class": bem$1A("text")
          }, [text]);
        }
      };
      const getStyle = () => {
        const {
          color,
          plain
        } = props2;
        if (color) {
          const style = {
            color: plain ? color : "white"
          };
          if (!plain) {
            style.background = color;
          }
          if (color.includes("gradient")) {
            style.border = 0;
          } else {
            style.borderColor = color;
          }
          return style;
        }
      };
      const onClick = (event) => {
        if (props2.loading) {
          preventDefault(event);
        } else if (!props2.disabled) {
          emit("click", event);
          route2();
        }
      };
      return () => {
        const {
          tag,
          type,
          size,
          block,
          round: round2,
          plain,
          square,
          loading,
          disabled,
          hairline,
          nativeType,
          iconPosition
        } = props2;
        const classes = [bem$1A([type, size, {
          plain,
          block,
          round: round2,
          square,
          loading,
          disabled,
          hairline
        }]), {
          [BORDER_SURROUND]: hairline
        }];
        return vue.createVNode(tag, {
          "type": nativeType,
          "class": classes,
          "style": getStyle(),
          "disabled": disabled,
          "onClick": onClick
        }, {
          default: () => [vue.createVNode("div", {
            "class": bem$1A("content")
          }, [iconPosition === "left" && renderIcon(), renderText(), iconPosition === "right" && renderIcon()])]
        });
      };
    }
  });
  const Button = withInstall(stdin_default$1L);
  const [name$1E, bem$1z] = createNamespace("action-bar-button");
  const actionBarButtonProps = extend({}, routeProps, {
    type: String,
    text: String,
    icon: String,
    color: String,
    loading: Boolean,
    disabled: Boolean
  });
  var stdin_default$1K = vue.defineComponent({
    name: name$1E,
    props: actionBarButtonProps,
    setup(props2, {
      slots
    }) {
      const route2 = useRoute();
      const {
        parent,
        index: index2
      } = useParent(ACTION_BAR_KEY);
      const isFirst = vue.computed(() => {
        if (parent) {
          const prev = parent.children[index2.value - 1];
          return !(prev && "isButton" in prev);
        }
      });
      const isLast = vue.computed(() => {
        if (parent) {
          const next = parent.children[index2.value + 1];
          return !(next && "isButton" in next);
        }
      });
      useExpose({
        isButton: true
      });
      return () => {
        const {
          type,
          icon,
          text,
          color,
          loading,
          disabled
        } = props2;
        return vue.createVNode(Button, {
          "class": bem$1z([type, {
            last: isLast.value,
            first: isFirst.value
          }]),
          "size": "large",
          "type": type,
          "icon": icon,
          "color": color,
          "loading": loading,
          "disabled": disabled,
          "onClick": route2
        }, {
          default: () => [slots.default ? slots.default() : text]
        });
      };
    }
  });
  const ActionBarButton = withInstall(stdin_default$1K);
  const [name$1D, bem$1y] = createNamespace("action-bar-icon");
  const actionBarIconProps = extend({}, routeProps, {
    dot: Boolean,
    text: String,
    icon: String,
    color: String,
    badge: numericProp,
    iconClass: unknownProp,
    badgeProps: Object,
    iconPrefix: String
  });
  var stdin_default$1J = vue.defineComponent({
    name: name$1D,
    props: actionBarIconProps,
    setup(props2, {
      slots
    }) {
      const route2 = useRoute();
      useParent(ACTION_BAR_KEY);
      const renderIcon = () => {
        const {
          dot,
          badge,
          icon,
          color,
          iconClass,
          badgeProps: badgeProps2,
          iconPrefix
        } = props2;
        if (slots.icon) {
          return vue.createVNode(Badge, vue.mergeProps({
            "dot": dot,
            "class": bem$1y("icon"),
            "content": badge
          }, badgeProps2), {
            default: slots.icon
          });
        }
        return vue.createVNode(Icon, {
          "tag": "div",
          "dot": dot,
          "name": icon,
          "badge": badge,
          "color": color,
          "class": [bem$1y("icon"), iconClass],
          "badgeProps": badgeProps2,
          "classPrefix": iconPrefix
        }, null);
      };
      return () => vue.createVNode("div", {
        "role": "button",
        "class": bem$1y(),
        "tabindex": 0,
        "onClick": route2
      }, [renderIcon(), slots.default ? slots.default() : props2.text]);
    }
  });
  const ActionBarIcon = withInstall(stdin_default$1J);
  const popupSharedProps = {
    // whether to show popup
    show: Boolean,
    // z-index
    zIndex: numericProp,
    // whether to show overlay
    overlay: truthProp,
    // transition duration
    duration: numericProp,
    // teleport
    teleport: [String, Object],
    // prevent body scroll
    lockScroll: truthProp,
    // whether to lazy render
    lazyRender: truthProp,
    // callback function before close
    beforeClose: Function,
    // overlay custom style
    overlayStyle: Object,
    // overlay custom class name
    overlayClass: unknownProp,
    // Initial rendering animation
    transitionAppear: Boolean,
    // whether to close popup when overlay is clicked
    closeOnClickOverlay: truthProp
  };
  const popupSharedPropKeys = Object.keys(
    popupSharedProps
  );
  function getDirection(x, y) {
    if (x > y) {
      return "horizontal";
    }
    if (y > x) {
      return "vertical";
    }
    return "";
  }
  function useTouch() {
    const startX = vue.ref(0);
    const startY = vue.ref(0);
    const deltaX = vue.ref(0);
    const deltaY = vue.ref(0);
    const offsetX = vue.ref(0);
    const offsetY = vue.ref(0);
    const direction = vue.ref("");
    const isTap = vue.ref(true);
    const isVertical = () => direction.value === "vertical";
    const isHorizontal = () => direction.value === "horizontal";
    const reset = () => {
      deltaX.value = 0;
      deltaY.value = 0;
      offsetX.value = 0;
      offsetY.value = 0;
      direction.value = "";
      isTap.value = true;
    };
    const start2 = (event) => {
      reset();
      startX.value = event.touches[0].clientX;
      startY.value = event.touches[0].clientY;
    };
    const move = (event) => {
      const touch = event.touches[0];
      deltaX.value = (touch.clientX < 0 ? 0 : touch.clientX) - startX.value;
      deltaY.value = touch.clientY - startY.value;
      offsetX.value = Math.abs(deltaX.value);
      offsetY.value = Math.abs(deltaY.value);
      const LOCK_DIRECTION_DISTANCE = 10;
      if (!direction.value || offsetX.value < LOCK_DIRECTION_DISTANCE && offsetY.value < LOCK_DIRECTION_DISTANCE) {
        direction.value = getDirection(offsetX.value, offsetY.value);
      }
      if (isTap.value && (offsetX.value > TAP_OFFSET || offsetY.value > TAP_OFFSET)) {
        isTap.value = false;
      }
    };
    return {
      move,
      start: start2,
      reset,
      startX,
      startY,
      deltaX,
      deltaY,
      offsetX,
      offsetY,
      direction,
      isVertical,
      isHorizontal,
      isTap
    };
  }
  let totalLockCount = 0;
  const BODY_LOCK_CLASS = "van-overflow-hidden";
  function useLockScroll(rootRef, shouldLock) {
    const touch = useTouch();
    const DIRECTION_UP = "01";
    const DIRECTION_DOWN = "10";
    const onTouchMove = (event) => {
      touch.move(event);
      const direction = touch.deltaY.value > 0 ? DIRECTION_DOWN : DIRECTION_UP;
      const el = getScrollParent$1(
        event.target,
        rootRef.value
      );
      const { scrollHeight, offsetHeight, scrollTop } = el;
      let status = "11";
      if (scrollTop === 0) {
        status = offsetHeight >= scrollHeight ? "00" : "01";
      } else if (scrollTop + offsetHeight >= scrollHeight) {
        status = "10";
      }
      if (status !== "11" && touch.isVertical() && !(parseInt(status, 2) & parseInt(direction, 2))) {
        preventDefault(event, true);
      }
    };
    const lock = () => {
      document.addEventListener("touchstart", touch.start);
      document.addEventListener("touchmove", onTouchMove, { passive: false });
      if (!totalLockCount) {
        document.body.classList.add(BODY_LOCK_CLASS);
      }
      totalLockCount++;
    };
    const unlock = () => {
      if (totalLockCount) {
        document.removeEventListener("touchstart", touch.start);
        document.removeEventListener("touchmove", onTouchMove);
        totalLockCount--;
        if (!totalLockCount) {
          document.body.classList.remove(BODY_LOCK_CLASS);
        }
      }
    };
    const init = () => shouldLock() && lock();
    const destroy = () => shouldLock() && unlock();
    onMountedOrActivated(init);
    vue.onDeactivated(destroy);
    vue.onBeforeUnmount(destroy);
    vue.watch(shouldLock, (value) => {
      value ? lock() : unlock();
    });
  }
  function useLazyRender(show) {
    const inited = vue.ref(false);
    vue.watch(
      show,
      (value) => {
        if (value) {
          inited.value = value;
        }
      },
      { immediate: true }
    );
    return (render) => () => inited.value ? render() : null;
  }
  const useScopeId = () => {
    var _a;
    const { scopeId } = ((_a = vue.getCurrentInstance()) == null ? void 0 : _a.vnode) || {};
    return scopeId ? { [scopeId]: "" } : null;
  };
  const [name$1C, bem$1x] = createNamespace("overlay");
  const overlayProps = {
    show: Boolean,
    zIndex: numericProp,
    duration: numericProp,
    className: unknownProp,
    lockScroll: truthProp,
    lazyRender: truthProp,
    customStyle: Object,
    teleport: [String, Object]
  };
  var stdin_default$1I = vue.defineComponent({
    name: name$1C,
    props: overlayProps,
    setup(props2, {
      slots
    }) {
      const root = vue.ref();
      const lazyRender = useLazyRender(() => props2.show || !props2.lazyRender);
      const onTouchMove = (event) => {
        if (props2.lockScroll) {
          preventDefault(event, true);
        }
      };
      const renderOverlay = lazyRender(() => {
        var _a;
        const style = extend(getZIndexStyle(props2.zIndex), props2.customStyle);
        if (isDef(props2.duration)) {
          style.animationDuration = `${props2.duration}s`;
        }
        return vue.withDirectives(vue.createVNode("div", {
          "ref": root,
          "style": style,
          "class": [bem$1x(), props2.className]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), [[vue.vShow, props2.show]]);
      });
      useEventListener("touchmove", onTouchMove, {
        target: root
      });
      return () => {
        const Content = vue.createVNode(vue.Transition, {
          "name": "van-fade",
          "appear": true
        }, {
          default: renderOverlay
        });
        if (props2.teleport) {
          return vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [Content]
          });
        }
        return Content;
      };
    }
  });
  const Overlay = withInstall(stdin_default$1I);
  const popupProps$2 = extend({}, popupSharedProps, {
    round: Boolean,
    position: makeStringProp("center"),
    closeIcon: makeStringProp("cross"),
    closeable: Boolean,
    transition: String,
    iconPrefix: String,
    closeOnPopstate: Boolean,
    closeIconPosition: makeStringProp("top-right"),
    safeAreaInsetTop: Boolean,
    safeAreaInsetBottom: Boolean
  });
  const [name$1B, bem$1w] = createNamespace("popup");
  var stdin_default$1H = vue.defineComponent({
    name: name$1B,
    inheritAttrs: false,
    props: popupProps$2,
    emits: ["open", "close", "opened", "closed", "keydown", "update:show", "clickOverlay", "clickCloseIcon"],
    setup(props2, {
      emit,
      attrs,
      slots
    }) {
      let opened;
      let shouldReopen;
      const zIndex = vue.ref();
      const popupRef = vue.ref();
      const lazyRender = useLazyRender(() => props2.show || !props2.lazyRender);
      const style = vue.computed(() => {
        const style2 = {
          zIndex: zIndex.value
        };
        if (isDef(props2.duration)) {
          const key = props2.position === "center" ? "animationDuration" : "transitionDuration";
          style2[key] = `${props2.duration}s`;
        }
        return style2;
      });
      const open2 = () => {
        if (!opened) {
          opened = true;
          zIndex.value = props2.zIndex !== void 0 ? +props2.zIndex : useGlobalZIndex();
          emit("open");
        }
      };
      const close = () => {
        if (opened) {
          callInterceptor(props2.beforeClose, {
            done() {
              opened = false;
              emit("close");
              emit("update:show", false);
            }
          });
        }
      };
      const onClickOverlay = (event) => {
        emit("clickOverlay", event);
        if (props2.closeOnClickOverlay) {
          close();
        }
      };
      const renderOverlay = () => {
        if (props2.overlay) {
          return vue.createVNode(Overlay, vue.mergeProps({
            "show": props2.show,
            "class": props2.overlayClass,
            "zIndex": zIndex.value,
            "duration": props2.duration,
            "customStyle": props2.overlayStyle,
            "role": props2.closeOnClickOverlay ? "button" : void 0,
            "tabindex": props2.closeOnClickOverlay ? 0 : void 0
          }, useScopeId(), {
            "onClick": onClickOverlay
          }), {
            default: slots["overlay-content"]
          });
        }
      };
      const onClickCloseIcon = (event) => {
        emit("clickCloseIcon", event);
        close();
      };
      const renderCloseIcon = () => {
        if (props2.closeable) {
          return vue.createVNode(Icon, {
            "role": "button",
            "tabindex": 0,
            "name": props2.closeIcon,
            "class": [bem$1w("close-icon", props2.closeIconPosition), HAPTICS_FEEDBACK],
            "classPrefix": props2.iconPrefix,
            "onClick": onClickCloseIcon
          }, null);
        }
      };
      let timer;
      const onOpened = () => {
        if (timer)
          clearTimeout(timer);
        timer = setTimeout(() => {
          emit("opened");
        });
      };
      const onClosed = () => emit("closed");
      const onKeydown = (event) => emit("keydown", event);
      const renderPopup = lazyRender(() => {
        var _a;
        const {
          round: round2,
          position,
          safeAreaInsetTop,
          safeAreaInsetBottom
        } = props2;
        return vue.withDirectives(vue.createVNode("div", vue.mergeProps({
          "ref": popupRef,
          "style": style.value,
          "role": "dialog",
          "tabindex": 0,
          "class": [bem$1w({
            round: round2,
            [position]: position
          }), {
            "van-safe-area-top": safeAreaInsetTop,
            "van-safe-area-bottom": safeAreaInsetBottom
          }],
          "onKeydown": onKeydown
        }, attrs, useScopeId()), [(_a = slots.default) == null ? void 0 : _a.call(slots), renderCloseIcon()]), [[vue.vShow, props2.show]]);
      });
      const renderTransition = () => {
        const {
          position,
          transition,
          transitionAppear
        } = props2;
        const name2 = position === "center" ? "van-fade" : `van-popup-slide-${position}`;
        return vue.createVNode(vue.Transition, {
          "name": transition || name2,
          "appear": transitionAppear,
          "onAfterEnter": onOpened,
          "onAfterLeave": onClosed
        }, {
          default: renderPopup
        });
      };
      vue.watch(() => props2.show, (show) => {
        if (show && !opened) {
          open2();
          if (attrs.tabindex === 0) {
            vue.nextTick(() => {
              var _a;
              (_a = popupRef.value) == null ? void 0 : _a.focus();
            });
          }
        }
        if (!show && opened) {
          opened = false;
          emit("close");
        }
      });
      useExpose({
        popupRef
      });
      useLockScroll(popupRef, () => props2.show && props2.lockScroll);
      useEventListener("popstate", () => {
        if (props2.closeOnPopstate) {
          close();
          shouldReopen = false;
        }
      });
      vue.onMounted(() => {
        if (props2.show) {
          open2();
        }
      });
      vue.onActivated(() => {
        if (shouldReopen) {
          emit("update:show", true);
          shouldReopen = false;
        }
      });
      vue.onDeactivated(() => {
        if (props2.show && props2.teleport) {
          close();
          shouldReopen = true;
        }
      });
      vue.provide(POPUP_TOGGLE_KEY, () => props2.show);
      return () => {
        if (props2.teleport) {
          return vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [renderOverlay(), renderTransition()]
          });
        }
        return vue.createVNode(vue.Fragment, null, [renderOverlay(), renderTransition()]);
      };
    }
  });
  const Popup = withInstall(stdin_default$1H);
  const [name$1A, bem$1v] = createNamespace("action-sheet");
  const actionSheetProps = extend({}, popupSharedProps, {
    title: String,
    round: truthProp,
    actions: makeArrayProp(),
    closeIcon: makeStringProp("cross"),
    closeable: truthProp,
    cancelText: String,
    description: String,
    closeOnPopstate: truthProp,
    closeOnClickAction: Boolean,
    safeAreaInsetBottom: truthProp
  });
  const popupInheritKeys$2 = [...popupSharedPropKeys, "round", "closeOnPopstate", "safeAreaInsetBottom"];
  var stdin_default$1G = vue.defineComponent({
    name: name$1A,
    props: actionSheetProps,
    emits: ["select", "cancel", "update:show"],
    setup(props2, {
      slots,
      emit
    }) {
      const updateShow = (show) => emit("update:show", show);
      const onCancel = () => {
        updateShow(false);
        emit("cancel");
      };
      const renderHeader = () => {
        if (props2.title) {
          return vue.createVNode("div", {
            "class": bem$1v("header")
          }, [props2.title, props2.closeable && vue.createVNode(Icon, {
            "name": props2.closeIcon,
            "class": [bem$1v("close"), HAPTICS_FEEDBACK],
            "onClick": onCancel
          }, null)]);
        }
      };
      const renderCancel = () => {
        if (slots.cancel || props2.cancelText) {
          return [vue.createVNode("div", {
            "class": bem$1v("gap")
          }, null), vue.createVNode("button", {
            "type": "button",
            "class": bem$1v("cancel"),
            "onClick": onCancel
          }, [slots.cancel ? slots.cancel() : props2.cancelText])];
        }
      };
      const renderIcon = (action) => {
        if (action.icon) {
          return vue.createVNode(Icon, {
            "class": bem$1v("item-icon"),
            "name": action.icon
          }, null);
        }
      };
      const renderActionContent = (action, index2) => {
        if (action.loading) {
          return vue.createVNode(Loading, {
            "class": bem$1v("loading-icon")
          }, null);
        }
        if (slots.action) {
          return slots.action({
            action,
            index: index2
          });
        }
        return [vue.createVNode("span", {
          "class": bem$1v("name")
        }, [action.name]), action.subname && vue.createVNode("div", {
          "class": bem$1v("subname")
        }, [action.subname])];
      };
      const renderAction = (action, index2) => {
        const {
          color,
          loading,
          callback,
          disabled,
          className
        } = action;
        const onClick = () => {
          if (disabled || loading) {
            return;
          }
          if (callback) {
            callback(action);
          }
          if (props2.closeOnClickAction) {
            updateShow(false);
          }
          vue.nextTick(() => emit("select", action, index2));
        };
        return vue.createVNode("button", {
          "type": "button",
          "style": {
            color
          },
          "class": [bem$1v("item", {
            loading,
            disabled
          }), className],
          "onClick": onClick
        }, [renderIcon(action), renderActionContent(action, index2)]);
      };
      const renderDescription = () => {
        if (props2.description || slots.description) {
          const content = slots.description ? slots.description() : props2.description;
          return vue.createVNode("div", {
            "class": bem$1v("description")
          }, [content]);
        }
      };
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": bem$1v(),
        "position": "bottom",
        "onUpdate:show": updateShow
      }, pick(props2, popupInheritKeys$2)), {
        default: () => {
          var _a;
          return [renderHeader(), renderDescription(), vue.createVNode("div", {
            "class": bem$1v("content")
          }, [props2.actions.map(renderAction), (_a = slots.default) == null ? void 0 : _a.call(slots)]), renderCancel()];
        }
      });
    }
  });
  const ActionSheet = withInstall(stdin_default$1G);
  const [name$1z, bem$1u, t$m] = createNamespace("picker");
  const getFirstEnabledOption = (options) => options.find((option) => !option.disabled) || options[0];
  function getColumnsType(columns, fields) {
    const firstColumn = columns[0];
    if (firstColumn) {
      if (Array.isArray(firstColumn)) {
        return "multiple";
      }
      if (fields.children in firstColumn) {
        return "cascade";
      }
    }
    return "default";
  }
  function findIndexOfEnabledOption(options, index2) {
    index2 = clamp(index2, 0, options.length);
    for (let i2 = index2; i2 < options.length; i2++) {
      if (!options[i2].disabled)
        return i2;
    }
    for (let i2 = index2 - 1; i2 >= 0; i2--) {
      if (!options[i2].disabled)
        return i2;
    }
    return 0;
  }
  const isOptionExist = (options, value, fields) => value !== void 0 && !!options.find((option) => option[fields.value] === value);
  function findOptionByValue(options, value, fields) {
    const index2 = options.findIndex((option) => option[fields.value] === value);
    const enabledIndex = findIndexOfEnabledOption(options, index2);
    return options[enabledIndex];
  }
  function formatCascadeColumns(columns, fields, selectedValues) {
    const formatted = [];
    let cursor = {
      [fields.children]: columns
    };
    let columnIndex = 0;
    while (cursor && cursor[fields.children]) {
      const options = cursor[fields.children];
      const value = selectedValues.value[columnIndex];
      cursor = isDef(value) ? findOptionByValue(options, value, fields) : void 0;
      if (!cursor && options.length) {
        const firstValue = getFirstEnabledOption(options)[fields.value];
        cursor = findOptionByValue(options, firstValue, fields);
      }
      columnIndex++;
      formatted.push(options);
    }
    return formatted;
  }
  function getElementTranslateY(element) {
    const { transform } = window.getComputedStyle(element);
    const translateY = transform.slice(7, transform.length - 1).split(", ")[5];
    return Number(translateY);
  }
  function assignDefaultFields(fields) {
    return extend(
      {
        text: "text",
        value: "value",
        children: "children"
      },
      fields
    );
  }
  const DEFAULT_DURATION = 200;
  const MOMENTUM_TIME = 300;
  const MOMENTUM_DISTANCE = 15;
  const [name$1y, bem$1t] = createNamespace("picker-column");
  const PICKER_KEY = Symbol(name$1y);
  var stdin_default$1F = vue.defineComponent({
    name: name$1y,
    props: {
      value: numericProp,
      fields: makeRequiredProp(Object),
      options: makeArrayProp(),
      readonly: Boolean,
      allowHtml: Boolean,
      optionHeight: makeRequiredProp(Number),
      swipeDuration: makeRequiredProp(numericProp),
      visibleOptionNum: makeRequiredProp(numericProp)
    },
    emits: ["change", "clickOption", "scrollInto"],
    setup(props2, {
      emit,
      slots
    }) {
      let moving;
      let startOffset;
      let touchStartTime;
      let momentumOffset;
      let transitionEndTrigger;
      const root = vue.ref();
      const wrapper = vue.ref();
      const currentOffset = vue.ref(0);
      const currentDuration = vue.ref(0);
      const touch = useTouch();
      const count = () => props2.options.length;
      const baseOffset = () => props2.optionHeight * (+props2.visibleOptionNum - 1) / 2;
      const updateValueByIndex = (index2) => {
        let enabledIndex = findIndexOfEnabledOption(props2.options, index2);
        const offset2 = -enabledIndex * props2.optionHeight;
        const trigger = () => {
          if (enabledIndex > count() - 1) {
            enabledIndex = findIndexOfEnabledOption(props2.options, index2);
          }
          const value = props2.options[enabledIndex][props2.fields.value];
          if (value !== props2.value) {
            emit("change", value);
          }
        };
        if (moving && offset2 !== currentOffset.value) {
          transitionEndTrigger = trigger;
        } else {
          trigger();
        }
        currentOffset.value = offset2;
      };
      const isReadonly = () => props2.readonly || !props2.options.length;
      const onClickOption = (index2) => {
        if (moving || isReadonly()) {
          return;
        }
        transitionEndTrigger = null;
        currentDuration.value = DEFAULT_DURATION;
        updateValueByIndex(index2);
        emit("clickOption", props2.options[index2]);
      };
      const getIndexByOffset = (offset2) => clamp(Math.round(-offset2 / props2.optionHeight), 0, count() - 1);
      const currentIndex = vue.computed(() => getIndexByOffset(currentOffset.value));
      const momentum = (distance, duration) => {
        const speed = Math.abs(distance / duration);
        distance = currentOffset.value + speed / 3e-3 * (distance < 0 ? -1 : 1);
        const index2 = getIndexByOffset(distance);
        currentDuration.value = +props2.swipeDuration;
        updateValueByIndex(index2);
      };
      const stopMomentum = () => {
        moving = false;
        currentDuration.value = 0;
        if (transitionEndTrigger) {
          transitionEndTrigger();
          transitionEndTrigger = null;
        }
      };
      const onTouchStart = (event) => {
        if (isReadonly()) {
          return;
        }
        touch.start(event);
        if (moving) {
          const translateY = getElementTranslateY(wrapper.value);
          currentOffset.value = Math.min(0, translateY - baseOffset());
        }
        currentDuration.value = 0;
        startOffset = currentOffset.value;
        touchStartTime = Date.now();
        momentumOffset = startOffset;
        transitionEndTrigger = null;
      };
      const onTouchMove = (event) => {
        if (isReadonly()) {
          return;
        }
        touch.move(event);
        if (touch.isVertical()) {
          moving = true;
          preventDefault(event, true);
        }
        const newOffset = clamp(startOffset + touch.deltaY.value, -(count() * props2.optionHeight), props2.optionHeight);
        const newIndex = getIndexByOffset(newOffset);
        if (newIndex !== currentIndex.value) {
          emit("scrollInto", props2.options[newIndex]);
        }
        currentOffset.value = newOffset;
        const now2 = Date.now();
        if (now2 - touchStartTime > MOMENTUM_TIME) {
          touchStartTime = now2;
          momentumOffset = newOffset;
        }
      };
      const onTouchEnd = () => {
        if (isReadonly()) {
          return;
        }
        const distance = currentOffset.value - momentumOffset;
        const duration = Date.now() - touchStartTime;
        const startMomentum = duration < MOMENTUM_TIME && Math.abs(distance) > MOMENTUM_DISTANCE;
        if (startMomentum) {
          momentum(distance, duration);
          return;
        }
        const index2 = getIndexByOffset(currentOffset.value);
        currentDuration.value = DEFAULT_DURATION;
        updateValueByIndex(index2);
        setTimeout(() => {
          moving = false;
        }, 0);
      };
      const renderOptions = () => {
        const optionStyle = {
          height: `${props2.optionHeight}px`
        };
        return props2.options.map((option, index2) => {
          const text = option[props2.fields.text];
          const {
            disabled
          } = option;
          const value = option[props2.fields.value];
          const data = {
            role: "button",
            style: optionStyle,
            tabindex: disabled ? -1 : 0,
            class: [bem$1t("item", {
              disabled,
              selected: value === props2.value
            }), option.className],
            onClick: () => onClickOption(index2)
          };
          const childData = {
            class: "van-ellipsis",
            [props2.allowHtml ? "innerHTML" : "textContent"]: text
          };
          return vue.createVNode("li", data, [slots.option ? slots.option(option, index2) : vue.createVNode("div", childData, null)]);
        });
      };
      useParent(PICKER_KEY);
      useExpose({
        stopMomentum
      });
      vue.watchEffect(() => {
        const index2 = moving ? Math.floor(-currentOffset.value / props2.optionHeight) : props2.options.findIndex((option) => option[props2.fields.value] === props2.value);
        const enabledIndex = findIndexOfEnabledOption(props2.options, index2);
        const offset2 = -enabledIndex * props2.optionHeight;
        if (moving && enabledIndex < index2)
          stopMomentum();
        currentOffset.value = offset2;
      });
      useEventListener("touchmove", onTouchMove, {
        target: root
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "class": bem$1t(),
        "onTouchstartPassive": onTouchStart,
        "onTouchend": onTouchEnd,
        "onTouchcancel": onTouchEnd
      }, [vue.createVNode("ul", {
        "ref": wrapper,
        "style": {
          transform: `translate3d(0, ${currentOffset.value + baseOffset()}px, 0)`,
          transitionDuration: `${currentDuration.value}ms`,
          transitionProperty: currentDuration.value ? "all" : "none"
        },
        "class": bem$1t("wrapper"),
        "onTransitionend": stopMomentum
      }, [renderOptions()])]);
    }
  });
  const [name$1x] = createNamespace("picker-toolbar");
  const pickerToolbarProps = {
    title: String,
    cancelButtonText: String,
    confirmButtonText: String
  };
  const pickerToolbarSlots = ["cancel", "confirm", "title", "toolbar"];
  const pickerToolbarPropKeys = Object.keys(pickerToolbarProps);
  var stdin_default$1E = vue.defineComponent({
    name: name$1x,
    props: pickerToolbarProps,
    emits: ["confirm", "cancel"],
    setup(props2, {
      emit,
      slots
    }) {
      const renderTitle = () => {
        if (slots.title) {
          return slots.title();
        }
        if (props2.title) {
          return vue.createVNode("div", {
            "class": [bem$1u("title"), "van-ellipsis"]
          }, [props2.title]);
        }
      };
      const onCancel = () => emit("cancel");
      const onConfirm = () => emit("confirm");
      const renderCancel = () => {
        var _a;
        const text = (_a = props2.cancelButtonText) != null ? _a : t$m("cancel");
        if (!slots.cancel && !text) {
          return;
        }
        return vue.createVNode("button", {
          "type": "button",
          "class": [bem$1u("cancel"), HAPTICS_FEEDBACK],
          "onClick": onCancel
        }, [slots.cancel ? slots.cancel() : text]);
      };
      const renderConfirm = () => {
        var _a;
        const text = (_a = props2.confirmButtonText) != null ? _a : t$m("confirm");
        if (!slots.confirm && !text) {
          return;
        }
        return vue.createVNode("button", {
          "type": "button",
          "class": [bem$1u("confirm"), HAPTICS_FEEDBACK],
          "onClick": onConfirm
        }, [slots.confirm ? slots.confirm() : text]);
      };
      return () => vue.createVNode("div", {
        "class": bem$1u("toolbar")
      }, [slots.toolbar ? slots.toolbar() : [renderCancel(), renderTitle(), renderConfirm()]]);
    }
  });
  const useSyncPropRef = (getProp, setProp) => {
    const propRef = vue.ref(getProp());
    vue.watch(getProp, (value) => {
      if (value !== propRef.value) {
        propRef.value = value;
      }
    });
    vue.watch(propRef, (value) => {
      if (value !== getProp()) {
        setProp(value);
      }
    });
    return propRef;
  };
  function scrollLeftTo(scroller, to, duration) {
    let rafId;
    let count = 0;
    const from = scroller.scrollLeft;
    const frames = duration === 0 ? 1 : Math.round(duration * 1e3 / 16);
    let scrollLeft = from;
    function cancel() {
      cancelRaf(rafId);
    }
    function animate() {
      scrollLeft += (to - from) / frames;
      scroller.scrollLeft = scrollLeft;
      if (++count < frames) {
        rafId = raf(animate);
      }
    }
    animate();
    return cancel;
  }
  function scrollTopTo(scroller, to, duration, callback) {
    let rafId;
    let current2 = getScrollTop(scroller);
    const isDown = current2 < to;
    const frames = duration === 0 ? 1 : Math.round(duration * 1e3 / 16);
    const step = (to - current2) / frames;
    function cancel() {
      cancelRaf(rafId);
    }
    function animate() {
      current2 += step;
      if (isDown && current2 > to || !isDown && current2 < to) {
        current2 = to;
      }
      setScrollTop(scroller, current2);
      if (isDown && current2 < to || !isDown && current2 > to) {
        rafId = raf(animate);
      } else if (callback) {
        rafId = raf(callback);
      }
    }
    animate();
    return cancel;
  }
  let current = 0;
  function useId() {
    const vm = vue.getCurrentInstance();
    const { name: name2 = "unknown" } = (vm == null ? void 0 : vm.type) || {};
    return `${name2}-${++current}`;
  }
  function useRefs() {
    const refs = vue.ref([]);
    const cache2 = [];
    vue.onBeforeUpdate(() => {
      refs.value = [];
    });
    const setRefs = (index2) => {
      if (!cache2[index2]) {
        cache2[index2] = (el) => {
          refs.value[index2] = el;
        };
      }
      return cache2[index2];
    };
    return [refs, setRefs];
  }
  function useVisibilityChange(target, onChange) {
    if (!inBrowser$1 || !window.IntersectionObserver) {
      return;
    }
    const observer = new IntersectionObserver(
      (entries) => {
        onChange(entries[0].intersectionRatio > 0);
      },
      { root: document.body }
    );
    const observe = () => {
      if (target.value) {
        observer.observe(target.value);
      }
    };
    const unobserve = () => {
      if (target.value) {
        observer.unobserve(target.value);
      }
    };
    vue.onDeactivated(unobserve);
    vue.onBeforeUnmount(unobserve);
    onMountedOrActivated(observe);
  }
  const [name$1w, bem$1s] = createNamespace("sticky");
  const stickyProps = {
    zIndex: numericProp,
    position: makeStringProp("top"),
    container: Object,
    offsetTop: makeNumericProp(0),
    offsetBottom: makeNumericProp(0)
  };
  var stdin_default$1D = vue.defineComponent({
    name: name$1w,
    props: stickyProps,
    emits: ["scroll", "change"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const scrollParent = useScrollParent(root);
      const state = vue.reactive({
        fixed: false,
        width: 0,
        // root width
        height: 0,
        // root height
        transform: 0
      });
      const isReset = vue.ref(false);
      const offset2 = vue.computed(() => unitToPx(props2.position === "top" ? props2.offsetTop : props2.offsetBottom));
      const rootStyle = vue.computed(() => {
        if (isReset.value) {
          return;
        }
        const {
          fixed,
          height: height2,
          width: width2
        } = state;
        if (fixed) {
          return {
            width: `${width2}px`,
            height: `${height2}px`
          };
        }
      });
      const stickyStyle = vue.computed(() => {
        if (!state.fixed || isReset.value) {
          return;
        }
        const style = extend(getZIndexStyle(props2.zIndex), {
          width: `${state.width}px`,
          height: `${state.height}px`,
          [props2.position]: `${offset2.value}px`
        });
        if (state.transform) {
          style.transform = `translate3d(0, ${state.transform}px, 0)`;
        }
        return style;
      });
      const emitScroll = (scrollTop) => emit("scroll", {
        scrollTop,
        isFixed: state.fixed
      });
      const onScroll = () => {
        if (!root.value || isHidden(root)) {
          return;
        }
        const {
          container,
          position
        } = props2;
        const rootRect = useRect(root);
        const scrollTop = getScrollTop(window);
        state.width = rootRect.width;
        state.height = rootRect.height;
        if (position === "top") {
          if (container) {
            const containerRect = useRect(container);
            const difference = containerRect.bottom - offset2.value - state.height;
            state.fixed = offset2.value > rootRect.top && containerRect.bottom > 0;
            state.transform = difference < 0 ? difference : 0;
          } else {
            state.fixed = offset2.value > rootRect.top;
          }
        } else {
          const {
            clientHeight
          } = document.documentElement;
          if (container) {
            const containerRect = useRect(container);
            const difference = clientHeight - containerRect.top - offset2.value - state.height;
            state.fixed = clientHeight - offset2.value < rootRect.bottom && clientHeight > containerRect.top;
            state.transform = difference < 0 ? -difference : 0;
          } else {
            state.fixed = clientHeight - offset2.value < rootRect.bottom;
          }
        }
        emitScroll(scrollTop);
      };
      vue.watch(() => state.fixed, (value) => emit("change", value));
      useEventListener("scroll", onScroll, {
        target: scrollParent,
        passive: true
      });
      useVisibilityChange(root, onScroll);
      vue.watch([windowWidth, windowHeight], () => {
        if (!root.value || isHidden(root) || !state.fixed) {
          return;
        }
        isReset.value = true;
        vue.nextTick(() => {
          const rootRect = useRect(root);
          state.width = rootRect.width;
          state.height = rootRect.height;
          isReset.value = false;
        });
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "style": rootStyle.value
        }, [vue.createVNode("div", {
          "class": bem$1s({
            fixed: state.fixed && !isReset.value
          }),
          "style": stickyStyle.value
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
      };
    }
  });
  const Sticky = withInstall(stdin_default$1D);
  const [name$1v, bem$1r] = createNamespace("swipe");
  const swipeProps = {
    loop: truthProp,
    width: numericProp,
    height: numericProp,
    vertical: Boolean,
    autoplay: makeNumericProp(0),
    duration: makeNumericProp(500),
    touchable: truthProp,
    lazyRender: Boolean,
    initialSwipe: makeNumericProp(0),
    indicatorColor: String,
    showIndicators: truthProp,
    stopPropagation: truthProp
  };
  const SWIPE_KEY = Symbol(name$1v);
  var stdin_default$1C = vue.defineComponent({
    name: name$1v,
    props: swipeProps,
    emits: ["change", "dragStart", "dragEnd"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const track = vue.ref();
      const state = vue.reactive({
        rect: null,
        width: 0,
        height: 0,
        offset: 0,
        active: 0,
        swiping: false
      });
      let dragging = false;
      const touch = useTouch();
      const {
        children,
        linkChildren
      } = useChildren(SWIPE_KEY);
      const count = vue.computed(() => children.length);
      const size = vue.computed(() => state[props2.vertical ? "height" : "width"]);
      const delta = vue.computed(() => props2.vertical ? touch.deltaY.value : touch.deltaX.value);
      const minOffset = vue.computed(() => {
        if (state.rect) {
          const base = props2.vertical ? state.rect.height : state.rect.width;
          return base - size.value * count.value;
        }
        return 0;
      });
      const maxCount = vue.computed(() => size.value ? Math.ceil(Math.abs(minOffset.value) / size.value) : count.value);
      const trackSize = vue.computed(() => count.value * size.value);
      const activeIndicator = vue.computed(() => (state.active + count.value) % count.value);
      const isCorrectDirection = vue.computed(() => {
        const expect = props2.vertical ? "vertical" : "horizontal";
        return touch.direction.value === expect;
      });
      const trackStyle = vue.computed(() => {
        const style = {
          transitionDuration: `${state.swiping ? 0 : props2.duration}ms`,
          transform: `translate${props2.vertical ? "Y" : "X"}(${+state.offset.toFixed(2)}px)`
        };
        if (size.value) {
          const mainAxis = props2.vertical ? "height" : "width";
          const crossAxis = props2.vertical ? "width" : "height";
          style[mainAxis] = `${trackSize.value}px`;
          style[crossAxis] = props2[crossAxis] ? `${props2[crossAxis]}px` : "";
        }
        return style;
      });
      const getTargetActive = (pace) => {
        const {
          active
        } = state;
        if (pace) {
          if (props2.loop) {
            return clamp(active + pace, -1, count.value);
          }
          return clamp(active + pace, 0, maxCount.value);
        }
        return active;
      };
      const getTargetOffset = (targetActive, offset2 = 0) => {
        let currentPosition = targetActive * size.value;
        if (!props2.loop) {
          currentPosition = Math.min(currentPosition, -minOffset.value);
        }
        let targetOffset = offset2 - currentPosition;
        if (!props2.loop) {
          targetOffset = clamp(targetOffset, minOffset.value, 0);
        }
        return targetOffset;
      };
      const move = ({
        pace = 0,
        offset: offset2 = 0,
        emitChange
      }) => {
        if (count.value <= 1) {
          return;
        }
        const {
          active
        } = state;
        const targetActive = getTargetActive(pace);
        const targetOffset = getTargetOffset(targetActive, offset2);
        if (props2.loop) {
          if (children[0] && targetOffset !== minOffset.value) {
            const outRightBound = targetOffset < minOffset.value;
            children[0].setOffset(outRightBound ? trackSize.value : 0);
          }
          if (children[count.value - 1] && targetOffset !== 0) {
            const outLeftBound = targetOffset > 0;
            children[count.value - 1].setOffset(outLeftBound ? -trackSize.value : 0);
          }
        }
        state.active = targetActive;
        state.offset = targetOffset;
        if (emitChange && targetActive !== active) {
          emit("change", activeIndicator.value);
        }
      };
      const correctPosition = () => {
        state.swiping = true;
        if (state.active <= -1) {
          move({
            pace: count.value
          });
        } else if (state.active >= count.value) {
          move({
            pace: -count.value
          });
        }
      };
      const prev = () => {
        correctPosition();
        touch.reset();
        doubleRaf(() => {
          state.swiping = false;
          move({
            pace: -1,
            emitChange: true
          });
        });
      };
      const next = () => {
        correctPosition();
        touch.reset();
        doubleRaf(() => {
          state.swiping = false;
          move({
            pace: 1,
            emitChange: true
          });
        });
      };
      let autoplayTimer;
      const stopAutoplay = () => clearTimeout(autoplayTimer);
      const autoplay = () => {
        stopAutoplay();
        if (+props2.autoplay > 0 && count.value > 1) {
          autoplayTimer = setTimeout(() => {
            next();
            autoplay();
          }, +props2.autoplay);
        }
      };
      const initialize = (active = +props2.initialSwipe) => {
        if (!root.value) {
          return;
        }
        const cb = () => {
          var _a, _b;
          if (!isHidden(root)) {
            const rect = {
              width: root.value.offsetWidth,
              height: root.value.offsetHeight
            };
            state.rect = rect;
            state.width = +((_a = props2.width) != null ? _a : rect.width);
            state.height = +((_b = props2.height) != null ? _b : rect.height);
          }
          if (count.value) {
            active = Math.min(count.value - 1, active);
            if (active === -1) {
              active = count.value - 1;
            }
          }
          state.active = active;
          state.swiping = true;
          state.offset = getTargetOffset(active);
          children.forEach((swipe) => {
            swipe.setOffset(0);
          });
          autoplay();
        };
        if (isHidden(root)) {
          vue.nextTick().then(cb);
        } else {
          cb();
        }
      };
      const resize = () => initialize(state.active);
      let touchStartTime;
      const onTouchStart = (event) => {
        if (!props2.touchable || // avoid resetting position on multi-finger touch
        event.touches.length > 1)
          return;
        touch.start(event);
        dragging = false;
        touchStartTime = Date.now();
        stopAutoplay();
        correctPosition();
      };
      const onTouchMove = (event) => {
        if (props2.touchable && state.swiping) {
          touch.move(event);
          if (isCorrectDirection.value) {
            const isEdgeTouch = !props2.loop && (state.active === 0 && delta.value > 0 || state.active === count.value - 1 && delta.value < 0);
            if (!isEdgeTouch) {
              preventDefault(event, props2.stopPropagation);
              move({
                offset: delta.value
              });
              if (!dragging) {
                emit("dragStart", {
                  index: activeIndicator.value
                });
                dragging = true;
              }
            }
          }
        }
      };
      const onTouchEnd = () => {
        if (!props2.touchable || !state.swiping) {
          return;
        }
        const duration = Date.now() - touchStartTime;
        const speed = delta.value / duration;
        const shouldSwipe = Math.abs(speed) > 0.25 || Math.abs(delta.value) > size.value / 2;
        if (shouldSwipe && isCorrectDirection.value) {
          const offset2 = props2.vertical ? touch.offsetY.value : touch.offsetX.value;
          let pace = 0;
          if (props2.loop) {
            pace = offset2 > 0 ? delta.value > 0 ? -1 : 1 : 0;
          } else {
            pace = -Math[delta.value > 0 ? "ceil" : "floor"](delta.value / size.value);
          }
          move({
            pace,
            emitChange: true
          });
        } else if (delta.value) {
          move({
            pace: 0
          });
        }
        dragging = false;
        state.swiping = false;
        emit("dragEnd", {
          index: activeIndicator.value
        });
        autoplay();
      };
      const swipeTo = (index2, options = {}) => {
        correctPosition();
        touch.reset();
        doubleRaf(() => {
          let targetIndex;
          if (props2.loop && index2 === count.value) {
            targetIndex = state.active === 0 ? 0 : index2;
          } else {
            targetIndex = index2 % count.value;
          }
          if (options.immediate) {
            doubleRaf(() => {
              state.swiping = false;
            });
          } else {
            state.swiping = false;
          }
          move({
            pace: targetIndex - state.active,
            emitChange: true
          });
        });
      };
      const renderDot = (_, index2) => {
        const active = index2 === activeIndicator.value;
        const style = active ? {
          backgroundColor: props2.indicatorColor
        } : void 0;
        return vue.createVNode("i", {
          "style": style,
          "class": bem$1r("indicator", {
            active
          })
        }, null);
      };
      const renderIndicator = () => {
        if (slots.indicator) {
          return slots.indicator({
            active: activeIndicator.value,
            total: count.value
          });
        }
        if (props2.showIndicators && count.value > 1) {
          return vue.createVNode("div", {
            "class": bem$1r("indicators", {
              vertical: props2.vertical
            })
          }, [Array(count.value).fill("").map(renderDot)]);
        }
      };
      useExpose({
        prev,
        next,
        state,
        resize,
        swipeTo
      });
      linkChildren({
        size,
        props: props2,
        count,
        activeIndicator
      });
      vue.watch(() => props2.initialSwipe, (value) => initialize(+value));
      vue.watch(count, () => initialize(state.active));
      vue.watch(() => props2.autoplay, autoplay);
      vue.watch([windowWidth, windowHeight, () => props2.width, () => props2.height], resize);
      vue.watch(usePageVisibility(), (visible) => {
        if (visible === "visible") {
          autoplay();
        } else {
          stopAutoplay();
        }
      });
      vue.onMounted(initialize);
      vue.onActivated(() => initialize(state.active));
      onPopupReopen(() => initialize(state.active));
      vue.onDeactivated(stopAutoplay);
      vue.onBeforeUnmount(stopAutoplay);
      useEventListener("touchmove", onTouchMove, {
        target: track
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$1r()
        }, [vue.createVNode("div", {
          "ref": track,
          "style": trackStyle.value,
          "class": bem$1r("track", {
            vertical: props2.vertical
          }),
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), renderIndicator()]);
      };
    }
  });
  const Swipe = withInstall(stdin_default$1C);
  const [name$1u, bem$1q] = createNamespace("tabs");
  var stdin_default$1B = vue.defineComponent({
    name: name$1u,
    props: {
      count: makeRequiredProp(Number),
      inited: Boolean,
      animated: Boolean,
      duration: makeRequiredProp(numericProp),
      swipeable: Boolean,
      lazyRender: Boolean,
      currentIndex: makeRequiredProp(Number)
    },
    emits: ["change"],
    setup(props2, {
      emit,
      slots
    }) {
      const swipeRef = vue.ref();
      const onChange = (index2) => emit("change", index2);
      const renderChildren = () => {
        var _a;
        const Content = (_a = slots.default) == null ? void 0 : _a.call(slots);
        if (props2.animated || props2.swipeable) {
          return vue.createVNode(Swipe, {
            "ref": swipeRef,
            "loop": false,
            "class": bem$1q("track"),
            "duration": +props2.duration * 1e3,
            "touchable": props2.swipeable,
            "lazyRender": props2.lazyRender,
            "showIndicators": false,
            "onChange": onChange
          }, {
            default: () => [Content]
          });
        }
        return Content;
      };
      const swipeToCurrentTab = (index2) => {
        const swipe = swipeRef.value;
        if (swipe && swipe.state.active !== index2) {
          swipe.swipeTo(index2, {
            immediate: !props2.inited
          });
        }
      };
      vue.watch(() => props2.currentIndex, swipeToCurrentTab);
      vue.onMounted(() => {
        swipeToCurrentTab(props2.currentIndex);
      });
      useExpose({
        swipeRef
      });
      return () => vue.createVNode("div", {
        "class": bem$1q("content", {
          animated: props2.animated || props2.swipeable
        })
      }, [renderChildren()]);
    }
  });
  const [name$1t, bem$1p] = createNamespace("tabs");
  const tabsProps = {
    type: makeStringProp("line"),
    color: String,
    border: Boolean,
    sticky: Boolean,
    shrink: Boolean,
    active: makeNumericProp(0),
    duration: makeNumericProp(0.3),
    animated: Boolean,
    ellipsis: truthProp,
    swipeable: Boolean,
    scrollspy: Boolean,
    offsetTop: makeNumericProp(0),
    background: String,
    lazyRender: truthProp,
    showHeader: truthProp,
    lineWidth: numericProp,
    lineHeight: numericProp,
    beforeChange: Function,
    swipeThreshold: makeNumericProp(5),
    titleActiveColor: String,
    titleInactiveColor: String
  };
  const TABS_KEY = Symbol(name$1t);
  var stdin_default$1A = vue.defineComponent({
    name: name$1t,
    props: tabsProps,
    emits: ["change", "scroll", "rendered", "clickTab", "update:active"],
    setup(props2, {
      emit,
      slots
    }) {
      let tabHeight;
      let lockScroll;
      let stickyFixed;
      let cancelScrollLeftToRaf;
      let cancelScrollTopToRaf;
      const root = vue.ref();
      const navRef = vue.ref();
      const wrapRef = vue.ref();
      const contentRef = vue.ref();
      const id = useId();
      const scroller = useScrollParent(root);
      const [titleRefs, setTitleRefs] = useRefs();
      const {
        children,
        linkChildren
      } = useChildren(TABS_KEY);
      const state = vue.reactive({
        inited: false,
        position: "",
        lineStyle: {},
        currentIndex: -1
      });
      const scrollable = vue.computed(() => children.length > +props2.swipeThreshold || !props2.ellipsis || props2.shrink);
      const navStyle = vue.computed(() => ({
        borderColor: props2.color,
        background: props2.background
      }));
      const getTabName = (tab, index2) => {
        var _a;
        return (_a = tab.name) != null ? _a : index2;
      };
      const currentName = vue.computed(() => {
        const activeTab = children[state.currentIndex];
        if (activeTab) {
          return getTabName(activeTab, state.currentIndex);
        }
      });
      const offsetTopPx = vue.computed(() => unitToPx(props2.offsetTop));
      const scrollOffset = vue.computed(() => {
        if (props2.sticky) {
          return offsetTopPx.value + tabHeight;
        }
        return 0;
      });
      const scrollIntoView = (immediate) => {
        const nav = navRef.value;
        const titles = titleRefs.value;
        if (!scrollable.value || !nav || !titles || !titles[state.currentIndex]) {
          return;
        }
        const title = titles[state.currentIndex].$el;
        const to = title.offsetLeft - (nav.offsetWidth - title.offsetWidth) / 2;
        if (cancelScrollLeftToRaf)
          cancelScrollLeftToRaf();
        cancelScrollLeftToRaf = scrollLeftTo(nav, to, immediate ? 0 : +props2.duration);
      };
      const setLine = () => {
        const shouldAnimate = state.inited;
        vue.nextTick(() => {
          const titles = titleRefs.value;
          if (!titles || !titles[state.currentIndex] || props2.type !== "line" || isHidden(root.value)) {
            return;
          }
          const title = titles[state.currentIndex].$el;
          const {
            lineWidth,
            lineHeight
          } = props2;
          const left2 = title.offsetLeft + title.offsetWidth / 2;
          const lineStyle = {
            width: addUnit$2(lineWidth),
            backgroundColor: props2.color,
            transform: `translateX(${left2}px) translateX(-50%)`
          };
          if (shouldAnimate) {
            lineStyle.transitionDuration = `${props2.duration}s`;
          }
          if (isDef(lineHeight)) {
            const height2 = addUnit$2(lineHeight);
            lineStyle.height = height2;
            lineStyle.borderRadius = height2;
          }
          state.lineStyle = lineStyle;
        });
      };
      const findAvailableTab = (index2) => {
        const diff = index2 < state.currentIndex ? -1 : 1;
        while (index2 >= 0 && index2 < children.length) {
          if (!children[index2].disabled) {
            return index2;
          }
          index2 += diff;
        }
      };
      const setCurrentIndex = (currentIndex, skipScrollIntoView) => {
        const newIndex = findAvailableTab(currentIndex);
        if (!isDef(newIndex)) {
          return;
        }
        const newTab = children[newIndex];
        const newName = getTabName(newTab, newIndex);
        const shouldEmitChange = state.currentIndex !== null;
        if (state.currentIndex !== newIndex) {
          state.currentIndex = newIndex;
          if (!skipScrollIntoView) {
            scrollIntoView();
          }
          setLine();
        }
        if (newName !== props2.active) {
          emit("update:active", newName);
          if (shouldEmitChange) {
            emit("change", newName, newTab.title);
          }
        }
        if (stickyFixed && !props2.scrollspy) {
          setRootScrollTop(Math.ceil(getElementTop(root.value) - offsetTopPx.value));
        }
      };
      const setCurrentIndexByName = (name2, skipScrollIntoView) => {
        const matched = children.find((tab, index22) => getTabName(tab, index22) === name2);
        const index2 = matched ? children.indexOf(matched) : 0;
        setCurrentIndex(index2, skipScrollIntoView);
      };
      const scrollToCurrentContent = (immediate = false) => {
        if (props2.scrollspy) {
          const target = children[state.currentIndex].$el;
          if (target && scroller.value) {
            const to = getElementTop(target, scroller.value) - scrollOffset.value;
            lockScroll = true;
            if (cancelScrollTopToRaf)
              cancelScrollTopToRaf();
            cancelScrollTopToRaf = scrollTopTo(scroller.value, to, immediate ? 0 : +props2.duration, () => {
              lockScroll = false;
            });
          }
        }
      };
      const onClickTab = (item, index2, event) => {
        const {
          title,
          disabled
        } = children[index2];
        const name2 = getTabName(children[index2], index2);
        if (!disabled) {
          callInterceptor(props2.beforeChange, {
            args: [name2],
            done: () => {
              setCurrentIndex(index2);
              scrollToCurrentContent();
            }
          });
          route$1(item);
        }
        emit("clickTab", {
          name: name2,
          title,
          event,
          disabled
        });
      };
      const onStickyScroll = (params) => {
        stickyFixed = params.isFixed;
        emit("scroll", params);
      };
      const scrollTo = (name2) => {
        vue.nextTick(() => {
          setCurrentIndexByName(name2);
          scrollToCurrentContent(true);
        });
      };
      const getCurrentIndexOnScroll = () => {
        for (let index2 = 0; index2 < children.length; index2++) {
          const {
            top: top2
          } = useRect(children[index2].$el);
          if (top2 > scrollOffset.value) {
            return index2 === 0 ? 0 : index2 - 1;
          }
        }
        return children.length - 1;
      };
      const onScroll = () => {
        if (props2.scrollspy && !lockScroll) {
          const index2 = getCurrentIndexOnScroll();
          setCurrentIndex(index2);
        }
      };
      const renderLine = () => {
        if (props2.type === "line" && children.length) {
          return vue.createVNode("div", {
            "class": bem$1p("line"),
            "style": state.lineStyle
          }, null);
        }
      };
      const renderHeader = () => {
        var _a, _b, _c;
        const {
          type,
          border,
          sticky
        } = props2;
        const Header = [vue.createVNode("div", {
          "ref": sticky ? void 0 : wrapRef,
          "class": [bem$1p("wrap"), {
            [BORDER_TOP_BOTTOM]: type === "line" && border
          }]
        }, [vue.createVNode("div", {
          "ref": navRef,
          "role": "tablist",
          "class": bem$1p("nav", [type, {
            shrink: props2.shrink,
            complete: scrollable.value
          }]),
          "style": navStyle.value,
          "aria-orientation": "horizontal"
        }, [(_a = slots["nav-left"]) == null ? void 0 : _a.call(slots), children.map((item) => item.renderTitle(onClickTab)), renderLine(), (_b = slots["nav-right"]) == null ? void 0 : _b.call(slots)])]), (_c = slots["nav-bottom"]) == null ? void 0 : _c.call(slots)];
        if (sticky) {
          return vue.createVNode("div", {
            "ref": wrapRef
          }, [Header]);
        }
        return Header;
      };
      const resize = () => {
        setLine();
        vue.nextTick(() => {
          var _a, _b;
          scrollIntoView(true);
          (_b = (_a = contentRef.value) == null ? void 0 : _a.swipeRef.value) == null ? void 0 : _b.resize();
        });
      };
      vue.watch(() => [props2.color, props2.duration, props2.lineWidth, props2.lineHeight], setLine);
      vue.watch(windowWidth, resize);
      vue.watch(() => props2.active, (value) => {
        if (value !== currentName.value) {
          setCurrentIndexByName(value);
        }
      });
      vue.watch(() => children.length, () => {
        if (state.inited) {
          setCurrentIndexByName(props2.active);
          setLine();
          vue.nextTick(() => {
            scrollIntoView(true);
          });
        }
      });
      const init = () => {
        setCurrentIndexByName(props2.active, true);
        vue.nextTick(() => {
          state.inited = true;
          if (wrapRef.value) {
            tabHeight = useRect(wrapRef.value).height;
          }
          scrollIntoView(true);
        });
      };
      const onRendered = (name2, title) => emit("rendered", name2, title);
      useExpose({
        resize,
        scrollTo
      });
      vue.onActivated(setLine);
      onPopupReopen(setLine);
      onMountedOrActivated(init);
      useVisibilityChange(root, setLine);
      useEventListener("scroll", onScroll, {
        target: scroller,
        passive: true
      });
      linkChildren({
        id,
        props: props2,
        setLine,
        scrollable,
        onRendered,
        currentName,
        setTitleRefs,
        scrollIntoView
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "class": bem$1p([props2.type])
      }, [props2.showHeader ? props2.sticky ? vue.createVNode(Sticky, {
        "container": root.value,
        "offsetTop": offsetTopPx.value,
        "onScroll": onStickyScroll
      }, {
        default: () => [renderHeader()]
      }) : renderHeader() : null, vue.createVNode(stdin_default$1B, {
        "ref": contentRef,
        "count": children.length,
        "inited": state.inited,
        "animated": props2.animated,
        "duration": props2.duration,
        "swipeable": props2.swipeable,
        "lazyRender": props2.lazyRender,
        "currentIndex": state.currentIndex,
        "onChange": setCurrentIndex
      }, {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      })]);
    }
  });
  const TAB_STATUS_KEY = Symbol();
  const useTabStatus = () => vue.inject(TAB_STATUS_KEY, null);
  const [name$1s, bem$1o] = createNamespace("tab");
  const TabTitle = vue.defineComponent({
    name: name$1s,
    props: {
      id: String,
      dot: Boolean,
      type: String,
      color: String,
      title: String,
      badge: numericProp,
      shrink: Boolean,
      isActive: Boolean,
      disabled: Boolean,
      controls: String,
      scrollable: Boolean,
      activeColor: String,
      inactiveColor: String,
      showZeroBadge: truthProp
    },
    setup(props2, {
      slots
    }) {
      const style = vue.computed(() => {
        const style2 = {};
        const {
          type,
          color,
          disabled,
          isActive,
          activeColor,
          inactiveColor
        } = props2;
        const isCard = type === "card";
        if (color && isCard) {
          style2.borderColor = color;
          if (!disabled) {
            if (isActive) {
              style2.backgroundColor = color;
            } else {
              style2.color = color;
            }
          }
        }
        const titleColor = isActive ? activeColor : inactiveColor;
        if (titleColor) {
          style2.color = titleColor;
        }
        return style2;
      });
      const renderText = () => {
        const Text = vue.createVNode("span", {
          "class": bem$1o("text", {
            ellipsis: !props2.scrollable
          })
        }, [slots.title ? slots.title() : props2.title]);
        if (props2.dot || isDef(props2.badge) && props2.badge !== "") {
          return vue.createVNode(Badge, {
            "dot": props2.dot,
            "content": props2.badge,
            "showZero": props2.showZeroBadge
          }, {
            default: () => [Text]
          });
        }
        return Text;
      };
      return () => vue.createVNode("div", {
        "id": props2.id,
        "role": "tab",
        "class": [bem$1o([props2.type, {
          grow: props2.scrollable && !props2.shrink,
          shrink: props2.shrink,
          active: props2.isActive,
          disabled: props2.disabled
        }])],
        "style": style.value,
        "tabindex": props2.disabled ? void 0 : props2.isActive ? 0 : -1,
        "aria-selected": props2.isActive,
        "aria-disabled": props2.disabled || void 0,
        "aria-controls": props2.controls,
        "data-allow-mismatch": "attribute"
      }, [renderText()]);
    }
  });
  const [name$1r, bem$1n] = createNamespace("swipe-item");
  var stdin_default$1z = vue.defineComponent({
    name: name$1r,
    setup(props2, {
      slots
    }) {
      let rendered;
      const state = vue.reactive({
        offset: 0,
        inited: false,
        mounted: false
      });
      const {
        parent,
        index: index2
      } = useParent(SWIPE_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/swipe-item/SwipeItem.mjs:24", "[Vant] <SwipeItem> must be a child component of <Swipe>.");
        }
        return;
      }
      const style = vue.computed(() => {
        const style2 = {};
        const {
          vertical
        } = parent.props;
        if (parent.size.value) {
          style2[vertical ? "height" : "width"] = `${parent.size.value}px`;
        }
        if (state.offset) {
          style2.transform = `translate${vertical ? "Y" : "X"}(${state.offset}px)`;
        }
        return style2;
      });
      const shouldRender = vue.computed(() => {
        const {
          loop,
          lazyRender
        } = parent.props;
        if (!lazyRender || rendered) {
          return true;
        }
        if (!state.mounted) {
          return false;
        }
        const active = parent.activeIndicator.value;
        const maxActive = parent.count.value - 1;
        const prevActive = active === 0 && loop ? maxActive : active - 1;
        const nextActive = active === maxActive && loop ? 0 : active + 1;
        rendered = index2.value === active || index2.value === prevActive || index2.value === nextActive;
        return rendered;
      });
      const setOffset = (offset2) => {
        state.offset = offset2;
      };
      vue.onMounted(() => {
        vue.nextTick(() => {
          state.mounted = true;
        });
      });
      useExpose({
        setOffset
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$1n(),
          "style": style.value
        }, [shouldRender.value ? (_a = slots.default) == null ? void 0 : _a.call(slots) : null]);
      };
    }
  });
  const SwipeItem = withInstall(stdin_default$1z);
  const [name$1q, bem$1m] = createNamespace("tab");
  const tabProps = extend({}, routeProps, {
    dot: Boolean,
    name: numericProp,
    badge: numericProp,
    title: String,
    disabled: Boolean,
    titleClass: unknownProp,
    titleStyle: [String, Object],
    showZeroBadge: truthProp
  });
  var stdin_default$1y = vue.defineComponent({
    name: name$1q,
    props: tabProps,
    setup(props2, {
      slots
    }) {
      const id = useId();
      const inited = vue.ref(false);
      const instance2 = vue.getCurrentInstance();
      const {
        parent,
        index: index2
      } = useParent(TABS_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/tab/Tab.mjs:38", "[Vant] <Tab> must be a child component of <Tabs>.");
        }
        return;
      }
      const getName = () => {
        var _a;
        return (_a = props2.name) != null ? _a : index2.value;
      };
      const init = () => {
        inited.value = true;
        if (parent.props.lazyRender) {
          vue.nextTick(() => {
            parent.onRendered(getName(), props2.title);
          });
        }
      };
      const active = vue.computed(() => {
        const isActive = getName() === parent.currentName.value;
        if (isActive && !inited.value) {
          init();
        }
        return isActive;
      });
      const parsedClass = vue.ref("");
      const parsedStyle = vue.ref("");
      vue.watchEffect(() => {
        const {
          titleClass,
          titleStyle
        } = props2;
        parsedClass.value = titleClass ? shared.normalizeClass(titleClass) : "";
        parsedStyle.value = titleStyle && typeof titleStyle !== "string" ? shared.stringifyStyle(shared.normalizeStyle(titleStyle)) : titleStyle;
      });
      const renderTitle = (onClickTab) => vue.createVNode(TabTitle, vue.mergeProps({
        "key": id,
        "id": `${parent.id}-${index2.value}`,
        "ref": parent.setTitleRefs(index2.value),
        "style": parsedStyle.value,
        "class": parsedClass.value,
        "isActive": active.value,
        "controls": id,
        "scrollable": parent.scrollable.value,
        "activeColor": parent.props.titleActiveColor,
        "inactiveColor": parent.props.titleInactiveColor,
        "onClick": (event) => onClickTab(instance2.proxy, index2.value, event)
      }, pick(parent.props, ["type", "color", "shrink"]), pick(props2, ["dot", "badge", "title", "disabled", "showZeroBadge"])), {
        title: slots.title
      });
      const hasInactiveClass = vue.ref(!active.value);
      vue.watch(active, (val) => {
        if (val) {
          hasInactiveClass.value = false;
        } else {
          doubleRaf(() => {
            hasInactiveClass.value = true;
          });
        }
      });
      vue.watch(() => props2.title, () => {
        parent.setLine();
        parent.scrollIntoView();
      });
      vue.provide(TAB_STATUS_KEY, active);
      useExpose({
        id,
        renderTitle
      });
      return () => {
        var _a;
        const label = `${parent.id}-${index2.value}`;
        const {
          animated,
          swipeable,
          scrollspy,
          lazyRender
        } = parent.props;
        if (!slots.default && !animated) {
          return;
        }
        const show = scrollspy || active.value;
        if (animated || swipeable) {
          return vue.createVNode(SwipeItem, {
            "id": id,
            "role": "tabpanel",
            "class": bem$1m("panel-wrapper", {
              inactive: hasInactiveClass.value
            }),
            "tabindex": active.value ? 0 : -1,
            "aria-hidden": !active.value,
            "aria-labelledby": label,
            "data-allow-mismatch": "attribute"
          }, {
            default: () => {
              var _a2;
              return [vue.createVNode("div", {
                "class": bem$1m("panel")
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])];
            }
          });
        }
        const shouldRender = inited.value || scrollspy || !lazyRender;
        const Content = shouldRender ? (_a = slots.default) == null ? void 0 : _a.call(slots) : null;
        return vue.withDirectives(vue.createVNode("div", {
          "id": id,
          "role": "tabpanel",
          "class": bem$1m("panel"),
          "tabindex": show ? 0 : -1,
          "aria-labelledby": label,
          "data-allow-mismatch": "attribute"
        }, [Content]), [[vue.vShow, show]]);
      };
    }
  });
  const Tab = withInstall(stdin_default$1y);
  const Tabs = withInstall(stdin_default$1A);
  const [name$1p, bem$1l] = createNamespace("picker-group");
  const PICKER_GROUP_KEY = Symbol(name$1p);
  const pickerGroupProps = extend({
    tabs: makeArrayProp(),
    activeTab: makeNumericProp(0),
    nextStepText: String,
    showToolbar: truthProp
  }, pickerToolbarProps);
  var stdin_default$1x = vue.defineComponent({
    name: name$1p,
    props: pickerGroupProps,
    emits: ["confirm", "cancel", "update:activeTab"],
    setup(props2, {
      emit,
      slots
    }) {
      const activeTab = useSyncPropRef(() => props2.activeTab, (value) => emit("update:activeTab", value));
      const {
        children,
        linkChildren
      } = useChildren(PICKER_GROUP_KEY);
      linkChildren();
      const showNextButton = () => +activeTab.value < props2.tabs.length - 1 && props2.nextStepText;
      const onConfirm = () => {
        if (showNextButton()) {
          activeTab.value = +activeTab.value + 1;
        } else {
          emit("confirm", children.map((item) => item.confirm()));
        }
      };
      const onCancel = () => emit("cancel");
      return () => {
        var _a, _b;
        let childNodes = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) == null ? void 0 : _b.filter((node) => node.type !== vue.Comment).map((node) => {
          if (node.type === vue.Fragment) {
            return node.children;
          }
          return node;
        });
        if (childNodes) {
          childNodes = flat(childNodes);
        }
        const confirmButtonText = showNextButton() ? props2.nextStepText : props2.confirmButtonText;
        return vue.createVNode("div", {
          "class": bem$1l()
        }, [props2.showToolbar ? vue.createVNode(stdin_default$1E, {
          "title": props2.title,
          "cancelButtonText": props2.cancelButtonText,
          "confirmButtonText": confirmButtonText,
          "onConfirm": onConfirm,
          "onCancel": onCancel
        }, pick(slots, pickerToolbarSlots)) : null, vue.createVNode(Tabs, {
          "active": activeTab.value,
          "onUpdate:active": ($event) => activeTab.value = $event,
          "class": bem$1l("tabs"),
          "shrink": true,
          "animated": true,
          "lazyRender": false
        }, {
          default: () => [props2.tabs.map((title, index2) => vue.createVNode(Tab, {
            "title": title,
            "titleClass": bem$1l("tab-title")
          }, {
            default: () => [childNodes == null ? void 0 : childNodes[index2]]
          }))]
        })]);
      };
    }
  });
  const pickerSharedProps = extend({
    loading: Boolean,
    readonly: Boolean,
    allowHtml: Boolean,
    optionHeight: makeNumericProp(44),
    showToolbar: truthProp,
    swipeDuration: makeNumericProp(1e3),
    visibleOptionNum: makeNumericProp(6)
  }, pickerToolbarProps);
  const pickerProps = extend({}, pickerSharedProps, {
    columns: makeArrayProp(),
    modelValue: makeArrayProp(),
    toolbarPosition: makeStringProp("top"),
    columnsFieldNames: Object
  });
  var stdin_default$1w = vue.defineComponent({
    name: name$1z,
    props: pickerProps,
    emits: ["confirm", "cancel", "change", "scrollInto", "clickOption", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const columnsRef = vue.ref();
      const selectedValues = vue.ref(props2.modelValue.slice(0));
      const {
        parent
      } = useParent(PICKER_GROUP_KEY);
      const {
        children,
        linkChildren
      } = useChildren(PICKER_KEY);
      linkChildren();
      const fields = vue.computed(() => assignDefaultFields(props2.columnsFieldNames));
      const optionHeight = vue.computed(() => unitToPx(props2.optionHeight));
      const columnsType = vue.computed(() => getColumnsType(props2.columns, fields.value));
      const currentColumns = vue.computed(() => {
        const {
          columns
        } = props2;
        switch (columnsType.value) {
          case "multiple":
            return columns;
          case "cascade":
            return formatCascadeColumns(columns, fields.value, selectedValues);
          default:
            return [columns];
        }
      });
      const hasOptions = vue.computed(() => currentColumns.value.some((options) => options.length));
      const selectedOptions = vue.computed(() => currentColumns.value.map((options, index2) => findOptionByValue(options, selectedValues.value[index2], fields.value)));
      const selectedIndexes = vue.computed(() => currentColumns.value.map((options, index2) => options.findIndex((option) => option[fields.value.value] === selectedValues.value[index2])));
      const setValue = (index2, value) => {
        if (selectedValues.value[index2] !== value) {
          const newValues = selectedValues.value.slice(0);
          newValues[index2] = value;
          selectedValues.value = newValues;
        }
      };
      const getEventParams = () => ({
        selectedValues: selectedValues.value.slice(0),
        selectedOptions: selectedOptions.value,
        selectedIndexes: selectedIndexes.value
      });
      const onChange = (value, columnIndex) => {
        setValue(columnIndex, value);
        if (columnsType.value === "cascade") {
          selectedValues.value.forEach((value2, index2) => {
            const options = currentColumns.value[index2];
            if (!isOptionExist(options, value2, fields.value)) {
              setValue(index2, options.length ? options[0][fields.value.value] : void 0);
            }
          });
        }
        vue.nextTick(() => {
          emit("change", extend({
            columnIndex
          }, getEventParams()));
        });
      };
      const onClickOption = (currentOption, columnIndex) => {
        const params = {
          columnIndex,
          currentOption
        };
        emit("clickOption", extend(getEventParams(), params));
        emit("scrollInto", params);
      };
      const confirm = () => {
        children.forEach((child) => child.stopMomentum());
        const params = getEventParams();
        vue.nextTick(() => {
          emit("confirm", params);
        });
        return params;
      };
      const cancel = () => emit("cancel", getEventParams());
      const renderColumnItems = () => currentColumns.value.map((options, columnIndex) => vue.createVNode(stdin_default$1F, {
        "value": selectedValues.value[columnIndex],
        "fields": fields.value,
        "options": options,
        "readonly": props2.readonly,
        "allowHtml": props2.allowHtml,
        "optionHeight": optionHeight.value,
        "swipeDuration": props2.swipeDuration,
        "visibleOptionNum": props2.visibleOptionNum,
        "onChange": (value) => onChange(value, columnIndex),
        "onClickOption": (option) => onClickOption(option, columnIndex),
        "onScrollInto": (option) => {
          emit("scrollInto", {
            currentOption: option,
            columnIndex
          });
        }
      }, {
        option: slots.option
      }));
      const renderMask = (wrapHeight) => {
        if (hasOptions.value) {
          const frameStyle = {
            height: `${optionHeight.value}px`
          };
          const maskStyle = {
            backgroundSize: `100% ${(wrapHeight - optionHeight.value) / 2}px`
          };
          return [vue.createVNode("div", {
            "class": bem$1u("mask"),
            "style": maskStyle
          }, null), vue.createVNode("div", {
            "class": [BORDER_UNSET_TOP_BOTTOM, bem$1u("frame")],
            "style": frameStyle
          }, null)];
        }
      };
      const renderColumns = () => {
        const wrapHeight = optionHeight.value * +props2.visibleOptionNum;
        const columnsStyle = {
          height: `${wrapHeight}px`
        };
        return vue.createVNode("div", {
          "ref": columnsRef,
          "class": bem$1u("columns"),
          "style": columnsStyle
        }, [renderColumnItems(), renderMask(wrapHeight)]);
      };
      const renderToolbar = () => {
        if (props2.showToolbar && !parent) {
          return vue.createVNode(stdin_default$1E, vue.mergeProps(pick(props2, pickerToolbarPropKeys), {
            "onConfirm": confirm,
            "onCancel": cancel
          }), pick(slots, pickerToolbarSlots));
        }
      };
      vue.watch(currentColumns, (columns) => {
        columns.forEach((options, index2) => {
          if (options.length && !isOptionExist(options, selectedValues.value[index2], fields.value)) {
            setValue(index2, getFirstEnabledOption(options)[fields.value.value]);
          }
        });
      }, {
        immediate: true
      });
      let lastEmittedModelValue;
      vue.watch(() => props2.modelValue, (newValues) => {
        if (!isSameValue(newValues, selectedValues.value) && !isSameValue(newValues, lastEmittedModelValue)) {
          selectedValues.value = newValues.slice(0);
          lastEmittedModelValue = newValues.slice(0);
        }
      }, {
        deep: true
      });
      vue.watch(selectedValues, (newValues) => {
        if (!isSameValue(newValues, props2.modelValue)) {
          lastEmittedModelValue = newValues.slice(0);
          emit("update:modelValue", lastEmittedModelValue);
        }
      }, {
        immediate: true
      });
      useEventListener("touchmove", preventDefault, {
        target: columnsRef
      });
      const getSelectedOptions = () => selectedOptions.value;
      useExpose({
        confirm,
        getSelectedOptions
      });
      return () => {
        var _a, _b;
        return vue.createVNode("div", {
          "class": bem$1u()
        }, [props2.toolbarPosition === "top" ? renderToolbar() : null, props2.loading ? vue.createVNode(Loading, {
          "class": bem$1u("loading")
        }, null) : null, (_a = slots["columns-top"]) == null ? void 0 : _a.call(slots), renderColumns(), (_b = slots["columns-bottom"]) == null ? void 0 : _b.call(slots), props2.toolbarPosition === "bottom" ? renderToolbar() : null]);
      };
    }
  });
  const AREA_EMPTY_CODE = "000000";
  const INHERIT_SLOTS = [
    "title",
    "cancel",
    "confirm",
    "toolbar",
    "columns-top",
    "columns-bottom"
  ];
  const INHERIT_PROPS = [
    "title",
    "loading",
    "readonly",
    "optionHeight",
    "swipeDuration",
    "visibleOptionNum",
    "cancelButtonText",
    "confirmButtonText"
  ];
  const makeOption = (text = "", value = AREA_EMPTY_CODE, children = void 0) => ({
    text,
    value,
    children
  });
  function formatDataForCascade({
    areaList,
    columnsNum,
    columnsPlaceholder: placeholder
  }) {
    const {
      city_list: city = {},
      county_list: county = {},
      province_list: province = {}
    } = areaList;
    const showCity = +columnsNum > 1;
    const showCounty = +columnsNum > 2;
    const getProvinceChildren = () => {
      if (showCity) {
        return placeholder.length > 1 ? [
          makeOption(
            placeholder[1],
            AREA_EMPTY_CODE,
            showCounty ? [] : void 0
          )
        ] : [];
      }
    };
    const provinceMap = /* @__PURE__ */ new Map();
    Object.keys(province).forEach((code2) => {
      provinceMap.set(
        code2.slice(0, 2),
        makeOption(province[code2], code2, getProvinceChildren())
      );
    });
    const cityMap = /* @__PURE__ */ new Map();
    if (showCity) {
      const getCityChildren = () => {
        if (showCounty) {
          return placeholder.length > 2 ? [makeOption(placeholder[2])] : [];
        }
      };
      Object.keys(city).forEach((code2) => {
        const option = makeOption(city[code2], code2, getCityChildren());
        cityMap.set(code2.slice(0, 4), option);
        const province2 = provinceMap.get(code2.slice(0, 2));
        if (province2) {
          province2.children.push(option);
        }
      });
    }
    if (showCounty) {
      Object.keys(county).forEach((code2) => {
        const city2 = cityMap.get(code2.slice(0, 4));
        if (city2) {
          city2.children.push(makeOption(county[code2], code2));
        }
      });
    }
    const options = Array.from(provinceMap.values());
    if (placeholder.length) {
      const county2 = showCounty ? [makeOption(placeholder[2])] : void 0;
      const city2 = showCity ? [makeOption(placeholder[1], AREA_EMPTY_CODE, county2)] : void 0;
      options.unshift(makeOption(placeholder[0], AREA_EMPTY_CODE, city2));
    }
    return options;
  }
  const Picker = withInstall(stdin_default$1w);
  const [name$1o, bem$1k] = createNamespace("area");
  const areaProps = extend({}, pick(pickerSharedProps, INHERIT_PROPS), {
    modelValue: String,
    columnsNum: makeNumericProp(3),
    columnsPlaceholder: makeArrayProp(),
    areaList: {
      type: Object,
      default: () => ({})
    }
  });
  var stdin_default$1v = vue.defineComponent({
    name: name$1o,
    props: areaProps,
    emits: ["change", "confirm", "cancel", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const codes = vue.ref([]);
      const picker = vue.ref();
      const columns = vue.computed(() => formatDataForCascade(props2));
      const onChange = (...args) => emit("change", ...args);
      const onCancel = (...args) => emit("cancel", ...args);
      const onConfirm = (...args) => emit("confirm", ...args);
      vue.watch(codes, (newCodes) => {
        const lastCode = newCodes.length ? newCodes[newCodes.length - 1] : "";
        if (lastCode && lastCode !== props2.modelValue) {
          emit("update:modelValue", lastCode);
        }
      }, {
        deep: true
      });
      vue.watch(() => props2.modelValue, (newCode) => {
        if (newCode) {
          const lastCode = codes.value.length ? codes.value[codes.value.length - 1] : "";
          if (newCode !== lastCode) {
            codes.value = [`${newCode.slice(0, 2)}0000`, `${newCode.slice(0, 4)}00`, newCode].slice(0, +props2.columnsNum);
          }
        } else {
          codes.value = [];
        }
      }, {
        immediate: true
      });
      useExpose({
        confirm: () => {
          var _a;
          return (_a = picker.value) == null ? void 0 : _a.confirm();
        },
        getSelectedOptions: () => {
          var _a;
          return ((_a = picker.value) == null ? void 0 : _a.getSelectedOptions()) || [];
        }
      });
      return () => vue.createVNode(Picker, vue.mergeProps({
        "ref": picker,
        "modelValue": codes.value,
        "onUpdate:modelValue": ($event) => codes.value = $event,
        "class": bem$1k(),
        "columns": columns.value,
        "onChange": onChange,
        "onCancel": onCancel,
        "onConfirm": onConfirm
      }, pick(props2, INHERIT_PROPS)), pick(slots, INHERIT_SLOTS));
    }
  });
  const Area = withInstall(stdin_default$1v);
  const [name$1n, bem$1j] = createNamespace("cell");
  const cellSharedProps = {
    tag: makeStringProp("div"),
    icon: String,
    size: String,
    title: numericProp,
    value: numericProp,
    label: numericProp,
    center: Boolean,
    isLink: Boolean,
    border: truthProp,
    iconPrefix: String,
    valueClass: unknownProp,
    labelClass: unknownProp,
    titleClass: unknownProp,
    titleStyle: null,
    arrowDirection: String,
    required: {
      type: [Boolean, String],
      default: null
    },
    clickable: {
      type: Boolean,
      default: null
    }
  };
  const cellProps = extend({}, cellSharedProps, routeProps);
  var stdin_default$1u = vue.defineComponent({
    name: name$1n,
    props: cellProps,
    setup(props2, {
      slots
    }) {
      const route2 = useRoute();
      const renderLabel = () => {
        const showLabel = slots.label || isDef(props2.label);
        if (showLabel) {
          return vue.createVNode("div", {
            "class": [bem$1j("label"), props2.labelClass]
          }, [slots.label ? slots.label() : props2.label]);
        }
      };
      const renderTitle = () => {
        var _a;
        if (slots.title || isDef(props2.title)) {
          const titleSlot = (_a = slots.title) == null ? void 0 : _a.call(slots);
          if (Array.isArray(titleSlot) && titleSlot.length === 0) {
            return;
          }
          return vue.createVNode("div", {
            "class": [bem$1j("title"), props2.titleClass],
            "style": props2.titleStyle
          }, [titleSlot || vue.createVNode("span", null, [props2.title]), renderLabel()]);
        }
      };
      const renderValue = () => {
        const slot = slots.value || slots.default;
        const hasValue = slot || isDef(props2.value);
        if (hasValue) {
          return vue.createVNode("div", {
            "class": [bem$1j("value"), props2.valueClass]
          }, [slot ? slot() : vue.createVNode("span", null, [props2.value])]);
        }
      };
      const renderLeftIcon = () => {
        if (slots.icon) {
          return slots.icon();
        }
        if (props2.icon) {
          return vue.createVNode(Icon, {
            "name": props2.icon,
            "class": bem$1j("left-icon"),
            "classPrefix": props2.iconPrefix
          }, null);
        }
      };
      const renderRightIcon = () => {
        if (slots["right-icon"]) {
          return slots["right-icon"]();
        }
        if (props2.isLink) {
          const name2 = props2.arrowDirection && props2.arrowDirection !== "right" ? `arrow-${props2.arrowDirection}` : "arrow";
          return vue.createVNode(Icon, {
            "name": name2,
            "class": bem$1j("right-icon")
          }, null);
        }
      };
      return () => {
        var _a;
        const {
          tag,
          size,
          center,
          border,
          isLink,
          required
        } = props2;
        const clickable = (_a = props2.clickable) != null ? _a : isLink;
        const classes = {
          center,
          required: !!required,
          clickable,
          borderless: !border
        };
        if (size) {
          classes[size] = !!size;
        }
        return vue.createVNode(tag, {
          "class": bem$1j(classes),
          "role": clickable ? "button" : void 0,
          "tabindex": clickable ? 0 : void 0,
          "onClick": route2
        }, {
          default: () => {
            var _a2;
            return [renderLeftIcon(), renderTitle(), renderValue(), renderRightIcon(), (_a2 = slots.extra) == null ? void 0 : _a2.call(slots)];
          }
        });
      };
    }
  });
  const Cell = withInstall(stdin_default$1u);
  const [name$1m, bem$1i] = createNamespace("form");
  const formProps = {
    colon: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    required: [Boolean, String],
    showError: Boolean,
    labelWidth: numericProp,
    labelAlign: String,
    inputAlign: String,
    scrollToError: Boolean,
    scrollToErrorPosition: String,
    validateFirst: Boolean,
    submitOnEnter: truthProp,
    showErrorMessage: truthProp,
    errorMessageAlign: String,
    validateTrigger: {
      type: [String, Array],
      default: "onBlur"
    }
  };
  var stdin_default$1t = vue.defineComponent({
    name: name$1m,
    props: formProps,
    emits: ["submit", "failed"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        children,
        linkChildren
      } = useChildren(FORM_KEY);
      const getFieldsByNames = (names) => {
        if (names) {
          return children.filter((field) => names.includes(field.name));
        }
        return children;
      };
      const validateSeq = (names) => new Promise((resolve, reject) => {
        const errors = [];
        const fields = getFieldsByNames(names);
        fields.reduce((promise2, field) => promise2.then(() => {
          if (!errors.length) {
            return field.validate().then((error2) => {
              if (error2) {
                errors.push(error2);
              }
            });
          }
        }), Promise.resolve()).then(() => {
          if (errors.length) {
            reject(errors);
          } else {
            resolve();
          }
        });
      });
      const validateAll = (names) => new Promise((resolve, reject) => {
        const fields = getFieldsByNames(names);
        Promise.all(fields.map((item) => item.validate())).then((errors) => {
          errors = errors.filter(Boolean);
          if (errors.length) {
            reject(errors);
          } else {
            resolve();
          }
        });
      });
      const validateField = (name2) => {
        const matched = children.find((item) => item.name === name2);
        if (matched) {
          return new Promise((resolve, reject) => {
            matched.validate().then((error2) => {
              if (error2) {
                reject(error2);
              } else {
                resolve();
              }
            });
          });
        }
        return Promise.reject();
      };
      const validate = (name2) => {
        if (typeof name2 === "string") {
          return validateField(name2);
        }
        return props2.validateFirst ? validateSeq(name2) : validateAll(name2);
      };
      const resetValidation = (name2) => {
        if (typeof name2 === "string") {
          name2 = [name2];
        }
        const fields = getFieldsByNames(name2);
        fields.forEach((item) => {
          item.resetValidation();
        });
      };
      const getValidationStatus = () => children.reduce((form, field) => {
        form[field.name] = field.getValidationStatus();
        return form;
      }, {});
      const scrollToField = (name2, options) => {
        children.some((item) => {
          if (item.name === name2) {
            item.$el.scrollIntoView(options);
            return true;
          }
          return false;
        });
      };
      const getValues = () => children.reduce((form, field) => {
        if (field.name !== void 0) {
          form[field.name] = field.formValue.value;
        }
        return form;
      }, {});
      const submit = () => {
        const values = getValues();
        validate().then(() => emit("submit", values)).catch((errors) => {
          emit("failed", {
            values,
            errors
          });
          const {
            scrollToError,
            scrollToErrorPosition
          } = props2;
          if (scrollToError && errors[0].name) {
            scrollToField(errors[0].name, scrollToErrorPosition ? {
              block: scrollToErrorPosition
            } : void 0);
          }
        });
      };
      const onSubmit = (event) => {
        preventDefault(event);
        submit();
      };
      linkChildren({
        props: props2
      });
      useExpose({
        submit,
        validate,
        getValues,
        scrollToField,
        resetValidation,
        getValidationStatus
      });
      return () => {
        var _a;
        return vue.createVNode("form", {
          "class": bem$1i(),
          "onSubmit": onSubmit
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Form = withInstall(stdin_default$1t);
  function isEmptyValue(value) {
    if (Array.isArray(value)) {
      return !value.length;
    }
    if (value === 0) {
      return false;
    }
    return !value;
  }
  function runSyncRule(value, rule) {
    if (isEmptyValue(value)) {
      if (rule.required) {
        return false;
      }
      if (rule.validateEmpty === false) {
        return true;
      }
    }
    if (rule.pattern && !rule.pattern.test(String(value))) {
      return false;
    }
    return true;
  }
  function runRuleValidator(value, rule) {
    return new Promise((resolve) => {
      const returnVal = rule.validator(value, rule);
      if (isPromise$1(returnVal)) {
        returnVal.then(resolve);
        return;
      }
      resolve(returnVal);
    });
  }
  function getRuleMessage(value, rule) {
    const { message } = rule;
    if (isFunction(message)) {
      return message(value, rule);
    }
    return message || "";
  }
  function startComposing({ target }) {
    target.composing = true;
  }
  function endComposing({ target }) {
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  function resizeTextarea(input, autosize) {
    const scrollTop = getRootScrollTop();
    input.style.height = "auto";
    let height2 = input.scrollHeight;
    if (isObject$1(autosize)) {
      const { maxHeight, minHeight } = autosize;
      if (maxHeight !== void 0) {
        height2 = Math.min(height2, maxHeight);
      }
      if (minHeight !== void 0) {
        height2 = Math.max(height2, minHeight);
      }
    }
    if (height2) {
      input.style.height = `${height2}px`;
      setRootScrollTop(scrollTop);
    }
  }
  function mapInputType(type, inputmode) {
    if (type === "number") {
      type = "text";
      inputmode != null ? inputmode : inputmode = "decimal";
    }
    if (type === "digit") {
      type = "tel";
      inputmode != null ? inputmode : inputmode = "numeric";
    }
    return { type, inputmode };
  }
  function getStringLength(str) {
    return [...str].length;
  }
  function cutString(str, maxlength) {
    return [...str].slice(0, maxlength).join("");
  }
  const [name$1l, bem$1h] = createNamespace("field");
  const fieldSharedProps = {
    id: String,
    name: String,
    leftIcon: String,
    rightIcon: String,
    autofocus: Boolean,
    clearable: Boolean,
    maxlength: numericProp,
    max: Number,
    min: Number,
    formatter: Function,
    clearIcon: makeStringProp("clear"),
    modelValue: makeNumericProp(""),
    inputAlign: String,
    placeholder: String,
    autocomplete: String,
    autocapitalize: String,
    autocorrect: String,
    errorMessage: String,
    enterkeyhint: String,
    clearTrigger: makeStringProp("focus"),
    formatTrigger: makeStringProp("onChange"),
    spellcheck: {
      type: Boolean,
      default: null
    },
    error: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    inputmode: String
  };
  const fieldProps = extend({}, cellSharedProps, fieldSharedProps, {
    rows: numericProp,
    type: makeStringProp("text"),
    rules: Array,
    autosize: [Boolean, Object],
    labelWidth: numericProp,
    labelClass: unknownProp,
    labelAlign: String,
    showWordLimit: Boolean,
    errorMessageAlign: String,
    colon: {
      type: Boolean,
      default: null
    }
  });
  var stdin_default$1s = vue.defineComponent({
    name: name$1l,
    props: fieldProps,
    emits: ["blur", "focus", "clear", "keypress", "clickInput", "endValidate", "startValidate", "clickLeftIcon", "clickRightIcon", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const id = useId();
      const state = vue.reactive({
        status: "unvalidated",
        focused: false,
        validateMessage: ""
      });
      const inputRef = vue.ref();
      const clearIconRef = vue.ref();
      const customValue = vue.ref();
      const {
        parent: form
      } = useParent(FORM_KEY);
      const getModelValue = () => {
        var _a;
        return String((_a = props2.modelValue) != null ? _a : "");
      };
      const getProp = (key) => {
        if (isDef(props2[key])) {
          return props2[key];
        }
        if (form && isDef(form.props[key])) {
          return form.props[key];
        }
      };
      const showClear = vue.computed(() => {
        const readonly = getProp("readonly");
        if (props2.clearable && !readonly) {
          const hasValue = getModelValue() !== "";
          const trigger = props2.clearTrigger === "always" || props2.clearTrigger === "focus" && state.focused;
          return hasValue && trigger;
        }
        return false;
      });
      const formValue = vue.computed(() => {
        if (customValue.value && slots.input) {
          return customValue.value();
        }
        return props2.modelValue;
      });
      const showRequiredMark = vue.computed(() => {
        var _a;
        const required = getProp("required");
        if (required === "auto") {
          return (_a = props2.rules) == null ? void 0 : _a.some((rule) => rule.required);
        }
        return required;
      });
      const runRules = (rules) => rules.reduce((promise2, rule) => promise2.then(() => {
        if (state.status === "failed") {
          return;
        }
        let {
          value
        } = formValue;
        if (rule.formatter) {
          value = rule.formatter(value, rule);
        }
        if (!runSyncRule(value, rule)) {
          state.status = "failed";
          state.validateMessage = getRuleMessage(value, rule);
          return;
        }
        if (rule.validator) {
          if (isEmptyValue(value) && rule.validateEmpty === false) {
            return;
          }
          return runRuleValidator(value, rule).then((result) => {
            if (result && typeof result === "string") {
              state.status = "failed";
              state.validateMessage = result;
            } else if (result === false) {
              state.status = "failed";
              state.validateMessage = getRuleMessage(value, rule);
            }
          });
        }
      }), Promise.resolve());
      const resetValidation = () => {
        state.status = "unvalidated";
        state.validateMessage = "";
      };
      const endValidate = () => emit("endValidate", {
        status: state.status,
        message: state.validateMessage
      });
      const validate = (rules = props2.rules) => new Promise((resolve) => {
        resetValidation();
        if (rules) {
          emit("startValidate");
          runRules(rules).then(() => {
            if (state.status === "failed") {
              resolve({
                name: props2.name,
                message: state.validateMessage
              });
              endValidate();
            } else {
              state.status = "passed";
              resolve();
              endValidate();
            }
          });
        } else {
          resolve();
        }
      });
      const validateWithTrigger = (trigger) => {
        if (form && props2.rules) {
          const {
            validateTrigger
          } = form.props;
          const defaultTrigger = toArray(validateTrigger).includes(trigger);
          const rules = props2.rules.filter((rule) => {
            if (rule.trigger) {
              return toArray(rule.trigger).includes(trigger);
            }
            return defaultTrigger;
          });
          if (rules.length) {
            validate(rules);
          }
        }
      };
      const limitValueLength = (value) => {
        var _a;
        const {
          maxlength
        } = props2;
        if (isDef(maxlength) && getStringLength(value) > +maxlength) {
          const modelValue = getModelValue();
          if (modelValue && getStringLength(modelValue) === +maxlength) {
            return modelValue;
          }
          const selectionEnd = (_a = inputRef.value) == null ? void 0 : _a.selectionEnd;
          if (state.focused && selectionEnd) {
            const valueArr = [...value];
            const exceededLength = valueArr.length - +maxlength;
            valueArr.splice(selectionEnd - exceededLength, exceededLength);
            return valueArr.join("");
          }
          return cutString(value, +maxlength);
        }
        return value;
      };
      const updateValue = (value, trigger = "onChange") => {
        var _a, _b;
        const originalValue = value;
        value = limitValueLength(value);
        const limitDiffLen = getStringLength(originalValue) - getStringLength(value);
        if (props2.type === "number" || props2.type === "digit") {
          const isNumber2 = props2.type === "number";
          value = formatNumber(value, isNumber2, isNumber2);
          if (trigger === "onBlur" && value !== "" && (props2.min !== void 0 || props2.max !== void 0)) {
            const adjustedValue = clamp(+value, (_a = props2.min) != null ? _a : -Infinity, (_b = props2.max) != null ? _b : Infinity);
            value = adjustedValue.toString();
          }
        }
        let formatterDiffLen = 0;
        if (props2.formatter && trigger === props2.formatTrigger) {
          const {
            formatter,
            maxlength
          } = props2;
          value = formatter(value);
          if (isDef(maxlength) && getStringLength(value) > +maxlength) {
            value = cutString(value, +maxlength);
          }
          if (inputRef.value && state.focused) {
            const {
              selectionEnd
            } = inputRef.value;
            const bcoVal = cutString(originalValue, selectionEnd);
            formatterDiffLen = getStringLength(formatter(bcoVal)) - getStringLength(bcoVal);
          }
        }
        if (inputRef.value && inputRef.value.value !== value) {
          if (state.focused) {
            let {
              selectionStart,
              selectionEnd
            } = inputRef.value;
            inputRef.value.value = value;
            if (isDef(selectionStart) && isDef(selectionEnd)) {
              const valueLen = getStringLength(value);
              if (limitDiffLen) {
                selectionStart -= limitDiffLen;
                selectionEnd -= limitDiffLen;
              } else if (formatterDiffLen) {
                selectionStart += formatterDiffLen;
                selectionEnd += formatterDiffLen;
              }
              inputRef.value.setSelectionRange(Math.min(selectionStart, valueLen), Math.min(selectionEnd, valueLen));
            }
          } else {
            inputRef.value.value = value;
          }
        }
        if (value !== props2.modelValue) {
          emit("update:modelValue", value);
        }
      };
      const onInput = (event) => {
        if (!event.target.composing) {
          updateValue(event.target.value);
        }
      };
      const blur = () => {
        var _a;
        return (_a = inputRef.value) == null ? void 0 : _a.blur();
      };
      const focus = () => {
        var _a;
        return (_a = inputRef.value) == null ? void 0 : _a.focus();
      };
      const adjustTextareaSize = () => {
        const input = inputRef.value;
        if (props2.type === "textarea" && props2.autosize && input) {
          resizeTextarea(input, props2.autosize);
        }
      };
      const onFocus = (event) => {
        state.focused = true;
        emit("focus", event);
        vue.nextTick(adjustTextareaSize);
        if (getProp("readonly")) {
          blur();
        }
      };
      const onBlur = (event) => {
        state.focused = false;
        updateValue(getModelValue(), "onBlur");
        emit("blur", event);
        if (getProp("readonly")) {
          return;
        }
        validateWithTrigger("onBlur");
        vue.nextTick(adjustTextareaSize);
        resetScroll();
      };
      const onClickInput = (event) => emit("clickInput", event);
      const onClickLeftIcon = (event) => emit("clickLeftIcon", event);
      const onClickRightIcon = (event) => emit("clickRightIcon", event);
      const onClear = (event) => {
        preventDefault(event);
        emit("update:modelValue", "");
        emit("clear", event);
      };
      const showError = vue.computed(() => {
        if (typeof props2.error === "boolean") {
          return props2.error;
        }
        if (form && form.props.showError && state.status === "failed") {
          return true;
        }
      });
      const labelStyle = vue.computed(() => {
        const labelWidth = getProp("labelWidth");
        const labelAlign = getProp("labelAlign");
        if (labelWidth && labelAlign !== "top") {
          return {
            width: addUnit$2(labelWidth)
          };
        }
      });
      const onKeypress = (event) => {
        const ENTER_CODE = 13;
        if (event.keyCode === ENTER_CODE) {
          const submitOnEnter = form && form.props.submitOnEnter;
          if (!submitOnEnter && props2.type !== "textarea") {
            preventDefault(event);
          }
          if (props2.type === "search") {
            blur();
          }
        }
        emit("keypress", event);
      };
      const getInputId = () => props2.id || `${id}-input`;
      const getValidationStatus = () => state.status;
      const renderInput = () => {
        const controlClass = bem$1h("control", [getProp("inputAlign"), {
          error: showError.value,
          custom: !!slots.input,
          "min-height": props2.type === "textarea" && !props2.autosize
        }]);
        if (slots.input) {
          return vue.createVNode("div", {
            "class": controlClass,
            "onClick": onClickInput
          }, [slots.input()]);
        }
        const inputAttrs = {
          id: getInputId(),
          ref: inputRef,
          name: props2.name,
          rows: props2.rows !== void 0 ? +props2.rows : void 0,
          class: controlClass,
          disabled: getProp("disabled"),
          readonly: getProp("readonly"),
          autofocus: props2.autofocus,
          placeholder: props2.placeholder,
          autocomplete: props2.autocomplete,
          autocapitalize: props2.autocapitalize,
          autocorrect: props2.autocorrect,
          enterkeyhint: props2.enterkeyhint,
          spellcheck: props2.spellcheck,
          "aria-labelledby": props2.label ? `${id}-label` : void 0,
          "data-allow-mismatch": "attribute",
          onBlur,
          onFocus,
          onInput,
          onClick: onClickInput,
          onChange: endComposing,
          onKeypress,
          onCompositionend: endComposing,
          onCompositionstart: startComposing
        };
        if (props2.type === "textarea") {
          return vue.createVNode("textarea", vue.mergeProps(inputAttrs, {
            "inputmode": props2.inputmode
          }), null);
        }
        return vue.createVNode("input", vue.mergeProps(mapInputType(props2.type, props2.inputmode), inputAttrs), null);
      };
      const renderLeftIcon = () => {
        const leftIconSlot = slots["left-icon"];
        if (props2.leftIcon || leftIconSlot) {
          return vue.createVNode("div", {
            "class": bem$1h("left-icon"),
            "onClick": onClickLeftIcon
          }, [leftIconSlot ? leftIconSlot() : vue.createVNode(Icon, {
            "name": props2.leftIcon,
            "classPrefix": props2.iconPrefix
          }, null)]);
        }
      };
      const renderRightIcon = () => {
        const rightIconSlot = slots["right-icon"];
        if (props2.rightIcon || rightIconSlot) {
          return vue.createVNode("div", {
            "class": bem$1h("right-icon"),
            "onClick": onClickRightIcon
          }, [rightIconSlot ? rightIconSlot() : vue.createVNode(Icon, {
            "name": props2.rightIcon,
            "classPrefix": props2.iconPrefix
          }, null)]);
        }
      };
      const renderWordLimit = () => {
        if (props2.showWordLimit && props2.maxlength) {
          const count = getStringLength(getModelValue());
          return vue.createVNode("div", {
            "class": bem$1h("word-limit")
          }, [vue.createVNode("span", {
            "class": bem$1h("word-num")
          }, [count]), vue.createTextVNode("/"), props2.maxlength]);
        }
      };
      const renderMessage = () => {
        if (form && form.props.showErrorMessage === false) {
          return;
        }
        const message = props2.errorMessage || state.validateMessage;
        if (message) {
          const slot = slots["error-message"];
          const errorMessageAlign = getProp("errorMessageAlign");
          return vue.createVNode("div", {
            "class": bem$1h("error-message", errorMessageAlign)
          }, [slot ? slot({
            message
          }) : message]);
        }
      };
      const renderLabel = () => {
        const labelWidth = getProp("labelWidth");
        const labelAlign = getProp("labelAlign");
        const colon = getProp("colon") ? ":" : "";
        if (slots.label) {
          return [slots.label(), colon];
        }
        if (props2.label) {
          return vue.createVNode("label", {
            "id": `${id}-label`,
            "for": slots.input ? void 0 : getInputId(),
            "data-allow-mismatch": "attribute",
            "onClick": (event) => {
              preventDefault(event);
              focus();
            },
            "style": labelAlign === "top" && labelWidth ? {
              width: addUnit$2(labelWidth)
            } : void 0
          }, [props2.label + colon]);
        }
      };
      const renderFieldBody = () => [vue.createVNode("div", {
        "class": bem$1h("body")
      }, [renderInput(), showClear.value && vue.createVNode(Icon, {
        "ref": clearIconRef,
        "name": props2.clearIcon,
        "class": bem$1h("clear")
      }, null), renderRightIcon(), slots.button && vue.createVNode("div", {
        "class": bem$1h("button")
      }, [slots.button()])]), renderWordLimit(), renderMessage()];
      useExpose({
        blur,
        focus,
        validate,
        formValue,
        resetValidation,
        getValidationStatus
      });
      vue.provide(CUSTOM_FIELD_INJECTION_KEY, {
        customValue,
        resetValidation,
        validateWithTrigger
      });
      vue.watch(() => props2.modelValue, () => {
        updateValue(getModelValue());
        resetValidation();
        validateWithTrigger("onChange");
        vue.nextTick(adjustTextareaSize);
      });
      vue.onMounted(() => {
        updateValue(getModelValue(), props2.formatTrigger);
        vue.nextTick(adjustTextareaSize);
      });
      useEventListener("touchstart", onClear, {
        target: vue.computed(() => {
          var _a;
          return (_a = clearIconRef.value) == null ? void 0 : _a.$el;
        })
      });
      return () => {
        const disabled = getProp("disabled");
        const labelAlign = getProp("labelAlign");
        const LeftIcon = renderLeftIcon();
        const renderTitle = () => {
          const Label = renderLabel();
          if (labelAlign === "top") {
            return [LeftIcon, Label].filter(Boolean);
          }
          return Label || [];
        };
        return vue.createVNode(Cell, {
          "size": props2.size,
          "class": bem$1h({
            error: showError.value,
            disabled,
            [`label-${labelAlign}`]: labelAlign
          }),
          "center": props2.center,
          "border": props2.border,
          "isLink": props2.isLink,
          "clickable": props2.clickable,
          "titleStyle": labelStyle.value,
          "valueClass": bem$1h("value"),
          "titleClass": [bem$1h("label", [labelAlign, {
            required: showRequiredMark.value
          }]), props2.labelClass],
          "arrowDirection": props2.arrowDirection
        }, {
          icon: LeftIcon && labelAlign !== "top" ? () => LeftIcon : null,
          title: renderTitle,
          value: renderFieldBody,
          extra: slots.extra
        });
      };
    }
  });
  const Field = withInstall(stdin_default$1s);
  let lockCount = 0;
  function lockClick(lock) {
    if (lock) {
      if (!lockCount) {
        document.body.classList.add("van-toast--unclickable");
      }
      lockCount++;
    } else if (lockCount) {
      lockCount--;
      if (!lockCount) {
        document.body.classList.remove("van-toast--unclickable");
      }
    }
  }
  const [name$1k, bem$1g] = createNamespace("toast");
  const popupInheritProps$1 = ["show", "overlay", "teleport", "transition", "overlayClass", "overlayStyle", "closeOnClickOverlay", "zIndex"];
  const toastProps = {
    icon: String,
    show: Boolean,
    type: makeStringProp("text"),
    overlay: Boolean,
    message: numericProp,
    iconSize: numericProp,
    duration: makeNumberProp(2e3),
    position: makeStringProp("middle"),
    teleport: [String, Object],
    wordBreak: String,
    className: unknownProp,
    iconPrefix: String,
    transition: makeStringProp("van-fade"),
    loadingType: String,
    forbidClick: Boolean,
    overlayClass: unknownProp,
    overlayStyle: Object,
    closeOnClick: Boolean,
    closeOnClickOverlay: Boolean,
    zIndex: numericProp
  };
  var stdin_default$1r = vue.defineComponent({
    name: name$1k,
    props: toastProps,
    emits: ["update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      let timer;
      let clickable = false;
      const toggleClickable = () => {
        const newValue = props2.show && props2.forbidClick;
        if (clickable !== newValue) {
          clickable = newValue;
          lockClick(clickable);
        }
      };
      const updateShow = (show) => emit("update:show", show);
      const onClick = () => {
        if (props2.closeOnClick) {
          updateShow(false);
        }
      };
      const clearTimer = () => clearTimeout(timer);
      const renderIcon = () => {
        const {
          icon,
          type,
          iconSize,
          iconPrefix,
          loadingType
        } = props2;
        const hasIcon = icon || type === "success" || type === "fail";
        if (hasIcon) {
          return vue.createVNode(Icon, {
            "name": icon || type,
            "size": iconSize,
            "class": bem$1g("icon"),
            "classPrefix": iconPrefix
          }, null);
        }
        if (type === "loading") {
          return vue.createVNode(Loading, {
            "class": bem$1g("loading"),
            "size": iconSize,
            "type": loadingType
          }, null);
        }
      };
      const renderMessage = () => {
        const {
          type,
          message
        } = props2;
        if (slots.message) {
          return vue.createVNode("div", {
            "class": bem$1g("text")
          }, [slots.message()]);
        }
        if (isDef(message) && message !== "") {
          return type === "html" ? vue.createVNode("div", {
            "key": 0,
            "class": bem$1g("text"),
            "innerHTML": String(message)
          }, null) : vue.createVNode("div", {
            "class": bem$1g("text")
          }, [message]);
        }
      };
      vue.watch(() => [props2.show, props2.forbidClick], toggleClickable);
      vue.watch(() => [props2.show, props2.type, props2.message, props2.duration], () => {
        clearTimer();
        if (props2.show && props2.duration > 0) {
          timer = setTimeout(() => {
            updateShow(false);
          }, props2.duration);
        }
      });
      vue.onMounted(toggleClickable);
      vue.onUnmounted(toggleClickable);
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": [bem$1g([props2.position, props2.wordBreak === "normal" ? "break-normal" : props2.wordBreak, {
          [props2.type]: !props2.icon
        }]), props2.className],
        "lockScroll": false,
        "onClick": onClick,
        "onClosed": clearTimer,
        "onUpdate:show": updateShow
      }, pick(props2, popupInheritProps$1)), {
        default: () => [renderIcon(), renderMessage()]
      });
    }
  });
  function usePopupState() {
    const state = vue.reactive({
      show: false
    });
    const toggle = (show) => {
      state.show = show;
    };
    const open2 = (props2) => {
      extend(state, props2, { transitionAppear: true });
      toggle(true);
    };
    const close = () => toggle(false);
    useExpose({ open: open2, close, toggle });
    return {
      open: open2,
      close,
      state,
      toggle
    };
  }
  function mountComponent(RootComponent) {
    const app = vue.createApp(RootComponent);
    const root = document.createElement("div");
    document.body.appendChild(root);
    return {
      instance: app.mount(root),
      unmount() {
        app.unmount();
        document.body.removeChild(root);
      }
    };
  }
  const defaultOptions = {
    icon: "",
    type: "text",
    message: "",
    className: "",
    overlay: false,
    onClose: void 0,
    onOpened: void 0,
    duration: 2e3,
    teleport: "body",
    iconSize: void 0,
    iconPrefix: void 0,
    position: "middle",
    transition: "van-fade",
    forbidClick: false,
    loadingType: void 0,
    overlayClass: "",
    overlayStyle: void 0,
    closeOnClick: false,
    closeOnClickOverlay: false
  };
  let queue = [];
  let allowMultiple = false;
  let currentOptions = extend({}, defaultOptions);
  const defaultOptionsMap = /* @__PURE__ */ new Map();
  function parseOptions(message) {
    if (isObject$1(message)) {
      return message;
    }
    return {
      message
    };
  }
  function createInstance() {
    const {
      instance: instance2,
      unmount
    } = mountComponent({
      setup() {
        const message = vue.ref("");
        const {
          open: open2,
          state,
          close,
          toggle
        } = usePopupState();
        const onClosed = () => {
        };
        const render = () => {
          const attrs = {
            onClosed,
            "onUpdate:show": toggle
          };
          return vue.createVNode(stdin_default$1r, vue.mergeProps(state, attrs), null);
        };
        vue.watch(message, (val) => {
          state.message = val;
        });
        vue.getCurrentInstance().render = render;
        return {
          open: open2,
          close,
          message
        };
      }
    });
    return instance2;
  }
  function getInstance() {
    if (!queue.length || allowMultiple) {
      const instance2 = createInstance();
      queue.push(instance2);
    }
    return queue[queue.length - 1];
  }
  function showToast(options = {}) {
    if (!inBrowser$1) {
      return {};
    }
    const toast2 = getInstance();
    const parsedOptions = parseOptions(options);
    toast2.open(extend({}, currentOptions, defaultOptionsMap.get(parsedOptions.type || currentOptions.type), parsedOptions));
    return toast2;
  }
  const Toast = withInstall(stdin_default$1r);
  const [name$1j, bem$1f] = createNamespace("switch");
  const switchProps = {
    size: numericProp,
    loading: Boolean,
    disabled: Boolean,
    modelValue: unknownProp,
    activeColor: String,
    inactiveColor: String,
    activeValue: {
      type: unknownProp,
      default: true
    },
    inactiveValue: {
      type: unknownProp,
      default: false
    }
  };
  var stdin_default$1q = vue.defineComponent({
    name: name$1j,
    props: switchProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const isChecked = () => props2.modelValue === props2.activeValue;
      const onClick = () => {
        if (!props2.disabled && !props2.loading) {
          const newValue = isChecked() ? props2.inactiveValue : props2.activeValue;
          emit("update:modelValue", newValue);
          emit("change", newValue);
        }
      };
      const renderLoading = () => {
        if (props2.loading) {
          const color = isChecked() ? props2.activeColor : props2.inactiveColor;
          return vue.createVNode(Loading, {
            "class": bem$1f("loading"),
            "color": color
          }, null);
        }
        if (slots.node) {
          return slots.node();
        }
      };
      useCustomFieldValue(() => props2.modelValue);
      return () => {
        var _a;
        const {
          size,
          loading,
          disabled,
          activeColor,
          inactiveColor
        } = props2;
        const checked = isChecked();
        const style = {
          fontSize: addUnit$2(size),
          backgroundColor: checked ? activeColor : inactiveColor
        };
        return vue.createVNode("div", {
          "role": "switch",
          "class": bem$1f({
            on: checked,
            loading,
            disabled
          }),
          "style": style,
          "tabindex": disabled ? void 0 : 0,
          "aria-checked": checked,
          "onClick": onClick
        }, [vue.createVNode("div", {
          "class": bem$1f("node")
        }, [renderLoading()]), (_a = slots.background) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Switch = withInstall(stdin_default$1q);
  const [name$1i, bem$1e] = createNamespace("address-edit-detail");
  const t$l = createNamespace("address-edit")[2];
  var stdin_default$1p = vue.defineComponent({
    name: name$1i,
    props: {
      show: Boolean,
      rows: numericProp,
      value: String,
      rules: Array,
      focused: Boolean,
      maxlength: numericProp,
      searchResult: Array,
      showSearchResult: Boolean
    },
    emits: ["blur", "focus", "input", "selectSearch"],
    setup(props2, {
      emit
    }) {
      const field = vue.ref();
      const showSearchResult = () => props2.focused && props2.searchResult && props2.showSearchResult;
      const onSelect = (express) => {
        emit("selectSearch", express);
        emit("input", `${express.address || ""} ${express.name || ""}`.trim());
      };
      const renderSearchResult = () => {
        if (!showSearchResult()) {
          return;
        }
        const {
          searchResult
        } = props2;
        return searchResult.map((express) => vue.createVNode(Cell, {
          "clickable": true,
          "key": (express.name || "") + (express.address || ""),
          "icon": "location-o",
          "title": express.name,
          "label": express.address,
          "class": bem$1e("search-item"),
          "border": false,
          "onClick": () => onSelect(express)
        }, null));
      };
      const onBlur = (event) => emit("blur", event);
      const onFocus = (event) => emit("focus", event);
      const onInput = (value) => emit("input", value);
      return () => {
        if (props2.show) {
          return vue.createVNode(vue.Fragment, null, [vue.createVNode(Field, {
            "autosize": true,
            "clearable": true,
            "ref": field,
            "class": bem$1e(),
            "rows": props2.rows,
            "type": "textarea",
            "rules": props2.rules,
            "label": t$l("addressDetail"),
            "border": !showSearchResult(),
            "maxlength": props2.maxlength,
            "modelValue": props2.value,
            "placeholder": t$l("addressDetail"),
            "onBlur": onBlur,
            "onFocus": onFocus,
            "onUpdate:modelValue": onInput
          }, null), renderSearchResult()]);
        }
      };
    }
  });
  const [name$1h, bem$1d, t$k] = createNamespace("address-edit");
  const DEFAULT_DATA = {
    name: "",
    tel: "",
    city: "",
    county: "",
    country: "",
    province: "",
    areaCode: "",
    isDefault: false,
    addressDetail: ""
  };
  const addressEditProps = {
    areaList: Object,
    isSaving: Boolean,
    isDeleting: Boolean,
    validator: Function,
    showArea: truthProp,
    showDetail: truthProp,
    showDelete: Boolean,
    disableArea: Boolean,
    searchResult: Array,
    telMaxlength: numericProp,
    showSetDefault: Boolean,
    saveButtonText: String,
    areaPlaceholder: String,
    deleteButtonText: String,
    showSearchResult: Boolean,
    detailRows: makeNumericProp(1),
    detailMaxlength: makeNumericProp(200),
    areaColumnsPlaceholder: makeArrayProp(),
    addressInfo: {
      type: Object,
      default: () => extend({}, DEFAULT_DATA)
    },
    telValidator: {
      type: Function,
      default: isMobile
    }
  };
  var stdin_default$1o = vue.defineComponent({
    name: name$1h,
    props: addressEditProps,
    emits: ["save", "focus", "change", "delete", "clickArea", "changeArea", "changeDetail", "selectSearch", "changeDefault"],
    setup(props2, {
      emit,
      slots
    }) {
      const areaRef = vue.ref();
      const data = vue.reactive({});
      const showAreaPopup = vue.ref(false);
      const detailFocused = vue.ref(false);
      const areaListLoaded = vue.computed(() => isObject$1(props2.areaList) && Object.keys(props2.areaList).length);
      const areaText = vue.computed(() => {
        const {
          province,
          city,
          county,
          areaCode
        } = data;
        if (areaCode) {
          const arr = [province, city, county];
          if (province && province === city) {
            arr.splice(1, 1);
          }
          return arr.filter(Boolean).join("/");
        }
        return "";
      });
      const hideBottomFields = vue.computed(() => {
        var _a;
        return ((_a = props2.searchResult) == null ? void 0 : _a.length) && detailFocused.value;
      });
      const onFocus = (key) => {
        detailFocused.value = key === "addressDetail";
        emit("focus", key);
      };
      const onChange = (key, value) => {
        emit("change", {
          key,
          value
        });
      };
      const rules = vue.computed(() => {
        const {
          validator,
          telValidator
        } = props2;
        const makeRule = (name2, emptyMessage) => ({
          validator: (value) => {
            if (validator) {
              const message = validator(name2, value);
              if (message) {
                return message;
              }
            }
            if (!value) {
              return emptyMessage;
            }
            return true;
          }
        });
        return {
          name: [makeRule("name", t$k("nameEmpty"))],
          tel: [makeRule("tel", t$k("telInvalid")), {
            validator: telValidator,
            message: t$k("telInvalid")
          }],
          areaCode: [makeRule("areaCode", t$k("areaEmpty"))],
          addressDetail: [makeRule("addressDetail", t$k("addressEmpty"))]
        };
      });
      const onSave = () => emit("save", data);
      const onChangeDetail = (val) => {
        data.addressDetail = val;
        emit("changeDetail", val);
      };
      const assignAreaText = (options) => {
        data.province = options[0].text;
        data.city = options[1].text;
        data.county = options[2].text;
      };
      const onAreaConfirm = ({
        selectedValues,
        selectedOptions
      }) => {
        if (selectedValues.some((value) => value === AREA_EMPTY_CODE)) {
          showToast(t$k("areaEmpty"));
        } else {
          showAreaPopup.value = false;
          assignAreaText(selectedOptions);
          emit("changeArea", selectedOptions);
        }
      };
      const onDelete = () => emit("delete", data);
      const setAreaCode = (code2) => {
        data.areaCode = code2 || "";
      };
      const onDetailBlur = () => {
        setTimeout(() => {
          detailFocused.value = false;
        });
      };
      const setAddressDetail = (value) => {
        data.addressDetail = value;
      };
      const renderSetDefaultCell = () => {
        if (props2.showSetDefault) {
          const slots2 = {
            "right-icon": () => vue.createVNode(Switch, {
              "modelValue": data.isDefault,
              "onUpdate:modelValue": ($event) => data.isDefault = $event,
              "onChange": (event) => emit("changeDefault", event)
            }, null)
          };
          return vue.withDirectives(vue.createVNode(Cell, {
            "center": true,
            "border": false,
            "title": t$k("defaultAddress"),
            "class": bem$1d("default")
          }, slots2), [[vue.vShow, !hideBottomFields.value]]);
        }
      };
      useExpose({
        setAreaCode,
        setAddressDetail
      });
      vue.watch(() => props2.addressInfo, (value) => {
        extend(data, DEFAULT_DATA, value);
        vue.nextTick(() => {
          var _a;
          const options = (_a = areaRef.value) == null ? void 0 : _a.getSelectedOptions();
          if (options && options.every((option) => option && option.value !== AREA_EMPTY_CODE)) {
            assignAreaText(options);
          }
        });
      }, {
        deep: true,
        immediate: true
      });
      return () => {
        const {
          disableArea
        } = props2;
        return vue.createVNode(Form, {
          "class": bem$1d(),
          "onSubmit": onSave
        }, {
          default: () => {
            var _a;
            return [vue.createVNode("div", {
              "class": bem$1d("fields")
            }, [vue.createVNode(Field, {
              "modelValue": data.name,
              "onUpdate:modelValue": [($event) => data.name = $event, (val) => onChange("name", val)],
              "clearable": true,
              "label": t$k("name"),
              "rules": rules.value.name,
              "placeholder": t$k("name"),
              "onFocus": () => onFocus("name")
            }, null), vue.createVNode(Field, {
              "modelValue": data.tel,
              "onUpdate:modelValue": [($event) => data.tel = $event, (val) => onChange("tel", val)],
              "clearable": true,
              "type": "tel",
              "label": t$k("tel"),
              "rules": rules.value.tel,
              "maxlength": props2.telMaxlength,
              "placeholder": t$k("tel"),
              "onFocus": () => onFocus("tel")
            }, null), vue.withDirectives(vue.createVNode(Field, {
              "readonly": true,
              "label": t$k("area"),
              "is-link": !disableArea,
              "modelValue": areaText.value,
              "rules": props2.showArea ? rules.value.areaCode : void 0,
              "placeholder": props2.areaPlaceholder || t$k("area"),
              "onFocus": () => onFocus("areaCode"),
              "onClick": () => {
                emit("clickArea");
                showAreaPopup.value = !disableArea;
              }
            }, null), [[vue.vShow, props2.showArea]]), vue.createVNode(stdin_default$1p, {
              "show": props2.showDetail,
              "rows": props2.detailRows,
              "rules": rules.value.addressDetail,
              "value": data.addressDetail,
              "focused": detailFocused.value,
              "maxlength": props2.detailMaxlength,
              "searchResult": props2.searchResult,
              "showSearchResult": props2.showSearchResult,
              "onBlur": onDetailBlur,
              "onFocus": () => onFocus("addressDetail"),
              "onInput": onChangeDetail,
              "onSelectSearch": (event) => emit("selectSearch", event)
            }, null), (_a = slots.default) == null ? void 0 : _a.call(slots)]), renderSetDefaultCell(), vue.withDirectives(vue.createVNode("div", {
              "class": bem$1d("buttons")
            }, [vue.createVNode(Button, {
              "block": true,
              "round": true,
              "type": "primary",
              "text": props2.saveButtonText || t$k("save"),
              "class": bem$1d("button"),
              "loading": props2.isSaving,
              "nativeType": "submit"
            }, null), props2.showDelete && vue.createVNode(Button, {
              "block": true,
              "round": true,
              "class": bem$1d("button"),
              "loading": props2.isDeleting,
              "text": props2.deleteButtonText || t$k("delete"),
              "onClick": onDelete
            }, null)]), [[vue.vShow, !hideBottomFields.value]]), vue.createVNode(Popup, {
              "show": showAreaPopup.value,
              "onUpdate:show": ($event) => showAreaPopup.value = $event,
              "round": true,
              "teleport": "body",
              "position": "bottom",
              "lazyRender": false
            }, {
              default: () => [vue.createVNode(Area, {
                "modelValue": data.areaCode,
                "onUpdate:modelValue": ($event) => data.areaCode = $event,
                "ref": areaRef,
                "loading": !areaListLoaded.value,
                "areaList": props2.areaList,
                "columnsPlaceholder": props2.areaColumnsPlaceholder,
                "onConfirm": onAreaConfirm,
                "onCancel": () => {
                  showAreaPopup.value = false;
                }
              }, null)]
            })];
          }
        });
      };
    }
  });
  const AddressEdit = withInstall(stdin_default$1o);
  const [name$1g, bem$1c] = createNamespace("radio-group");
  const radioGroupProps = {
    shape: String,
    disabled: Boolean,
    iconSize: numericProp,
    direction: String,
    modelValue: unknownProp,
    checkedColor: String
  };
  const RADIO_KEY = Symbol(name$1g);
  var stdin_default$1n = vue.defineComponent({
    name: name$1g,
    props: radioGroupProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        linkChildren
      } = useChildren(RADIO_KEY);
      const updateValue = (value) => emit("update:modelValue", value);
      vue.watch(() => props2.modelValue, (value) => emit("change", value));
      linkChildren({
        props: props2,
        updateValue
      });
      useCustomFieldValue(() => props2.modelValue);
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$1c([props2.direction]),
          "role": "radiogroup"
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const RadioGroup = withInstall(stdin_default$1n);
  const [name$1f, bem$1b] = createNamespace("checkbox-group");
  const checkboxGroupProps = {
    max: numericProp,
    shape: makeStringProp("round"),
    disabled: Boolean,
    iconSize: numericProp,
    direction: String,
    modelValue: makeArrayProp(),
    checkedColor: String
  };
  const CHECKBOX_GROUP_KEY = Symbol(name$1f);
  var stdin_default$1m = vue.defineComponent({
    name: name$1f,
    props: checkboxGroupProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        children,
        linkChildren
      } = useChildren(CHECKBOX_GROUP_KEY);
      const updateValue = (value) => emit("update:modelValue", value);
      const toggleAll = (options = {}) => {
        if (typeof options === "boolean") {
          options = {
            checked: options
          };
        }
        const {
          checked,
          skipDisabled
        } = options;
        const checkedChildren = children.filter((item) => {
          if (!item.props.bindGroup) {
            return false;
          }
          if (item.props.disabled && skipDisabled) {
            return item.checked.value;
          }
          return checked != null ? checked : !item.checked.value;
        });
        const names = checkedChildren.map((item) => item.name);
        updateValue(names);
      };
      vue.watch(() => props2.modelValue, (value) => emit("change", value));
      useExpose({
        toggleAll
      });
      useCustomFieldValue(() => props2.modelValue);
      linkChildren({
        props: props2,
        updateValue
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$1b([props2.direction])
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const CheckboxGroup = withInstall(stdin_default$1m);
  const [name$1e, bem$1a] = createNamespace("tag");
  const tagProps = {
    size: String,
    mark: Boolean,
    show: truthProp,
    type: makeStringProp("default"),
    color: String,
    plain: Boolean,
    round: Boolean,
    textColor: String,
    closeable: Boolean
  };
  var stdin_default$1l = vue.defineComponent({
    name: name$1e,
    props: tagProps,
    emits: ["close"],
    setup(props2, {
      slots,
      emit
    }) {
      const onClose = (event) => {
        event.stopPropagation();
        emit("close", event);
      };
      const getStyle = () => {
        if (props2.plain) {
          return {
            color: props2.textColor || props2.color,
            borderColor: props2.color
          };
        }
        return {
          color: props2.textColor,
          background: props2.color
        };
      };
      const renderTag = () => {
        var _a;
        const {
          type,
          mark: mark2,
          plain,
          round: round2,
          size,
          closeable
        } = props2;
        const classes = {
          mark: mark2,
          plain,
          round: round2
        };
        if (size) {
          classes[size] = size;
        }
        const CloseIcon = closeable && vue.createVNode(Icon, {
          "name": "cross",
          "class": [bem$1a("close"), HAPTICS_FEEDBACK],
          "onClick": onClose
        }, null);
        return vue.createVNode("span", {
          "style": getStyle(),
          "class": bem$1a([classes, type])
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots), CloseIcon]);
      };
      return () => vue.createVNode(vue.Transition, {
        "name": props2.closeable ? "van-fade" : void 0
      }, {
        default: () => [props2.show ? renderTag() : null]
      });
    }
  });
  const Tag = withInstall(stdin_default$1l);
  const checkerProps = {
    name: unknownProp,
    disabled: Boolean,
    iconSize: numericProp,
    modelValue: unknownProp,
    checkedColor: String,
    labelPosition: String,
    labelDisabled: Boolean
  };
  var stdin_default$1k = vue.defineComponent({
    props: extend({}, checkerProps, {
      bem: makeRequiredProp(Function),
      role: String,
      shape: String,
      parent: Object,
      checked: Boolean,
      bindGroup: truthProp,
      indeterminate: {
        type: Boolean,
        default: null
      }
    }),
    emits: ["click", "toggle"],
    setup(props2, {
      emit,
      slots
    }) {
      const iconRef = vue.ref();
      const getParentProp = (name2) => {
        if (props2.parent && props2.bindGroup) {
          return props2.parent.props[name2];
        }
      };
      const disabled = vue.computed(() => {
        if (props2.parent && props2.bindGroup) {
          const disabled2 = getParentProp("disabled") || props2.disabled;
          if (props2.role === "checkbox") {
            const checkedCount = getParentProp("modelValue").length;
            const max = getParentProp("max");
            const overlimit = max && checkedCount >= +max;
            return disabled2 || overlimit && !props2.checked;
          }
          return disabled2;
        }
        return props2.disabled;
      });
      const direction = vue.computed(() => getParentProp("direction"));
      const iconStyle = vue.computed(() => {
        const checkedColor = props2.checkedColor || getParentProp("checkedColor");
        if (checkedColor && props2.checked && !disabled.value) {
          return {
            borderColor: checkedColor,
            backgroundColor: checkedColor
          };
        }
      });
      const shape = vue.computed(() => {
        return props2.shape || getParentProp("shape") || "round";
      });
      const onClick = (event) => {
        const {
          target
        } = event;
        const icon = iconRef.value;
        const iconClicked = icon === target || (icon == null ? void 0 : icon.contains(target));
        if (!disabled.value && (iconClicked || !props2.labelDisabled)) {
          emit("toggle");
        }
        emit("click", event);
      };
      const renderIcon = () => {
        var _a, _b;
        const {
          bem: bem2,
          checked,
          indeterminate
        } = props2;
        const iconSize = props2.iconSize || getParentProp("iconSize");
        return vue.createVNode("div", {
          "ref": iconRef,
          "class": bem2("icon", [shape.value, {
            disabled: disabled.value,
            checked,
            indeterminate
          }]),
          "style": shape.value !== "dot" ? {
            fontSize: addUnit$2(iconSize)
          } : {
            width: addUnit$2(iconSize),
            height: addUnit$2(iconSize),
            borderColor: (_a = iconStyle.value) == null ? void 0 : _a.borderColor
          }
        }, [slots.icon ? slots.icon({
          checked,
          disabled: disabled.value
        }) : shape.value !== "dot" ? vue.createVNode(Icon, {
          "name": indeterminate ? "minus" : "success",
          "style": iconStyle.value
        }, null) : vue.createVNode("div", {
          "class": bem2("icon--dot__icon"),
          "style": {
            backgroundColor: (_b = iconStyle.value) == null ? void 0 : _b.backgroundColor
          }
        }, null)]);
      };
      const renderLabel = () => {
        const {
          checked
        } = props2;
        if (slots.default) {
          return vue.createVNode("span", {
            "class": props2.bem("label", [props2.labelPosition, {
              disabled: disabled.value
            }])
          }, [slots.default({
            checked,
            disabled: disabled.value
          })]);
        }
      };
      return () => {
        const nodes = props2.labelPosition === "left" ? [renderLabel(), renderIcon()] : [renderIcon(), renderLabel()];
        return vue.createVNode("div", {
          "role": props2.role,
          "class": props2.bem([{
            disabled: disabled.value,
            "label-disabled": props2.labelDisabled
          }, direction.value]),
          "tabindex": disabled.value ? void 0 : 0,
          "aria-checked": props2.checked,
          "onClick": onClick
        }, [nodes]);
      };
    }
  });
  const radioProps = extend({}, checkerProps, {
    shape: String
  });
  const [name$1d, bem$19] = createNamespace("radio");
  var stdin_default$1j = vue.defineComponent({
    name: name$1d,
    props: radioProps,
    emits: ["update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        parent
      } = useParent(RADIO_KEY);
      const checked = () => {
        const value = parent ? parent.props.modelValue : props2.modelValue;
        return value === props2.name;
      };
      const toggle = () => {
        if (parent) {
          parent.updateValue(props2.name);
        } else {
          emit("update:modelValue", props2.name);
        }
      };
      return () => vue.createVNode(stdin_default$1k, vue.mergeProps({
        "bem": bem$19,
        "role": "radio",
        "parent": parent,
        "checked": checked(),
        "onToggle": toggle
      }, props2), pick(slots, ["default", "icon"]));
    }
  });
  const Radio = withInstall(stdin_default$1j);
  const [name$1c, bem$18] = createNamespace("checkbox");
  const checkboxProps = extend({}, checkerProps, {
    shape: String,
    bindGroup: truthProp,
    indeterminate: {
      type: Boolean,
      default: null
    }
  });
  var stdin_default$1i = vue.defineComponent({
    name: name$1c,
    props: checkboxProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        parent
      } = useParent(CHECKBOX_GROUP_KEY);
      const setParentValue = (checked2) => {
        const {
          name: name2
        } = props2;
        const {
          max,
          modelValue
        } = parent.props;
        const value = modelValue.slice();
        if (checked2) {
          const overlimit = max && value.length >= +max;
          if (!overlimit && !value.includes(name2)) {
            value.push(name2);
            if (props2.bindGroup) {
              parent.updateValue(value);
            }
          }
        } else {
          const index2 = value.indexOf(name2);
          if (index2 !== -1) {
            value.splice(index2, 1);
            if (props2.bindGroup) {
              parent.updateValue(value);
            }
          }
        }
      };
      const checked = vue.computed(() => {
        if (parent && props2.bindGroup) {
          return parent.props.modelValue.indexOf(props2.name) !== -1;
        }
        return !!props2.modelValue;
      });
      const toggle = (newValue = !checked.value) => {
        if (parent && props2.bindGroup) {
          setParentValue(newValue);
        } else {
          emit("update:modelValue", newValue);
        }
        if (props2.indeterminate !== null)
          emit("change", newValue);
      };
      vue.watch(() => props2.modelValue, (value) => {
        if (props2.indeterminate === null)
          emit("change", value);
      });
      useExpose({
        toggle,
        props: props2,
        checked
      });
      useCustomFieldValue(() => props2.modelValue);
      return () => vue.createVNode(stdin_default$1k, vue.mergeProps({
        "bem": bem$18,
        "role": "checkbox",
        "parent": parent,
        "checked": checked.value,
        "onToggle": toggle
      }, props2), pick(slots, ["default", "icon"]));
    }
  });
  const Checkbox = withInstall(stdin_default$1i);
  const [name$1b, bem$17] = createNamespace("address-item");
  var stdin_default$1h = vue.defineComponent({
    name: name$1b,
    props: {
      address: makeRequiredProp(Object),
      disabled: Boolean,
      switchable: Boolean,
      singleChoice: Boolean,
      defaultTagText: String,
      rightIcon: makeStringProp("edit")
    },
    emits: ["edit", "click", "select"],
    setup(props2, {
      slots,
      emit
    }) {
      const onClick = (event) => {
        if (props2.switchable) {
          emit("select");
        }
        emit("click", event);
      };
      const renderRightIcon = () => vue.createVNode(Icon, {
        "name": props2.rightIcon,
        "class": bem$17("edit"),
        "onClick": (event) => {
          event.stopPropagation();
          emit("edit");
          emit("click", event);
        }
      }, null);
      const renderTag = () => {
        if (slots.tag) {
          return slots.tag(props2.address);
        }
        if (props2.address.isDefault && props2.defaultTagText) {
          return vue.createVNode(Tag, {
            "type": "primary",
            "round": true,
            "class": bem$17("tag")
          }, {
            default: () => [props2.defaultTagText]
          });
        }
      };
      const renderContent = () => {
        const {
          address,
          disabled,
          switchable,
          singleChoice
        } = props2;
        const Info = [vue.createVNode("div", {
          "class": bem$17("name")
        }, [`${address.name} ${address.tel}`, renderTag()]), vue.createVNode("div", {
          "class": bem$17("address")
        }, [address.address])];
        if (switchable && !disabled) {
          if (singleChoice) {
            return vue.createVNode(Radio, {
              "name": address.id,
              "iconSize": 18
            }, {
              default: () => [Info]
            });
          } else {
            return vue.createVNode(Checkbox, {
              "name": address.id,
              "iconSize": 18
            }, {
              default: () => [Info]
            });
          }
        }
        return Info;
      };
      return () => {
        var _a;
        const {
          disabled
        } = props2;
        return vue.createVNode("div", {
          "class": bem$17({
            disabled
          }),
          "onClick": onClick
        }, [vue.createVNode(Cell, {
          "border": false,
          "titleClass": bem$17("title")
        }, {
          title: renderContent,
          "right-icon": renderRightIcon
        }), (_a = slots.bottom) == null ? void 0 : _a.call(slots, extend({}, props2.address, {
          disabled
        }))]);
      };
    }
  });
  const [name$1a, bem$16, t$j] = createNamespace("address-list");
  const addressListProps = {
    list: makeArrayProp(),
    modelValue: [...numericProp, Array],
    switchable: truthProp,
    disabledText: String,
    disabledList: makeArrayProp(),
    showAddButton: truthProp,
    addButtonText: String,
    defaultTagText: String,
    rightIcon: makeStringProp("edit")
  };
  var stdin_default$1g = vue.defineComponent({
    name: name$1a,
    props: addressListProps,
    emits: ["add", "edit", "select", "clickItem", "editDisabled", "selectDisabled", "update:modelValue"],
    setup(props2, {
      slots,
      emit
    }) {
      const singleChoice = vue.computed(() => !Array.isArray(props2.modelValue));
      const renderItem = (item, index2, disabled) => {
        const onEdit = () => emit(disabled ? "editDisabled" : "edit", item, index2);
        const onClick = (event) => emit("clickItem", item, index2, {
          event
        });
        const onSelect = () => {
          emit(disabled ? "selectDisabled" : "select", item, index2);
          if (!disabled) {
            if (singleChoice.value) {
              emit("update:modelValue", item.id);
            } else {
              const value = props2.modelValue;
              if (value.includes(item.id)) {
                emit("update:modelValue", value.filter((id) => id !== item.id));
              } else {
                emit("update:modelValue", [...value, item.id]);
              }
            }
          }
        };
        return vue.createVNode(stdin_default$1h, {
          "key": item.id,
          "address": item,
          "disabled": disabled,
          "switchable": props2.switchable,
          "singleChoice": singleChoice.value,
          "defaultTagText": props2.defaultTagText,
          "rightIcon": props2.rightIcon,
          "onEdit": onEdit,
          "onClick": onClick,
          "onSelect": onSelect
        }, {
          bottom: slots["item-bottom"],
          tag: slots.tag
        });
      };
      const renderList = (list, disabled) => {
        if (list) {
          return list.map((item, index2) => renderItem(item, index2, disabled));
        }
      };
      const renderBottom = () => props2.showAddButton ? vue.createVNode("div", {
        "class": [bem$16("bottom"), "van-safe-area-bottom"]
      }, [vue.createVNode(Button, {
        "round": true,
        "block": true,
        "type": "primary",
        "text": props2.addButtonText || t$j("add"),
        "class": bem$16("add"),
        "onClick": () => emit("add")
      }, null)]) : void 0;
      return () => {
        var _a, _b;
        const List2 = renderList(props2.list);
        const DisabledList = renderList(props2.disabledList, true);
        const DisabledText = props2.disabledText && vue.createVNode("div", {
          "class": bem$16("disabled-text")
        }, [props2.disabledText]);
        return vue.createVNode("div", {
          "class": bem$16()
        }, [(_a = slots.top) == null ? void 0 : _a.call(slots), !singleChoice.value && Array.isArray(props2.modelValue) ? vue.createVNode(CheckboxGroup, {
          "modelValue": props2.modelValue
        }, {
          default: () => [List2]
        }) : vue.createVNode(RadioGroup, {
          "modelValue": props2.modelValue
        }, {
          default: () => [List2]
        }), DisabledText, DisabledList, (_b = slots.default) == null ? void 0 : _b.call(slots), renderBottom()]);
      };
    }
  });
  const AddressList = withInstall(stdin_default$1g);
  function throttle$1(action, delay2) {
    let timeout2 = null;
    let lastRun = 0;
    return function(...args) {
      if (timeout2) {
        return;
      }
      const elapsed = Date.now() - lastRun;
      const runCallback = () => {
        lastRun = Date.now();
        timeout2 = false;
        action.apply(this, args);
      };
      if (elapsed >= delay2) {
        runCallback();
      } else {
        timeout2 = setTimeout(runCallback, delay2);
      }
    };
  }
  const [name$19, bem$15] = createNamespace("back-top");
  const backTopProps = {
    right: numericProp,
    bottom: numericProp,
    zIndex: numericProp,
    target: [String, Object],
    offset: makeNumericProp(200),
    immediate: Boolean,
    teleport: {
      type: [String, Object],
      default: "body"
    }
  };
  var stdin_default$1f = vue.defineComponent({
    name: name$19,
    inheritAttrs: false,
    props: backTopProps,
    emits: ["click"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      let shouldReshow = false;
      const show = vue.ref(false);
      const root = vue.ref();
      const scrollParent = vue.ref();
      const style = vue.computed(() => extend(getZIndexStyle(props2.zIndex), {
        right: addUnit$2(props2.right),
        bottom: addUnit$2(props2.bottom)
      }));
      const onClick = (event) => {
        var _a;
        emit("click", event);
        (_a = scrollParent.value) == null ? void 0 : _a.scrollTo({
          top: 0,
          behavior: props2.immediate ? "auto" : "smooth"
        });
      };
      const scroll = () => {
        show.value = scrollParent.value ? getScrollTop(scrollParent.value) >= +props2.offset : false;
      };
      const getTarget2 = () => {
        const {
          target
        } = props2;
        if (typeof target === "string") {
          const el = document.querySelector(target);
          if (el) {
            return el;
          }
          {
            formatAppLog("error", "at node_modules/vant/es/back-top/BackTop.mjs:58", `[Vant] BackTop: target element "${target}" was not found, the BackTop component will not be rendered.`);
          }
        } else {
          return target;
        }
      };
      const updateTarget = () => {
        if (inBrowser$1) {
          vue.nextTick(() => {
            scrollParent.value = props2.target ? getTarget2() : getScrollParent$1(root.value);
            scroll();
          });
        }
      };
      useEventListener("scroll", throttle$1(scroll, 100), {
        target: scrollParent
      });
      vue.onMounted(updateTarget);
      vue.onActivated(() => {
        if (shouldReshow) {
          show.value = true;
          shouldReshow = false;
        }
      });
      vue.onDeactivated(() => {
        if (show.value && props2.teleport) {
          show.value = false;
          shouldReshow = true;
        }
      });
      vue.watch(() => props2.target, updateTarget);
      return () => {
        const Content = vue.createVNode("div", vue.mergeProps({
          "ref": !props2.teleport ? root : void 0,
          "class": bem$15({
            active: show.value
          }),
          "style": style.value,
          "onClick": onClick
        }, attrs), [slots.default ? slots.default() : vue.createVNode(Icon, {
          "name": "back-top",
          "class": bem$15("icon")
        }, null)]);
        if (props2.teleport) {
          return [vue.createVNode("div", {
            "ref": root,
            "class": bem$15("placeholder")
          }, null), vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [Content]
          })];
        }
        return Content;
      };
    }
  });
  const BackTop = withInstall(stdin_default$1f);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const barrageProps = {
    top: makeNumericProp(10),
    rows: makeNumericProp(4),
    duration: makeNumericProp(4e3),
    autoPlay: truthProp,
    delay: makeNumberProp(300),
    modelValue: makeArrayProp()
  };
  const [name$18, bem$14] = createNamespace("barrage");
  var stdin_default$1e = vue.defineComponent({
    name: name$18,
    props: barrageProps,
    emits: ["update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const barrageWrapper = vue.ref();
      const className = bem$14("item");
      const total = vue.ref(0);
      const barrageItems = [];
      const createBarrageItem = (text, delay2 = props2.delay) => {
        const item = document.createElement("span");
        item.className = className;
        item.innerText = String(text);
        item.style.animationDuration = `${props2.duration}ms`;
        item.style.animationDelay = `${delay2}ms`;
        item.style.animationName = "van-barrage";
        item.style.animationTimingFunction = "linear";
        return item;
      };
      const isInitBarrage = vue.ref(true);
      const isPlay = vue.ref(props2.autoPlay);
      const appendBarrageItem = ({
        id,
        text
      }, i2) => {
        var _a;
        const item = createBarrageItem(text, isInitBarrage.value ? i2 * props2.delay : void 0);
        if (!props2.autoPlay && isPlay.value === false) {
          item.style.animationPlayState = "paused";
        }
        (_a = barrageWrapper.value) == null ? void 0 : _a.append(item);
        total.value++;
        const top2 = (total.value - 1) % +props2.rows * item.offsetHeight + +props2.top;
        item.style.top = `${top2}px`;
        item.dataset.id = String(id);
        barrageItems.push(item);
        item.addEventListener("animationend", () => {
          emit("update:modelValue", [...props2.modelValue].filter((v2) => String(v2.id) !== item.dataset.id));
        });
      };
      const updateBarrages = (newValue, oldValue) => {
        const map = new Map(oldValue.map((item) => [item.id, item]));
        newValue.forEach((item, i2) => {
          if (map.has(item.id)) {
            map.delete(item.id);
          } else {
            appendBarrageItem(item, i2);
          }
        });
        map.forEach((item) => {
          const index2 = barrageItems.findIndex((span) => span.dataset.id === String(item.id));
          if (index2 > -1) {
            barrageItems[index2].remove();
            barrageItems.splice(index2, 1);
          }
        });
        isInitBarrage.value = false;
      };
      vue.watch(() => props2.modelValue.slice(), (newValue, oldValue) => updateBarrages(newValue != null ? newValue : [], oldValue != null ? oldValue : []), {
        deep: true
      });
      const rootStyle = vue.ref({});
      vue.onMounted(() => __async(this, null, function* () {
        var _a;
        rootStyle.value["--move-distance"] = `-${(_a = barrageWrapper.value) == null ? void 0 : _a.offsetWidth}px`;
        yield vue.nextTick();
        updateBarrages(props2.modelValue, []);
      }));
      const play = () => {
        isPlay.value = true;
        barrageItems.forEach((item) => {
          item.style.animationPlayState = "running";
        });
      };
      const pause = () => {
        isPlay.value = false;
        barrageItems.forEach((item) => {
          item.style.animationPlayState = "paused";
        });
      };
      useExpose({
        play,
        pause
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$14(),
          "ref": barrageWrapper,
          "style": rootStyle.value
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Barrage = withInstall(stdin_default$1e);
  const [name$17, bem$13, t$i] = createNamespace("calendar");
  const formatMonthTitle = (date2) => t$i("monthTitle", date2.getFullYear(), date2.getMonth() + 1);
  function compareMonth(date1, date2) {
    const year1 = date1.getFullYear();
    const year2 = date2.getFullYear();
    if (year1 === year2) {
      const month1 = date1.getMonth();
      const month2 = date2.getMonth();
      return month1 === month2 ? 0 : month1 > month2 ? 1 : -1;
    }
    return year1 > year2 ? 1 : -1;
  }
  function compareDay(day1, day2) {
    const compareMonthResult = compareMonth(day1, day2);
    if (compareMonthResult === 0) {
      const date1 = day1.getDate();
      const date2 = day2.getDate();
      return date1 === date2 ? 0 : date1 > date2 ? 1 : -1;
    }
    return compareMonthResult;
  }
  const cloneDate = (date2) => new Date(date2);
  const cloneDates = (dates) => Array.isArray(dates) ? dates.map(cloneDate) : cloneDate(dates);
  function getDayByOffset(date2, offset2) {
    const cloned = cloneDate(date2);
    cloned.setDate(cloned.getDate() + offset2);
    return cloned;
  }
  function getMonthByOffset(date2, offset2) {
    const cloned = cloneDate(date2);
    cloned.setMonth(cloned.getMonth() + offset2);
    if (cloned.getDate() !== date2.getDate()) {
      cloned.setDate(0);
    }
    return cloned;
  }
  function getYearByOffset(date2, offset2) {
    const cloned = cloneDate(date2);
    cloned.setFullYear(cloned.getFullYear() + offset2);
    if (cloned.getDate() !== date2.getDate()) {
      cloned.setDate(0);
    }
    return cloned;
  }
  const getPrevDay = (date2) => getDayByOffset(date2, -1);
  const getNextDay = (date2) => getDayByOffset(date2, 1);
  const getPrevMonth = (date2) => getMonthByOffset(date2, -1);
  const getNextMonth = (date2) => getMonthByOffset(date2, 1);
  const getPrevYear = (date2) => getYearByOffset(date2, -1);
  const getNextYear = (date2) => getYearByOffset(date2, 1);
  const getToday = () => {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    return today;
  };
  function calcDateNum(date2) {
    const day1 = date2[0].getTime();
    const day2 = date2[1].getTime();
    return (day2 - day1) / (1e3 * 60 * 60 * 24) + 1;
  }
  const sharedProps = extend({}, pickerSharedProps, {
    modelValue: makeArrayProp(),
    filter: Function,
    formatter: {
      type: Function,
      default: (type, option) => option
    }
  });
  const pickerInheritKeys = Object.keys(pickerSharedProps);
  function times$1(n2, iteratee) {
    if (n2 < 0) {
      return [];
    }
    const result = Array(n2);
    let index2 = -1;
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  const getMonthEndDay = (year, month) => 32 - new Date(year, month - 1, 32).getDate();
  const genOptions = (min, max, type, formatter, filter, values) => {
    const options = times$1(max - min + 1, (index2) => {
      const value = padZero$1(min + index2);
      return formatter(type, {
        text: value,
        value
      });
    });
    return filter ? filter(type, options, values) : options;
  };
  const formatValueRange = (values, columns) => values.map((value, index2) => {
    const column = columns[index2];
    if (column.length) {
      const minValue = +column[0].value;
      const maxValue = +column[column.length - 1].value;
      return padZero$1(clamp(+value, minValue, maxValue));
    }
    return value;
  });
  const [name$16] = createNamespace("calendar-day");
  var stdin_default$1d = vue.defineComponent({
    name: name$16,
    props: {
      item: makeRequiredProp(Object),
      color: String,
      index: Number,
      offset: makeNumberProp(0),
      rowHeight: String
    },
    emits: ["click", "clickDisabledDate"],
    setup(props2, {
      emit,
      slots
    }) {
      const style = vue.computed(() => {
        var _a;
        const {
          item,
          index: index2,
          color,
          offset: offset2,
          rowHeight
        } = props2;
        const style2 = {
          height: rowHeight
        };
        if (item.type === "placeholder") {
          style2.width = "100%";
          return style2;
        }
        if (index2 === 0) {
          style2.marginLeft = `${100 * offset2 / 7}%`;
        }
        if (color) {
          switch (item.type) {
            case "end":
            case "start":
            case "start-end":
            case "multiple-middle":
            case "multiple-selected":
              style2.background = color;
              break;
            case "middle":
              style2.color = color;
              break;
          }
        }
        if (offset2 + (((_a = item.date) == null ? void 0 : _a.getDate()) || 1) > 28) {
          style2.marginBottom = 0;
        }
        return style2;
      });
      const onClick = () => {
        if (props2.item.type !== "disabled") {
          emit("click", props2.item);
        } else {
          emit("clickDisabledDate", props2.item);
        }
      };
      const renderTopInfo = () => {
        const {
          topInfo
        } = props2.item;
        if (topInfo || slots["top-info"]) {
          return vue.createVNode("div", {
            "class": bem$13("top-info")
          }, [slots["top-info"] ? slots["top-info"](props2.item) : topInfo]);
        }
      };
      const renderBottomInfo = () => {
        const {
          bottomInfo
        } = props2.item;
        if (bottomInfo || slots["bottom-info"]) {
          return vue.createVNode("div", {
            "class": bem$13("bottom-info")
          }, [slots["bottom-info"] ? slots["bottom-info"](props2.item) : bottomInfo]);
        }
      };
      const renderText = () => {
        return slots.text ? slots.text(props2.item) : props2.item.text;
      };
      const renderContent = () => {
        const {
          item,
          color,
          rowHeight
        } = props2;
        const {
          type
        } = item;
        const Nodes = [renderTopInfo(), renderText(), renderBottomInfo()];
        if (type === "selected") {
          return vue.createVNode("div", {
            "class": bem$13("selected-day"),
            "style": {
              width: rowHeight,
              height: rowHeight,
              background: color
            }
          }, [Nodes]);
        }
        return Nodes;
      };
      return () => {
        const {
          type,
          className
        } = props2.item;
        if (type === "placeholder") {
          return vue.createVNode("div", {
            "class": bem$13("day"),
            "style": style.value
          }, null);
        }
        return vue.createVNode("div", {
          "role": "gridcell",
          "style": style.value,
          "class": [bem$13("day", type), className],
          "tabindex": type === "disabled" ? void 0 : -1,
          "onClick": onClick
        }, [renderContent()]);
      };
    }
  });
  const [name$15] = createNamespace("calendar-month");
  const calendarMonthProps = {
    date: makeRequiredProp(Date),
    type: String,
    color: String,
    minDate: Date,
    maxDate: Date,
    showMark: Boolean,
    rowHeight: numericProp,
    formatter: Function,
    lazyRender: Boolean,
    currentDate: [Date, Array],
    allowSameDay: Boolean,
    showSubtitle: Boolean,
    showMonthTitle: Boolean,
    firstDayOfWeek: Number
  };
  var stdin_default$1c = vue.defineComponent({
    name: name$15,
    props: calendarMonthProps,
    emits: ["click", "clickDisabledDate"],
    setup(props2, {
      emit,
      slots
    }) {
      const [visible, setVisible] = useToggle();
      const daysRef = vue.ref();
      const monthRef = vue.ref();
      const height2 = useHeight(monthRef);
      const title = vue.computed(() => formatMonthTitle(props2.date));
      const rowHeight = vue.computed(() => addUnit$2(props2.rowHeight));
      const offset2 = vue.computed(() => {
        const date2 = props2.date.getDate();
        const day = props2.date.getDay();
        const realDay = (day - date2 % 7 + 8) % 7;
        if (props2.firstDayOfWeek) {
          return (realDay + 7 - props2.firstDayOfWeek) % 7;
        }
        return realDay;
      });
      const totalDay = vue.computed(() => getMonthEndDay(props2.date.getFullYear(), props2.date.getMonth() + 1));
      const shouldRender = vue.computed(() => visible.value || !props2.lazyRender);
      const getTitle = () => title.value;
      const getMultipleDayType = (day) => {
        const isSelected = (date2) => props2.currentDate.some((item) => compareDay(item, date2) === 0);
        if (isSelected(day)) {
          const prevDay = getPrevDay(day);
          const nextDay = getNextDay(day);
          const prevSelected = isSelected(prevDay);
          const nextSelected = isSelected(nextDay);
          if (prevSelected && nextSelected) {
            return "multiple-middle";
          }
          if (prevSelected) {
            return "end";
          }
          if (nextSelected) {
            return "start";
          }
          return "multiple-selected";
        }
        return "";
      };
      const getRangeDayType = (day) => {
        const [startDay, endDay] = props2.currentDate;
        if (!startDay) {
          return "";
        }
        const compareToStart = compareDay(day, startDay);
        if (!endDay) {
          return compareToStart === 0 ? "start" : "";
        }
        const compareToEnd = compareDay(day, endDay);
        if (props2.allowSameDay && compareToStart === 0 && compareToEnd === 0) {
          return "start-end";
        }
        if (compareToStart === 0) {
          return "start";
        }
        if (compareToEnd === 0) {
          return "end";
        }
        if (compareToStart > 0 && compareToEnd < 0) {
          return "middle";
        }
        return "";
      };
      const getDayType = (day) => {
        const {
          type,
          minDate,
          maxDate,
          currentDate
        } = props2;
        if (minDate && compareDay(day, minDate) < 0 || maxDate && compareDay(day, maxDate) > 0) {
          return "disabled";
        }
        if (currentDate === null) {
          return "";
        }
        if (Array.isArray(currentDate)) {
          if (type === "multiple") {
            return getMultipleDayType(day);
          }
          if (type === "range") {
            return getRangeDayType(day);
          }
        } else if (type === "single") {
          return compareDay(day, currentDate) === 0 ? "selected" : "";
        }
        return "";
      };
      const getBottomInfo = (dayType) => {
        if (props2.type === "range") {
          if (dayType === "start" || dayType === "end") {
            return t$i(dayType);
          }
          if (dayType === "start-end") {
            return `${t$i("start")}/${t$i("end")}`;
          }
        }
      };
      const renderTitle = () => {
        if (props2.showMonthTitle) {
          return vue.createVNode("div", {
            "class": bem$13("month-title")
          }, [slots["month-title"] ? slots["month-title"]({
            date: props2.date,
            text: title.value
          }) : title.value]);
        }
      };
      const renderMark = () => {
        if (props2.showMark && shouldRender.value) {
          return vue.createVNode("div", {
            "class": bem$13("month-mark")
          }, [props2.date.getMonth() + 1]);
        }
      };
      const placeholders = vue.computed(() => {
        const count = Math.ceil((totalDay.value + offset2.value) / 7);
        return Array(count).fill({
          type: "placeholder"
        });
      });
      const days = vue.computed(() => {
        const days2 = [];
        const year = props2.date.getFullYear();
        const month = props2.date.getMonth();
        for (let day = 1; day <= totalDay.value; day++) {
          const date2 = new Date(year, month, day);
          const type = getDayType(date2);
          let config2 = {
            date: date2,
            type,
            text: day,
            bottomInfo: getBottomInfo(type)
          };
          if (props2.formatter) {
            config2 = props2.formatter(config2);
          }
          days2.push(config2);
        }
        return days2;
      });
      const disabledDays = vue.computed(() => days.value.filter((day) => day.type === "disabled"));
      const scrollToDate = (body, targetDate) => {
        if (daysRef.value) {
          const daysRect = useRect(daysRef.value);
          const totalRows = placeholders.value.length;
          const currentRow = Math.ceil((targetDate.getDate() + offset2.value) / 7);
          const rowOffset = (currentRow - 1) * daysRect.height / totalRows;
          setScrollTop(body, daysRect.top + rowOffset + body.scrollTop - useRect(body).top);
        }
      };
      const renderDay = (item, index2) => vue.createVNode(stdin_default$1d, {
        "item": item,
        "index": index2,
        "color": props2.color,
        "offset": offset2.value,
        "rowHeight": rowHeight.value,
        "onClick": (item2) => emit("click", item2),
        "onClickDisabledDate": (item2) => emit("clickDisabledDate", item2)
      }, pick(slots, ["top-info", "bottom-info", "text"]));
      const renderDays = () => vue.createVNode("div", {
        "ref": daysRef,
        "role": "grid",
        "class": bem$13("days")
      }, [renderMark(), (shouldRender.value ? days : placeholders).value.map(renderDay)]);
      useExpose({
        getTitle,
        getHeight: () => height2.value,
        setVisible,
        scrollToDate,
        disabledDays
      });
      return () => vue.createVNode("div", {
        "class": bem$13("month"),
        "ref": monthRef
      }, [renderTitle(), renderDays()]);
    }
  });
  const [name$14] = createNamespace("calendar-header");
  var stdin_default$1b = vue.defineComponent({
    name: name$14,
    props: {
      date: Date,
      minDate: Date,
      maxDate: Date,
      title: String,
      subtitle: String,
      showTitle: Boolean,
      showSubtitle: Boolean,
      firstDayOfWeek: Number,
      switchMode: makeStringProp("none")
    },
    emits: ["clickSubtitle", "panelChange"],
    setup(props2, {
      slots,
      emit
    }) {
      const prevMonthDisabled = vue.computed(() => props2.date && props2.minDate && compareMonth(getPrevMonth(props2.date), props2.minDate) < 0);
      const prevYearDisabled = vue.computed(() => props2.date && props2.minDate && compareMonth(getPrevYear(props2.date), props2.minDate) < 0);
      const nextMonthDisabled = vue.computed(() => props2.date && props2.maxDate && compareMonth(getNextMonth(props2.date), props2.maxDate) > 0);
      const nextYearDisabled = vue.computed(() => props2.date && props2.maxDate && compareMonth(getNextYear(props2.date), props2.maxDate) > 0);
      const renderTitle = () => {
        if (props2.showTitle) {
          const text = props2.title || t$i("title");
          const title = slots.title ? slots.title() : text;
          return vue.createVNode("div", {
            "class": bem$13("header-title")
          }, [title]);
        }
      };
      const onClickSubtitle = (event) => emit("clickSubtitle", event);
      const onPanelChange = (date2) => emit("panelChange", date2);
      const renderAction = (isNext) => {
        const showYearAction = props2.switchMode === "year-month";
        const monthSlot = slots[isNext ? "next-month" : "prev-month"];
        const yearSlot = slots[isNext ? "next-year" : "prev-year"];
        const monthDisabled = isNext ? nextMonthDisabled.value : prevMonthDisabled.value;
        const yearDisabled = isNext ? nextYearDisabled.value : prevYearDisabled.value;
        const monthIconName = isNext ? "arrow" : "arrow-left";
        const yearIconName = isNext ? "arrow-double-right" : "arrow-double-left";
        const onMonthChange = () => onPanelChange((isNext ? getNextMonth : getPrevMonth)(props2.date));
        const onYearChange = () => onPanelChange((isNext ? getNextYear : getPrevYear)(props2.date));
        const MonthAction = vue.createVNode("view", {
          "class": bem$13("header-action", {
            disabled: monthDisabled
          }),
          "onClick": monthDisabled ? void 0 : onMonthChange
        }, [monthSlot ? monthSlot({
          disabled: monthDisabled
        }) : vue.createVNode(Icon, {
          "class": {
            [HAPTICS_FEEDBACK]: !monthDisabled
          },
          "name": monthIconName
        }, null)]);
        const YearAction = showYearAction && vue.createVNode("view", {
          "class": bem$13("header-action", {
            disabled: yearDisabled
          }),
          "onClick": yearDisabled ? void 0 : onYearChange
        }, [yearSlot ? yearSlot({
          disabled: yearDisabled
        }) : vue.createVNode(Icon, {
          "class": {
            [HAPTICS_FEEDBACK]: !yearDisabled
          },
          "name": yearIconName
        }, null)]);
        return isNext ? [MonthAction, YearAction] : [YearAction, MonthAction];
      };
      const renderSubtitle = () => {
        if (props2.showSubtitle) {
          const title = slots.subtitle ? slots.subtitle({
            date: props2.date,
            text: props2.subtitle
          }) : props2.subtitle;
          const canSwitch = props2.switchMode !== "none";
          return vue.createVNode("div", {
            "class": bem$13("header-subtitle", {
              "with-switch": canSwitch
            }),
            "onClick": onClickSubtitle
          }, [canSwitch ? [renderAction(), vue.createVNode("div", {
            "class": bem$13("header-subtitle-text")
          }, [title]), renderAction(true)] : title]);
        }
      };
      const renderWeekDays = () => {
        const {
          firstDayOfWeek
        } = props2;
        const weekdays = t$i("weekdays");
        const renderWeekDays2 = [...weekdays.slice(firstDayOfWeek, 7), ...weekdays.slice(0, firstDayOfWeek)];
        return vue.createVNode("div", {
          "class": bem$13("weekdays")
        }, [renderWeekDays2.map((text) => vue.createVNode("span", {
          "class": bem$13("weekday")
        }, [text]))]);
      };
      return () => vue.createVNode("div", {
        "class": bem$13("header")
      }, [renderTitle(), renderSubtitle(), renderWeekDays()]);
    }
  });
  const calendarProps = {
    show: Boolean,
    type: makeStringProp("single"),
    switchMode: makeStringProp("none"),
    title: String,
    color: String,
    round: truthProp,
    readonly: Boolean,
    poppable: truthProp,
    maxRange: makeNumericProp(null),
    position: makeStringProp("bottom"),
    teleport: [String, Object],
    showMark: truthProp,
    showTitle: truthProp,
    formatter: Function,
    rowHeight: numericProp,
    confirmText: String,
    rangePrompt: String,
    lazyRender: truthProp,
    showConfirm: truthProp,
    defaultDate: [Date, Array],
    allowSameDay: Boolean,
    showSubtitle: truthProp,
    closeOnPopstate: truthProp,
    showRangePrompt: truthProp,
    confirmDisabledText: String,
    closeOnClickOverlay: truthProp,
    safeAreaInsetTop: Boolean,
    safeAreaInsetBottom: truthProp,
    minDate: {
      type: Date,
      validator: isDate
    },
    maxDate: {
      type: Date,
      validator: isDate
    },
    firstDayOfWeek: {
      type: numericProp,
      default: 0,
      validator: (val) => val >= 0 && val <= 6
    }
  };
  var stdin_default$1a = vue.defineComponent({
    name: name$17,
    props: calendarProps,
    emits: ["select", "confirm", "unselect", "monthShow", "overRange", "update:show", "clickSubtitle", "clickDisabledDate", "panelChange"],
    setup(props2, {
      emit,
      slots
    }) {
      const canSwitch = vue.computed(() => props2.switchMode !== "none");
      const minDate = vue.computed(() => {
        if (!props2.minDate && !canSwitch.value) {
          return getToday();
        }
        return props2.minDate;
      });
      const maxDate = vue.computed(() => {
        if (!props2.maxDate && !canSwitch.value) {
          return getMonthByOffset(getToday(), 6);
        }
        return props2.maxDate;
      });
      const limitDateRange = (date2, min = minDate.value, max = maxDate.value) => {
        if (min && compareDay(date2, min) === -1) {
          return min;
        }
        if (max && compareDay(date2, max) === 1) {
          return max;
        }
        return date2;
      };
      const getInitialDate = (defaultDate = props2.defaultDate) => {
        const {
          type,
          allowSameDay
        } = props2;
        if (defaultDate === null) {
          return defaultDate;
        }
        const now2 = getToday();
        if (type === "range") {
          if (!Array.isArray(defaultDate)) {
            defaultDate = [];
          }
          if (defaultDate.length === 1 && compareDay(defaultDate[0], now2) === 1) {
            defaultDate = [];
          }
          const min = minDate.value;
          const max = maxDate.value;
          const start2 = limitDateRange(defaultDate[0] || now2, min, max ? allowSameDay ? max : getPrevDay(max) : void 0);
          const end2 = limitDateRange(defaultDate[1] || (allowSameDay ? now2 : getNextDay(now2)), min ? allowSameDay ? min : getNextDay(min) : void 0);
          return [start2, end2];
        }
        if (type === "multiple") {
          if (Array.isArray(defaultDate)) {
            return defaultDate.map((date2) => limitDateRange(date2));
          }
          return [limitDateRange(now2)];
        }
        if (!defaultDate || Array.isArray(defaultDate)) {
          defaultDate = now2;
        }
        return limitDateRange(defaultDate);
      };
      const getInitialPanelDate = () => {
        const date2 = Array.isArray(currentDate.value) ? currentDate.value[0] : currentDate.value;
        return date2 ? date2 : limitDateRange(getToday());
      };
      let bodyHeight;
      const bodyRef = vue.ref();
      const currentDate = vue.ref(getInitialDate());
      const currentPanelDate = vue.ref(getInitialPanelDate());
      const currentMonthRef = vue.ref();
      const [monthRefs, setMonthRefs] = useRefs();
      const dayOffset = vue.computed(() => props2.firstDayOfWeek ? +props2.firstDayOfWeek % 7 : 0);
      const months = vue.computed(() => {
        const months2 = [];
        if (!minDate.value || !maxDate.value) {
          return months2;
        }
        const cursor = new Date(minDate.value);
        cursor.setDate(1);
        do {
          months2.push(new Date(cursor));
          cursor.setMonth(cursor.getMonth() + 1);
        } while (compareMonth(cursor, maxDate.value) !== 1);
        return months2;
      });
      const buttonDisabled = vue.computed(() => {
        if (currentDate.value) {
          if (props2.type === "range") {
            return !currentDate.value[0] || !currentDate.value[1];
          }
          if (props2.type === "multiple") {
            return !currentDate.value.length;
          }
        }
        return !currentDate.value;
      });
      const getSelectedDate = () => currentDate.value;
      const onScroll = () => {
        const top2 = getScrollTop(bodyRef.value);
        const bottom2 = top2 + bodyHeight;
        const heights = months.value.map((item, index2) => monthRefs.value[index2].getHeight());
        const heightSum = heights.reduce((a2, b2) => a2 + b2, 0);
        if (bottom2 > heightSum && top2 > 0) {
          return;
        }
        let height2 = 0;
        let currentMonth;
        const visibleRange = [-1, -1];
        for (let i2 = 0; i2 < months.value.length; i2++) {
          const month = monthRefs.value[i2];
          const visible = height2 <= bottom2 && height2 + heights[i2] >= top2;
          if (visible) {
            visibleRange[1] = i2;
            if (!currentMonth) {
              currentMonth = month;
              visibleRange[0] = i2;
            }
            if (!monthRefs.value[i2].showed) {
              monthRefs.value[i2].showed = true;
              emit("monthShow", {
                date: month.date,
                title: month.getTitle()
              });
            }
          }
          height2 += heights[i2];
        }
        months.value.forEach((month, index2) => {
          const visible = index2 >= visibleRange[0] - 1 && index2 <= visibleRange[1] + 1;
          monthRefs.value[index2].setVisible(visible);
        });
        if (currentMonth) {
          currentMonthRef.value = currentMonth;
        }
      };
      const scrollToDate = (targetDate) => {
        if (canSwitch.value) {
          currentPanelDate.value = targetDate;
        } else {
          raf(() => {
            months.value.some((month, index2) => {
              if (compareMonth(month, targetDate) === 0) {
                if (bodyRef.value) {
                  monthRefs.value[index2].scrollToDate(bodyRef.value, targetDate);
                }
                return true;
              }
              return false;
            });
            onScroll();
          });
        }
      };
      const scrollToCurrentDate = () => {
        if (props2.poppable && !props2.show) {
          return;
        }
        if (currentDate.value) {
          const targetDate = props2.type === "single" ? currentDate.value : currentDate.value[0];
          if (isDate(targetDate)) {
            scrollToDate(targetDate);
          }
        } else if (!canSwitch.value) {
          raf(onScroll);
        }
      };
      const init = () => {
        if (props2.poppable && !props2.show) {
          return;
        }
        if (!canSwitch.value) {
          raf(() => {
            bodyHeight = Math.floor(useRect(bodyRef).height);
          });
        }
        scrollToCurrentDate();
      };
      const reset = (date2 = getInitialDate()) => {
        currentDate.value = date2;
        scrollToCurrentDate();
      };
      const checkRange = (date2) => {
        const {
          maxRange,
          rangePrompt,
          showRangePrompt
        } = props2;
        if (maxRange && calcDateNum(date2) > +maxRange) {
          if (showRangePrompt) {
            showToast(rangePrompt || t$i("rangePrompt", maxRange));
          }
          emit("overRange");
          return false;
        }
        return true;
      };
      const onPanelChange = (date2) => {
        currentPanelDate.value = date2;
        emit("panelChange", {
          date: date2
        });
      };
      const onConfirm = () => {
        var _a;
        return emit("confirm", (_a = currentDate.value) != null ? _a : cloneDates(currentDate.value));
      };
      const select = (date2, complete) => {
        const setCurrentDate = (date22) => {
          currentDate.value = date22;
          emit("select", cloneDates(date22));
        };
        if (complete && props2.type === "range") {
          const valid = checkRange(date2);
          if (!valid) {
            setCurrentDate([date2[0], getDayByOffset(date2[0], +props2.maxRange - 1)]);
            return;
          }
        }
        setCurrentDate(date2);
        if (complete && !props2.showConfirm) {
          onConfirm();
        }
      };
      const getDisabledDate = (disabledDays2, startDay, date2) => {
        var _a;
        return (_a = disabledDays2.find((day) => compareDay(startDay, day.date) === -1 && compareDay(day.date, date2) === -1)) == null ? void 0 : _a.date;
      };
      const disabledDays = vue.computed(() => monthRefs.value.reduce((arr, ref2) => {
        var _a, _b;
        arr.push(...(_b = (_a = ref2.disabledDays) == null ? void 0 : _a.value) != null ? _b : []);
        return arr;
      }, []));
      const onClickDay = (item) => {
        if (props2.readonly || !item.date) {
          return;
        }
        const {
          date: date2
        } = item;
        const {
          type
        } = props2;
        if (type === "range") {
          if (!currentDate.value) {
            select([date2]);
            return;
          }
          const [startDay, endDay] = currentDate.value;
          if (startDay && !endDay) {
            const compareToStart = compareDay(date2, startDay);
            if (compareToStart === 1) {
              const disabledDay = getDisabledDate(disabledDays.value, startDay, date2);
              if (disabledDay) {
                const endDay2 = getPrevDay(disabledDay);
                if (compareDay(startDay, endDay2) === -1) {
                  select([startDay, endDay2]);
                } else {
                  select([date2]);
                }
              } else {
                select([startDay, date2], true);
              }
            } else if (compareToStart === -1) {
              select([date2]);
            } else if (props2.allowSameDay) {
              select([date2, date2], true);
            }
          } else {
            select([date2]);
          }
        } else if (type === "multiple") {
          if (!currentDate.value) {
            select([date2]);
            return;
          }
          const dates = currentDate.value;
          const selectedIndex = dates.findIndex((dateItem) => compareDay(dateItem, date2) === 0);
          if (selectedIndex !== -1) {
            const [unselectedDate] = dates.splice(selectedIndex, 1);
            emit("unselect", cloneDate(unselectedDate));
          } else if (props2.maxRange && dates.length >= +props2.maxRange) {
            showToast(props2.rangePrompt || t$i("rangePrompt", props2.maxRange));
          } else {
            select([...dates, date2]);
          }
        } else {
          select(date2, true);
        }
      };
      const updateShow = (value) => emit("update:show", value);
      const renderMonth = (date2, index2) => {
        const showMonthTitle = index2 !== 0 || !props2.showSubtitle;
        return vue.createVNode(stdin_default$1c, vue.mergeProps({
          "ref": canSwitch.value ? currentMonthRef : setMonthRefs(index2),
          "date": date2,
          "currentDate": currentDate.value,
          "showMonthTitle": showMonthTitle,
          "firstDayOfWeek": dayOffset.value,
          "lazyRender": canSwitch.value ? false : props2.lazyRender,
          "maxDate": maxDate.value,
          "minDate": minDate.value
        }, pick(props2, ["type", "color", "showMark", "formatter", "rowHeight", "showSubtitle", "allowSameDay"]), {
          "onClick": onClickDay,
          "onClickDisabledDate": (item) => emit("clickDisabledDate", item)
        }), pick(slots, ["top-info", "bottom-info", "month-title", "text"]));
      };
      const renderFooterButton = () => {
        if (slots.footer) {
          return slots.footer();
        }
        if (props2.showConfirm) {
          const slot = slots["confirm-text"];
          const disabled = buttonDisabled.value;
          const text = disabled ? props2.confirmDisabledText : props2.confirmText;
          return vue.createVNode(Button, {
            "round": true,
            "block": true,
            "type": "primary",
            "color": props2.color,
            "class": bem$13("confirm"),
            "disabled": disabled,
            "nativeType": "button",
            "onClick": onConfirm
          }, {
            default: () => [slot ? slot({
              disabled
            }) : text || t$i("confirm")]
          });
        }
      };
      const renderFooter = () => vue.createVNode("div", {
        "class": [bem$13("footer"), {
          "van-safe-area-bottom": props2.safeAreaInsetBottom
        }]
      }, [renderFooterButton()]);
      const renderCalendar = () => {
        var _a, _b;
        return vue.createVNode("div", {
          "class": bem$13()
        }, [vue.createVNode(stdin_default$1b, {
          "date": (_a = currentMonthRef.value) == null ? void 0 : _a.date,
          "maxDate": maxDate.value,
          "minDate": minDate.value,
          "title": props2.title,
          "subtitle": (_b = currentMonthRef.value) == null ? void 0 : _b.getTitle(),
          "showTitle": props2.showTitle,
          "showSubtitle": props2.showSubtitle,
          "switchMode": props2.switchMode,
          "firstDayOfWeek": dayOffset.value,
          "onClickSubtitle": (event) => emit("clickSubtitle", event),
          "onPanelChange": onPanelChange
        }, pick(slots, ["title", "subtitle", "prev-month", "prev-year", "next-month", "next-year"])), vue.createVNode("div", {
          "ref": bodyRef,
          "class": bem$13("body"),
          "onScroll": canSwitch.value ? void 0 : onScroll
        }, [canSwitch.value ? renderMonth(currentPanelDate.value, 0) : months.value.map(renderMonth)]), renderFooter()]);
      };
      vue.watch(() => props2.show, init);
      vue.watch(() => [props2.type, props2.minDate, props2.maxDate, props2.switchMode], () => reset(getInitialDate(currentDate.value)));
      vue.watch(() => props2.defaultDate, (value) => {
        reset(value);
      });
      useExpose({
        reset,
        scrollToDate,
        getSelectedDate
      });
      onMountedOrActivated(init);
      return () => {
        if (props2.poppable) {
          return vue.createVNode(Popup, {
            "show": props2.show,
            "class": bem$13("popup"),
            "round": props2.round,
            "position": props2.position,
            "closeable": props2.showTitle || props2.showSubtitle,
            "teleport": props2.teleport,
            "closeOnPopstate": props2.closeOnPopstate,
            "safeAreaInsetTop": props2.safeAreaInsetTop,
            "closeOnClickOverlay": props2.closeOnClickOverlay,
            "onUpdate:show": updateShow
          }, {
            default: renderCalendar
          });
        }
        return renderCalendar();
      };
    }
  });
  const Calendar = withInstall(stdin_default$1a);
  const [name$13, bem$12] = createNamespace("image");
  const imageProps = {
    src: String,
    alt: String,
    fit: String,
    position: String,
    round: Boolean,
    block: Boolean,
    width: numericProp,
    height: numericProp,
    radius: numericProp,
    lazyLoad: Boolean,
    iconSize: numericProp,
    showError: truthProp,
    errorIcon: makeStringProp("photo-fail"),
    iconPrefix: String,
    showLoading: truthProp,
    loadingIcon: makeStringProp("photo"),
    crossorigin: String,
    referrerpolicy: String
  };
  var stdin_default$19 = vue.defineComponent({
    name: name$13,
    props: imageProps,
    emits: ["load", "error"],
    setup(props2, {
      emit,
      slots
    }) {
      const error2 = vue.ref(false);
      const loading = vue.ref(true);
      const imageRef = vue.ref();
      const {
        $Lazyload
      } = vue.getCurrentInstance().proxy;
      const style = vue.computed(() => {
        const style2 = {
          width: addUnit$2(props2.width),
          height: addUnit$2(props2.height)
        };
        if (isDef(props2.radius)) {
          style2.overflow = "hidden";
          style2.borderRadius = addUnit$2(props2.radius);
        }
        return style2;
      });
      vue.watch(() => props2.src, () => {
        error2.value = false;
        loading.value = true;
      });
      const onLoad2 = (event) => {
        if (loading.value) {
          loading.value = false;
          emit("load", event);
        }
      };
      const triggerLoad = () => {
        const loadEvent = new Event("load");
        Object.defineProperty(loadEvent, "target", {
          value: imageRef.value,
          enumerable: true
        });
        onLoad2(loadEvent);
      };
      const onError = (event) => {
        error2.value = true;
        loading.value = false;
        emit("error", event);
      };
      const renderIcon = (name2, className, slot) => {
        if (slot) {
          return slot();
        }
        return vue.createVNode(Icon, {
          "name": name2,
          "size": props2.iconSize,
          "class": className,
          "classPrefix": props2.iconPrefix
        }, null);
      };
      const renderPlaceholder = () => {
        if (loading.value && props2.showLoading) {
          return vue.createVNode("div", {
            "class": bem$12("loading")
          }, [renderIcon(props2.loadingIcon, bem$12("loading-icon"), slots.loading)]);
        }
        if (error2.value && props2.showError) {
          return vue.createVNode("div", {
            "class": bem$12("error")
          }, [renderIcon(props2.errorIcon, bem$12("error-icon"), slots.error)]);
        }
      };
      const renderImage = () => {
        if (error2.value || !props2.src) {
          return;
        }
        const attrs = {
          alt: props2.alt,
          class: bem$12("img"),
          style: {
            objectFit: props2.fit,
            objectPosition: props2.position
          },
          crossorigin: props2.crossorigin,
          referrerpolicy: props2.referrerpolicy
        };
        if (props2.lazyLoad) {
          return vue.withDirectives(vue.createVNode("img", vue.mergeProps({
            "ref": imageRef
          }, attrs), null), [[vue.resolveDirective("lazy"), props2.src]]);
        }
        return vue.createVNode("img", vue.mergeProps({
          "ref": imageRef,
          "src": props2.src,
          "onLoad": onLoad2,
          "onError": onError
        }, attrs), null);
      };
      const onLazyLoaded = ({
        el
      }) => {
        const check = () => {
          if (el === imageRef.value && loading.value) {
            triggerLoad();
          }
        };
        if (imageRef.value) {
          check();
        } else {
          vue.nextTick(check);
        }
      };
      const onLazyLoadError = ({
        el
      }) => {
        if (el === imageRef.value && !error2.value) {
          onError();
        }
      };
      if ($Lazyload && inBrowser$1) {
        $Lazyload.$on("loaded", onLazyLoaded);
        $Lazyload.$on("error", onLazyLoadError);
        vue.onBeforeUnmount(() => {
          $Lazyload.$off("loaded", onLazyLoaded);
          $Lazyload.$off("error", onLazyLoadError);
        });
      }
      vue.onMounted(() => {
        vue.nextTick(() => {
          var _a;
          if (((_a = imageRef.value) == null ? void 0 : _a.complete) && !props2.lazyLoad) {
            triggerLoad();
          }
        });
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$12({
            round: props2.round,
            block: props2.block
          }),
          "style": style.value
        }, [renderImage(), renderPlaceholder(), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Image$1 = withInstall(stdin_default$19);
  const [name$12, bem$11] = createNamespace("card");
  const cardProps = {
    tag: String,
    num: numericProp,
    desc: String,
    thumb: String,
    title: String,
    price: numericProp,
    centered: Boolean,
    lazyLoad: Boolean,
    currency: makeStringProp(""),
    thumbLink: String,
    originPrice: numericProp
  };
  var stdin_default$18 = vue.defineComponent({
    name: name$12,
    props: cardProps,
    emits: ["clickThumb"],
    setup(props2, {
      slots,
      emit
    }) {
      const renderTitle = () => {
        if (slots.title) {
          return slots.title();
        }
        if (props2.title) {
          return vue.createVNode("div", {
            "class": [bem$11("title"), "van-multi-ellipsis--l2"]
          }, [props2.title]);
        }
      };
      const renderThumbTag = () => {
        if (slots.tag || props2.tag) {
          return vue.createVNode("div", {
            "class": bem$11("tag")
          }, [slots.tag ? slots.tag() : vue.createVNode(Tag, {
            "mark": true,
            "type": "primary"
          }, {
            default: () => [props2.tag]
          })]);
        }
      };
      const renderThumbImage = () => {
        if (slots.thumb) {
          return slots.thumb();
        }
        return vue.createVNode(Image$1, {
          "src": props2.thumb,
          "fit": "cover",
          "width": "100%",
          "height": "100%",
          "lazyLoad": props2.lazyLoad
        }, null);
      };
      const renderThumb = () => {
        if (slots.thumb || props2.thumb) {
          return vue.createVNode("a", {
            "href": props2.thumbLink,
            "class": bem$11("thumb"),
            "onClick": (event) => emit("clickThumb", event)
          }, [renderThumbImage(), renderThumbTag()]);
        }
      };
      const renderDesc = () => {
        if (slots.desc) {
          return slots.desc();
        }
        if (props2.desc) {
          return vue.createVNode("div", {
            "class": [bem$11("desc"), "van-ellipsis"]
          }, [props2.desc]);
        }
      };
      const renderPriceText = () => {
        const priceArr = props2.price.toString().split(".");
        return vue.createVNode("div", null, [vue.createVNode("span", {
          "class": bem$11("price-currency")
        }, [props2.currency]), vue.createVNode("span", {
          "class": bem$11("price-integer")
        }, [priceArr[0]]), priceArr.length > 1 && vue.createVNode(vue.Fragment, null, [vue.createTextVNode("."), vue.createVNode("span", {
          "class": bem$11("price-decimal")
        }, [priceArr[1]])])]);
      };
      return () => {
        var _a, _b, _c;
        const showNum = slots.num || isDef(props2.num);
        const showPrice = slots.price || isDef(props2.price);
        const showOriginPrice = slots["origin-price"] || isDef(props2.originPrice);
        const showBottom = showNum || showPrice || showOriginPrice || slots.bottom;
        const Price = showPrice && vue.createVNode("div", {
          "class": bem$11("price")
        }, [slots.price ? slots.price() : renderPriceText()]);
        const OriginPrice = showOriginPrice && vue.createVNode("div", {
          "class": bem$11("origin-price")
        }, [slots["origin-price"] ? slots["origin-price"]() : `${props2.currency} ${props2.originPrice}`]);
        const Num = showNum && vue.createVNode("div", {
          "class": bem$11("num")
        }, [slots.num ? slots.num() : `x${props2.num}`]);
        const Footer = slots.footer && vue.createVNode("div", {
          "class": bem$11("footer")
        }, [slots.footer()]);
        const Bottom = showBottom && vue.createVNode("div", {
          "class": bem$11("bottom")
        }, [(_a = slots["price-top"]) == null ? void 0 : _a.call(slots), Price, OriginPrice, Num, (_b = slots.bottom) == null ? void 0 : _b.call(slots)]);
        return vue.createVNode("div", {
          "class": bem$11()
        }, [vue.createVNode("div", {
          "class": bem$11("header")
        }, [renderThumb(), vue.createVNode("div", {
          "class": bem$11("content", {
            centered: props2.centered
          })
        }, [vue.createVNode("div", null, [renderTitle(), renderDesc(), (_c = slots.tags) == null ? void 0 : _c.call(slots)]), Bottom])]), Footer]);
      };
    }
  });
  const Card = withInstall(stdin_default$18);
  const [name$11, bem$10, t$h] = createNamespace("cascader");
  const cascaderProps = {
    title: String,
    options: makeArrayProp(),
    closeable: truthProp,
    swipeable: truthProp,
    closeIcon: makeStringProp("cross"),
    showHeader: truthProp,
    modelValue: numericProp,
    fieldNames: Object,
    placeholder: String,
    activeColor: String
  };
  var stdin_default$17 = vue.defineComponent({
    name: name$11,
    props: cascaderProps,
    emits: ["close", "change", "finish", "clickTab", "update:modelValue"],
    setup(props2, {
      slots,
      emit
    }) {
      const tabs = vue.ref([]);
      const activeTab = vue.ref(0);
      const [selectedElementRefs, setSelectedElementRefs] = useRefs();
      const {
        text: textKey,
        value: valueKey,
        children: childrenKey
      } = extend({
        text: "text",
        value: "value",
        children: "children"
      }, props2.fieldNames);
      const getSelectedOptionsByValue = (options, value) => {
        for (const option of options) {
          if (option[valueKey] === value) {
            return [option];
          }
          if (option[childrenKey]) {
            const selectedOptions = getSelectedOptionsByValue(option[childrenKey], value);
            if (selectedOptions) {
              return [option, ...selectedOptions];
            }
          }
        }
      };
      const updateTabs = () => {
        const {
          options,
          modelValue
        } = props2;
        if (modelValue !== void 0) {
          const selectedOptions = getSelectedOptionsByValue(options, modelValue);
          if (selectedOptions) {
            let optionsCursor = options;
            tabs.value = selectedOptions.map((option) => {
              const tab = {
                options: optionsCursor,
                selected: option
              };
              const next = optionsCursor.find((item) => item[valueKey] === option[valueKey]);
              if (next) {
                optionsCursor = next[childrenKey];
              }
              return tab;
            });
            if (optionsCursor) {
              tabs.value.push({
                options: optionsCursor,
                selected: null
              });
            }
            vue.nextTick(() => {
              activeTab.value = tabs.value.length - 1;
            });
            return;
          }
        }
        tabs.value = [{
          options,
          selected: null
        }];
      };
      const onSelect = (option, tabIndex) => {
        if (option.disabled) {
          return;
        }
        tabs.value[tabIndex].selected = option;
        if (tabs.value.length > tabIndex + 1) {
          tabs.value = tabs.value.slice(0, tabIndex + 1);
        }
        if (option[childrenKey]) {
          const nextTab = {
            options: option[childrenKey],
            selected: null
          };
          if (tabs.value[tabIndex + 1]) {
            tabs.value[tabIndex + 1] = nextTab;
          } else {
            tabs.value.push(nextTab);
          }
          vue.nextTick(() => {
            activeTab.value++;
          });
        }
        const selectedOptions = tabs.value.map((tab) => tab.selected).filter(Boolean);
        emit("update:modelValue", option[valueKey]);
        const params = {
          value: option[valueKey],
          tabIndex,
          selectedOptions
        };
        emit("change", params);
        if (!option[childrenKey]) {
          emit("finish", params);
        }
      };
      const onClose = () => emit("close");
      const onClickTab = ({
        name: name2,
        title
      }) => emit("clickTab", name2, title);
      const renderHeader = () => props2.showHeader ? vue.createVNode("div", {
        "class": bem$10("header")
      }, [vue.createVNode("h2", {
        "class": bem$10("title")
      }, [slots.title ? slots.title() : props2.title]), props2.closeable ? vue.createVNode(Icon, {
        "name": props2.closeIcon,
        "class": [bem$10("close-icon"), HAPTICS_FEEDBACK],
        "onClick": onClose
      }, null) : null]) : null;
      const renderOption = (option, selectedOption, tabIndex) => {
        const {
          disabled
        } = option;
        const selected = !!(selectedOption && option[valueKey] === selectedOption[valueKey]);
        const color = option.color || (selected ? props2.activeColor : void 0);
        const Text = slots.option ? slots.option({
          option,
          selected
        }) : vue.createVNode("span", null, [option[textKey]]);
        return vue.createVNode("li", {
          "ref": selected ? setSelectedElementRefs(tabIndex) : void 0,
          "role": "menuitemradio",
          "class": [bem$10("option", {
            selected,
            disabled
          }), option.className],
          "style": {
            color
          },
          "tabindex": disabled ? void 0 : selected ? 0 : -1,
          "aria-checked": selected,
          "aria-disabled": disabled || void 0,
          "onClick": () => onSelect(option, tabIndex)
        }, [Text, selected ? vue.createVNode(Icon, {
          "name": "success",
          "class": bem$10("selected-icon")
        }, null) : null]);
      };
      const renderOptions = (options, selectedOption, tabIndex) => vue.createVNode("ul", {
        "role": "menu",
        "class": bem$10("options")
      }, [options.map((option) => renderOption(option, selectedOption, tabIndex))]);
      const renderTab = (tab, tabIndex) => {
        const {
          options,
          selected
        } = tab;
        const placeholder = props2.placeholder || t$h("select");
        const title = selected ? selected[textKey] : placeholder;
        return vue.createVNode(Tab, {
          "title": title,
          "titleClass": bem$10("tab", {
            unselected: !selected
          })
        }, {
          default: () => {
            var _a, _b;
            return [(_a = slots["options-top"]) == null ? void 0 : _a.call(slots, {
              tabIndex
            }), renderOptions(options, selected, tabIndex), (_b = slots["options-bottom"]) == null ? void 0 : _b.call(slots, {
              tabIndex
            })];
          }
        });
      };
      const renderTabs = () => vue.createVNode(Tabs, {
        "active": activeTab.value,
        "onUpdate:active": ($event) => activeTab.value = $event,
        "shrink": true,
        "animated": true,
        "class": bem$10("tabs"),
        "color": props2.activeColor,
        "swipeable": props2.swipeable,
        "onClickTab": onClickTab
      }, {
        default: () => [tabs.value.map(renderTab)]
      });
      const scrollIntoView = (el) => {
        const scrollParent = el.parentElement;
        if (scrollParent) {
          scrollParent.scrollTop = el.offsetTop - (scrollParent.offsetHeight - el.offsetHeight) / 2;
        }
      };
      updateTabs();
      vue.watch(activeTab, (value) => {
        const el = selectedElementRefs.value[value];
        if (el)
          scrollIntoView(el);
      });
      vue.watch(() => props2.options, updateTabs, {
        deep: true
      });
      vue.watch(() => props2.modelValue, (value) => {
        if (value !== void 0) {
          const values = tabs.value.map((tab) => {
            var _a;
            return (_a = tab.selected) == null ? void 0 : _a[valueKey];
          });
          if (values.includes(value)) {
            return;
          }
        }
        updateTabs();
      });
      return () => vue.createVNode("div", {
        "class": bem$10()
      }, [renderHeader(), renderTabs()]);
    }
  });
  const Cascader = withInstall(stdin_default$17);
  const [name$10, bem$$] = createNamespace("cell-group");
  const cellGroupProps = {
    title: String,
    inset: Boolean,
    border: truthProp
  };
  var stdin_default$16 = vue.defineComponent({
    name: name$10,
    inheritAttrs: false,
    props: cellGroupProps,
    setup(props2, {
      slots,
      attrs
    }) {
      const renderGroup = () => {
        var _a;
        return vue.createVNode("div", vue.mergeProps({
          "class": [bem$$({
            inset: props2.inset
          }), {
            [BORDER_TOP_BOTTOM]: props2.border && !props2.inset
          }]
        }, attrs, useScopeId()), [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
      const renderTitle = () => vue.createVNode("div", {
        "class": bem$$("title", {
          inset: props2.inset
        })
      }, [slots.title ? slots.title() : props2.title]);
      return () => {
        if (props2.title || slots.title) {
          return vue.createVNode(vue.Fragment, null, [renderTitle(), renderGroup()]);
        }
        return renderGroup();
      };
    }
  });
  const CellGroup = withInstall(stdin_default$16);
  const [name$$, bem$_] = createNamespace("circle");
  let uid = 0;
  const format$1 = (rate) => Math.min(Math.max(+rate, 0), 100);
  function getPath(clockwise, viewBoxSize) {
    const sweepFlag = clockwise ? 1 : 0;
    return `M ${viewBoxSize / 2} ${viewBoxSize / 2} m 0, -500 a 500, 500 0 1, ${sweepFlag} 0, 1000 a 500, 500 0 1, ${sweepFlag} 0, -1000`;
  }
  const circleProps = {
    text: String,
    size: numericProp,
    fill: makeStringProp("none"),
    rate: makeNumericProp(100),
    speed: makeNumericProp(0),
    color: [String, Object],
    clockwise: truthProp,
    layerColor: String,
    currentRate: makeNumberProp(0),
    strokeWidth: makeNumericProp(40),
    strokeLinecap: String,
    startPosition: makeStringProp("top")
  };
  var stdin_default$15 = vue.defineComponent({
    name: name$$,
    props: circleProps,
    emits: ["update:currentRate"],
    setup(props2, {
      emit,
      slots
    }) {
      const id = `van-circle-${uid++}`;
      const viewBoxSize = vue.computed(() => +props2.strokeWidth + 1e3);
      const path = vue.computed(() => getPath(props2.clockwise, viewBoxSize.value));
      const svgStyle = vue.computed(() => {
        const ROTATE_ANGLE_MAP = {
          top: 0,
          right: 90,
          bottom: 180,
          left: 270
        };
        const angleValue = ROTATE_ANGLE_MAP[props2.startPosition];
        if (angleValue) {
          return {
            transform: `rotate(${angleValue}deg)`
          };
        }
      });
      vue.watch(() => props2.rate, (rate) => {
        let rafId;
        const startTime = Date.now();
        const startRate = props2.currentRate;
        const endRate = format$1(rate);
        const duration = Math.abs((startRate - endRate) * 1e3 / +props2.speed);
        const animate = () => {
          const now2 = Date.now();
          const progress = Math.min((now2 - startTime) / duration, 1);
          const rate2 = progress * (endRate - startRate) + startRate;
          emit("update:currentRate", format$1(parseFloat(rate2.toFixed(1))));
          if (endRate > startRate ? rate2 < endRate : rate2 > endRate) {
            rafId = raf(animate);
          }
        };
        if (props2.speed) {
          if (rafId) {
            cancelRaf(rafId);
          }
          rafId = raf(animate);
        } else {
          emit("update:currentRate", endRate);
        }
      }, {
        immediate: true
      });
      const renderHover = () => {
        const PERIMETER = 3140;
        const {
          strokeWidth,
          currentRate,
          strokeLinecap
        } = props2;
        const offset2 = PERIMETER * currentRate / 100;
        const color = isObject$1(props2.color) ? `url(#${id})` : props2.color;
        const style = {
          stroke: color,
          strokeWidth: `${+strokeWidth + 1}px`,
          strokeLinecap,
          strokeDasharray: `${offset2}px ${PERIMETER}px`
        };
        return vue.createVNode("path", {
          "d": path.value,
          "style": style,
          "class": bem$_("hover"),
          "stroke": color
        }, null);
      };
      const renderLayer = () => {
        const style = {
          fill: props2.fill,
          stroke: props2.layerColor,
          strokeWidth: `${props2.strokeWidth}px`
        };
        return vue.createVNode("path", {
          "class": bem$_("layer"),
          "style": style,
          "d": path.value
        }, null);
      };
      const renderGradient = () => {
        const {
          color
        } = props2;
        if (!isObject$1(color)) {
          return;
        }
        const Stops = Object.keys(color).sort((a2, b2) => parseFloat(a2) - parseFloat(b2)).map((key, index2) => vue.createVNode("stop", {
          "key": index2,
          "offset": key,
          "stop-color": color[key]
        }, null));
        return vue.createVNode("defs", null, [vue.createVNode("linearGradient", {
          "id": id,
          "x1": "100%",
          "y1": "0%",
          "x2": "0%",
          "y2": "0%"
        }, [Stops])]);
      };
      const renderText = () => {
        if (slots.default) {
          return slots.default();
        }
        if (props2.text) {
          return vue.createVNode("div", {
            "class": bem$_("text")
          }, [props2.text]);
        }
      };
      return () => vue.createVNode("div", {
        "class": bem$_(),
        "style": getSizeStyle(props2.size)
      }, [vue.createVNode("svg", {
        "viewBox": `0 0 ${viewBoxSize.value} ${viewBoxSize.value}`,
        "style": svgStyle.value
      }, [renderGradient(), renderLayer(), renderHover()]), renderText()]);
    }
  });
  const Circle = withInstall(stdin_default$15);
  const [name$_, bem$Z] = createNamespace("row");
  const ROW_KEY = Symbol(name$_);
  const rowProps = {
    tag: makeStringProp("div"),
    wrap: truthProp,
    align: String,
    gutter: {
      type: [String, Number, Array],
      default: 0
    },
    justify: String
  };
  var stdin_default$14 = vue.defineComponent({
    name: name$_,
    props: rowProps,
    setup(props2, {
      slots
    }) {
      const {
        children,
        linkChildren
      } = useChildren(ROW_KEY);
      const groups = vue.computed(() => {
        const groups2 = [[]];
        let totalSpan = 0;
        children.forEach((child, index2) => {
          totalSpan += Number(child.span);
          if (totalSpan > 24) {
            groups2.push([index2]);
            totalSpan -= 24;
          } else {
            groups2[groups2.length - 1].push(index2);
          }
        });
        return groups2;
      });
      const spaces = vue.computed(() => {
        let gutter = 0;
        if (Array.isArray(props2.gutter)) {
          gutter = Number(props2.gutter[0]) || 0;
        } else {
          gutter = Number(props2.gutter);
        }
        const spaces2 = [];
        if (!gutter) {
          return spaces2;
        }
        groups.value.forEach((group) => {
          const averagePadding = gutter * (group.length - 1) / group.length;
          group.forEach((item, index2) => {
            if (index2 === 0) {
              spaces2.push({
                right: averagePadding
              });
            } else {
              const left2 = gutter - spaces2[item - 1].right;
              const right2 = averagePadding - left2;
              spaces2.push({
                left: left2,
                right: right2
              });
            }
          });
        });
        return spaces2;
      });
      const verticalSpaces = vue.computed(() => {
        const {
          gutter
        } = props2;
        const spaces2 = [];
        if (Array.isArray(gutter) && gutter.length > 1) {
          const bottom2 = Number(gutter[1]) || 0;
          if (bottom2 <= 0) {
            return spaces2;
          }
          groups.value.forEach((group, index2) => {
            if (index2 === groups.value.length - 1)
              return;
            group.forEach(() => {
              spaces2.push({
                bottom: bottom2
              });
            });
          });
        }
        return spaces2;
      });
      linkChildren({
        spaces,
        verticalSpaces
      });
      return () => {
        const {
          tag,
          wrap,
          align,
          justify
        } = props2;
        return vue.createVNode(tag, {
          "class": bem$Z({
            [`align-${align}`]: align,
            [`justify-${justify}`]: justify,
            nowrap: !wrap
          })
        }, {
          default: () => {
            var _a;
            return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
          }
        });
      };
    }
  });
  const [name$Z, bem$Y] = createNamespace("col");
  const colProps = {
    tag: makeStringProp("div"),
    span: makeNumericProp(0),
    offset: numericProp
  };
  var stdin_default$13 = vue.defineComponent({
    name: name$Z,
    props: colProps,
    setup(props2, {
      slots
    }) {
      const {
        parent,
        index: index2
      } = useParent(ROW_KEY);
      const style = vue.computed(() => {
        if (!parent) {
          return;
        }
        const {
          spaces,
          verticalSpaces
        } = parent;
        let styles = {};
        if (spaces && spaces.value && spaces.value[index2.value]) {
          const {
            left: left2,
            right: right2
          } = spaces.value[index2.value];
          styles = {
            paddingLeft: left2 ? `${left2}px` : null,
            paddingRight: right2 ? `${right2}px` : null
          };
        }
        const {
          bottom: bottom2
        } = verticalSpaces.value[index2.value] || {};
        return extend(styles, {
          marginBottom: bottom2 ? `${bottom2}px` : null
        });
      });
      return () => {
        const {
          tag,
          span,
          offset: offset2
        } = props2;
        return vue.createVNode(tag, {
          "style": style.value,
          "class": bem$Y({
            [span]: span,
            [`offset-${offset2}`]: offset2
          })
        }, {
          default: () => {
            var _a;
            return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
          }
        });
      };
    }
  });
  const Col = withInstall(stdin_default$13);
  const [name$Y, bem$X] = createNamespace("collapse");
  const COLLAPSE_KEY = Symbol(name$Y);
  const collapseProps = {
    border: truthProp,
    accordion: Boolean,
    modelValue: {
      type: [String, Number, Array],
      default: ""
    }
  };
  function validateModelValue(modelValue, accordion) {
    if (accordion && Array.isArray(modelValue)) {
      formatAppLog("error", "at node_modules/vant/es/collapse/Collapse.mjs:17", '[Vant] Collapse: "v-model" should not be Array in accordion mode');
      return false;
    }
    if (!accordion && !Array.isArray(modelValue)) {
      formatAppLog("error", "at node_modules/vant/es/collapse/Collapse.mjs:21", '[Vant] Collapse: "v-model" should be Array in non-accordion mode');
      return false;
    }
    return true;
  }
  var stdin_default$12 = vue.defineComponent({
    name: name$Y,
    props: collapseProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        linkChildren,
        children
      } = useChildren(COLLAPSE_KEY);
      const updateName = (name2) => {
        emit("change", name2);
        emit("update:modelValue", name2);
      };
      const toggle = (name2, expanded) => {
        const {
          accordion,
          modelValue
        } = props2;
        if (accordion) {
          updateName(name2 === modelValue ? "" : name2);
        } else if (expanded) {
          updateName(modelValue.concat(name2));
        } else {
          updateName(modelValue.filter((activeName) => activeName !== name2));
        }
      };
      const toggleAll = (options = {}) => {
        if (props2.accordion) {
          return;
        }
        if (typeof options === "boolean") {
          options = {
            expanded: options
          };
        }
        const {
          expanded,
          skipDisabled
        } = options;
        const expandedChildren = children.filter((item) => {
          if (item.disabled && skipDisabled) {
            return item.expanded.value;
          }
          return expanded != null ? expanded : !item.expanded.value;
        });
        const names = expandedChildren.map((item) => item.itemName.value);
        updateName(names);
      };
      const isExpanded = (name2) => {
        const {
          accordion,
          modelValue
        } = props2;
        if (!validateModelValue(modelValue, accordion)) {
          return false;
        }
        return accordion ? modelValue === name2 : modelValue.includes(name2);
      };
      useExpose({
        toggleAll
      });
      linkChildren({
        toggle,
        isExpanded
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": [bem$X(), {
            [BORDER_TOP_BOTTOM]: props2.border
          }]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Collapse = withInstall(stdin_default$12);
  const [name$X, bem$W] = createNamespace("collapse-item");
  const CELL_SLOTS = ["icon", "title", "value", "label", "right-icon"];
  const collapseItemProps = extend({}, cellSharedProps, {
    name: numericProp,
    isLink: truthProp,
    disabled: Boolean,
    readonly: Boolean,
    lazyRender: truthProp
  });
  var stdin_default$11 = vue.defineComponent({
    name: name$X,
    props: collapseItemProps,
    setup(props2, {
      slots
    }) {
      const wrapperRef = vue.ref();
      const contentRef = vue.ref();
      const {
        parent,
        index: index2
      } = useParent(COLLAPSE_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/collapse-item/CollapseItem.mjs:32", "[Vant] <CollapseItem> must be a child component of <Collapse>.");
        }
        return;
      }
      const name2 = vue.computed(() => {
        var _a;
        return (_a = props2.name) != null ? _a : index2.value;
      });
      const expanded = vue.computed(() => parent.isExpanded(name2.value));
      const show = vue.ref(expanded.value);
      const lazyRender = useLazyRender(() => show.value || !props2.lazyRender);
      const onTransitionEnd = () => {
        if (!expanded.value) {
          show.value = false;
        } else if (wrapperRef.value) {
          wrapperRef.value.style.height = "";
        }
      };
      vue.watch(expanded, (value, oldValue) => {
        if (oldValue === null) {
          return;
        }
        if (value) {
          show.value = true;
        }
        const tick = value ? vue.nextTick : raf;
        tick(() => {
          if (!contentRef.value || !wrapperRef.value) {
            return;
          }
          const {
            offsetHeight
          } = contentRef.value;
          if (offsetHeight) {
            const contentHeight = `${offsetHeight}px`;
            wrapperRef.value.style.height = value ? "0" : contentHeight;
            doubleRaf(() => {
              if (wrapperRef.value) {
                wrapperRef.value.style.height = value ? contentHeight : "0";
              }
            });
          } else {
            onTransitionEnd();
          }
        });
      });
      const toggle = (newValue = !expanded.value) => {
        parent.toggle(name2.value, newValue);
      };
      const onClickTitle = () => {
        if (!props2.disabled && !props2.readonly) {
          toggle();
        }
      };
      const renderTitle = () => {
        const {
          border,
          disabled,
          readonly
        } = props2;
        const attrs = pick(props2, Object.keys(cellSharedProps));
        if (readonly) {
          attrs.isLink = false;
        }
        if (disabled || readonly) {
          attrs.clickable = false;
        }
        return vue.createVNode(Cell, vue.mergeProps({
          "role": "button",
          "class": bem$W("title", {
            disabled,
            expanded: expanded.value,
            borderless: !border
          }),
          "aria-expanded": String(expanded.value),
          "onClick": onClickTitle
        }, attrs), pick(slots, CELL_SLOTS));
      };
      const renderContent = lazyRender(() => {
        var _a;
        return vue.withDirectives(vue.createVNode("div", {
          "ref": wrapperRef,
          "class": bem$W("wrapper"),
          "onTransitionend": onTransitionEnd
        }, [vue.createVNode("div", {
          "ref": contentRef,
          "class": bem$W("content")
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]), [[vue.vShow, show.value]]);
      });
      useExpose({
        toggle,
        expanded,
        itemName: name2
      });
      return () => vue.createVNode("div", {
        "class": [bem$W({
          border: index2.value && props2.border
        })]
      }, [renderTitle(), renderContent()]);
    }
  });
  const CollapseItem = withInstall(stdin_default$11);
  const ConfigProvider = withInstall(stdin_default$1P);
  const [name$W, bem$V, t$g] = createNamespace("contact-card");
  const contactCardProps = {
    tel: String,
    name: String,
    type: makeStringProp("add"),
    addText: String,
    editable: truthProp
  };
  var stdin_default$10 = vue.defineComponent({
    name: name$W,
    props: contactCardProps,
    emits: ["click"],
    setup(props2, {
      emit
    }) {
      const onClick = (event) => {
        if (props2.editable) {
          emit("click", event);
        }
      };
      const renderContent = () => {
        if (props2.type === "add") {
          return props2.addText || t$g("addContact");
        }
        return [vue.createVNode("div", null, [`${t$g("name")}${props2.name}`]), vue.createVNode("div", null, [`${t$g("tel")}${props2.tel}`])];
      };
      return () => vue.createVNode(Cell, {
        "center": true,
        "icon": props2.type === "edit" ? "contact" : "add-square",
        "class": bem$V([props2.type]),
        "border": false,
        "isLink": props2.editable,
        "titleClass": bem$V("title"),
        "onClick": onClick
      }, {
        title: renderContent
      });
    }
  });
  const ContactCard = withInstall(stdin_default$10);
  const [name$V, bem$U, t$f] = createNamespace("contact-edit");
  const DEFAULT_CONTACT = {
    tel: "",
    name: ""
  };
  const contactEditProps = {
    isEdit: Boolean,
    isSaving: Boolean,
    isDeleting: Boolean,
    showSetDefault: Boolean,
    setDefaultLabel: String,
    contactInfo: {
      type: Object,
      default: () => extend({}, DEFAULT_CONTACT)
    },
    telValidator: {
      type: Function,
      default: isMobile
    }
  };
  var stdin_default$$ = vue.defineComponent({
    name: name$V,
    props: contactEditProps,
    emits: ["save", "delete", "changeDefault"],
    setup(props2, {
      emit
    }) {
      const contact = vue.reactive(extend({}, DEFAULT_CONTACT, props2.contactInfo));
      const onSave = () => {
        if (!props2.isSaving) {
          emit("save", contact);
        }
      };
      const onDelete = () => emit("delete", contact);
      const renderButtons = () => vue.createVNode("div", {
        "class": bem$U("buttons")
      }, [vue.createVNode(Button, {
        "block": true,
        "round": true,
        "type": "primary",
        "text": t$f("save"),
        "class": bem$U("button"),
        "loading": props2.isSaving,
        "nativeType": "submit"
      }, null), props2.isEdit && vue.createVNode(Button, {
        "block": true,
        "round": true,
        "text": t$f("delete"),
        "class": bem$U("button"),
        "loading": props2.isDeleting,
        "onClick": onDelete
      }, null)]);
      const renderSwitch = () => vue.createVNode(Switch, {
        "modelValue": contact.isDefault,
        "onUpdate:modelValue": ($event) => contact.isDefault = $event,
        "onChange": (checked) => emit("changeDefault", checked)
      }, null);
      const renderSetDefault = () => {
        if (props2.showSetDefault) {
          return vue.createVNode(Cell, {
            "title": props2.setDefaultLabel,
            "class": bem$U("switch-cell"),
            "border": false
          }, {
            "right-icon": renderSwitch
          });
        }
      };
      vue.watch(() => props2.contactInfo, (value) => extend(contact, DEFAULT_CONTACT, value));
      return () => vue.createVNode(Form, {
        "class": bem$U(),
        "onSubmit": onSave
      }, {
        default: () => [vue.createVNode("div", {
          "class": bem$U("fields")
        }, [vue.createVNode(Field, {
          "modelValue": contact.name,
          "onUpdate:modelValue": ($event) => contact.name = $event,
          "clearable": true,
          "label": t$f("name"),
          "rules": [{
            required: true,
            message: t$f("nameEmpty")
          }],
          "maxlength": "30",
          "placeholder": t$f("name")
        }, null), vue.createVNode(Field, {
          "modelValue": contact.tel,
          "onUpdate:modelValue": ($event) => contact.tel = $event,
          "clearable": true,
          "type": "tel",
          "label": t$f("tel"),
          "rules": [{
            validator: props2.telValidator,
            message: t$f("telInvalid")
          }],
          "placeholder": t$f("tel")
        }, null)]), renderSetDefault(), renderButtons()]
      });
    }
  });
  const ContactEdit = withInstall(stdin_default$$);
  const [name$U, bem$T, t$e] = createNamespace("contact-list");
  const contactListProps = {
    list: Array,
    addText: String,
    modelValue: unknownProp,
    defaultTagText: String
  };
  var stdin_default$_ = vue.defineComponent({
    name: name$U,
    props: contactListProps,
    emits: ["add", "edit", "select", "update:modelValue"],
    setup(props2, {
      emit
    }) {
      const renderItem = (item, index2) => {
        const onClick = () => {
          emit("update:modelValue", item.id);
          emit("select", item, index2);
        };
        const renderRightIcon = () => vue.createVNode(Radio, {
          "class": bem$T("radio"),
          "name": item.id,
          "iconSize": 18
        }, null);
        const renderEditIcon = () => vue.createVNode(Icon, {
          "name": "edit",
          "class": bem$T("edit"),
          "onClick": (event) => {
            event.stopPropagation();
            emit("edit", item, index2);
          }
        }, null);
        const renderContent = () => {
          const nodes = [`${item.name}${item.tel}`];
          if (item.isDefault && props2.defaultTagText) {
            nodes.push(vue.createVNode(Tag, {
              "type": "primary",
              "round": true,
              "class": bem$T("item-tag")
            }, {
              default: () => [props2.defaultTagText]
            }));
          }
          return nodes;
        };
        return vue.createVNode(Cell, {
          "key": item.id,
          "isLink": true,
          "center": true,
          "class": bem$T("item"),
          "titleClass": bem$T("item-title"),
          "onClick": onClick
        }, {
          icon: renderEditIcon,
          title: renderContent,
          "right-icon": renderRightIcon
        });
      };
      return () => vue.createVNode("div", {
        "class": bem$T()
      }, [vue.createVNode(RadioGroup, {
        "modelValue": props2.modelValue,
        "class": bem$T("group")
      }, {
        default: () => [props2.list && props2.list.map(renderItem)]
      }), vue.createVNode("div", {
        "class": [bem$T("bottom"), "van-safe-area-bottom"]
      }, [vue.createVNode(Button, {
        "round": true,
        "block": true,
        "type": "primary",
        "class": bem$T("add"),
        "text": props2.addText || t$e("addContact"),
        "onClick": () => emit("add")
      }, null)])]);
    }
  });
  const ContactList = withInstall(stdin_default$_);
  function parseFormat(format2, currentTime) {
    const { days } = currentTime;
    let { hours, minutes, seconds, milliseconds } = currentTime;
    if (format2.includes("DD")) {
      format2 = format2.replace("DD", padZero$1(days));
    } else {
      hours += days * 24;
    }
    if (format2.includes("HH")) {
      format2 = format2.replace("HH", padZero$1(hours));
    } else {
      minutes += hours * 60;
    }
    if (format2.includes("mm")) {
      format2 = format2.replace("mm", padZero$1(minutes));
    } else {
      seconds += minutes * 60;
    }
    if (format2.includes("ss")) {
      format2 = format2.replace("ss", padZero$1(seconds));
    } else {
      milliseconds += seconds * 1e3;
    }
    if (format2.includes("S")) {
      const ms = padZero$1(milliseconds, 3);
      if (format2.includes("SSS")) {
        format2 = format2.replace("SSS", ms);
      } else if (format2.includes("SS")) {
        format2 = format2.replace("SS", ms.slice(0, 2));
      } else {
        format2 = format2.replace("S", ms.charAt(0));
      }
    }
    return format2;
  }
  const [name$T, bem$S] = createNamespace("count-down");
  const countDownProps = {
    time: makeNumericProp(0),
    format: makeStringProp("HH:mm:ss"),
    autoStart: truthProp,
    millisecond: Boolean
  };
  var stdin_default$Z = vue.defineComponent({
    name: name$T,
    props: countDownProps,
    emits: ["change", "finish"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        start: start2,
        pause,
        reset,
        current: current2
      } = useCountDown({
        time: +props2.time,
        millisecond: props2.millisecond,
        onChange: (current22) => emit("change", current22),
        onFinish: () => emit("finish")
      });
      const timeText = vue.computed(() => parseFormat(props2.format, current2.value));
      const resetTime = () => {
        reset(+props2.time);
        if (props2.autoStart) {
          start2();
        }
      };
      vue.watch(() => props2.time, resetTime, {
        immediate: true
      });
      useExpose({
        start: start2,
        pause,
        reset: resetTime
      });
      return () => vue.createVNode("div", {
        "role": "timer",
        "class": bem$S()
      }, [slots.default ? slots.default(current2.value) : timeText.value]);
    }
  });
  const CountDown = withInstall(stdin_default$Z);
  function getDate(timeStamp) {
    const date2 = new Date(timeStamp * 1e3);
    return `${date2.getFullYear()}.${padZero$1(date2.getMonth() + 1)}.${padZero$1(
      date2.getDate()
    )}`;
  }
  const formatDiscount = (discount) => (discount / 10).toFixed(discount % 10 === 0 ? 0 : 1);
  const formatAmount = (amount2) => (amount2 / 100).toFixed(amount2 % 100 === 0 ? 0 : amount2 % 10 === 0 ? 1 : 2);
  const [name$S, bem$R, t$d] = createNamespace("coupon");
  var stdin_default$Y = vue.defineComponent({
    name: name$S,
    props: {
      chosen: Boolean,
      coupon: makeRequiredProp(Object),
      disabled: Boolean,
      currency: makeStringProp("")
    },
    setup(props2) {
      const validPeriod = vue.computed(() => {
        const {
          startAt,
          endAt
        } = props2.coupon;
        return `${getDate(startAt)} - ${getDate(endAt)}`;
      });
      const faceAmount = vue.computed(() => {
        const {
          coupon,
          currency
        } = props2;
        if (coupon.valueDesc) {
          return [coupon.valueDesc, vue.createVNode("span", null, [coupon.unitDesc || ""])];
        }
        if (coupon.denominations) {
          const denominations = formatAmount(coupon.denominations);
          return [vue.createVNode("span", null, [currency]), ` ${denominations}`];
        }
        if (coupon.discount) {
          return t$d("discount", formatDiscount(coupon.discount));
        }
        return "";
      });
      const conditionMessage = vue.computed(() => {
        const condition = formatAmount(props2.coupon.originCondition || 0);
        return condition === "0" ? t$d("unlimited") : t$d("condition", condition);
      });
      return () => {
        const {
          chosen,
          coupon,
          disabled
        } = props2;
        const description = disabled && coupon.reason || coupon.description;
        return vue.createVNode("div", {
          "class": bem$R({
            disabled
          })
        }, [vue.createVNode("div", {
          "class": bem$R("content")
        }, [vue.createVNode("div", {
          "class": bem$R("head")
        }, [vue.createVNode("h2", {
          "class": bem$R("amount")
        }, [faceAmount.value]), vue.createVNode("p", {
          "class": bem$R("condition")
        }, [coupon.condition || conditionMessage.value])]), vue.createVNode("div", {
          "class": bem$R("body")
        }, [vue.createVNode("p", {
          "class": bem$R("name")
        }, [coupon.name]), vue.createVNode("p", {
          "class": bem$R("valid")
        }, [validPeriod.value]), !disabled && vue.createVNode(Checkbox, {
          "class": bem$R("corner"),
          "modelValue": chosen
        }, null)])]), description && vue.createVNode("p", {
          "class": bem$R("description")
        }, [description])]);
      };
    }
  });
  const Coupon = withInstall(stdin_default$Y);
  const [name$R, bem$Q, t$c] = createNamespace("coupon-cell");
  const couponCellProps = {
    title: String,
    border: truthProp,
    editable: truthProp,
    coupons: makeArrayProp(),
    currency: makeStringProp(""),
    chosenCoupon: {
      type: [Number, Array],
      default: -1
    }
  };
  const getValue = (coupon) => {
    const {
      value,
      denominations
    } = coupon;
    if (isDef(value)) {
      return value;
    }
    if (isDef(denominations)) {
      return denominations;
    }
    return 0;
  };
  function formatValue({
    coupons,
    chosenCoupon,
    currency
  }) {
    let value = 0;
    let isExist = false;
    (Array.isArray(chosenCoupon) ? chosenCoupon : [chosenCoupon]).forEach((i2) => {
      const coupon = coupons[+i2];
      if (coupon) {
        isExist = true;
        value += getValue(coupon);
      }
    });
    if (isExist) {
      return `-${currency} ${(value / 100).toFixed(2)}`;
    }
    return coupons.length === 0 ? t$c("noCoupon") : t$c("count", coupons.length);
  }
  var stdin_default$X = vue.defineComponent({
    name: name$R,
    props: couponCellProps,
    setup(props2) {
      return () => {
        const selected = Array.isArray(props2.chosenCoupon) ? props2.chosenCoupon.length : props2.coupons[+props2.chosenCoupon];
        return vue.createVNode(Cell, {
          "class": bem$Q(),
          "value": formatValue(props2),
          "title": props2.title || t$c("title"),
          "border": props2.border,
          "isLink": props2.editable,
          "valueClass": bem$Q("value", {
            selected
          })
        }, null);
      };
    }
  });
  const CouponCell = withInstall(stdin_default$X);
  const [name$Q, bem$P] = createNamespace("empty");
  const emptyProps = {
    image: makeStringProp("default"),
    imageSize: [Number, String, Array],
    description: String
  };
  var stdin_default$W = vue.defineComponent({
    name: name$Q,
    props: emptyProps,
    setup(props2, {
      slots
    }) {
      const renderDescription = () => {
        const description = slots.description ? slots.description() : props2.description;
        if (description) {
          return vue.createVNode("p", {
            "class": bem$P("description")
          }, [description]);
        }
      };
      const renderBottom = () => {
        if (slots.default) {
          return vue.createVNode("div", {
            "class": bem$P("bottom")
          }, [slots.default()]);
        }
      };
      const baseId = useId();
      const getId = (num) => `${baseId}-${num}`;
      const getUrlById = (num) => `url(#${getId(num)})`;
      const renderStop = (color, offset2, opacity) => vue.createVNode("stop", {
        "stop-color": color,
        "offset": `${offset2}%`,
        "stop-opacity": opacity
      }, null);
      const renderStops = (fromColor, toColor) => [renderStop(fromColor, 0), renderStop(toColor, 100)];
      const renderShadow = (id) => [vue.createVNode("defs", null, [vue.createVNode("radialGradient", {
        "id": getId(id),
        "cx": "50%",
        "cy": "54%",
        "fx": "50%",
        "fy": "54%",
        "r": "297%",
        "gradientTransform": "matrix(-.16 0 0 -.33 .58 .72)",
        "data-allow-mismatch": "attribute"
      }, [renderStop("#EBEDF0", 0), renderStop("#F2F3F5", 100, 0.3)])]), vue.createVNode("ellipse", {
        "fill": getUrlById(id),
        "opacity": ".8",
        "cx": "80",
        "cy": "140",
        "rx": "46",
        "ry": "8",
        "data-allow-mismatch": "attribute"
      }, null)];
      const renderBuilding = () => [vue.createVNode("defs", null, [vue.createVNode("linearGradient", {
        "id": getId("a"),
        "x1": "64%",
        "y1": "100%",
        "x2": "64%",
        "data-allow-mismatch": "attribute"
      }, [renderStop("#FFF", 0, 0.5), renderStop("#F2F3F5", 100)])]), vue.createVNode("g", {
        "opacity": ".8",
        "data-allow-mismatch": "children"
      }, [vue.createVNode("path", {
        "d": "M36 131V53H16v20H2v58h34z",
        "fill": getUrlById("a")
      }, null), vue.createVNode("path", {
        "d": "M123 15h22v14h9v77h-31V15z",
        "fill": getUrlById("a")
      }, null)])];
      const renderCloud = () => [vue.createVNode("defs", null, [vue.createVNode("linearGradient", {
        "id": getId("b"),
        "x1": "64%",
        "y1": "97%",
        "x2": "64%",
        "y2": "0%",
        "data-allow-mismatch": "attribute"
      }, [renderStop("#F2F3F5", 0, 0.3), renderStop("#F2F3F5", 100)])]), vue.createVNode("g", {
        "opacity": ".8",
        "data-allow-mismatch": "children"
      }, [vue.createVNode("path", {
        "d": "M87 6c3 0 7 3 8 6a8 8 0 1 1-1 16H80a7 7 0 0 1-8-6c0-4 3-7 6-7 0-5 4-9 9-9Z",
        "fill": getUrlById("b")
      }, null), vue.createVNode("path", {
        "d": "M19 23c2 0 3 1 4 3 2 0 4 2 4 4a4 4 0 0 1-4 3v1h-7v-1l-1 1c-2 0-3-2-3-4 0-1 1-3 3-3 0-2 2-4 4-4Z",
        "fill": getUrlById("b")
      }, null)])];
      const renderNetwork = () => vue.createVNode("svg", {
        "viewBox": "0 0 160 160"
      }, [vue.createVNode("defs", {
        "data-allow-mismatch": "children"
      }, [vue.createVNode("linearGradient", {
        "id": getId(1),
        "x1": "64%",
        "y1": "100%",
        "x2": "64%"
      }, [renderStop("#FFF", 0, 0.5), renderStop("#F2F3F5", 100)]), vue.createVNode("linearGradient", {
        "id": getId(2),
        "x1": "50%",
        "x2": "50%",
        "y2": "84%"
      }, [renderStop("#EBEDF0", 0), renderStop("#DCDEE0", 100, 0)]), vue.createVNode("linearGradient", {
        "id": getId(3),
        "x1": "100%",
        "x2": "100%",
        "y2": "100%"
      }, [renderStops("#EAEDF0", "#DCDEE0")]), vue.createVNode("radialGradient", {
        "id": getId(4),
        "cx": "50%",
        "cy": "0%",
        "fx": "50%",
        "fy": "0%",
        "r": "100%",
        "gradientTransform": "matrix(0 1 -.54 0 .5 -.5)"
      }, [renderStop("#EBEDF0", 0), renderStop("#FFF", 100, 0)])]), vue.createVNode("g", {
        "fill": "none"
      }, [renderBuilding(), vue.createVNode("path", {
        "fill": getUrlById(4),
        "d": "M0 139h160v21H0z",
        "data-allow-mismatch": "attribute"
      }, null), vue.createVNode("path", {
        "d": "M80 54a7 7 0 0 1 3 13v27l-2 2h-2a2 2 0 0 1-2-2V67a7 7 0 0 1 3-13z",
        "fill": getUrlById(2),
        "data-allow-mismatch": "attribute"
      }, null), vue.createVNode("g", {
        "opacity": ".6",
        "stroke-linecap": "round",
        "stroke-width": "7",
        "data-allow-mismatch": "children"
      }, [vue.createVNode("path", {
        "d": "M64 47a19 19 0 0 0-5 13c0 5 2 10 5 13",
        "stroke": getUrlById(3)
      }, null), vue.createVNode("path", {
        "d": "M53 36a34 34 0 0 0 0 48",
        "stroke": getUrlById(3)
      }, null), vue.createVNode("path", {
        "d": "M95 73a19 19 0 0 0 6-13c0-5-2-9-6-13",
        "stroke": getUrlById(3)
      }, null), vue.createVNode("path", {
        "d": "M106 84a34 34 0 0 0 0-48",
        "stroke": getUrlById(3)
      }, null)]), vue.createVNode("g", {
        "transform": "translate(31 105)"
      }, [vue.createVNode("rect", {
        "fill": "#EBEDF0",
        "width": "98",
        "height": "34",
        "rx": "2"
      }, null), vue.createVNode("rect", {
        "fill": "#FFF",
        "x": "9",
        "y": "8",
        "width": "80",
        "height": "18",
        "rx": "1.1"
      }, null), vue.createVNode("rect", {
        "fill": "#EBEDF0",
        "x": "15",
        "y": "12",
        "width": "18",
        "height": "6",
        "rx": "1.1"
      }, null)])])]);
      const renderMaterial = () => vue.createVNode("svg", {
        "viewBox": "0 0 160 160"
      }, [vue.createVNode("defs", {
        "data-allow-mismatch": "children"
      }, [vue.createVNode("linearGradient", {
        "x1": "50%",
        "x2": "50%",
        "y2": "100%",
        "id": getId(5)
      }, [renderStops("#F2F3F5", "#DCDEE0")]), vue.createVNode("linearGradient", {
        "x1": "95%",
        "y1": "48%",
        "x2": "5.5%",
        "y2": "51%",
        "id": getId(6)
      }, [renderStops("#EAEDF1", "#DCDEE0")]), vue.createVNode("linearGradient", {
        "y1": "45%",
        "x2": "100%",
        "y2": "54%",
        "id": getId(7)
      }, [renderStops("#EAEDF1", "#DCDEE0")])]), renderBuilding(), renderCloud(), vue.createVNode("g", {
        "transform": "translate(36 50)",
        "fill": "none"
      }, [vue.createVNode("g", {
        "transform": "translate(8)"
      }, [vue.createVNode("rect", {
        "fill": "#EBEDF0",
        "opacity": ".6",
        "x": "38",
        "y": "13",
        "width": "36",
        "height": "53",
        "rx": "2"
      }, null), vue.createVNode("rect", {
        "fill": getUrlById(5),
        "width": "64",
        "height": "66",
        "rx": "2",
        "data-allow-mismatch": "attribute"
      }, null), vue.createVNode("rect", {
        "fill": "#FFF",
        "x": "6",
        "y": "6",
        "width": "52",
        "height": "55",
        "rx": "1"
      }, null), vue.createVNode("g", {
        "transform": "translate(15 17)",
        "fill": getUrlById(6),
        "data-allow-mismatch": "attribute"
      }, [vue.createVNode("rect", {
        "width": "34",
        "height": "6",
        "rx": "1"
      }, null), vue.createVNode("path", {
        "d": "M0 14h34v6H0z"
      }, null), vue.createVNode("rect", {
        "y": "28",
        "width": "34",
        "height": "6",
        "rx": "1"
      }, null)])]), vue.createVNode("rect", {
        "fill": getUrlById(7),
        "y": "61",
        "width": "88",
        "height": "28",
        "rx": "1",
        "data-allow-mismatch": "attribute"
      }, null), vue.createVNode("rect", {
        "fill": "#F7F8FA",
        "x": "29",
        "y": "72",
        "width": "30",
        "height": "6",
        "rx": "1"
      }, null)])]);
      const renderError = () => vue.createVNode("svg", {
        "viewBox": "0 0 160 160"
      }, [vue.createVNode("defs", null, [vue.createVNode("linearGradient", {
        "x1": "50%",
        "x2": "50%",
        "y2": "100%",
        "id": getId(8),
        "data-allow-mismatch": "attribute"
      }, [renderStops("#EAEDF1", "#DCDEE0")])]), renderBuilding(), renderCloud(), renderShadow("c"), vue.createVNode("path", {
        "d": "m59 60 21 21 21-21h3l9 9v3L92 93l21 21v3l-9 9h-3l-21-21-21 21h-3l-9-9v-3l21-21-21-21v-3l9-9h3Z",
        "fill": getUrlById(8),
        "data-allow-mismatch": "attribute"
      }, null)]);
      const renderSearch = () => vue.createVNode("svg", {
        "viewBox": "0 0 160 160"
      }, [vue.createVNode("defs", {
        "data-allow-mismatch": "children"
      }, [vue.createVNode("linearGradient", {
        "x1": "50%",
        "y1": "100%",
        "x2": "50%",
        "id": getId(9)
      }, [renderStops("#EEE", "#D8D8D8")]), vue.createVNode("linearGradient", {
        "x1": "100%",
        "y1": "50%",
        "y2": "50%",
        "id": getId(10)
      }, [renderStops("#F2F3F5", "#DCDEE0")]), vue.createVNode("linearGradient", {
        "x1": "50%",
        "x2": "50%",
        "y2": "100%",
        "id": getId(11)
      }, [renderStops("#F2F3F5", "#DCDEE0")]), vue.createVNode("linearGradient", {
        "x1": "50%",
        "x2": "50%",
        "y2": "100%",
        "id": getId(12)
      }, [renderStops("#FFF", "#F7F8FA")])]), renderBuilding(), renderCloud(), renderShadow("d"), vue.createVNode("g", {
        "transform": "rotate(-45 113 -4)",
        "fill": "none",
        "data-allow-mismatch": "children"
      }, [vue.createVNode("rect", {
        "fill": getUrlById(9),
        "x": "24",
        "y": "52.8",
        "width": "5.8",
        "height": "19",
        "rx": "1"
      }, null), vue.createVNode("rect", {
        "fill": getUrlById(10),
        "x": "22.1",
        "y": "67.3",
        "width": "9.9",
        "height": "28",
        "rx": "1"
      }, null), vue.createVNode("circle", {
        "stroke": getUrlById(11),
        "stroke-width": "8",
        "cx": "27",
        "cy": "27",
        "r": "27"
      }, null), vue.createVNode("circle", {
        "fill": getUrlById(12),
        "cx": "27",
        "cy": "27",
        "r": "16"
      }, null), vue.createVNode("path", {
        "d": "M37 7c-8 0-15 5-16 12",
        "stroke": getUrlById(11),
        "stroke-width": "3",
        "opacity": ".5",
        "stroke-linecap": "round",
        "transform": "rotate(45 29 13)"
      }, null)])]);
      const renderImage = () => {
        var _a;
        if (slots.image) {
          return slots.image();
        }
        const PRESET_IMAGES = {
          error: renderError,
          search: renderSearch,
          network: renderNetwork,
          default: renderMaterial
        };
        return ((_a = PRESET_IMAGES[props2.image]) == null ? void 0 : _a.call(PRESET_IMAGES)) || vue.createVNode("img", {
          "src": props2.image
        }, null);
      };
      return () => vue.createVNode("div", {
        "class": bem$P()
      }, [vue.createVNode("div", {
        "class": bem$P("image"),
        "style": getSizeStyle(props2.imageSize)
      }, [renderImage()]), renderDescription(), renderBottom()]);
    }
  });
  const Empty = withInstall(stdin_default$W);
  const [name$P, bem$O, t$b] = createNamespace("coupon-list");
  const couponListProps = {
    code: makeStringProp(""),
    coupons: makeArrayProp(),
    currency: makeStringProp(""),
    showCount: truthProp,
    emptyImage: String,
    enabledTitle: String,
    disabledTitle: String,
    disabledCoupons: makeArrayProp(),
    showExchangeBar: truthProp,
    showCloseButton: truthProp,
    closeButtonText: String,
    inputPlaceholder: String,
    exchangeMinLength: makeNumberProp(1),
    exchangeButtonText: String,
    displayedCouponIndex: makeNumberProp(-1),
    exchangeButtonLoading: Boolean,
    exchangeButtonDisabled: Boolean,
    chosenCoupon: {
      type: [Number, Array],
      default: -1
    }
  };
  var stdin_default$V = vue.defineComponent({
    name: name$P,
    props: couponListProps,
    emits: ["change", "exchange", "update:code"],
    setup(props2, {
      emit,
      slots
    }) {
      const [couponRefs, setCouponRefs] = useRefs();
      const root = vue.ref();
      const barRef = vue.ref();
      const activeTab = vue.ref(0);
      const listHeight = vue.ref(0);
      const currentCode = vue.ref(props2.code);
      const buttonDisabled = vue.computed(() => !props2.exchangeButtonLoading && (props2.exchangeButtonDisabled || !currentCode.value || currentCode.value.length < props2.exchangeMinLength));
      const updateListHeight = () => {
        const TABS_HEIGHT = 44;
        const rootHeight = useRect(root).height;
        const headerHeight = useRect(barRef).height + TABS_HEIGHT;
        listHeight.value = (rootHeight > headerHeight ? rootHeight : windowHeight.value) - headerHeight;
      };
      const onExchange = () => {
        emit("exchange", currentCode.value);
        if (!props2.code) {
          currentCode.value = "";
        }
      };
      const scrollToCoupon = (index2) => {
        vue.nextTick(() => {
          var _a;
          return (_a = couponRefs.value[index2]) == null ? void 0 : _a.scrollIntoView();
        });
      };
      const renderEmpty = () => vue.createVNode(Empty, {
        "image": props2.emptyImage
      }, {
        default: () => [vue.createVNode("p", {
          "class": bem$O("empty-tip")
        }, [t$b("noCoupon")])]
      });
      const renderExchangeBar = () => {
        if (props2.showExchangeBar) {
          return vue.createVNode("div", {
            "ref": barRef,
            "class": bem$O("exchange-bar")
          }, [vue.createVNode(Field, {
            "modelValue": currentCode.value,
            "onUpdate:modelValue": ($event) => currentCode.value = $event,
            "clearable": true,
            "border": false,
            "class": bem$O("field"),
            "placeholder": props2.inputPlaceholder || t$b("placeholder"),
            "maxlength": "20"
          }, null), vue.createVNode(Button, {
            "plain": true,
            "type": "primary",
            "class": bem$O("exchange"),
            "text": props2.exchangeButtonText || t$b("exchange"),
            "loading": props2.exchangeButtonLoading,
            "disabled": buttonDisabled.value,
            "onClick": onExchange
          }, null)]);
        }
      };
      const renderCouponTab = () => {
        const {
          coupons,
          chosenCoupon
        } = props2;
        const count = props2.showCount ? ` (${coupons.length})` : "";
        const title = (props2.enabledTitle || t$b("enable")) + count;
        const updateChosenCoupon = (currentValues = [], value = 0) => {
          if (currentValues.includes(value)) {
            return currentValues.filter((item) => item !== value);
          }
          return [...currentValues, value];
        };
        return vue.createVNode(Tab, {
          "title": title
        }, {
          default: () => {
            var _a;
            return [vue.createVNode("div", {
              "class": bem$O("list", {
                "with-bottom": props2.showCloseButton
              }),
              "style": {
                height: `${listHeight.value}px`
              }
            }, [coupons.map((coupon, index2) => vue.createVNode(Coupon, {
              "key": coupon.id,
              "ref": setCouponRefs(index2),
              "coupon": coupon,
              "chosen": Array.isArray(chosenCoupon) ? chosenCoupon.includes(index2) : index2 === chosenCoupon,
              "currency": props2.currency,
              "onClick": () => emit("change", Array.isArray(chosenCoupon) ? updateChosenCoupon(chosenCoupon, index2) : index2)
            }, null)), !coupons.length && renderEmpty(), (_a = slots["list-footer"]) == null ? void 0 : _a.call(slots)])];
          }
        });
      };
      const renderDisabledTab = () => {
        const {
          disabledCoupons
        } = props2;
        const count = props2.showCount ? ` (${disabledCoupons.length})` : "";
        const title = (props2.disabledTitle || t$b("disabled")) + count;
        return vue.createVNode(Tab, {
          "title": title
        }, {
          default: () => {
            var _a;
            return [vue.createVNode("div", {
              "class": bem$O("list", {
                "with-bottom": props2.showCloseButton
              }),
              "style": {
                height: `${listHeight.value}px`
              }
            }, [disabledCoupons.map((coupon) => vue.createVNode(Coupon, {
              "disabled": true,
              "key": coupon.id,
              "coupon": coupon,
              "currency": props2.currency
            }, null)), !disabledCoupons.length && renderEmpty(), (_a = slots["disabled-list-footer"]) == null ? void 0 : _a.call(slots)])];
          }
        });
      };
      vue.watch(() => props2.code, (value) => {
        currentCode.value = value;
      });
      vue.watch(windowHeight, updateListHeight);
      vue.watch(currentCode, (value) => emit("update:code", value));
      vue.watch(() => props2.displayedCouponIndex, scrollToCoupon);
      vue.onMounted(() => {
        updateListHeight();
        scrollToCoupon(props2.displayedCouponIndex);
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "class": bem$O()
      }, [renderExchangeBar(), vue.createVNode(Tabs, {
        "active": activeTab.value,
        "onUpdate:active": ($event) => activeTab.value = $event,
        "class": bem$O("tab")
      }, {
        default: () => [renderCouponTab(), renderDisabledTab()]
      }), vue.createVNode("div", {
        "class": bem$O("bottom")
      }, [slots["list-button"] ? slots["list-button"]() : vue.withDirectives(vue.createVNode(Button, {
        "round": true,
        "block": true,
        "type": "primary",
        "class": bem$O("close"),
        "text": props2.closeButtonText || t$b("close"),
        "onClick": () => emit("change", Array.isArray(props2.chosenCoupon) ? [] : -1)
      }, null), [[vue.vShow, props2.showCloseButton]])])]);
    }
  });
  const CouponList = withInstall(stdin_default$V);
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const [name$O] = createNamespace("date-picker");
  const datePickerProps = extend({}, sharedProps, {
    columnsType: {
      type: Array,
      default: () => ["year", "month", "day"]
    },
    minDate: {
      type: Date,
      default: () => new Date(currentYear - 10, 0, 1),
      validator: isDate
    },
    maxDate: {
      type: Date,
      default: () => new Date(currentYear + 10, 11, 31),
      validator: isDate
    }
  });
  var stdin_default$U = vue.defineComponent({
    name: name$O,
    props: datePickerProps,
    emits: ["confirm", "cancel", "change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const currentValues = vue.ref(props2.modelValue);
      const updatedByExternalSources = vue.ref(false);
      const pickerRef = vue.ref();
      const computedValues = vue.computed(() => updatedByExternalSources.value ? props2.modelValue : currentValues.value);
      const isMinYear = (year) => year === props2.minDate.getFullYear();
      const isMaxYear = (year) => year === props2.maxDate.getFullYear();
      const isMinMonth = (month) => month === props2.minDate.getMonth() + 1;
      const isMaxMonth = (month) => month === props2.maxDate.getMonth() + 1;
      const getValue2 = (type) => {
        const {
          minDate,
          columnsType
        } = props2;
        const index2 = columnsType.indexOf(type);
        const value = computedValues.value[index2];
        if (value) {
          return +value;
        }
        switch (type) {
          case "year":
            return minDate.getFullYear();
          case "month":
            return minDate.getMonth() + 1;
          case "day":
            return minDate.getDate();
        }
      };
      const genYearOptions = () => {
        const minYear = props2.minDate.getFullYear();
        const maxYear = props2.maxDate.getFullYear();
        return genOptions(minYear, maxYear, "year", props2.formatter, props2.filter, computedValues.value);
      };
      const genMonthOptions = () => {
        const year = getValue2("year");
        const minMonth = isMinYear(year) ? props2.minDate.getMonth() + 1 : 1;
        const maxMonth = isMaxYear(year) ? props2.maxDate.getMonth() + 1 : 12;
        return genOptions(minMonth, maxMonth, "month", props2.formatter, props2.filter, computedValues.value);
      };
      const genDayOptions = () => {
        const year = getValue2("year");
        const month = getValue2("month");
        const minDate = isMinYear(year) && isMinMonth(month) ? props2.minDate.getDate() : 1;
        const maxDate = isMaxYear(year) && isMaxMonth(month) ? props2.maxDate.getDate() : getMonthEndDay(year, month);
        return genOptions(minDate, maxDate, "day", props2.formatter, props2.filter, computedValues.value);
      };
      const confirm = () => {
        var _a;
        return (_a = pickerRef.value) == null ? void 0 : _a.confirm();
      };
      const getSelectedDate = () => currentValues.value;
      const columns = vue.computed(() => props2.columnsType.map((type) => {
        switch (type) {
          case "year":
            return genYearOptions();
          case "month":
            return genMonthOptions();
          case "day":
            return genDayOptions();
          default: {
            throw new Error(`[Vant] DatePicker: unsupported columns type: ${type}`);
          }
        }
      }));
      vue.watch(currentValues, (newValues) => {
        if (!isSameValue(newValues, props2.modelValue)) {
          emit("update:modelValue", newValues);
        }
      });
      vue.watch(() => props2.modelValue, (newValues, oldValues) => {
        updatedByExternalSources.value = isSameValue(oldValues, currentValues.value);
        newValues = formatValueRange(newValues, columns.value);
        if (!isSameValue(newValues, currentValues.value)) {
          currentValues.value = newValues;
        }
        updatedByExternalSources.value = false;
      }, {
        immediate: true
      });
      const onChange = (...args) => emit("change", ...args);
      const onCancel = (...args) => emit("cancel", ...args);
      const onConfirm = (...args) => emit("confirm", ...args);
      useExpose({
        confirm,
        getSelectedDate
      });
      return () => vue.createVNode(Picker, vue.mergeProps({
        "ref": pickerRef,
        "modelValue": currentValues.value,
        "onUpdate:modelValue": ($event) => currentValues.value = $event,
        "columns": columns.value,
        "onChange": onChange,
        "onCancel": onCancel,
        "onConfirm": onConfirm
      }, pick(props2, pickerInheritKeys)), slots);
    }
  });
  const DatePicker = withInstall(stdin_default$U);
  const [name$N, bem$N, t$a] = createNamespace("dialog");
  const dialogProps = extend({}, popupSharedProps, {
    title: String,
    theme: String,
    width: numericProp,
    message: [String, Function],
    callback: Function,
    allowHtml: Boolean,
    className: unknownProp,
    transition: makeStringProp("van-dialog-bounce"),
    messageAlign: String,
    closeOnPopstate: truthProp,
    showCancelButton: Boolean,
    cancelButtonText: String,
    cancelButtonColor: String,
    cancelButtonDisabled: Boolean,
    confirmButtonText: String,
    confirmButtonColor: String,
    confirmButtonDisabled: Boolean,
    showConfirmButton: truthProp,
    closeOnClickOverlay: Boolean,
    keyboardEnabled: truthProp
  });
  const popupInheritKeys$1 = [...popupSharedPropKeys, "transition", "closeOnPopstate"];
  var stdin_default$T = vue.defineComponent({
    name: name$N,
    props: dialogProps,
    emits: ["confirm", "cancel", "keydown", "update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const loading = vue.reactive({
        confirm: false,
        cancel: false
      });
      const updateShow = (value) => emit("update:show", value);
      const close = (action) => {
        var _a;
        updateShow(false);
        (_a = props2.callback) == null ? void 0 : _a.call(props2, action);
      };
      const getActionHandler = (action) => () => {
        if (!props2.show) {
          return;
        }
        emit(action);
        if (props2.beforeClose) {
          loading[action] = true;
          callInterceptor(props2.beforeClose, {
            args: [action],
            done() {
              close(action);
              loading[action] = false;
            },
            canceled() {
              loading[action] = false;
            }
          });
        } else {
          close(action);
        }
      };
      const onCancel = getActionHandler("cancel");
      const onConfirm = getActionHandler("confirm");
      const onKeydown = vue.withKeys((event) => {
        var _a, _b;
        if (!props2.keyboardEnabled) {
          return;
        }
        if (event.target !== ((_b = (_a = root.value) == null ? void 0 : _a.popupRef) == null ? void 0 : _b.value)) {
          return;
        }
        const onEventType = {
          Enter: props2.showConfirmButton ? onConfirm : noop$1,
          Escape: props2.showCancelButton ? onCancel : noop$1
        };
        onEventType[event.key]();
        emit("keydown", event);
      }, ["enter", "esc"]);
      const renderTitle = () => {
        const title = slots.title ? slots.title() : props2.title;
        if (title) {
          return vue.createVNode("div", {
            "class": bem$N("header", {
              isolated: !props2.message && !slots.default
            })
          }, [title]);
        }
      };
      const renderMessage = (hasTitle) => {
        const {
          message,
          allowHtml,
          messageAlign
        } = props2;
        const classNames = bem$N("message", {
          "has-title": hasTitle,
          [messageAlign]: messageAlign
        });
        const content = isFunction(message) ? message() : message;
        if (allowHtml && typeof content === "string") {
          return vue.createVNode("div", {
            "class": classNames,
            "innerHTML": content
          }, null);
        }
        return vue.createVNode("div", {
          "class": classNames
        }, [content]);
      };
      const renderContent = () => {
        if (slots.default) {
          return vue.createVNode("div", {
            "class": bem$N("content")
          }, [slots.default()]);
        }
        const {
          title,
          message,
          allowHtml
        } = props2;
        if (message) {
          const hasTitle = !!(title || slots.title);
          return vue.createVNode("div", {
            "key": allowHtml ? 1 : 0,
            "class": bem$N("content", {
              isolated: !hasTitle
            })
          }, [renderMessage(hasTitle)]);
        }
      };
      const renderButtons = () => vue.createVNode("div", {
        "class": [BORDER_TOP, bem$N("footer")]
      }, [props2.showCancelButton && vue.createVNode(Button, {
        "size": "large",
        "text": props2.cancelButtonText || t$a("cancel"),
        "class": bem$N("cancel"),
        "style": {
          color: props2.cancelButtonColor
        },
        "loading": loading.cancel,
        "disabled": props2.cancelButtonDisabled,
        "onClick": onCancel
      }, null), props2.showConfirmButton && vue.createVNode(Button, {
        "size": "large",
        "text": props2.confirmButtonText || t$a("confirm"),
        "class": [bem$N("confirm"), {
          [BORDER_LEFT]: props2.showCancelButton
        }],
        "style": {
          color: props2.confirmButtonColor
        },
        "loading": loading.confirm,
        "disabled": props2.confirmButtonDisabled,
        "onClick": onConfirm
      }, null)]);
      const renderRoundButtons = () => vue.createVNode(ActionBar, {
        "class": bem$N("footer")
      }, {
        default: () => [props2.showCancelButton && vue.createVNode(ActionBarButton, {
          "type": "warning",
          "text": props2.cancelButtonText || t$a("cancel"),
          "class": bem$N("cancel"),
          "color": props2.cancelButtonColor,
          "loading": loading.cancel,
          "disabled": props2.cancelButtonDisabled,
          "onClick": onCancel
        }, null), props2.showConfirmButton && vue.createVNode(ActionBarButton, {
          "type": "danger",
          "text": props2.confirmButtonText || t$a("confirm"),
          "class": bem$N("confirm"),
          "color": props2.confirmButtonColor,
          "loading": loading.confirm,
          "disabled": props2.confirmButtonDisabled,
          "onClick": onConfirm
        }, null)]
      });
      const renderFooter = () => {
        if (slots.footer) {
          return slots.footer();
        }
        return props2.theme === "round-button" ? renderRoundButtons() : renderButtons();
      };
      return () => {
        const {
          width: width2,
          title,
          theme,
          message,
          className
        } = props2;
        return vue.createVNode(Popup, vue.mergeProps({
          "ref": root,
          "role": "dialog",
          "class": [bem$N([theme]), className],
          "style": {
            width: addUnit$2(width2)
          },
          "tabindex": 0,
          "aria-labelledby": title || message,
          "onKeydown": onKeydown,
          "onUpdate:show": updateShow
        }, pick(props2, popupInheritKeys$1)), {
          default: () => [renderTitle(), renderContent(), renderFooter()]
        });
      };
    }
  });
  const Dialog = withInstall(stdin_default$T);
  const [name$M, bem$M] = createNamespace("divider");
  const dividerProps = {
    dashed: Boolean,
    hairline: truthProp,
    vertical: Boolean,
    contentPosition: makeStringProp("center")
  };
  var stdin_default$S = vue.defineComponent({
    name: name$M,
    props: dividerProps,
    setup(props2, {
      slots
    }) {
      return () => {
        var _a;
        return vue.createVNode("div", {
          "role": "separator",
          "class": bem$M({
            dashed: props2.dashed,
            hairline: props2.hairline,
            vertical: props2.vertical,
            [`content-${props2.contentPosition}`]: !!slots.default && !props2.vertical
          })
        }, [!props2.vertical && ((_a = slots.default) == null ? void 0 : _a.call(slots))]);
      };
    }
  });
  const Divider = withInstall(stdin_default$S);
  const [name$L, bem$L] = createNamespace("dropdown-menu");
  const dropdownMenuProps = {
    overlay: truthProp,
    zIndex: numericProp,
    duration: makeNumericProp(0.2),
    direction: makeStringProp("down"),
    activeColor: String,
    autoLocate: Boolean,
    closeOnClickOutside: truthProp,
    closeOnClickOverlay: truthProp,
    swipeThreshold: numericProp
  };
  const DROPDOWN_KEY = Symbol(name$L);
  var stdin_default$R = vue.defineComponent({
    name: name$L,
    props: dropdownMenuProps,
    setup(props2, {
      slots
    }) {
      const id = useId();
      const root = vue.ref();
      const barRef = vue.ref();
      const offset2 = vue.ref(0);
      const {
        children,
        linkChildren
      } = useChildren(DROPDOWN_KEY);
      const scrollParent = useScrollParent(root);
      const opened = vue.computed(() => children.some((item) => item.state.showWrapper));
      const scrollable = vue.computed(() => props2.swipeThreshold && children.length > +props2.swipeThreshold);
      const barStyle = vue.computed(() => {
        if (opened.value && isDef(props2.zIndex)) {
          return {
            zIndex: +props2.zIndex + 1
          };
        }
      });
      const close = () => {
        children.forEach((item) => {
          item.toggle(false);
        });
      };
      const onClickAway = () => {
        if (props2.closeOnClickOutside) {
          close();
        }
      };
      const updateOffset = () => {
        if (barRef.value) {
          const rect = useRect(barRef);
          if (props2.direction === "down") {
            offset2.value = rect.bottom;
          } else {
            offset2.value = windowHeight.value - rect.top;
          }
        }
      };
      const onScroll = () => {
        if (opened.value) {
          updateOffset();
        }
      };
      const toggleItem = (active) => {
        children.forEach((item, index2) => {
          if (index2 === active) {
            item.toggle();
          } else if (item.state.showPopup) {
            item.toggle(false, {
              immediate: true
            });
          }
        });
      };
      const renderTitle = (item, index2) => {
        const {
          showPopup
        } = item.state;
        const {
          disabled,
          titleClass
        } = item;
        return vue.createVNode("div", {
          "id": `${id}-${index2}`,
          "role": "button",
          "tabindex": disabled ? void 0 : 0,
          "data-allow-mismatch": "attribute",
          "class": [bem$L("item", {
            disabled,
            grow: scrollable.value
          }), {
            [HAPTICS_FEEDBACK]: !disabled
          }],
          "onClick": () => {
            if (!disabled) {
              toggleItem(index2);
            }
          }
        }, [vue.createVNode("span", {
          "class": [bem$L("title", {
            down: showPopup === (props2.direction === "down"),
            active: showPopup
          }), titleClass],
          "style": {
            color: showPopup ? props2.activeColor : ""
          }
        }, [vue.createVNode("div", {
          "class": "van-ellipsis"
        }, [item.renderTitle()])])]);
      };
      useExpose({
        close
      });
      linkChildren({
        id,
        props: props2,
        offset: offset2,
        updateOffset
      });
      useClickAway(root, onClickAway);
      useEventListener("scroll", onScroll, {
        target: scrollParent,
        passive: true
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$L()
        }, [vue.createVNode("div", {
          "ref": barRef,
          "style": barStyle.value,
          "class": bem$L("bar", {
            opened: opened.value,
            scrollable: scrollable.value
          })
        }, [children.map(renderTitle)]), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const [name$K, bem$K] = createNamespace("dropdown-item");
  const dropdownItemProps = {
    title: String,
    options: makeArrayProp(),
    disabled: Boolean,
    teleport: [String, Object],
    lazyRender: truthProp,
    modelValue: unknownProp,
    titleClass: unknownProp
  };
  var stdin_default$Q = vue.defineComponent({
    name: name$K,
    inheritAttrs: false,
    props: dropdownItemProps,
    emits: ["open", "opened", "close", "closed", "change", "update:modelValue"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      const state = vue.reactive({
        showPopup: false,
        transition: true,
        showWrapper: false
      });
      const wrapperRef = vue.ref();
      const {
        parent,
        index: index2
      } = useParent(DROPDOWN_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/dropdown-item/DropdownItem.mjs:41", "[Vant] <DropdownItem> must be a child component of <DropdownMenu>.");
        }
        return;
      }
      const getEmitter = (name2) => () => emit(name2);
      const onOpen = getEmitter("open");
      const onClose = getEmitter("close");
      const onOpened = getEmitter("opened");
      const onClosed = () => {
        state.showWrapper = false;
        emit("closed");
      };
      const onClickWrapper = (event) => {
        if (props2.teleport) {
          event.stopPropagation();
        }
      };
      const toggle = (show = !state.showPopup, options = {}) => {
        if (show === state.showPopup) {
          return;
        }
        state.showPopup = show;
        state.transition = !options.immediate;
        if (show) {
          parent.updateOffset();
          state.showWrapper = true;
        }
      };
      const renderTitle = () => {
        if (slots.title) {
          return slots.title();
        }
        if (props2.title) {
          return props2.title;
        }
        const match = props2.options.find((option) => option.value === props2.modelValue);
        return match ? match.text : "";
      };
      const renderOption = (option) => {
        const {
          activeColor
        } = parent.props;
        const {
          disabled
        } = option;
        const active = option.value === props2.modelValue;
        const onClick = () => {
          if (disabled) {
            return;
          }
          state.showPopup = false;
          if (option.value !== props2.modelValue) {
            emit("update:modelValue", option.value);
            emit("change", option.value);
          }
        };
        const renderIcon = () => {
          if (active) {
            return vue.createVNode(Icon, {
              "class": bem$K("icon"),
              "color": disabled ? void 0 : activeColor,
              "name": "success"
            }, null);
          }
        };
        return vue.createVNode(Cell, {
          "role": "menuitem",
          "key": String(option.value),
          "icon": option.icon,
          "title": option.text,
          "class": bem$K("option", {
            active,
            disabled
          }),
          "style": {
            color: active ? activeColor : ""
          },
          "tabindex": active ? 0 : -1,
          "clickable": !disabled,
          "onClick": onClick
        }, {
          value: renderIcon
        });
      };
      const renderContent = () => {
        const {
          offset: offset2
        } = parent;
        const {
          autoLocate,
          zIndex,
          overlay,
          duration,
          direction,
          closeOnClickOverlay
        } = parent.props;
        const style = getZIndexStyle(zIndex);
        let offsetValue = offset2.value;
        if (autoLocate && wrapperRef.value) {
          const offsetParent = getContainingBlock$1(wrapperRef.value);
          if (offsetParent) {
            offsetValue -= useRect(offsetParent).top;
          }
        }
        if (direction === "down") {
          style.top = `${offsetValue}px`;
        } else {
          style.bottom = `${offsetValue}px`;
        }
        return vue.withDirectives(vue.createVNode("div", vue.mergeProps({
          "ref": wrapperRef,
          "style": style,
          "class": bem$K([direction]),
          "onClick": onClickWrapper
        }, attrs), [vue.createVNode(Popup, {
          "show": state.showPopup,
          "onUpdate:show": ($event) => state.showPopup = $event,
          "role": "menu",
          "class": bem$K("content"),
          "overlay": overlay,
          "position": direction === "down" ? "top" : "bottom",
          "duration": state.transition ? duration : 0,
          "lazyRender": props2.lazyRender,
          "overlayStyle": {
            position: "absolute"
          },
          "aria-labelledby": `${parent.id}-${index2.value}`,
          "data-allow-mismatch": "attribute",
          "closeOnClickOverlay": closeOnClickOverlay,
          "onOpen": onOpen,
          "onClose": onClose,
          "onOpened": onOpened,
          "onClosed": onClosed
        }, {
          default: () => {
            var _a;
            return [props2.options.map(renderOption), (_a = slots.default) == null ? void 0 : _a.call(slots)];
          }
        })]), [[vue.vShow, state.showWrapper]]);
      };
      useExpose({
        state,
        toggle,
        renderTitle
      });
      return () => {
        if (props2.teleport) {
          return vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [renderContent()]
          });
        }
        return renderContent();
      };
    }
  });
  const DropdownItem = withInstall(stdin_default$Q);
  const DropdownMenu = withInstall(stdin_default$R);
  const floatingBubbleProps = {
    gap: makeNumberProp(24),
    icon: String,
    axis: makeStringProp("y"),
    magnetic: String,
    offset: {
      type: Object,
      default: () => ({
        x: -1,
        y: -1
      })
    },
    teleport: {
      type: [String, Object],
      default: "body"
    }
  };
  const [name$J, bem$J] = createNamespace("floating-bubble");
  var stdin_default$P = vue.defineComponent({
    name: name$J,
    inheritAttrs: false,
    props: floatingBubbleProps,
    emits: ["click", "update:offset", "offsetChange"],
    setup(props2, {
      slots,
      emit,
      attrs
    }) {
      const rootRef = vue.ref();
      const state = vue.ref({
        x: 0,
        y: 0,
        width: 0,
        height: 0
      });
      const boundary = vue.computed(() => ({
        top: props2.gap,
        right: windowWidth.value - state.value.width - props2.gap,
        bottom: windowHeight.value - state.value.height - props2.gap,
        left: props2.gap
      }));
      const dragging = vue.ref(false);
      let initialized = false;
      const rootStyle = vue.computed(() => {
        const style = {};
        const x = addUnit$2(state.value.x);
        const y = addUnit$2(state.value.y);
        style.transform = `translate3d(${x}, ${y}, 0)`;
        if (dragging.value || !initialized) {
          style.transition = "none";
        }
        return style;
      });
      const updateState = () => {
        if (!show.value)
          return;
        const {
          width: width2,
          height: height2
        } = useRect(rootRef.value);
        const {
          offset: offset2
        } = props2;
        state.value = {
          x: offset2.x > -1 ? offset2.x : windowWidth.value - width2 - props2.gap,
          y: offset2.y > -1 ? offset2.y : windowHeight.value - height2 - props2.gap,
          width: width2,
          height: height2
        };
      };
      const touch = useTouch();
      let prevX = 0;
      let prevY = 0;
      const onTouchStart = (e2) => {
        touch.start(e2);
        dragging.value = true;
        prevX = state.value.x;
        prevY = state.value.y;
      };
      const onTouchMove = (e2) => {
        e2.preventDefault();
        touch.move(e2);
        if (props2.axis === "lock")
          return;
        if (!touch.isTap.value) {
          if (props2.axis === "x" || props2.axis === "xy") {
            let nextX = prevX + touch.deltaX.value;
            if (nextX < boundary.value.left)
              nextX = boundary.value.left;
            if (nextX > boundary.value.right)
              nextX = boundary.value.right;
            state.value.x = nextX;
          }
          if (props2.axis === "y" || props2.axis === "xy") {
            let nextY = prevY + touch.deltaY.value;
            if (nextY < boundary.value.top)
              nextY = boundary.value.top;
            if (nextY > boundary.value.bottom)
              nextY = boundary.value.bottom;
            state.value.y = nextY;
          }
          const offset2 = pick(state.value, ["x", "y"]);
          emit("update:offset", offset2);
        }
      };
      useEventListener("touchmove", onTouchMove, {
        target: rootRef
      });
      const onTouchEnd = () => {
        dragging.value = false;
        vue.nextTick(() => {
          if (props2.magnetic === "x") {
            const nextX = closest([boundary.value.left, boundary.value.right], state.value.x);
            state.value.x = nextX;
          }
          if (props2.magnetic === "y") {
            const nextY = closest([boundary.value.top, boundary.value.bottom], state.value.y);
            state.value.y = nextY;
          }
          if (!touch.isTap.value) {
            const offset2 = pick(state.value, ["x", "y"]);
            emit("update:offset", offset2);
            if (prevX !== offset2.x || prevY !== offset2.y) {
              emit("offsetChange", offset2);
            }
          }
        });
      };
      const onClick = (e2) => {
        if (touch.isTap.value)
          emit("click", e2);
        else
          e2.stopPropagation();
      };
      vue.onMounted(() => {
        updateState();
        vue.nextTick(() => {
          initialized = true;
        });
      });
      vue.watch([windowWidth, windowHeight, () => props2.gap, () => props2.offset], updateState, {
        deep: true
      });
      const show = vue.ref(true);
      vue.onActivated(() => {
        show.value = true;
      });
      vue.onDeactivated(() => {
        if (props2.teleport) {
          show.value = false;
        }
      });
      return () => {
        const Content = vue.withDirectives(vue.createVNode("div", vue.mergeProps({
          "class": bem$J(),
          "ref": rootRef,
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd,
          "onClickCapture": onClick,
          "style": rootStyle.value
        }, attrs), [slots.default ? slots.default() : vue.createVNode(stdin_default$1N, {
          "name": props2.icon,
          "class": bem$J("icon")
        }, null)]), [[vue.vShow, show.value]]);
        return props2.teleport ? vue.createVNode(vue.Teleport, {
          "to": props2.teleport
        }, {
          default: () => [Content]
        }) : Content;
      };
    }
  });
  const FloatingBubble = withInstall(stdin_default$P);
  const floatingPanelProps = {
    height: makeNumericProp(0),
    anchors: makeArrayProp(),
    duration: makeNumericProp(0.3),
    contentDraggable: truthProp,
    lockScroll: Boolean,
    safeAreaInsetBottom: truthProp
  };
  const [name$I, bem$I] = createNamespace("floating-panel");
  var stdin_default$O = vue.defineComponent({
    name: name$I,
    props: floatingPanelProps,
    emits: ["heightChange", "update:height"],
    setup(props2, {
      emit,
      slots
    }) {
      const DAMP = 0.2;
      const rootRef = vue.ref();
      const contentRef = vue.ref();
      const height2 = useSyncPropRef(() => +props2.height, (value) => emit("update:height", value));
      const boundary = vue.computed(() => {
        var _a, _b;
        return {
          min: (_a = props2.anchors[0]) != null ? _a : 100,
          max: (_b = props2.anchors[props2.anchors.length - 1]) != null ? _b : Math.round(windowHeight.value * 0.6)
        };
      });
      const anchors = vue.computed(() => props2.anchors.length >= 2 ? props2.anchors : [boundary.value.min, boundary.value.max]);
      const dragging = vue.ref(false);
      const rootStyle = vue.computed(() => ({
        height: addUnit$2(boundary.value.max),
        transform: `translateY(calc(100% + ${addUnit$2(-height2.value)}))`,
        transition: !dragging.value ? `transform ${props2.duration}s cubic-bezier(0.18, 0.89, 0.32, 1.28)` : "none"
      }));
      const ease = (moveY) => {
        const absDistance = Math.abs(moveY);
        const {
          min,
          max
        } = boundary.value;
        if (absDistance > max) {
          return -(max + (absDistance - max) * DAMP);
        }
        if (absDistance < min) {
          return -(min - (min - absDistance) * DAMP);
        }
        return moveY;
      };
      let startY;
      let maxScroll = -1;
      const touch = useTouch();
      const onTouchstart = (e2) => {
        touch.start(e2);
        dragging.value = true;
        startY = -height2.value;
        maxScroll = -1;
      };
      const onTouchmove = (e2) => {
        var _a;
        touch.move(e2);
        const target = e2.target;
        if (contentRef.value === target || ((_a = contentRef.value) == null ? void 0 : _a.contains(target))) {
          const {
            scrollTop
          } = contentRef.value;
          maxScroll = Math.max(maxScroll, scrollTop);
          if (!props2.contentDraggable)
            return;
          if (-startY < boundary.value.max) {
            preventDefault(e2, true);
          } else if (!(scrollTop <= 0 && touch.deltaY.value > 0) || maxScroll > 0) {
            return;
          }
        }
        const moveY = touch.deltaY.value + startY;
        height2.value = -ease(moveY);
      };
      const onTouchend = () => {
        maxScroll = -1;
        dragging.value = false;
        height2.value = closest(anchors.value, height2.value);
        if (height2.value !== -startY) {
          emit("heightChange", {
            height: height2.value
          });
        }
      };
      vue.watch(boundary, () => {
        height2.value = closest(anchors.value, height2.value);
      }, {
        immediate: true
      });
      useLockScroll(rootRef, () => props2.lockScroll || dragging.value);
      useEventListener("touchmove", onTouchmove, {
        target: rootRef
      });
      const renderHeader = () => {
        if (slots.header) {
          return slots.header();
        }
        return vue.createVNode("div", {
          "class": bem$I("header")
        }, [vue.createVNode("div", {
          "class": bem$I("header-bar")
        }, null)]);
      };
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": [bem$I(), {
            "van-safe-area-bottom": props2.safeAreaInsetBottom
          }],
          "ref": rootRef,
          "style": rootStyle.value,
          "onTouchstartPassive": onTouchstart,
          "onTouchend": onTouchend,
          "onTouchcancel": onTouchend
        }, [renderHeader(), vue.createVNode("div", {
          "class": bem$I("content"),
          "ref": contentRef
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
      };
    }
  });
  const FloatingPanel = withInstall(stdin_default$O);
  const [name$H, bem$H] = createNamespace("grid");
  const gridProps = {
    square: Boolean,
    center: truthProp,
    border: truthProp,
    gutter: numericProp,
    reverse: Boolean,
    iconSize: numericProp,
    direction: String,
    clickable: Boolean,
    columnNum: makeNumericProp(4)
  };
  const GRID_KEY = Symbol(name$H);
  var stdin_default$N = vue.defineComponent({
    name: name$H,
    props: gridProps,
    setup(props2, {
      slots
    }) {
      const {
        linkChildren
      } = useChildren(GRID_KEY);
      linkChildren({
        props: props2
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "style": {
            paddingLeft: addUnit$2(props2.gutter)
          },
          "class": [bem$H(), {
            [BORDER_TOP]: props2.border && !props2.gutter
          }]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Grid = withInstall(stdin_default$N);
  const [name$G, bem$G] = createNamespace("grid-item");
  const gridItemProps = extend({}, routeProps, {
    dot: Boolean,
    text: String,
    icon: String,
    badge: numericProp,
    iconColor: String,
    iconPrefix: String,
    badgeProps: Object
  });
  var stdin_default$M = vue.defineComponent({
    name: name$G,
    props: gridItemProps,
    setup(props2, {
      slots
    }) {
      const {
        parent,
        index: index2
      } = useParent(GRID_KEY);
      const route2 = useRoute();
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/grid-item/GridItem.mjs:31", "[Vant] <GridItem> must be a child component of <Grid>.");
        }
        return;
      }
      const rootStyle = vue.computed(() => {
        const {
          square,
          gutter,
          columnNum
        } = parent.props;
        const percent = `${100 / +columnNum}%`;
        const style = {
          flexBasis: percent
        };
        if (square) {
          style.paddingTop = percent;
        } else if (gutter) {
          const gutterValue = addUnit$2(gutter);
          style.paddingRight = gutterValue;
          if (index2.value >= +columnNum) {
            style.marginTop = gutterValue;
          }
        }
        return style;
      });
      const contentStyle = vue.computed(() => {
        const {
          square,
          gutter
        } = parent.props;
        if (square && gutter) {
          const gutterValue = addUnit$2(gutter);
          return {
            right: gutterValue,
            bottom: gutterValue,
            height: "auto"
          };
        }
      });
      const renderIcon = () => {
        if (slots.icon) {
          return vue.createVNode(Badge, vue.mergeProps({
            "dot": props2.dot,
            "content": props2.badge
          }, props2.badgeProps), {
            default: slots.icon
          });
        }
        if (props2.icon) {
          return vue.createVNode(Icon, {
            "dot": props2.dot,
            "name": props2.icon,
            "size": parent.props.iconSize,
            "badge": props2.badge,
            "class": bem$G("icon"),
            "color": props2.iconColor,
            "badgeProps": props2.badgeProps,
            "classPrefix": props2.iconPrefix
          }, null);
        }
      };
      const renderText = () => {
        if (slots.text) {
          return slots.text();
        }
        if (props2.text) {
          return vue.createVNode("span", {
            "class": bem$G("text")
          }, [props2.text]);
        }
      };
      const renderContent = () => {
        if (slots.default) {
          return slots.default();
        }
        return [renderIcon(), renderText()];
      };
      return () => {
        const {
          center,
          border,
          square,
          gutter,
          reverse,
          direction,
          clickable
        } = parent.props;
        const classes = [bem$G("content", [direction, {
          center,
          square,
          reverse,
          clickable,
          surround: border && gutter
        }]), {
          [BORDER]: border
        }];
        return vue.createVNode("div", {
          "class": [bem$G({
            square
          })],
          "style": rootStyle.value
        }, [vue.createVNode("div", {
          "role": clickable ? "button" : void 0,
          "class": classes,
          "style": contentStyle.value,
          "tabindex": clickable ? 0 : void 0,
          "onClick": route2
        }, [renderContent()])]);
      };
    }
  });
  const GridItem = withInstall(stdin_default$M);
  const [name$F, bem$F] = createNamespace("highlight");
  const highlightProps = {
    autoEscape: truthProp,
    caseSensitive: Boolean,
    highlightClass: String,
    highlightTag: makeStringProp("span"),
    keywords: makeRequiredProp([String, Array]),
    sourceString: makeStringProp(""),
    tag: makeStringProp("div"),
    unhighlightClass: String,
    unhighlightTag: makeStringProp("span")
  };
  var stdin_default$L = vue.defineComponent({
    name: name$F,
    props: highlightProps,
    setup(props2) {
      const highlightChunks = vue.computed(() => {
        const {
          autoEscape,
          caseSensitive,
          keywords,
          sourceString
        } = props2;
        const flags = caseSensitive ? "g" : "gi";
        const _keywords = Array.isArray(keywords) ? keywords : [keywords];
        let chunks = _keywords.filter((keyword) => keyword).reduce((chunks2, keyword) => {
          if (autoEscape) {
            keyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          const regex = new RegExp(keyword, flags);
          let match;
          while (match = regex.exec(sourceString)) {
            const start2 = match.index;
            const end2 = regex.lastIndex;
            if (start2 >= end2) {
              regex.lastIndex++;
              continue;
            }
            chunks2.push({
              start: start2,
              end: end2,
              highlight: true
            });
          }
          return chunks2;
        }, []);
        chunks = chunks.sort((a2, b2) => a2.start - b2.start).reduce((chunks2, currentChunk) => {
          const prevChunk = chunks2[chunks2.length - 1];
          if (!prevChunk || currentChunk.start > prevChunk.end) {
            const unhighlightStart = prevChunk ? prevChunk.end : 0;
            const unhighlightEnd = currentChunk.start;
            if (unhighlightStart !== unhighlightEnd) {
              chunks2.push({
                start: unhighlightStart,
                end: unhighlightEnd,
                highlight: false
              });
            }
            chunks2.push(currentChunk);
          } else {
            prevChunk.end = Math.max(prevChunk.end, currentChunk.end);
          }
          return chunks2;
        }, []);
        const lastChunk = chunks[chunks.length - 1];
        if (!lastChunk) {
          chunks.push({
            start: 0,
            end: sourceString.length,
            highlight: false
          });
        }
        if (lastChunk && lastChunk.end < sourceString.length) {
          chunks.push({
            start: lastChunk.end,
            end: sourceString.length,
            highlight: false
          });
        }
        return chunks;
      });
      const renderContent = () => {
        const {
          sourceString,
          highlightClass,
          unhighlightClass,
          highlightTag,
          unhighlightTag
        } = props2;
        return highlightChunks.value.map((chunk) => {
          const {
            start: start2,
            end: end2,
            highlight
          } = chunk;
          const text = sourceString.slice(start2, end2);
          if (highlight) {
            return vue.createVNode(highlightTag, {
              "class": [bem$F("tag"), highlightClass]
            }, {
              default: () => [text]
            });
          }
          return vue.createVNode(unhighlightTag, {
            "class": unhighlightClass
          }, {
            default: () => [text]
          });
        });
      };
      return () => {
        const {
          tag
        } = props2;
        return vue.createVNode(tag, {
          "class": bem$F()
        }, {
          default: () => [renderContent()]
        });
      };
    }
  });
  const Highlight = withInstall(stdin_default$L);
  const getDistance = (touches) => Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);
  const getCenter = (touches) => ({
    x: (touches[0].clientX + touches[1].clientX) / 2,
    y: (touches[0].clientY + touches[1].clientY) / 2
  });
  const bem$E = createNamespace("image-preview")[1];
  const longImageRatio = 2.6;
  const imagePreviewItemProps = {
    src: String,
    show: Boolean,
    active: Number,
    minZoom: makeRequiredProp(numericProp),
    maxZoom: makeRequiredProp(numericProp),
    rootWidth: makeRequiredProp(Number),
    rootHeight: makeRequiredProp(Number),
    disableZoom: Boolean,
    doubleScale: Boolean,
    closeOnClickImage: Boolean,
    closeOnClickOverlay: Boolean,
    vertical: Boolean
  };
  var stdin_default$K = vue.defineComponent({
    props: imagePreviewItemProps,
    emits: ["scale", "close", "longPress"],
    setup(props2, {
      emit,
      slots
    }) {
      const state = vue.reactive({
        scale: 1,
        moveX: 0,
        moveY: 0,
        moving: false,
        zooming: false,
        initializing: false,
        imageRatio: 0
      });
      const touch = useTouch();
      const imageRef = vue.ref();
      const swipeItem = vue.ref();
      const vertical = vue.ref(false);
      const isLongImage = vue.ref(false);
      let initialMoveY = 0;
      const imageStyle = vue.computed(() => {
        const {
          scale,
          moveX,
          moveY,
          moving,
          zooming,
          initializing
        } = state;
        const style = {
          transitionDuration: zooming || moving || initializing ? "0s" : ".3s"
        };
        if (scale !== 1 || isLongImage.value) {
          style.transform = `matrix(${scale}, 0, 0, ${scale}, ${moveX}, ${moveY})`;
        }
        return style;
      });
      const maxMoveX = vue.computed(() => {
        if (state.imageRatio) {
          const {
            rootWidth,
            rootHeight
          } = props2;
          const displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;
          return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);
        }
        return 0;
      });
      const maxMoveY = vue.computed(() => {
        if (state.imageRatio) {
          const {
            rootWidth,
            rootHeight
          } = props2;
          const displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;
          return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);
        }
        return 0;
      });
      const setScale = (scale, center) => {
        var _a;
        scale = clamp(scale, +props2.minZoom, +props2.maxZoom + 1);
        if (scale !== state.scale) {
          const ratio = scale / state.scale;
          state.scale = scale;
          if (center) {
            const imageRect = useRect((_a = imageRef.value) == null ? void 0 : _a.$el);
            const origin = {
              x: imageRect.width * 0.5,
              y: imageRect.height * 0.5
            };
            const moveX = state.moveX - (center.x - imageRect.left - origin.x) * (ratio - 1);
            const moveY = state.moveY - (center.y - imageRect.top - origin.y) * (ratio - 1);
            state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);
            state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);
          } else {
            state.moveX = 0;
            state.moveY = isLongImage.value ? initialMoveY : 0;
          }
          emit("scale", {
            scale,
            index: props2.active
          });
        }
      };
      const resetScale = () => {
        setScale(1);
      };
      const toggleScale = () => {
        const scale = state.scale > 1 ? 1 : 2;
        setScale(scale, scale === 2 || isLongImage.value ? {
          x: touch.startX.value,
          y: touch.startY.value
        } : void 0);
      };
      let fingerNum;
      let startMoveX;
      let startMoveY;
      let startScale;
      let startDistance;
      let lastCenter;
      let doubleTapTimer;
      let touchStartTime;
      let isImageMoved = false;
      const onTouchStart = (event) => {
        const {
          touches
        } = event;
        fingerNum = touches.length;
        if (fingerNum === 2 && props2.disableZoom) {
          return;
        }
        const {
          offsetX
        } = touch;
        touch.start(event);
        startMoveX = state.moveX;
        startMoveY = state.moveY;
        touchStartTime = Date.now();
        isImageMoved = false;
        state.moving = fingerNum === 1 && (state.scale !== 1 || isLongImage.value);
        state.zooming = fingerNum === 2 && !offsetX.value;
        if (state.zooming) {
          startScale = state.scale;
          startDistance = getDistance(touches);
        }
      };
      const onTouchMove = (event) => {
        const {
          touches
        } = event;
        touch.move(event);
        if (state.moving) {
          const {
            deltaX,
            deltaY
          } = touch;
          const moveX = deltaX.value + startMoveX;
          const moveY = deltaY.value + startMoveY;
          if ((props2.vertical ? touch.isVertical() && Math.abs(moveY) > maxMoveY.value : touch.isHorizontal() && Math.abs(moveX) > maxMoveX.value) && !isImageMoved) {
            state.moving = false;
            return;
          }
          isImageMoved = true;
          preventDefault(event, true);
          state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);
          state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);
        }
        if (state.zooming) {
          preventDefault(event, true);
          if (touches.length === 2) {
            const distance = getDistance(touches);
            const scale = startScale * distance / startDistance;
            lastCenter = getCenter(touches);
            setScale(scale, lastCenter);
          }
        }
      };
      const checkClose = (event) => {
        var _a;
        const swipeItemEl = (_a = swipeItem.value) == null ? void 0 : _a.$el;
        if (!swipeItemEl)
          return;
        const imageEl = swipeItemEl.firstElementChild;
        const isClickOverlay = event.target === swipeItemEl;
        const isClickImage = imageEl == null ? void 0 : imageEl.contains(event.target);
        if (!props2.closeOnClickImage && isClickImage)
          return;
        if (!props2.closeOnClickOverlay && isClickOverlay)
          return;
        emit("close");
      };
      const checkTap = (event) => {
        if (fingerNum > 1) {
          return;
        }
        const deltaTime = Date.now() - touchStartTime;
        const TAP_TIME = 250;
        if (touch.isTap.value) {
          if (deltaTime < TAP_TIME) {
            if (props2.doubleScale) {
              if (doubleTapTimer) {
                clearTimeout(doubleTapTimer);
                doubleTapTimer = null;
                toggleScale();
              } else {
                doubleTapTimer = setTimeout(() => {
                  checkClose(event);
                  doubleTapTimer = null;
                }, TAP_TIME);
              }
            } else {
              checkClose(event);
            }
          } else if (deltaTime > LONG_PRESS_START_TIME) {
            emit("longPress");
          }
        }
      };
      const onTouchEnd = (event) => {
        let stopPropagation2 = false;
        if (state.moving || state.zooming) {
          stopPropagation2 = true;
          if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {
            stopPropagation2 = false;
          }
          if (!event.touches.length) {
            if (state.zooming) {
              state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);
              state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);
              state.zooming = false;
            }
            state.moving = false;
            startMoveX = 0;
            startMoveY = 0;
            startScale = 1;
            if (state.scale < 1) {
              resetScale();
            }
            const maxZoom = +props2.maxZoom;
            if (state.scale > maxZoom) {
              setScale(maxZoom, lastCenter);
            }
          }
        }
        preventDefault(event, stopPropagation2);
        checkTap(event);
        touch.reset();
      };
      const resize = () => {
        const {
          rootWidth,
          rootHeight
        } = props2;
        const rootRatio = rootHeight / rootWidth;
        const {
          imageRatio
        } = state;
        vertical.value = state.imageRatio > rootRatio && imageRatio < longImageRatio;
        isLongImage.value = state.imageRatio > rootRatio && imageRatio >= longImageRatio;
        if (isLongImage.value) {
          initialMoveY = (imageRatio * rootWidth - rootHeight) / 2;
          state.moveY = initialMoveY;
          state.initializing = true;
          raf(() => {
            state.initializing = false;
          });
        }
        resetScale();
      };
      const onLoad2 = (event) => {
        const {
          naturalWidth,
          naturalHeight
        } = event.target;
        state.imageRatio = naturalHeight / naturalWidth;
        resize();
      };
      vue.watch(() => props2.active, resetScale);
      vue.watch(() => props2.show, (value) => {
        if (!value) {
          resetScale();
        }
      });
      vue.watch(() => [props2.rootWidth, props2.rootHeight], resize);
      useEventListener("touchmove", onTouchMove, {
        target: vue.computed(() => {
          var _a;
          return (_a = swipeItem.value) == null ? void 0 : _a.$el;
        })
      });
      useExpose({
        resetScale
      });
      return () => {
        const imageSlots = {
          loading: () => vue.createVNode(Loading, {
            "type": "spinner"
          }, null)
        };
        return vue.createVNode(SwipeItem, {
          "ref": swipeItem,
          "class": bem$E("swipe-item"),
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd
        }, {
          default: () => [slots.image ? vue.createVNode("div", {
            "class": bem$E("image-wrap")
          }, [slots.image({
            src: props2.src,
            onLoad: onLoad2,
            style: imageStyle.value
          })]) : vue.createVNode(Image$1, {
            "ref": imageRef,
            "src": props2.src,
            "fit": "contain",
            "class": bem$E("image", {
              vertical: vertical.value
            }),
            "style": imageStyle.value,
            "onLoad": onLoad2
          }, imageSlots)]
        });
      };
    }
  });
  const [name$E, bem$D] = createNamespace("image-preview");
  const popupProps$1 = ["show", "teleport", "transition", "overlayStyle", "closeOnPopstate"];
  const imagePreviewProps = {
    show: Boolean,
    loop: truthProp,
    images: makeArrayProp(),
    minZoom: makeNumericProp(1 / 3),
    maxZoom: makeNumericProp(3),
    overlay: truthProp,
    vertical: Boolean,
    closeable: Boolean,
    showIndex: truthProp,
    className: unknownProp,
    closeIcon: makeStringProp("clear"),
    transition: String,
    beforeClose: Function,
    doubleScale: truthProp,
    overlayClass: unknownProp,
    overlayStyle: Object,
    swipeDuration: makeNumericProp(300),
    startPosition: makeNumericProp(0),
    showIndicators: Boolean,
    closeOnPopstate: truthProp,
    closeOnClickImage: truthProp,
    closeOnClickOverlay: truthProp,
    closeIconPosition: makeStringProp("top-right"),
    teleport: [String, Object]
  };
  var stdin_default$J = vue.defineComponent({
    name: name$E,
    props: imagePreviewProps,
    emits: ["scale", "close", "closed", "change", "longPress", "update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      const swipeRef = vue.ref();
      const activedPreviewItemRef = vue.ref();
      const state = vue.reactive({
        active: 0,
        rootWidth: 0,
        rootHeight: 0,
        disableZoom: false
      });
      const resize = () => {
        if (swipeRef.value) {
          const rect = useRect(swipeRef.value.$el);
          state.rootWidth = rect.width;
          state.rootHeight = rect.height;
          swipeRef.value.resize();
        }
      };
      const emitScale = (args) => emit("scale", args);
      const updateShow = (show) => emit("update:show", show);
      const emitClose = () => {
        callInterceptor(props2.beforeClose, {
          args: [state.active],
          done: () => updateShow(false)
        });
      };
      const setActive = (active) => {
        if (active !== state.active) {
          state.active = active;
          emit("change", active);
        }
      };
      const renderIndex = () => {
        if (props2.showIndex) {
          return vue.createVNode("div", {
            "class": bem$D("index")
          }, [slots.index ? slots.index({
            index: state.active
          }) : `${state.active + 1} / ${props2.images.length}`]);
        }
      };
      const renderCover = () => {
        if (slots.cover) {
          return vue.createVNode("div", {
            "class": bem$D("cover")
          }, [slots.cover()]);
        }
      };
      const onDragStart = () => {
        state.disableZoom = true;
      };
      const onDragEnd = () => {
        state.disableZoom = false;
      };
      const renderImages = () => vue.createVNode(Swipe, {
        "ref": swipeRef,
        "lazyRender": true,
        "loop": props2.loop,
        "class": bem$D("swipe"),
        "vertical": props2.vertical,
        "duration": props2.swipeDuration,
        "initialSwipe": props2.startPosition,
        "showIndicators": props2.showIndicators,
        "indicatorColor": "white",
        "onChange": setActive,
        "onDragEnd": onDragEnd,
        "onDragStart": onDragStart
      }, {
        default: () => [props2.images.map((image2, index2) => vue.createVNode(stdin_default$K, {
          "ref": (item) => {
            if (index2 === state.active) {
              activedPreviewItemRef.value = item;
            }
          },
          "src": image2,
          "show": props2.show,
          "active": state.active,
          "maxZoom": props2.maxZoom,
          "minZoom": props2.minZoom,
          "rootWidth": state.rootWidth,
          "rootHeight": state.rootHeight,
          "disableZoom": state.disableZoom,
          "doubleScale": props2.doubleScale,
          "closeOnClickImage": props2.closeOnClickImage,
          "closeOnClickOverlay": props2.closeOnClickOverlay,
          "vertical": props2.vertical,
          "onScale": emitScale,
          "onClose": emitClose,
          "onLongPress": () => emit("longPress", {
            index: index2
          })
        }, {
          image: slots.image
        }))]
      });
      const renderClose = () => {
        if (props2.closeable) {
          return vue.createVNode(Icon, {
            "role": "button",
            "name": props2.closeIcon,
            "class": [bem$D("close-icon", props2.closeIconPosition), HAPTICS_FEEDBACK],
            "onClick": emitClose
          }, null);
        }
      };
      const onClosed = () => emit("closed");
      const swipeTo = (index2, options) => {
        var _a;
        return (_a = swipeRef.value) == null ? void 0 : _a.swipeTo(index2, options);
      };
      useExpose({
        resetScale: () => {
          var _a;
          (_a = activedPreviewItemRef.value) == null ? void 0 : _a.resetScale();
        },
        swipeTo
      });
      vue.onMounted(resize);
      vue.watch([windowWidth, windowHeight], resize);
      vue.watch(() => props2.startPosition, (value) => setActive(+value));
      vue.watch(() => props2.show, (value) => {
        const {
          images,
          startPosition
        } = props2;
        if (value) {
          setActive(+startPosition);
          vue.nextTick(() => {
            resize();
            swipeTo(+startPosition, {
              immediate: true
            });
          });
        } else {
          emit("close", {
            index: state.active,
            url: images[state.active]
          });
        }
      });
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": [bem$D(), props2.className],
        "overlayClass": [bem$D("overlay"), props2.overlayClass],
        "onClosed": onClosed,
        "onUpdate:show": updateShow
      }, pick(props2, popupProps$1)), {
        default: () => [renderClose(), renderImages(), renderIndex(), renderCover()]
      });
    }
  });
  let instance$1;
  const defaultConfig = {
    loop: true,
    images: [],
    maxZoom: 3,
    minZoom: 1 / 3,
    onScale: void 0,
    onClose: void 0,
    onChange: void 0,
    vertical: false,
    teleport: "body",
    className: "",
    showIndex: true,
    closeable: false,
    closeIcon: "clear",
    transition: void 0,
    beforeClose: void 0,
    doubleScale: true,
    overlayStyle: void 0,
    overlayClass: void 0,
    startPosition: 0,
    swipeDuration: 300,
    showIndicators: false,
    closeOnPopstate: true,
    closeOnClickOverlay: true,
    closeIconPosition: "top-right"
  };
  function initInstance() {
    ({
      instance: instance$1
    } = mountComponent({
      setup() {
        const {
          state,
          toggle
        } = usePopupState();
        const onClosed = () => {
          state.images = [];
        };
        return () => vue.createVNode(stdin_default$J, vue.mergeProps(state, {
          "onClosed": onClosed,
          "onUpdate:show": toggle
        }), null);
      }
    }));
  }
  const showImagePreview = (options, startPosition = 0) => {
    if (!inBrowser$1) {
      return;
    }
    if (!instance$1) {
      initInstance();
    }
    options = Array.isArray(options) ? {
      images: options,
      startPosition
    } : options;
    instance$1.open(extend({}, defaultConfig, options));
    return instance$1;
  };
  const ImagePreview = withInstall(stdin_default$J);
  function genAlphabet() {
    const charCodeOfA = "A".charCodeAt(0);
    const indexList = Array(26).fill("").map((_, i2) => String.fromCharCode(charCodeOfA + i2));
    return indexList;
  }
  const [name$D, bem$C] = createNamespace("index-bar");
  const indexBarProps = {
    sticky: truthProp,
    zIndex: numericProp,
    teleport: [String, Object],
    highlightColor: String,
    stickyOffsetTop: makeNumberProp(0),
    indexList: {
      type: Array,
      default: genAlphabet
    }
  };
  const INDEX_BAR_KEY = Symbol(name$D);
  var stdin_default$I = vue.defineComponent({
    name: name$D,
    props: indexBarProps,
    emits: ["select", "change"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const sidebar = vue.ref();
      const activeAnchor = vue.ref("");
      const touch = useTouch();
      const scrollParent = useScrollParent(root);
      const {
        children,
        linkChildren
      } = useChildren(INDEX_BAR_KEY);
      let selectActiveIndex;
      linkChildren({
        props: props2
      });
      const sidebarStyle = vue.computed(() => {
        if (isDef(props2.zIndex)) {
          return {
            zIndex: +props2.zIndex + 1
          };
        }
      });
      const highlightStyle = vue.computed(() => {
        if (props2.highlightColor) {
          return {
            color: props2.highlightColor
          };
        }
      });
      const getActiveAnchor = (scrollTop, rects) => {
        for (let i2 = children.length - 1; i2 >= 0; i2--) {
          const prevHeight = i2 > 0 ? rects[i2 - 1].height : 0;
          const reachTop = props2.sticky ? prevHeight + props2.stickyOffsetTop : 0;
          if (scrollTop + reachTop >= rects[i2].top) {
            return i2;
          }
        }
        return -1;
      };
      const getMatchAnchor = (index2) => children.find((item) => String(item.index) === index2);
      const onScroll = () => {
        if (isHidden(root)) {
          return;
        }
        const {
          sticky,
          indexList
        } = props2;
        const scrollTop = getScrollTop(scrollParent.value);
        const scrollParentRect = useRect(scrollParent);
        const rects = children.map((item) => item.getRect(scrollParent.value, scrollParentRect));
        let active = -1;
        if (selectActiveIndex) {
          const match = getMatchAnchor(selectActiveIndex);
          if (match) {
            const rect = match.getRect(scrollParent.value, scrollParentRect);
            if (props2.sticky && props2.stickyOffsetTop) {
              active = getActiveAnchor(rect.top - props2.stickyOffsetTop, rects);
            } else {
              active = getActiveAnchor(rect.top, rects);
            }
          }
        } else {
          active = getActiveAnchor(scrollTop, rects);
        }
        activeAnchor.value = indexList[active];
        if (sticky) {
          children.forEach((item, index2) => {
            const {
              state,
              $el
            } = item;
            if (index2 === active || index2 === active - 1) {
              const rect = $el.getBoundingClientRect();
              state.left = rect.left;
              state.width = rect.width;
            } else {
              state.left = null;
              state.width = null;
            }
            if (index2 === active) {
              state.active = true;
              state.top = Math.max(props2.stickyOffsetTop, rects[index2].top - scrollTop) + scrollParentRect.top;
            } else if (index2 === active - 1 && selectActiveIndex === "") {
              const activeItemTop = rects[active].top - scrollTop;
              state.active = activeItemTop > 0;
              state.top = activeItemTop + scrollParentRect.top - rects[index2].height;
            } else {
              state.active = false;
            }
          });
        }
        selectActiveIndex = "";
      };
      const init = () => {
        vue.nextTick(onScroll);
      };
      useEventListener("scroll", onScroll, {
        target: scrollParent,
        passive: true
      });
      vue.onMounted(init);
      vue.watch(() => props2.indexList, init);
      vue.watch(activeAnchor, (value) => {
        if (value) {
          emit("change", value);
        }
      });
      const renderIndexes = () => props2.indexList.map((index2) => {
        const active = index2 === activeAnchor.value;
        return vue.createVNode("span", {
          "class": bem$C("index", {
            active
          }),
          "style": active ? highlightStyle.value : void 0,
          "data-index": index2
        }, [index2]);
      });
      const scrollTo = (index2) => {
        selectActiveIndex = String(index2);
        const match = getMatchAnchor(selectActiveIndex);
        if (match) {
          const scrollTop = getScrollTop(scrollParent.value);
          const scrollParentRect = useRect(scrollParent);
          const {
            offsetHeight
          } = document.documentElement;
          match.$el.scrollIntoView();
          if (scrollTop === offsetHeight - scrollParentRect.height) {
            onScroll();
            return;
          }
          if (props2.sticky && props2.stickyOffsetTop) {
            if (getRootScrollTop() === offsetHeight - scrollParentRect.height) {
              setRootScrollTop(getRootScrollTop());
            } else {
              setRootScrollTop(getRootScrollTop() - props2.stickyOffsetTop);
            }
          }
          emit("select", match.index);
        }
      };
      const scrollToElement = (element) => {
        const {
          index: index2
        } = element.dataset;
        if (index2) {
          scrollTo(index2);
        }
      };
      const onClickSidebar = (event) => {
        scrollToElement(event.target);
      };
      let touchActiveIndex;
      const onTouchMove = (event) => {
        touch.move(event);
        if (touch.isVertical()) {
          preventDefault(event);
          const {
            clientX,
            clientY
          } = event.touches[0];
          const target = document.elementFromPoint(clientX, clientY);
          if (target) {
            const {
              index: index2
            } = target.dataset;
            if (index2 && touchActiveIndex !== index2) {
              touchActiveIndex = index2;
              scrollToElement(target);
            }
          }
        }
      };
      const renderSidebar = () => vue.createVNode("div", {
        "ref": sidebar,
        "class": bem$C("sidebar"),
        "style": sidebarStyle.value,
        "onClick": onClickSidebar,
        "onTouchstartPassive": touch.start
      }, [renderIndexes()]);
      useExpose({
        scrollTo
      });
      useEventListener("touchmove", onTouchMove, {
        target: sidebar
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$C()
        }, [props2.teleport ? vue.createVNode(vue.Teleport, {
          "to": props2.teleport
        }, {
          default: () => [renderSidebar()]
        }) : renderSidebar(), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const [name$C, bem$B] = createNamespace("index-anchor");
  const indexAnchorProps = {
    index: numericProp
  };
  var stdin_default$H = vue.defineComponent({
    name: name$C,
    props: indexAnchorProps,
    setup(props2, {
      slots
    }) {
      const state = vue.reactive({
        top: 0,
        left: null,
        rect: {
          top: 0,
          height: 0
        },
        width: null,
        active: false
      });
      const root = vue.ref();
      const {
        parent
      } = useParent(INDEX_BAR_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/index-anchor/IndexAnchor.mjs:33", "[Vant] <IndexAnchor> must be a child component of <IndexBar>.");
        }
        return;
      }
      const isSticky = () => state.active && parent.props.sticky;
      const anchorStyle = vue.computed(() => {
        const {
          zIndex,
          highlightColor
        } = parent.props;
        if (isSticky()) {
          return extend(getZIndexStyle(zIndex), {
            left: state.left ? `${state.left}px` : void 0,
            width: state.width ? `${state.width}px` : void 0,
            transform: state.top ? `translate3d(0, ${state.top}px, 0)` : void 0,
            color: highlightColor
          });
        }
      });
      const getRect = (scrollParent, scrollParentRect) => {
        const rootRect = useRect(root);
        state.rect.height = rootRect.height;
        if (scrollParent === window || scrollParent === document.body) {
          state.rect.top = rootRect.top + getRootScrollTop();
        } else {
          state.rect.top = rootRect.top + getScrollTop(scrollParent) - scrollParentRect.top;
        }
        return state.rect;
      };
      useExpose({
        state,
        getRect
      });
      return () => {
        const sticky = isSticky();
        return vue.createVNode("div", {
          "ref": root,
          "style": {
            height: sticky ? `${state.rect.height}px` : void 0
          }
        }, [vue.createVNode("div", {
          "style": anchorStyle.value,
          "class": [bem$B({
            sticky
          }), {
            [BORDER_BOTTOM]: sticky
          }]
        }, [slots.default ? slots.default() : props2.index])]);
      };
    }
  });
  const IndexAnchor = withInstall(stdin_default$H);
  const IndexBar = withInstall(stdin_default$I);
  const [name$B, bem$A, t$9] = createNamespace("list");
  const listProps = {
    error: Boolean,
    offset: makeNumericProp(300),
    loading: Boolean,
    disabled: Boolean,
    finished: Boolean,
    scroller: Object,
    errorText: String,
    direction: makeStringProp("down"),
    loadingText: String,
    finishedText: String,
    immediateCheck: truthProp
  };
  var stdin_default$G = vue.defineComponent({
    name: name$B,
    props: listProps,
    emits: ["load", "update:error", "update:loading"],
    setup(props2, {
      emit,
      slots
    }) {
      const loading = vue.ref(props2.loading);
      const root = vue.ref();
      const placeholder = vue.ref();
      const tabStatus = useTabStatus();
      const scrollParent = useScrollParent(root);
      const scroller = vue.computed(() => props2.scroller || scrollParent.value);
      const check = () => {
        vue.nextTick(() => {
          if (loading.value || props2.finished || props2.disabled || props2.error || // skip check when inside an inactive tab
          (tabStatus == null ? void 0 : tabStatus.value) === false) {
            return;
          }
          const {
            direction
          } = props2;
          const offset2 = +props2.offset;
          const scrollParentRect = useRect(scroller);
          if (!scrollParentRect.height || isHidden(root)) {
            return;
          }
          let isReachEdge = false;
          const placeholderRect = useRect(placeholder);
          if (direction === "up") {
            isReachEdge = scrollParentRect.top - placeholderRect.top <= offset2;
          } else {
            isReachEdge = placeholderRect.bottom - scrollParentRect.bottom <= offset2;
          }
          if (isReachEdge) {
            loading.value = true;
            emit("update:loading", true);
            emit("load");
          }
        });
      };
      const renderFinishedText = () => {
        if (props2.finished) {
          const text = slots.finished ? slots.finished() : props2.finishedText;
          if (text) {
            return vue.createVNode("div", {
              "class": bem$A("finished-text")
            }, [text]);
          }
        }
      };
      const clickErrorText = () => {
        emit("update:error", false);
        check();
      };
      const renderErrorText = () => {
        if (props2.error) {
          const text = slots.error ? slots.error() : props2.errorText;
          if (text) {
            return vue.createVNode("div", {
              "role": "button",
              "class": bem$A("error-text"),
              "tabindex": 0,
              "onClick": clickErrorText
            }, [text]);
          }
        }
      };
      const renderLoading = () => {
        if (loading.value && !props2.finished && !props2.disabled) {
          return vue.createVNode("div", {
            "class": bem$A("loading")
          }, [slots.loading ? slots.loading() : vue.createVNode(Loading, {
            "class": bem$A("loading-icon")
          }, {
            default: () => [props2.loadingText || t$9("loading")]
          })]);
        }
      };
      vue.watch(() => [props2.loading, props2.finished, props2.error], check);
      if (tabStatus) {
        vue.watch(tabStatus, (tabActive) => {
          if (tabActive) {
            check();
          }
        });
      }
      vue.onUpdated(() => {
        loading.value = props2.loading;
      });
      vue.onMounted(() => {
        if (props2.immediateCheck) {
          check();
        }
      });
      useExpose({
        check
      });
      useEventListener("scroll", check, {
        target: scroller,
        passive: true
      });
      return () => {
        var _a;
        const Content = (_a = slots.default) == null ? void 0 : _a.call(slots);
        const Placeholder = vue.createVNode("div", {
          "ref": placeholder,
          "class": bem$A("placeholder")
        }, null);
        return vue.createVNode("div", {
          "ref": root,
          "role": "feed",
          "class": bem$A(),
          "aria-busy": loading.value
        }, [props2.direction === "down" ? Content : Placeholder, renderLoading(), renderFinishedText(), renderErrorText(), props2.direction === "up" ? Content : Placeholder]);
      };
    }
  });
  const List = withInstall(stdin_default$G);
  const [name$A, bem$z] = createNamespace("nav-bar");
  const navBarProps = {
    title: String,
    fixed: Boolean,
    zIndex: numericProp,
    border: truthProp,
    leftText: String,
    rightText: String,
    leftDisabled: Boolean,
    rightDisabled: Boolean,
    leftArrow: Boolean,
    placeholder: Boolean,
    safeAreaInsetTop: Boolean,
    clickable: truthProp
  };
  var stdin_default$F = vue.defineComponent({
    name: name$A,
    props: navBarProps,
    emits: ["clickLeft", "clickRight"],
    setup(props2, {
      emit,
      slots
    }) {
      const navBarRef = vue.ref();
      const renderPlaceholder = usePlaceholder(navBarRef, bem$z);
      const onClickLeft = (event) => {
        if (!props2.leftDisabled) {
          emit("clickLeft", event);
        }
      };
      const onClickRight = (event) => {
        if (!props2.rightDisabled) {
          emit("clickRight", event);
        }
      };
      const renderLeft = () => {
        if (slots.left) {
          return slots.left();
        }
        return [props2.leftArrow && vue.createVNode(Icon, {
          "class": bem$z("arrow"),
          "name": "arrow-left"
        }, null), props2.leftText && vue.createVNode("span", {
          "class": bem$z("text")
        }, [props2.leftText])];
      };
      const renderRight = () => {
        if (slots.right) {
          return slots.right();
        }
        return vue.createVNode("span", {
          "class": bem$z("text")
        }, [props2.rightText]);
      };
      const renderNavBar = () => {
        const {
          title,
          fixed,
          border,
          zIndex
        } = props2;
        const style = getZIndexStyle(zIndex);
        const hasLeft = props2.leftArrow || props2.leftText || slots.left;
        const hasRight = props2.rightText || slots.right;
        return vue.createVNode("div", {
          "ref": navBarRef,
          "style": style,
          "class": [bem$z({
            fixed
          }), {
            [BORDER_BOTTOM]: border,
            "van-safe-area-top": props2.safeAreaInsetTop
          }]
        }, [vue.createVNode("div", {
          "class": bem$z("content")
        }, [hasLeft && vue.createVNode("div", {
          "class": [bem$z("left", {
            disabled: props2.leftDisabled
          }), props2.clickable && !props2.leftDisabled ? HAPTICS_FEEDBACK : ""],
          "onClick": onClickLeft
        }, [renderLeft()]), vue.createVNode("div", {
          "class": [bem$z("title"), "van-ellipsis"]
        }, [slots.title ? slots.title() : title]), hasRight && vue.createVNode("div", {
          "class": [bem$z("right", {
            disabled: props2.rightDisabled
          }), props2.clickable && !props2.rightDisabled ? HAPTICS_FEEDBACK : ""],
          "onClick": onClickRight
        }, [renderRight()])])]);
      };
      return () => {
        if (props2.fixed && props2.placeholder) {
          return renderPlaceholder(renderNavBar);
        }
        return renderNavBar();
      };
    }
  });
  const NavBar = withInstall(stdin_default$F);
  const [name$z, bem$y] = createNamespace("notice-bar");
  const noticeBarProps = {
    text: String,
    mode: String,
    color: String,
    delay: makeNumericProp(1),
    speed: makeNumericProp(60),
    leftIcon: String,
    wrapable: Boolean,
    background: String,
    scrollable: {
      type: Boolean,
      default: null
    }
  };
  var stdin_default$E = vue.defineComponent({
    name: name$z,
    props: noticeBarProps,
    emits: ["close", "replay"],
    setup(props2, {
      emit,
      slots
    }) {
      let wrapWidth = 0;
      let contentWidth = 0;
      let startTimer;
      const wrapRef = vue.ref();
      const contentRef = vue.ref();
      const state = vue.reactive({
        show: true,
        offset: 0,
        duration: 0
      });
      const renderLeftIcon = () => {
        if (slots["left-icon"]) {
          return slots["left-icon"]();
        }
        if (props2.leftIcon) {
          return vue.createVNode(Icon, {
            "class": bem$y("left-icon"),
            "name": props2.leftIcon
          }, null);
        }
      };
      const getRightIconName = () => {
        if (props2.mode === "closeable") {
          return "cross";
        }
        if (props2.mode === "link") {
          return "arrow";
        }
      };
      const onClickRightIcon = (event) => {
        if (props2.mode === "closeable") {
          state.show = false;
          emit("close", event);
        }
      };
      const renderRightIcon = () => {
        if (slots["right-icon"]) {
          return slots["right-icon"]();
        }
        const name2 = getRightIconName();
        if (name2) {
          return vue.createVNode(Icon, {
            "name": name2,
            "class": bem$y("right-icon"),
            "onClick": onClickRightIcon
          }, null);
        }
      };
      const onTransitionEnd = () => {
        state.offset = wrapWidth;
        state.duration = 0;
        raf(() => {
          doubleRaf(() => {
            state.offset = -contentWidth;
            state.duration = (contentWidth + wrapWidth) / +props2.speed;
            emit("replay");
          });
        });
      };
      const renderMarquee = () => {
        const ellipsis = props2.scrollable === false && !props2.wrapable;
        const style = {
          transform: state.offset ? `translateX(${state.offset}px)` : "",
          transitionDuration: `${state.duration}s`
        };
        return vue.createVNode("div", {
          "ref": wrapRef,
          "role": "marquee",
          "class": bem$y("wrap")
        }, [vue.createVNode("div", {
          "ref": contentRef,
          "style": style,
          "class": [bem$y("content"), {
            "van-ellipsis": ellipsis
          }],
          "onTransitionend": onTransitionEnd
        }, [slots.default ? slots.default() : props2.text])]);
      };
      const reset = () => {
        const {
          delay: delay2,
          speed,
          scrollable
        } = props2;
        const ms = isDef(delay2) ? +delay2 * 1e3 : 0;
        wrapWidth = 0;
        contentWidth = 0;
        state.offset = 0;
        state.duration = 0;
        clearTimeout(startTimer);
        startTimer = setTimeout(() => {
          if (!wrapRef.value || !contentRef.value || scrollable === false) {
            return;
          }
          const wrapRefWidth = useRect(wrapRef).width;
          const contentRefWidth = useRect(contentRef).width;
          if (scrollable || contentRefWidth > wrapRefWidth) {
            doubleRaf(() => {
              wrapWidth = wrapRefWidth;
              contentWidth = contentRefWidth;
              state.offset = -contentWidth;
              state.duration = contentWidth / +speed;
            });
          }
        }, ms);
      };
      onPopupReopen(reset);
      onMountedOrActivated(reset);
      useEventListener("pageshow", reset);
      useExpose({
        reset
      });
      vue.watch(() => [props2.text, props2.scrollable], reset);
      return () => {
        const {
          color,
          wrapable,
          background
        } = props2;
        return vue.withDirectives(vue.createVNode("div", {
          "role": "alert",
          "class": bem$y({
            wrapable
          }),
          "style": {
            color,
            background
          }
        }, [renderLeftIcon(), renderMarquee(), renderRightIcon()]), [[vue.vShow, state.show]]);
      };
    }
  });
  const NoticeBar = withInstall(stdin_default$E);
  const [name$y, bem$x] = createNamespace("notify");
  const popupInheritProps = ["lockScroll", "position", "show", "teleport", "zIndex"];
  const notifyProps = extend({}, popupSharedProps, {
    type: makeStringProp("danger"),
    color: String,
    message: numericProp,
    position: makeStringProp("top"),
    className: unknownProp,
    background: String,
    lockScroll: Boolean
  });
  var stdin_default$D = vue.defineComponent({
    name: name$y,
    props: notifyProps,
    emits: ["update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      const updateShow = (show) => emit("update:show", show);
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": [bem$x([props2.type]), props2.className],
        "style": {
          color: props2.color,
          background: props2.background
        },
        "overlay": false,
        "duration": 0.2,
        "onUpdate:show": updateShow
      }, pick(props2, popupInheritProps)), {
        default: () => [slots.default ? slots.default() : props2.message]
      });
    }
  });
  const Notify = withInstall(stdin_default$D);
  const [name$x, bem$w] = createNamespace("key");
  const CollapseIcon = vue.createVNode("svg", {
    "class": bem$w("collapse-icon"),
    "viewBox": "0 0 30 24"
  }, [vue.createVNode("path", {
    "d": "M26 13h-2v2h2v-2zm-8-3h2V8h-2v2zm2-4h2V4h-2v2zm2 4h4V4h-2v4h-2v2zm-7 14 3-3h-6l3 3zM6 13H4v2h2v-2zm16 0H8v2h14v-2zm-12-3h2V8h-2v2zM28 0l1 1 1 1v15l-1 2H1l-1-2V2l1-1 1-1zm0 2H2v15h26V2zM6 4v2H4V4zm10 2h2V4h-2v2zM8 9v1H4V8zm8 0v1h-2V8zm-6-5v2H8V4zm4 0v2h-2V4z",
    "fill": "currentColor"
  }, null)]);
  const DeleteIcon = vue.createVNode("svg", {
    "class": bem$w("delete-icon"),
    "viewBox": "0 0 32 22"
  }, [vue.createVNode("path", {
    "d": "M28 0a4 4 0 0 1 4 4v14a4 4 0 0 1-4 4H10.4a2 2 0 0 1-1.4-.6L1 13.1c-.6-.5-.9-1.3-.9-2 0-1 .3-1.7.9-2.2L9 .6a2 2 0 0 1 1.4-.6zm0 2H10.4l-8.2 8.3a1 1 0 0 0-.3.7c0 .3.1.5.3.7l8.2 8.4H28a2 2 0 0 0 2-2V4c0-1.1-.9-2-2-2zm-5 4a1 1 0 0 1 .7.3 1 1 0 0 1 0 1.4L20.4 11l3.3 3.3c.2.2.3.5.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3L19 12.4l-3.4 3.3a1 1 0 0 1-.6.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.2.1-.5.3-.7l3.3-3.3-3.3-3.3A1 1 0 0 1 14 7c0-.3.1-.5.3-.7A1 1 0 0 1 15 6a1 1 0 0 1 .6.3L19 9.6l3.3-3.3A1 1 0 0 1 23 6z",
    "fill": "currentColor"
  }, null)]);
  var stdin_default$C = vue.defineComponent({
    name: name$x,
    props: {
      type: String,
      text: numericProp,
      color: String,
      wider: Boolean,
      large: Boolean,
      loading: Boolean
    },
    emits: ["press"],
    setup(props2, {
      emit,
      slots
    }) {
      const active = vue.ref(false);
      const touch = useTouch();
      const onTouchStart = (event) => {
        touch.start(event);
        active.value = true;
      };
      const onTouchMove = (event) => {
        touch.move(event);
        if (touch.direction.value) {
          active.value = false;
        }
      };
      const onTouchEnd = (event) => {
        if (active.value) {
          if (!slots.default) {
            preventDefault(event);
          }
          active.value = false;
          emit("press", props2.text, props2.type);
        }
      };
      const renderContent = () => {
        if (props2.loading) {
          return vue.createVNode(Loading, {
            "class": bem$w("loading-icon")
          }, null);
        }
        const text = slots.default ? slots.default() : props2.text;
        switch (props2.type) {
          case "delete":
            return text || DeleteIcon;
          case "extra":
            return text || CollapseIcon;
          default:
            return text;
        }
      };
      return () => vue.createVNode("div", {
        "class": bem$w("wrapper", {
          wider: props2.wider
        }),
        "onTouchstartPassive": onTouchStart,
        "onTouchmovePassive": onTouchMove,
        "onTouchend": onTouchEnd,
        "onTouchcancel": onTouchEnd
      }, [vue.createVNode("div", {
        "role": "button",
        "tabindex": 0,
        "class": bem$w([props2.color, {
          large: props2.large,
          active: active.value,
          delete: props2.type === "delete"
        }])
      }, [renderContent()])]);
    }
  });
  const [name$w, bem$v] = createNamespace("number-keyboard");
  const numberKeyboardProps = {
    show: Boolean,
    title: String,
    theme: makeStringProp("default"),
    zIndex: numericProp,
    teleport: [String, Object],
    maxlength: makeNumericProp(Infinity),
    modelValue: makeStringProp(""),
    transition: truthProp,
    blurOnClose: truthProp,
    showDeleteKey: truthProp,
    randomKeyOrder: Boolean,
    closeButtonText: String,
    deleteButtonText: String,
    closeButtonLoading: Boolean,
    hideOnClickOutside: truthProp,
    safeAreaInsetBottom: truthProp,
    extraKey: {
      type: [String, Array],
      default: ""
    }
  };
  function shuffle(array2) {
    for (let i2 = array2.length - 1; i2 > 0; i2--) {
      const j = Math.floor(Math.random() * (i2 + 1));
      const temp = array2[i2];
      array2[i2] = array2[j];
      array2[j] = temp;
    }
    return array2;
  }
  var stdin_default$B = vue.defineComponent({
    name: name$w,
    inheritAttrs: false,
    props: numberKeyboardProps,
    emits: ["show", "hide", "blur", "input", "close", "delete", "update:modelValue"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      const root = vue.ref();
      const genBasicKeys = () => {
        const keys2 = Array(9).fill("").map((_, i2) => ({
          text: i2 + 1
        }));
        if (props2.randomKeyOrder) {
          shuffle(keys2);
        }
        return keys2;
      };
      const genDefaultKeys = () => [...genBasicKeys(), {
        text: props2.extraKey,
        type: "extra"
      }, {
        text: 0
      }, {
        text: props2.showDeleteKey ? props2.deleteButtonText : "",
        type: props2.showDeleteKey ? "delete" : ""
      }];
      const genCustomKeys = () => {
        const keys2 = genBasicKeys();
        const {
          extraKey
        } = props2;
        const extraKeys = Array.isArray(extraKey) ? extraKey : [extraKey];
        if (extraKeys.length === 0) {
          keys2.push({
            text: 0,
            wider: true
          });
        } else if (extraKeys.length === 1) {
          keys2.push({
            text: 0,
            wider: true
          }, {
            text: extraKeys[0],
            type: "extra"
          });
        } else if (extraKeys.length === 2) {
          keys2.push({
            text: extraKeys[0],
            type: "extra"
          }, {
            text: 0
          }, {
            text: extraKeys[1],
            type: "extra"
          });
        }
        return keys2;
      };
      const keys = vue.computed(() => props2.theme === "custom" ? genCustomKeys() : genDefaultKeys());
      const onBlur = () => {
        if (props2.show) {
          emit("blur");
        }
      };
      const onClose = () => {
        emit("close");
        if (props2.blurOnClose) {
          onBlur();
        }
      };
      const onAnimationEnd = () => emit(props2.show ? "show" : "hide");
      const onPress = (text, type) => {
        if (text === "") {
          if (type === "extra") {
            onBlur();
          }
          return;
        }
        const value = props2.modelValue;
        if (type === "delete") {
          emit("delete");
          emit("update:modelValue", value.slice(0, value.length - 1));
        } else if (type === "close") {
          onClose();
        } else if (value.length < +props2.maxlength) {
          emit("input", text);
          emit("update:modelValue", value + text);
        }
      };
      const renderTitle = () => {
        const {
          title,
          theme,
          closeButtonText
        } = props2;
        const leftSlot = slots["title-left"];
        const showClose = closeButtonText && theme === "default";
        const showTitle = title || showClose || leftSlot;
        if (!showTitle) {
          return;
        }
        return vue.createVNode("div", {
          "class": bem$v("header")
        }, [leftSlot && vue.createVNode("span", {
          "class": bem$v("title-left")
        }, [leftSlot()]), title && vue.createVNode("h2", {
          "class": bem$v("title")
        }, [title]), showClose && vue.createVNode("button", {
          "type": "button",
          "class": [bem$v("close"), HAPTICS_FEEDBACK],
          "onClick": onClose
        }, [closeButtonText])]);
      };
      const renderKeys = () => keys.value.map((key) => {
        const keySlots = {};
        if (key.type === "delete") {
          keySlots.default = slots.delete;
        }
        if (key.type === "extra") {
          keySlots.default = slots["extra-key"];
        }
        return vue.createVNode(stdin_default$C, {
          "key": key.text,
          "text": key.text,
          "type": key.type,
          "wider": key.wider,
          "color": key.color,
          "onPress": onPress
        }, keySlots);
      });
      const renderSidebar = () => {
        if (props2.theme === "custom") {
          return vue.createVNode("div", {
            "class": bem$v("sidebar")
          }, [props2.showDeleteKey && vue.createVNode(stdin_default$C, {
            "large": true,
            "text": props2.deleteButtonText,
            "type": "delete",
            "onPress": onPress
          }, {
            default: slots.delete
          }), vue.createVNode(stdin_default$C, {
            "large": true,
            "text": props2.closeButtonText,
            "type": "close",
            "color": "blue",
            "loading": props2.closeButtonLoading,
            "onPress": onPress
          }, null)]);
        }
      };
      vue.watch(() => props2.show, (value) => {
        if (!props2.transition) {
          emit(value ? "show" : "hide");
        }
      });
      if (props2.hideOnClickOutside) {
        useClickAway(root, onBlur, {
          eventName: "touchstart"
        });
      }
      return () => {
        const Title = renderTitle();
        const Content = vue.createVNode(vue.Transition, {
          "name": props2.transition ? "van-slide-up" : ""
        }, {
          default: () => [vue.withDirectives(vue.createVNode("div", vue.mergeProps({
            "ref": root,
            "style": getZIndexStyle(props2.zIndex),
            "class": bem$v({
              unfit: !props2.safeAreaInsetBottom,
              "with-title": !!Title
            }),
            "onAnimationend": onAnimationEnd,
            "onTouchstartPassive": stopPropagation
          }, attrs), [Title, vue.createVNode("div", {
            "class": bem$v("body")
          }, [vue.createVNode("div", {
            "class": bem$v("keys")
          }, [renderKeys()]), renderSidebar()])]), [[vue.vShow, props2.show]])]
        });
        if (props2.teleport) {
          return vue.createVNode(vue.Teleport, {
            "to": props2.teleport
          }, {
            default: () => [Content]
          });
        }
        return Content;
      };
    }
  });
  const NumberKeyboard = withInstall(stdin_default$B);
  const [name$v, bem$u, t$8] = createNamespace("pagination");
  const makePage = (number2, text, active) => ({
    number: number2,
    text,
    active
  });
  const paginationProps = {
    mode: makeStringProp("multi"),
    prevText: String,
    nextText: String,
    pageCount: makeNumericProp(0),
    modelValue: makeNumberProp(0),
    totalItems: makeNumericProp(0),
    showPageSize: makeNumericProp(5),
    itemsPerPage: makeNumericProp(10),
    forceEllipses: Boolean,
    showPrevButton: truthProp,
    showNextButton: truthProp
  };
  var stdin_default$A = vue.defineComponent({
    name: name$v,
    props: paginationProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const count = vue.computed(() => {
        const {
          pageCount,
          totalItems,
          itemsPerPage
        } = props2;
        const count2 = +pageCount || Math.ceil(+totalItems / +itemsPerPage);
        return Math.max(1, count2);
      });
      const pages2 = vue.computed(() => {
        const items = [];
        const pageCount = count.value;
        const showPageSize = +props2.showPageSize;
        const {
          modelValue,
          forceEllipses
        } = props2;
        let startPage = 1;
        let endPage = pageCount;
        const isMaxSized = showPageSize < pageCount;
        if (isMaxSized) {
          startPage = Math.max(modelValue - Math.floor(showPageSize / 2), 1);
          endPage = startPage + showPageSize - 1;
          if (endPage > pageCount) {
            endPage = pageCount;
            startPage = endPage - showPageSize + 1;
          }
        }
        for (let number2 = startPage; number2 <= endPage; number2++) {
          const page2 = makePage(number2, number2, number2 === modelValue);
          items.push(page2);
        }
        if (isMaxSized && showPageSize > 0 && forceEllipses) {
          if (startPage > 1) {
            const prevPages = makePage(startPage - 1, "...");
            items.unshift(prevPages);
          }
          if (endPage < pageCount) {
            const nextPages = makePage(endPage + 1, "...");
            items.push(nextPages);
          }
        }
        return items;
      });
      const updateModelValue = (value, emitChange) => {
        value = clamp(value, 1, count.value);
        if (props2.modelValue !== value) {
          emit("update:modelValue", value);
          if (emitChange) {
            emit("change", value);
          }
        }
      };
      vue.watchEffect(() => updateModelValue(props2.modelValue));
      const renderDesc = () => vue.createVNode("li", {
        "class": bem$u("page-desc")
      }, [slots.pageDesc ? slots.pageDesc() : `${props2.modelValue}/${count.value}`]);
      const renderPrevButton = () => {
        const {
          mode,
          modelValue,
          showPrevButton
        } = props2;
        if (!showPrevButton) {
          return;
        }
        const slot = slots["prev-text"];
        const disabled = modelValue === 1;
        return vue.createVNode("li", {
          "class": [bem$u("item", {
            disabled,
            border: mode === "simple",
            prev: true
          }), BORDER_SURROUND]
        }, [vue.createVNode("button", {
          "type": "button",
          "disabled": disabled,
          "onClick": () => updateModelValue(modelValue - 1, true)
        }, [slot ? slot() : props2.prevText || t$8("prev")])]);
      };
      const renderNextButton = () => {
        const {
          mode,
          modelValue,
          showNextButton
        } = props2;
        if (!showNextButton) {
          return;
        }
        const slot = slots["next-text"];
        const disabled = modelValue === count.value;
        return vue.createVNode("li", {
          "class": [bem$u("item", {
            disabled,
            border: mode === "simple",
            next: true
          }), BORDER_SURROUND]
        }, [vue.createVNode("button", {
          "type": "button",
          "disabled": disabled,
          "onClick": () => updateModelValue(modelValue + 1, true)
        }, [slot ? slot() : props2.nextText || t$8("next")])]);
      };
      const renderPages = () => pages2.value.map((page2) => vue.createVNode("li", {
        "class": [bem$u("item", {
          active: page2.active,
          page: true
        }), BORDER_SURROUND]
      }, [vue.createVNode("button", {
        "type": "button",
        "aria-current": page2.active || void 0,
        "onClick": () => updateModelValue(page2.number, true)
      }, [slots.page ? slots.page(page2) : page2.text])]));
      return () => vue.createVNode("nav", {
        "role": "navigation",
        "class": bem$u()
      }, [vue.createVNode("ul", {
        "class": bem$u("items")
      }, [renderPrevButton(), props2.mode === "simple" ? renderDesc() : renderPages(), renderNextButton()])]);
    }
  });
  const Pagination = withInstall(stdin_default$A);
  const [name$u, bem$t] = createNamespace("password-input");
  const passwordInputProps = {
    info: String,
    mask: truthProp,
    value: makeStringProp(""),
    gutter: numericProp,
    length: makeNumericProp(6),
    focused: Boolean,
    errorInfo: String
  };
  var stdin_default$z = vue.defineComponent({
    name: name$u,
    props: passwordInputProps,
    emits: ["focus"],
    setup(props2, {
      emit
    }) {
      const onTouchStart = (event) => {
        event.stopPropagation();
        emit("focus", event);
      };
      const renderPoints = () => {
        const Points = [];
        const {
          mask,
          value,
          gutter,
          focused
        } = props2;
        const length = +props2.length;
        for (let i2 = 0; i2 < length; i2++) {
          const char = value[i2];
          const showBorder = i2 !== 0 && !gutter;
          const showCursor = focused && i2 === value.length;
          let style;
          if (i2 !== 0 && gutter) {
            style = {
              marginLeft: addUnit$2(gutter)
            };
          }
          Points.push(vue.createVNode("li", {
            "class": [{
              [BORDER_LEFT]: showBorder
            }, bem$t("item", {
              focus: showCursor
            })],
            "style": style
          }, [mask ? vue.createVNode("i", {
            "style": {
              visibility: char ? "visible" : "hidden"
            }
          }, null) : char, showCursor && vue.createVNode("div", {
            "class": bem$t("cursor")
          }, null)]));
        }
        return Points;
      };
      return () => {
        const info = props2.errorInfo || props2.info;
        return vue.createVNode("div", {
          "class": bem$t()
        }, [vue.createVNode("ul", {
          "class": [bem$t("security"), {
            [BORDER_SURROUND]: !props2.gutter
          }],
          "onTouchstartPassive": onTouchStart
        }, [renderPoints()]), info && vue.createVNode("div", {
          "class": bem$t(props2.errorInfo ? "error-info" : "info")
        }, [info])]);
      };
    }
  });
  const PasswordInput = withInstall(stdin_default$z);
  const PickerGroup = withInstall(stdin_default$1x);
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  var round$1 = Math.round;
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width2 = clientRect.width / scaleX;
    var height2 = clientRect.height / scaleY;
    return {
      width: width2,
      height: height2,
      top: y,
      right: x + width2,
      bottom: y + height2,
      left: x,
      x,
      y
    };
  }
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round$1(rect.width) / element.offsetWidth || 1;
    var scaleY = round$1(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width2 = element.offsetWidth;
    var height2 = element.offsetHeight;
    if (Math.abs(clientRect.width - width2) <= 1) {
      width2 = clientRect.width;
    }
    if (Math.abs(clientRect.height - height2) <= 1) {
      height2 = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width2,
      height: height2
    };
  }
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
  }
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce$1(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p2, c2) {
      return p2.replace(/%s/, c2);
    }, str);
  }
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index2, self2) {
        return self2.indexOf(value) === index2;
      }).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:376", format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:381", format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:386", format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:391", format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:396", format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:401", format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:406", format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:413", 'PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s2) {
              return '"' + s2 + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:421", format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current2) {
      var existing = merged2[current2.name];
      merged2[current2.name] = existing ? Object.assign({}, existing, current2, {
        options: Object.assign({}, existing.options, current2.options),
        data: Object.assign({}, existing.data, current2.data)
      }) : current2;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function computeOffsets(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }
    return offsets;
  }
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions2;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
        modifiersData: {},
        elements: {
          reference,
          popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance2 = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions2, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m2) {
            return m2.enabled;
          });
          {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name2 = _ref.name;
              return name2;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name2 = _ref2.name;
                return name2 === "flip";
              });
              if (!flipModifier) {
                formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:590", ['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle(popper), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              formatAppLog("warn", "at node_modules/@vant/popperjs/dist/index.esm.mjs:597", ['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance2.update();
        },
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference2 = _state$elements.reference, popper2 = _state$elements.popper;
          if (!areValidElements(reference2, popper2)) {
            {
              formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:610", INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference2, getOffsetParent(popper2), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper2)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
            {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:628", INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index2 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name: name2,
                instance: instance2
              }) || state;
            }
          }
        },
        update: debounce$1(function() {
          return new Promise(function(resolve) {
            instance2.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference, popper)) {
        {
          formatAppLog("error", "at node_modules/@vant/popperjs/dist/index.esm.mjs:661", INVALID_ELEMENT_ERROR);
        }
        return instance2;
      }
      instance2.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name2 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
          if (typeof effect3 === "function") {
            var cleanupFn = effect3({
              state,
              name: name2,
              instance: instance2,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance2;
    };
  }
  var passive = {
    passive: true
  };
  function effect(_ref) {
    var state = _ref.state, instance2 = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance2.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance2.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance2.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance2.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect,
    data: {}
  };
  function popperOffsets(_ref) {
    var state = _ref.state, name2 = _ref.name;
    state.modifiersData[name2] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round$1(x * dpr) / dpr || 0,
      y: round$1(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);
        if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    {
      var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        formatAppLog("warn", "at node_modules/@vant/popperjs/dist/index.esm.mjs:837", ["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name2) {
      var style = state.styles[name2] || {};
      var attributes = state.attributes[name2] || {};
      var element = state.elements[name2];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name22) {
        var value = attributes[name22];
        if (value === false) {
          element.removeAttribute(name22);
        } else {
          element.setAttribute(name22, value === true ? "" : value);
        }
      });
    });
  }
  function effect2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name2) {
        var element = state.elements[name2];
        var attributes = state.attributes[name2] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect2,
    requires: ["computeStyles"]
  };
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name2] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };
  const [name$t, bem$s] = createNamespace("popover");
  const popupProps = ["overlay", "duration", "teleport", "overlayStyle", "overlayClass", "closeOnClickOverlay"];
  const popoverProps = {
    show: Boolean,
    theme: makeStringProp("light"),
    overlay: Boolean,
    actions: makeArrayProp(),
    actionsDirection: makeStringProp("vertical"),
    trigger: makeStringProp("click"),
    duration: numericProp,
    showArrow: truthProp,
    placement: makeStringProp("bottom"),
    iconPrefix: String,
    overlayClass: unknownProp,
    overlayStyle: Object,
    closeOnClickAction: truthProp,
    closeOnClickOverlay: truthProp,
    closeOnClickOutside: truthProp,
    offset: {
      type: Array,
      default: () => [0, 8]
    },
    teleport: {
      type: [String, Object],
      default: "body"
    }
  };
  var stdin_default$y = vue.defineComponent({
    name: name$t,
    props: popoverProps,
    emits: ["select", "touchstart", "update:show"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      let popper;
      const popupRef = vue.ref();
      const wrapperRef = vue.ref();
      const popoverRef = vue.ref();
      const show = useSyncPropRef(() => props2.show, (value) => emit("update:show", value));
      const getPopoverOptions = () => ({
        placement: props2.placement,
        modifiers: [{
          name: "computeStyles",
          options: {
            adaptive: false,
            gpuAcceleration: false
          }
        }, extend({}, offset_default, {
          options: {
            offset: props2.offset
          }
        })]
      });
      const createPopperInstance = () => {
        if (wrapperRef.value && popoverRef.value) {
          return createPopper(wrapperRef.value, popoverRef.value.popupRef.value, getPopoverOptions());
        }
        return null;
      };
      const updateLocation = () => {
        vue.nextTick(() => {
          if (!show.value) {
            return;
          }
          if (!popper) {
            popper = createPopperInstance();
            if (inBrowser$1) {
              window.addEventListener("animationend", updateLocation);
              window.addEventListener("transitionend", updateLocation);
            }
          } else {
            popper.setOptions(getPopoverOptions());
          }
        });
      };
      const updateShow = (value) => {
        show.value = value;
      };
      const onClickWrapper = () => {
        if (props2.trigger === "click") {
          show.value = !show.value;
        }
      };
      const onClickAction = (action, index2) => {
        if (action.disabled) {
          return;
        }
        emit("select", action, index2);
        if (props2.closeOnClickAction) {
          show.value = false;
        }
      };
      const onClickAway = () => {
        if (show.value && props2.closeOnClickOutside && (!props2.overlay || props2.closeOnClickOverlay)) {
          show.value = false;
        }
      };
      const renderActionContent = (action, index2) => {
        if (slots.action) {
          return slots.action({
            action,
            index: index2
          });
        }
        return [action.icon && vue.createVNode(Icon, {
          "name": action.icon,
          "classPrefix": props2.iconPrefix,
          "class": bem$s("action-icon")
        }, null), vue.createVNode("div", {
          "class": [bem$s("action-text"), {
            [BORDER_BOTTOM]: props2.actionsDirection === "vertical"
          }]
        }, [action.text])];
      };
      const renderAction = (action, index2) => {
        const {
          icon,
          color,
          disabled,
          className
        } = action;
        return vue.createVNode("div", {
          "role": "menuitem",
          "class": [bem$s("action", {
            disabled,
            "with-icon": icon
          }), {
            [BORDER_RIGHT]: props2.actionsDirection === "horizontal"
          }, className],
          "style": {
            color
          },
          "tabindex": disabled ? void 0 : 0,
          "aria-disabled": disabled || void 0,
          "onClick": () => onClickAction(action, index2)
        }, [renderActionContent(action, index2)]);
      };
      vue.onMounted(() => {
        updateLocation();
        vue.watchEffect(() => {
          var _a;
          popupRef.value = (_a = popoverRef.value) == null ? void 0 : _a.popupRef.value;
        });
      });
      vue.onBeforeUnmount(() => {
        if (popper) {
          if (inBrowser$1) {
            window.removeEventListener("animationend", updateLocation);
            window.removeEventListener("transitionend", updateLocation);
          }
          popper.destroy();
          popper = null;
        }
      });
      vue.watch(() => [show.value, props2.offset, props2.placement], updateLocation);
      useClickAway([wrapperRef, popupRef], onClickAway, {
        eventName: "touchstart"
      });
      return () => {
        var _a;
        return vue.createVNode(vue.Fragment, null, [vue.createVNode("span", {
          "ref": wrapperRef,
          "class": bem$s("wrapper"),
          "onClick": onClickWrapper
        }, [(_a = slots.reference) == null ? void 0 : _a.call(slots)]), vue.createVNode(Popup, vue.mergeProps({
          "ref": popoverRef,
          "show": show.value,
          "class": bem$s([props2.theme]),
          "position": "",
          "transition": "van-popover-zoom",
          "lockScroll": false,
          "onUpdate:show": updateShow
        }, attrs, useScopeId(), pick(props2, popupProps)), {
          default: () => [props2.showArrow && vue.createVNode("div", {
            "class": bem$s("arrow")
          }, null), vue.createVNode("div", {
            "role": "menu",
            "class": bem$s("content", props2.actionsDirection)
          }, [slots.default ? slots.default() : props2.actions.map(renderAction)])]
        })]);
      };
    }
  });
  const Popover = withInstall(stdin_default$y);
  const [name$s, bem$r] = createNamespace("progress");
  const progressProps = {
    color: String,
    inactive: Boolean,
    pivotText: String,
    textColor: String,
    showPivot: truthProp,
    pivotColor: String,
    trackColor: String,
    strokeWidth: numericProp,
    percentage: {
      type: numericProp,
      default: 0,
      validator: (value) => +value >= 0 && +value <= 100
    }
  };
  var stdin_default$x = vue.defineComponent({
    name: name$s,
    props: progressProps,
    setup(props2) {
      const background = vue.computed(() => props2.inactive ? void 0 : props2.color);
      const renderPivot = () => {
        const {
          textColor,
          pivotText,
          pivotColor,
          percentage
        } = props2;
        const text = pivotText != null ? pivotText : `${percentage}%`;
        if (props2.showPivot && text) {
          const style = {
            color: textColor,
            left: `${+percentage}%`,
            transform: `translate(-${+percentage}%,-50%)`,
            background: pivotColor || background.value
          };
          return vue.createVNode("span", {
            "style": style,
            "class": bem$r("pivot", {
              inactive: props2.inactive
            })
          }, [text]);
        }
      };
      return () => {
        const {
          trackColor,
          percentage,
          strokeWidth
        } = props2;
        const rootStyle = {
          background: trackColor,
          height: addUnit$2(strokeWidth)
        };
        const portionStyle = {
          width: `${percentage}%`,
          background: background.value
        };
        return vue.createVNode("div", {
          "class": bem$r(),
          "style": rootStyle
        }, [vue.createVNode("span", {
          "class": bem$r("portion", {
            inactive: props2.inactive
          }),
          "style": portionStyle
        }, null), renderPivot()]);
      };
    }
  });
  const Progress = withInstall(stdin_default$x);
  const [name$r, bem$q, t$7] = createNamespace("pull-refresh");
  const DEFAULT_HEAD_HEIGHT = 50;
  const TEXT_STATUS = ["pulling", "loosing", "success"];
  const pullRefreshProps = {
    disabled: Boolean,
    modelValue: Boolean,
    headHeight: makeNumericProp(DEFAULT_HEAD_HEIGHT),
    successText: String,
    pullingText: String,
    loosingText: String,
    loadingText: String,
    pullDistance: numericProp,
    successDuration: makeNumericProp(500),
    animationDuration: makeNumericProp(300)
  };
  var stdin_default$w = vue.defineComponent({
    name: name$r,
    props: pullRefreshProps,
    emits: ["change", "refresh", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      let reachTop;
      const root = vue.ref();
      const track = vue.ref();
      const scrollParent = useScrollParent(root);
      const state = vue.reactive({
        status: "normal",
        distance: 0,
        duration: 0
      });
      const touch = useTouch();
      const getHeadStyle = () => {
        if (props2.headHeight !== DEFAULT_HEAD_HEIGHT) {
          return {
            height: `${props2.headHeight}px`
          };
        }
      };
      const isTouchable = () => state.status !== "loading" && state.status !== "success" && !props2.disabled;
      const ease = (distance) => {
        const pullDistance = +(props2.pullDistance || props2.headHeight);
        if (distance > pullDistance) {
          if (distance < pullDistance * 2) {
            distance = pullDistance + (distance - pullDistance) / 2;
          } else {
            distance = pullDistance * 1.5 + (distance - pullDistance * 2) / 4;
          }
        }
        return Math.round(distance);
      };
      const setStatus = (distance, isLoading) => {
        const pullDistance = +(props2.pullDistance || props2.headHeight);
        state.distance = distance;
        if (isLoading) {
          state.status = "loading";
        } else if (distance === 0) {
          state.status = "normal";
        } else if (distance < pullDistance) {
          state.status = "pulling";
        } else {
          state.status = "loosing";
        }
        emit("change", {
          status: state.status,
          distance
        });
      };
      const getStatusText = () => {
        const {
          status
        } = state;
        if (status === "normal") {
          return "";
        }
        return props2[`${status}Text`] || t$7(status);
      };
      const renderStatus = () => {
        const {
          status,
          distance
        } = state;
        if (slots[status]) {
          return slots[status]({
            distance
          });
        }
        const nodes = [];
        if (TEXT_STATUS.includes(status)) {
          nodes.push(vue.createVNode("div", {
            "class": bem$q("text")
          }, [getStatusText()]));
        }
        if (status === "loading") {
          nodes.push(vue.createVNode(Loading, {
            "class": bem$q("loading")
          }, {
            default: getStatusText
          }));
        }
        return nodes;
      };
      const showSuccessTip = () => {
        state.status = "success";
        setTimeout(() => {
          setStatus(0);
        }, +props2.successDuration);
      };
      const checkPosition = (event) => {
        reachTop = getScrollTop(scrollParent.value) === 0;
        if (reachTop) {
          state.duration = 0;
          touch.start(event);
        }
      };
      const onTouchStart = (event) => {
        if (isTouchable()) {
          checkPosition(event);
        }
      };
      const onTouchMove = (event) => {
        if (isTouchable()) {
          if (!reachTop) {
            checkPosition(event);
          }
          const {
            deltaY
          } = touch;
          touch.move(event);
          if (reachTop && deltaY.value >= 0 && touch.isVertical()) {
            preventDefault(event);
            setStatus(ease(deltaY.value));
          }
        }
      };
      const onTouchEnd = () => {
        if (reachTop && touch.deltaY.value && isTouchable()) {
          state.duration = +props2.animationDuration;
          if (state.status === "loosing") {
            setStatus(+props2.headHeight, true);
            emit("update:modelValue", true);
            vue.nextTick(() => emit("refresh"));
          } else {
            setStatus(0);
          }
        }
      };
      vue.watch(() => props2.modelValue, (value) => {
        state.duration = +props2.animationDuration;
        if (value) {
          setStatus(+props2.headHeight, true);
        } else if (slots.success || props2.successText) {
          showSuccessTip();
        } else {
          setStatus(0, false);
        }
      });
      useEventListener("touchmove", onTouchMove, {
        target: track
      });
      return () => {
        var _a;
        const trackStyle = {
          transitionDuration: `${state.duration}ms`,
          transform: state.distance ? `translate3d(0,${state.distance}px, 0)` : ""
        };
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$q()
        }, [vue.createVNode("div", {
          "ref": track,
          "class": bem$q("track"),
          "style": trackStyle,
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd
        }, [vue.createVNode("div", {
          "class": bem$q("head"),
          "style": getHeadStyle()
        }, [renderStatus()]), (_a = slots.default) == null ? void 0 : _a.call(slots)])]);
      };
    }
  });
  const PullRefresh = withInstall(stdin_default$w);
  const [name$q, bem$p] = createNamespace("rate");
  function getRateStatus(value, index2, allowHalf, readonly) {
    if (value >= index2) {
      return {
        status: "full",
        value: 1
      };
    }
    if (value + 0.5 >= index2 && allowHalf && !readonly) {
      return {
        status: "half",
        value: 0.5
      };
    }
    if (value + 1 >= index2 && allowHalf && readonly) {
      const cardinal = 10 ** 10;
      return {
        status: "half",
        value: Math.round((value - index2 + 1) * cardinal) / cardinal
      };
    }
    return {
      status: "void",
      value: 0
    };
  }
  const rateProps = {
    size: numericProp,
    icon: makeStringProp("star"),
    color: String,
    count: makeNumericProp(5),
    gutter: numericProp,
    clearable: Boolean,
    readonly: Boolean,
    disabled: Boolean,
    voidIcon: makeStringProp("star-o"),
    allowHalf: Boolean,
    voidColor: String,
    touchable: truthProp,
    iconPrefix: String,
    modelValue: makeNumberProp(0),
    disabledColor: String
  };
  var stdin_default$v = vue.defineComponent({
    name: name$q,
    props: rateProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit
    }) {
      const touch = useTouch();
      const [itemRefs, setItemRefs] = useRefs();
      const groupRef = vue.ref();
      const unselectable = vue.computed(() => props2.readonly || props2.disabled);
      const untouchable = vue.computed(() => unselectable.value || !props2.touchable);
      const list = vue.computed(() => Array(+props2.count).fill("").map((_, i2) => getRateStatus(props2.modelValue, i2 + 1, props2.allowHalf, props2.readonly)));
      let ranges;
      let groupRefRect;
      let minRectTop = Number.MAX_SAFE_INTEGER;
      let maxRectTop = Number.MIN_SAFE_INTEGER;
      const updateRanges = () => {
        groupRefRect = useRect(groupRef);
        const rects = itemRefs.value.map(useRect);
        ranges = [];
        rects.forEach((rect, index2) => {
          minRectTop = Math.min(rect.top, minRectTop);
          maxRectTop = Math.max(rect.top, maxRectTop);
          if (props2.allowHalf) {
            ranges.push({
              score: index2 + 0.5,
              left: rect.left,
              top: rect.top,
              height: rect.height
            }, {
              score: index2 + 1,
              left: rect.left + rect.width / 2,
              top: rect.top,
              height: rect.height
            });
          } else {
            ranges.push({
              score: index2 + 1,
              left: rect.left,
              top: rect.top,
              height: rect.height
            });
          }
        });
      };
      const getScoreByPosition = (x, y) => {
        for (let i2 = ranges.length - 1; i2 > 0; i2--) {
          if (y >= groupRefRect.top && y <= groupRefRect.bottom) {
            if (x > ranges[i2].left && y >= ranges[i2].top && y <= ranges[i2].top + ranges[i2].height) {
              return ranges[i2].score;
            }
          } else {
            const curTop = y < groupRefRect.top ? minRectTop : maxRectTop;
            if (x > ranges[i2].left && ranges[i2].top === curTop) {
              return ranges[i2].score;
            }
          }
        }
        return props2.allowHalf ? 0.5 : 1;
      };
      const select = (value) => {
        if (unselectable.value || value === props2.modelValue)
          return;
        emit("update:modelValue", value);
        emit("change", value);
      };
      const onTouchStart = (event) => {
        if (untouchable.value) {
          return;
        }
        touch.start(event);
        updateRanges();
      };
      const onTouchMove = (event) => {
        if (untouchable.value) {
          return;
        }
        touch.move(event);
        if (touch.isHorizontal() && !touch.isTap.value) {
          const {
            clientX,
            clientY
          } = event.touches[0];
          preventDefault(event);
          select(getScoreByPosition(clientX, clientY));
        }
      };
      const renderStar = (item, index2) => {
        const {
          icon,
          size,
          color,
          count,
          gutter,
          voidIcon,
          disabled,
          voidColor,
          allowHalf,
          iconPrefix,
          disabledColor
        } = props2;
        const score = index2 + 1;
        const isFull = item.status === "full";
        const isVoid = item.status === "void";
        const renderHalf = allowHalf && item.value > 0 && item.value < 1;
        let style;
        if (gutter && score !== +count) {
          style = {
            paddingRight: addUnit$2(gutter)
          };
        }
        const onClickItem = (event) => {
          updateRanges();
          let value = allowHalf ? getScoreByPosition(event.clientX, event.clientY) : score;
          if (props2.clearable && touch.isTap.value && value === props2.modelValue) {
            value = 0;
          }
          select(value);
        };
        return vue.createVNode("div", {
          "key": index2,
          "ref": setItemRefs(index2),
          "role": "radio",
          "style": style,
          "class": bem$p("item"),
          "tabindex": disabled ? void 0 : 0,
          "aria-setsize": count,
          "aria-posinset": score,
          "aria-checked": !isVoid,
          "onClick": onClickItem
        }, [vue.createVNode(Icon, {
          "size": size,
          "name": isFull ? icon : voidIcon,
          "class": bem$p("icon", {
            disabled,
            full: isFull
          }),
          "color": disabled ? disabledColor : isFull ? color : voidColor,
          "classPrefix": iconPrefix
        }, null), renderHalf && vue.createVNode(Icon, {
          "size": size,
          "style": {
            width: item.value + "em"
          },
          "name": isVoid ? voidIcon : icon,
          "class": bem$p("icon", ["half", {
            disabled,
            full: !isVoid
          }]),
          "color": disabled ? disabledColor : isVoid ? voidColor : color,
          "classPrefix": iconPrefix
        }, null)]);
      };
      useCustomFieldValue(() => props2.modelValue);
      useEventListener("touchmove", onTouchMove, {
        target: groupRef
      });
      return () => vue.createVNode("div", {
        "ref": groupRef,
        "role": "radiogroup",
        "class": bem$p({
          readonly: props2.readonly,
          disabled: props2.disabled
        }),
        "tabindex": props2.disabled ? void 0 : 0,
        "aria-disabled": props2.disabled,
        "aria-readonly": props2.readonly,
        "onTouchstartPassive": onTouchStart
      }, [list.value.map(renderStar)]);
    }
  });
  const Rate = withInstall(stdin_default$v);
  const props$1 = {
    figureArr: makeArrayProp(),
    delay: Number,
    duration: makeNumberProp(2),
    isStart: Boolean,
    direction: makeStringProp("down"),
    height: makeNumberProp(40)
  };
  const [name$p, bem$o] = createNamespace("rolling-text-item");
  var stdin_default$u = vue.defineComponent({
    name: name$p,
    props: props$1,
    setup(props2) {
      const newFigureArr = vue.computed(() => props2.direction === "down" ? props2.figureArr.slice().reverse() : props2.figureArr);
      const translatePx = vue.computed(() => {
        const totalHeight = props2.height * (props2.figureArr.length - 1);
        return `-${totalHeight}px`;
      });
      const itemStyle = vue.computed(() => ({
        lineHeight: addUnit$2(props2.height)
      }));
      const rootStyle = vue.computed(() => ({
        height: addUnit$2(props2.height),
        "--van-translate": translatePx.value,
        "--van-duration": props2.duration + "s",
        "--van-delay": props2.delay + "s"
      }));
      return () => vue.createVNode("div", {
        "class": bem$o([props2.direction]),
        "style": rootStyle.value
      }, [vue.createVNode("div", {
        "class": bem$o("box", {
          animate: props2.isStart
        })
      }, [Array.isArray(newFigureArr.value) && newFigureArr.value.map((figure) => vue.createVNode("div", {
        "class": bem$o("item"),
        "style": itemStyle.value
      }, [figure]))])]);
    }
  });
  const [name$o, bem$n] = createNamespace("rolling-text");
  const rollingTextProps = {
    startNum: makeNumberProp(0),
    targetNum: Number,
    textList: makeArrayProp(),
    duration: makeNumberProp(2),
    autoStart: truthProp,
    direction: makeStringProp("down"),
    stopOrder: makeStringProp("ltr"),
    height: makeNumberProp(40)
  };
  const CIRCLE_NUM = 2;
  var stdin_default$t = vue.defineComponent({
    name: name$o,
    props: rollingTextProps,
    setup(props2) {
      const isCustomType = vue.computed(() => Array.isArray(props2.textList) && props2.textList.length);
      const itemLength = vue.computed(() => {
        if (isCustomType.value)
          return props2.textList[0].length;
        return `${Math.max(props2.startNum, props2.targetNum)}`.length;
      });
      const getTextArrByIdx = (idx) => {
        const result = [];
        for (let i2 = 0; i2 < props2.textList.length; i2++) {
          result.push(props2.textList[i2][idx]);
        }
        return result;
      };
      const targetNumArr = vue.computed(() => {
        if (isCustomType.value)
          return new Array(itemLength.value).fill("");
        return padZero$1(props2.targetNum, itemLength.value).split("");
      });
      const startNumArr = vue.computed(() => padZero$1(props2.startNum, itemLength.value).split(""));
      const getFigureArr = (i2) => {
        const start22 = +startNumArr.value[i2];
        const target = +targetNumArr.value[i2];
        const result = [];
        for (let i22 = start22; i22 <= 9; i22++) {
          result.push(i22);
        }
        for (let i22 = 0; i22 <= CIRCLE_NUM; i22++) {
          for (let j = 0; j <= 9; j++) {
            result.push(j);
          }
        }
        for (let i22 = 0; i22 <= target; i22++) {
          result.push(i22);
        }
        return result;
      };
      const getDelay = (i2, len) => {
        if (props2.stopOrder === "ltr")
          return 0.2 * i2;
        return 0.2 * (len - 1 - i2);
      };
      const rolling = vue.ref(props2.autoStart);
      const start2 = () => {
        rolling.value = true;
      };
      const reset = () => {
        rolling.value = false;
        if (props2.autoStart) {
          raf(() => start2());
        }
      };
      vue.watch(() => props2.autoStart, (value) => {
        if (value) {
          start2();
        }
      });
      useExpose({
        start: start2,
        reset
      });
      return () => vue.createVNode("div", {
        "class": bem$n()
      }, [targetNumArr.value.map((_, i2) => vue.createVNode(stdin_default$u, {
        "figureArr": isCustomType.value ? getTextArrByIdx(i2) : getFigureArr(i2),
        "duration": props2.duration,
        "direction": props2.direction,
        "isStart": rolling.value,
        "height": props2.height,
        "delay": getDelay(i2, itemLength.value)
      }, null))]);
    }
  });
  const RollingText = withInstall(stdin_default$t);
  const Row = withInstall(stdin_default$14);
  const [name$n, bem$m, t$6] = createNamespace("search");
  const searchProps = extend({}, fieldSharedProps, {
    label: String,
    shape: makeStringProp("square"),
    leftIcon: makeStringProp("search"),
    clearable: truthProp,
    actionText: String,
    background: String,
    showAction: Boolean
  });
  var stdin_default$s = vue.defineComponent({
    name: name$n,
    props: searchProps,
    emits: ["blur", "focus", "clear", "search", "cancel", "clickInput", "clickLeftIcon", "clickRightIcon", "update:modelValue"],
    setup(props2, {
      emit,
      slots,
      attrs
    }) {
      const id = useId();
      const fieldRef = vue.ref();
      const onCancel = () => {
        if (!slots.action) {
          emit("update:modelValue", "");
          emit("cancel");
        }
      };
      const onKeypress = (event) => {
        const ENTER_CODE = 13;
        if (event.keyCode === ENTER_CODE) {
          preventDefault(event);
          emit("search", props2.modelValue);
        }
      };
      const getInputId = () => props2.id || `${id}-input`;
      const renderLabel = () => {
        if (slots.label || props2.label) {
          return vue.createVNode("label", {
            "class": bem$m("label"),
            "for": getInputId(),
            "data-allow-mismatch": "attribute"
          }, [slots.label ? slots.label() : props2.label]);
        }
      };
      const renderAction = () => {
        if (props2.showAction) {
          const text = props2.actionText || t$6("cancel");
          return vue.createVNode("div", {
            "class": bem$m("action"),
            "role": "button",
            "tabindex": 0,
            "onClick": onCancel
          }, [slots.action ? slots.action() : text]);
        }
      };
      const blur = () => {
        var _a;
        return (_a = fieldRef.value) == null ? void 0 : _a.blur();
      };
      const focus = () => {
        var _a;
        return (_a = fieldRef.value) == null ? void 0 : _a.focus();
      };
      const onBlur = (event) => emit("blur", event);
      const onFocus = (event) => emit("focus", event);
      const onClear = (event) => emit("clear", event);
      const onClickInput = (event) => emit("clickInput", event);
      const onClickLeftIcon = (event) => emit("clickLeftIcon", event);
      const onClickRightIcon = (event) => emit("clickRightIcon", event);
      const fieldPropNames = Object.keys(fieldSharedProps);
      const renderField = () => {
        const fieldAttrs = extend({}, attrs, pick(props2, fieldPropNames), {
          id: getInputId()
        });
        const onInput = (value) => emit("update:modelValue", value);
        return vue.createVNode(Field, vue.mergeProps({
          "ref": fieldRef,
          "type": "search",
          "class": bem$m("field", {
            "with-message": fieldAttrs.errorMessage
          }),
          "border": false,
          "onBlur": onBlur,
          "onFocus": onFocus,
          "onClear": onClear,
          "onKeypress": onKeypress,
          "onClickInput": onClickInput,
          "onClickLeftIcon": onClickLeftIcon,
          "onClickRightIcon": onClickRightIcon,
          "onUpdate:modelValue": onInput
        }, fieldAttrs), pick(slots, ["left-icon", "right-icon"]));
      };
      useExpose({
        focus,
        blur
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$m({
            "show-action": props2.showAction
          }),
          "style": {
            background: props2.background
          }
        }, [(_a = slots.left) == null ? void 0 : _a.call(slots), vue.createVNode("div", {
          "class": bem$m("content", props2.shape)
        }, [renderLabel(), renderField()]), renderAction()]);
      };
    }
  });
  const Search = withInstall(stdin_default$s);
  const isImage = (name2) => name2 == null ? void 0 : name2.includes("/");
  const popupInheritKeys = [...popupSharedPropKeys, "round", "closeOnPopstate", "safeAreaInsetBottom"];
  const iconMap = {
    qq: "qq",
    link: "link-o",
    weibo: "weibo",
    qrcode: "qr",
    poster: "photo-o",
    wechat: "wechat",
    "weapp-qrcode": "miniprogram-o",
    "wechat-moments": "wechat-moments"
  };
  const [name$m, bem$l, t$5] = createNamespace("share-sheet");
  const shareSheetProps = extend({}, popupSharedProps, {
    title: String,
    round: truthProp,
    options: makeArrayProp(),
    cancelText: String,
    description: String,
    closeOnPopstate: truthProp,
    safeAreaInsetBottom: truthProp
  });
  var stdin_default$r = vue.defineComponent({
    name: name$m,
    props: shareSheetProps,
    emits: ["cancel", "select", "update:show"],
    setup(props2, {
      emit,
      slots
    }) {
      const updateShow = (value) => emit("update:show", value);
      const onCancel = () => {
        updateShow(false);
        emit("cancel");
      };
      const onSelect = (option, index2) => emit("select", option, index2);
      const renderHeader = () => {
        const title = slots.title ? slots.title() : props2.title;
        const description = slots.description ? slots.description() : props2.description;
        if (title || description) {
          return vue.createVNode("div", {
            "class": bem$l("header")
          }, [title && vue.createVNode("h2", {
            "class": bem$l("title")
          }, [title]), description && vue.createVNode("span", {
            "class": bem$l("description")
          }, [description])]);
        }
      };
      const renderIcon = (icon) => {
        if (isImage(icon)) {
          return vue.createVNode("img", {
            "src": icon,
            "class": bem$l("image-icon")
          }, null);
        }
        return vue.createVNode("div", {
          "class": bem$l("icon", [icon])
        }, [vue.createVNode(Icon, {
          "name": iconMap[icon] || icon
        }, null)]);
      };
      const renderOption = (option, index2) => {
        const {
          name: name2,
          icon,
          className,
          description
        } = option;
        return vue.createVNode("div", {
          "role": "button",
          "tabindex": 0,
          "class": [bem$l("option"), className, HAPTICS_FEEDBACK],
          "onClick": () => onSelect(option, index2)
        }, [renderIcon(icon), name2 && vue.createVNode("span", {
          "class": bem$l("name")
        }, [name2]), description && vue.createVNode("span", {
          "class": bem$l("option-description")
        }, [description])]);
      };
      const renderOptions = (options, border) => vue.createVNode("div", {
        "class": bem$l("options", {
          border
        })
      }, [options.map(renderOption)]);
      const renderRows = () => {
        const {
          options
        } = props2;
        if (Array.isArray(options[0])) {
          return options.map((item, index2) => renderOptions(item, index2 !== 0));
        }
        return renderOptions(options);
      };
      const renderCancelButton = () => {
        var _a;
        const cancelText = (_a = props2.cancelText) != null ? _a : t$5("cancel");
        if (slots.cancel || cancelText) {
          return vue.createVNode("button", {
            "type": "button",
            "class": bem$l("cancel"),
            "onClick": onCancel
          }, [slots.cancel ? slots.cancel() : cancelText]);
        }
      };
      return () => vue.createVNode(Popup, vue.mergeProps({
        "class": bem$l(),
        "position": "bottom",
        "onUpdate:show": updateShow
      }, pick(props2, popupInheritKeys)), {
        default: () => [renderHeader(), renderRows(), renderCancelButton()]
      });
    }
  });
  const ShareSheet = withInstall(stdin_default$r);
  const [name$l, bem$k] = createNamespace("sidebar");
  const SIDEBAR_KEY = Symbol(name$l);
  const sidebarProps = {
    modelValue: makeNumericProp(0)
  };
  var stdin_default$q = vue.defineComponent({
    name: name$l,
    props: sidebarProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        linkChildren
      } = useChildren(SIDEBAR_KEY);
      const getActive = () => +props2.modelValue;
      const setActive = (value) => {
        if (value !== getActive()) {
          emit("update:modelValue", value);
          emit("change", value);
        }
      };
      linkChildren({
        getActive,
        setActive
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "role": "tablist",
          "class": bem$k()
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
    }
  });
  const Sidebar = withInstall(stdin_default$q);
  const [name$k, bem$j] = createNamespace("sidebar-item");
  const sidebarItemProps = extend({}, routeProps, {
    dot: Boolean,
    title: String,
    badge: numericProp,
    disabled: Boolean,
    badgeProps: Object
  });
  var stdin_default$p = vue.defineComponent({
    name: name$k,
    props: sidebarItemProps,
    emits: ["click"],
    setup(props2, {
      emit,
      slots
    }) {
      const route2 = useRoute();
      const {
        parent,
        index: index2
      } = useParent(SIDEBAR_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/sidebar-item/SidebarItem.mjs:30", "[Vant] <SidebarItem> must be a child component of <Sidebar>.");
        }
        return;
      }
      const onClick = () => {
        if (props2.disabled) {
          return;
        }
        emit("click", index2.value);
        parent.setActive(index2.value);
        route2();
      };
      return () => {
        const {
          dot,
          badge,
          title,
          disabled
        } = props2;
        const selected = index2.value === parent.getActive();
        return vue.createVNode("div", {
          "role": "tab",
          "class": bem$j({
            select: selected,
            disabled
          }),
          "tabindex": disabled ? void 0 : 0,
          "aria-selected": selected,
          "onClick": onClick
        }, [vue.createVNode(Badge, vue.mergeProps({
          "dot": dot,
          "class": bem$j("text"),
          "content": badge
        }, props2.badgeProps), {
          default: () => [slots.title ? slots.title() : title]
        })]);
      };
    }
  });
  const SidebarItem = withInstall(stdin_default$p);
  const [name$j, bem$i, t$4] = createNamespace("signature");
  const signatureProps = {
    tips: String,
    type: makeStringProp("png"),
    penColor: makeStringProp("#000"),
    lineWidth: makeNumberProp(3),
    clearButtonText: String,
    backgroundColor: makeStringProp(""),
    confirmButtonText: String
  };
  const hasCanvasSupport = () => {
    var _a;
    const canvas = document.createElement("canvas");
    return !!((_a = canvas.getContext) == null ? void 0 : _a.call(canvas, "2d"));
  };
  var stdin_default$o = vue.defineComponent({
    name: name$j,
    props: signatureProps,
    emits: ["submit", "clear", "start", "end", "signing"],
    setup(props2, {
      emit
    }) {
      const canvasRef = vue.ref();
      const wrapRef = vue.ref();
      const ctx = vue.computed(() => {
        if (!canvasRef.value)
          return null;
        return canvasRef.value.getContext("2d");
      });
      const isRenderCanvas = inBrowser$1 ? hasCanvasSupport() : true;
      let canvasWidth = 0;
      let canvasHeight = 0;
      let canvasRect;
      const touchStart = () => {
        if (!ctx.value) {
          return false;
        }
        ctx.value.beginPath();
        ctx.value.lineWidth = props2.lineWidth;
        ctx.value.strokeStyle = props2.penColor;
        canvasRect = useRect(canvasRef);
        emit("start");
      };
      const touchMove = (event) => {
        if (!ctx.value) {
          return false;
        }
        preventDefault(event);
        const touch = event.touches[0];
        const mouseX = touch.clientX - ((canvasRect == null ? void 0 : canvasRect.left) || 0);
        const mouseY = touch.clientY - ((canvasRect == null ? void 0 : canvasRect.top) || 0);
        ctx.value.lineCap = "round";
        ctx.value.lineJoin = "round";
        ctx.value.lineTo(mouseX, mouseY);
        ctx.value.stroke();
        emit("signing", event);
      };
      const touchEnd = (event) => {
        preventDefault(event);
        emit("end");
      };
      const isCanvasEmpty = (canvas) => {
        const empty2 = document.createElement("canvas");
        empty2.width = canvas.width;
        empty2.height = canvas.height;
        if (props2.backgroundColor) {
          const emptyCtx = empty2.getContext("2d");
          setCanvasBgColor(emptyCtx);
        }
        return canvas.toDataURL() === empty2.toDataURL();
      };
      const setCanvasBgColor = (ctx2) => {
        if (ctx2 && props2.backgroundColor) {
          ctx2.fillStyle = props2.backgroundColor;
          ctx2.fillRect(0, 0, canvasWidth, canvasHeight);
        }
      };
      const submit = () => {
        var _a, _b;
        const canvas = canvasRef.value;
        if (!canvas) {
          return;
        }
        const isEmpty = isCanvasEmpty(canvas);
        const image2 = isEmpty ? "" : ((_b = (_a = {
          jpg: () => canvas.toDataURL("image/jpeg", 0.8),
          jpeg: () => canvas.toDataURL("image/jpeg", 0.8)
        })[props2.type]) == null ? void 0 : _b.call(_a)) || canvas.toDataURL(`image/${props2.type}`);
        emit("submit", {
          image: image2,
          canvas
        });
      };
      const clear = () => {
        if (ctx.value) {
          ctx.value.clearRect(0, 0, canvasWidth, canvasHeight);
          ctx.value.closePath();
          setCanvasBgColor(ctx.value);
        }
        emit("clear");
      };
      const initialize = () => {
        var _a, _b, _c;
        if (isRenderCanvas && canvasRef.value) {
          const canvas = canvasRef.value;
          const dpr = inBrowser$1 ? window.devicePixelRatio : 1;
          canvasWidth = canvas.width = (((_a = wrapRef.value) == null ? void 0 : _a.offsetWidth) || 0) * dpr;
          canvasHeight = canvas.height = (((_b = wrapRef.value) == null ? void 0 : _b.offsetHeight) || 0) * dpr;
          (_c = ctx.value) == null ? void 0 : _c.scale(dpr, dpr);
          setCanvasBgColor(ctx.value);
        }
      };
      const resize = () => {
        if (ctx.value) {
          const data = ctx.value.getImageData(0, 0, canvasWidth, canvasHeight);
          initialize();
          ctx.value.putImageData(data, 0, 0);
        }
      };
      vue.watch(windowWidth, resize);
      vue.onMounted(initialize);
      useExpose({
        resize,
        clear,
        submit
      });
      return () => vue.createVNode("div", {
        "class": bem$i()
      }, [vue.createVNode("div", {
        "class": bem$i("content"),
        "ref": wrapRef
      }, [isRenderCanvas ? vue.createVNode("canvas", {
        "ref": canvasRef,
        "onTouchstartPassive": touchStart,
        "onTouchmove": touchMove,
        "onTouchend": touchEnd
      }, null) : vue.createVNode("p", null, [props2.tips])]), vue.createVNode("div", {
        "class": bem$i("footer")
      }, [vue.createVNode(Button, {
        "size": "small",
        "onClick": clear
      }, {
        default: () => [props2.clearButtonText || t$4("clear")]
      }), vue.createVNode(Button, {
        "type": "primary",
        "size": "small",
        "onClick": submit
      }, {
        default: () => [props2.confirmButtonText || t$4("confirm")]
      })])]);
    }
  });
  const Signature = withInstall(stdin_default$o);
  const [name$i, bem$h] = createNamespace("skeleton-title");
  const skeletonTitleProps = {
    round: Boolean,
    titleWidth: numericProp
  };
  var stdin_default$n = vue.defineComponent({
    name: name$i,
    props: skeletonTitleProps,
    setup(props2) {
      return () => vue.createVNode("h3", {
        "class": bem$h([{
          round: props2.round
        }]),
        "style": {
          width: addUnit$2(props2.titleWidth)
        }
      }, null);
    }
  });
  const SkeletonTitle = withInstall(stdin_default$n);
  var stdin_default$m = SkeletonTitle;
  const [name$h, bem$g] = createNamespace("skeleton-avatar");
  const skeletonAvatarProps = {
    avatarSize: numericProp,
    avatarShape: makeStringProp("round")
  };
  var stdin_default$l = vue.defineComponent({
    name: name$h,
    props: skeletonAvatarProps,
    setup(props2) {
      return () => vue.createVNode("div", {
        "class": bem$g([props2.avatarShape]),
        "style": getSizeStyle(props2.avatarSize)
      }, null);
    }
  });
  const SkeletonAvatar = withInstall(stdin_default$l);
  var stdin_default$k = SkeletonAvatar;
  const DEFAULT_ROW_WIDTH = "100%";
  const skeletonParagraphProps = {
    round: Boolean,
    rowWidth: {
      type: numericProp,
      default: DEFAULT_ROW_WIDTH
    }
  };
  const [name$g, bem$f] = createNamespace("skeleton-paragraph");
  var stdin_default$j = vue.defineComponent({
    name: name$g,
    props: skeletonParagraphProps,
    setup(props2) {
      return () => vue.createVNode("div", {
        "class": bem$f([{
          round: props2.round
        }]),
        "style": {
          width: props2.rowWidth
        }
      }, null);
    }
  });
  const SkeletonParagraph = withInstall(stdin_default$j);
  var stdin_default$i = SkeletonParagraph;
  const [name$f, bem$e] = createNamespace("skeleton");
  const DEFAULT_LAST_ROW_WIDTH = "60%";
  const skeletonProps = {
    row: makeNumericProp(0),
    round: Boolean,
    title: Boolean,
    titleWidth: numericProp,
    avatar: Boolean,
    avatarSize: numericProp,
    avatarShape: makeStringProp("round"),
    loading: truthProp,
    animate: truthProp,
    rowWidth: {
      type: [Number, String, Array],
      default: DEFAULT_ROW_WIDTH
    }
  };
  var stdin_default$h = vue.defineComponent({
    name: name$f,
    inheritAttrs: false,
    props: skeletonProps,
    setup(props2, {
      slots,
      attrs
    }) {
      const renderAvatar = () => {
        if (props2.avatar) {
          return vue.createVNode(stdin_default$k, {
            "avatarShape": props2.avatarShape,
            "avatarSize": props2.avatarSize
          }, null);
        }
      };
      const renderTitle = () => {
        if (props2.title) {
          return vue.createVNode(stdin_default$m, {
            "round": props2.round,
            "titleWidth": props2.titleWidth
          }, null);
        }
      };
      const getRowWidth = (index2) => {
        const {
          rowWidth
        } = props2;
        if (rowWidth === DEFAULT_ROW_WIDTH && index2 === +props2.row - 1) {
          return DEFAULT_LAST_ROW_WIDTH;
        }
        if (Array.isArray(rowWidth)) {
          return rowWidth[index2];
        }
        return rowWidth;
      };
      const renderRows = () => Array(+props2.row).fill("").map((_, i2) => vue.createVNode(stdin_default$i, {
        "key": i2,
        "round": props2.round,
        "rowWidth": addUnit$2(getRowWidth(i2))
      }, null));
      const renderContents = () => {
        if (slots.template) {
          return slots.template();
        }
        return vue.createVNode(vue.Fragment, null, [renderAvatar(), vue.createVNode("div", {
          "class": bem$e("content")
        }, [renderTitle(), renderRows()])]);
      };
      return () => {
        var _a;
        if (!props2.loading) {
          return (_a = slots.default) == null ? void 0 : _a.call(slots);
        }
        return vue.createVNode("div", vue.mergeProps({
          "class": bem$e({
            animate: props2.animate,
            round: props2.round
          })
        }, attrs), [renderContents()]);
      };
    }
  });
  const Skeleton = withInstall(stdin_default$h);
  const [name$e, bem$d] = createNamespace("skeleton-image");
  const skeletonImageProps = {
    imageSize: numericProp,
    imageShape: makeStringProp("square")
  };
  var stdin_default$g = vue.defineComponent({
    name: name$e,
    props: skeletonImageProps,
    setup(props2) {
      return () => vue.createVNode("div", {
        "class": bem$d([props2.imageShape]),
        "style": getSizeStyle(props2.imageSize)
      }, [vue.createVNode(Icon, {
        "name": "photo",
        "class": bem$d("icon")
      }, null)]);
    }
  });
  const SkeletonImage = withInstall(stdin_default$g);
  const [name$d, bem$c] = createNamespace("slider");
  const sliderProps = {
    min: makeNumericProp(0),
    max: makeNumericProp(100),
    step: makeNumericProp(1),
    range: Boolean,
    reverse: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    vertical: Boolean,
    barHeight: numericProp,
    buttonSize: numericProp,
    activeColor: String,
    inactiveColor: String,
    modelValue: {
      type: [Number, Array],
      default: 0
    }
  };
  var stdin_default$f = vue.defineComponent({
    name: name$d,
    props: sliderProps,
    emits: ["change", "dragEnd", "dragStart", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      let buttonIndex;
      let current2;
      let startValue;
      const root = vue.ref();
      const slider = [vue.ref(), vue.ref()];
      const dragStatus = vue.ref();
      const touch = useTouch();
      const scope = vue.computed(() => Number(props2.max) - Number(props2.min));
      const wrapperStyle = vue.computed(() => {
        const crossAxis = props2.vertical ? "width" : "height";
        return {
          background: props2.inactiveColor,
          [crossAxis]: addUnit$2(props2.barHeight)
        };
      });
      const isRange = (val) => props2.range && Array.isArray(val);
      const calcMainAxis = () => {
        const {
          modelValue,
          min
        } = props2;
        if (isRange(modelValue)) {
          return `${(modelValue[1] - modelValue[0]) * 100 / scope.value}%`;
        }
        return `${(modelValue - Number(min)) * 100 / scope.value}%`;
      };
      const calcOffset = () => {
        const {
          modelValue,
          min
        } = props2;
        if (isRange(modelValue)) {
          return `${(modelValue[0] - Number(min)) * 100 / scope.value}%`;
        }
        return "0%";
      };
      const barStyle = vue.computed(() => {
        const mainAxis = props2.vertical ? "height" : "width";
        const style = {
          [mainAxis]: calcMainAxis(),
          background: props2.activeColor
        };
        if (dragStatus.value) {
          style.transition = "none";
        }
        const getPositionKey = () => {
          if (props2.vertical) {
            return props2.reverse ? "bottom" : "top";
          }
          return props2.reverse ? "right" : "left";
        };
        style[getPositionKey()] = calcOffset();
        return style;
      });
      const format2 = (value) => {
        const min = +props2.min;
        const max = +props2.max;
        const step = +props2.step;
        value = clamp(value, min, max);
        const diff = Math.round((value - min) / step) * step;
        return addNumber(min, diff);
      };
      const updateStartValue = () => {
        const current22 = props2.modelValue;
        if (isRange(current22)) {
          startValue = current22.map(format2);
        } else {
          startValue = format2(current22);
        }
      };
      const handleRangeValue = (value) => {
        var _a, _b;
        const left2 = (_a = value[0]) != null ? _a : Number(props2.min);
        const right2 = (_b = value[1]) != null ? _b : Number(props2.max);
        return left2 > right2 ? [right2, left2] : [left2, right2];
      };
      const updateValue = (value, end2) => {
        if (isRange(value)) {
          value = handleRangeValue(value).map(format2);
        } else {
          value = format2(value);
        }
        if (!isSameValue(value, props2.modelValue)) {
          emit("update:modelValue", value);
        }
        if (end2 && !isSameValue(value, startValue)) {
          emit("change", value);
        }
      };
      const onClick = (event) => {
        event.stopPropagation();
        if (props2.disabled || props2.readonly) {
          return;
        }
        updateStartValue();
        const {
          min,
          reverse,
          vertical,
          modelValue
        } = props2;
        const rect = useRect(root);
        const getDelta = () => {
          if (vertical) {
            if (reverse) {
              return rect.bottom - event.clientY;
            }
            return event.clientY - rect.top;
          }
          if (reverse) {
            return rect.right - event.clientX;
          }
          return event.clientX - rect.left;
        };
        const total = vertical ? rect.height : rect.width;
        const value = Number(min) + getDelta() / total * scope.value;
        if (isRange(modelValue)) {
          const [left2, right2] = modelValue;
          const middle = (left2 + right2) / 2;
          if (value <= middle) {
            updateValue([value, right2], true);
          } else {
            updateValue([left2, value], true);
          }
        } else {
          updateValue(value, true);
        }
      };
      const onTouchStart = (event) => {
        if (props2.disabled || props2.readonly) {
          return;
        }
        touch.start(event);
        current2 = props2.modelValue;
        updateStartValue();
        dragStatus.value = "start";
      };
      const onTouchMove = (event) => {
        if (props2.disabled || props2.readonly) {
          return;
        }
        if (dragStatus.value === "start") {
          emit("dragStart", event);
        }
        preventDefault(event, true);
        touch.move(event);
        dragStatus.value = "dragging";
        const rect = useRect(root);
        const delta = props2.vertical ? touch.deltaY.value : touch.deltaX.value;
        const total = props2.vertical ? rect.height : rect.width;
        let diff = delta / total * scope.value;
        if (props2.reverse) {
          diff = -diff;
        }
        if (isRange(startValue)) {
          const index2 = props2.reverse ? 1 - buttonIndex : buttonIndex;
          current2[index2] = startValue[index2] + diff;
        } else {
          current2 = startValue + diff;
        }
        updateValue(current2);
      };
      const onTouchEnd = (event) => {
        if (props2.disabled || props2.readonly) {
          return;
        }
        if (dragStatus.value === "dragging") {
          updateValue(current2, true);
          emit("dragEnd", event);
        }
        dragStatus.value = "";
      };
      const getButtonClassName = (index2) => {
        if (typeof index2 === "number") {
          const position = ["left", "right"];
          return bem$c(`button-wrapper`, position[index2]);
        }
        return bem$c("button-wrapper", props2.reverse ? "left" : "right");
      };
      const renderButtonContent = (value, index2) => {
        const dragging = dragStatus.value === "dragging";
        if (typeof index2 === "number") {
          const slot = slots[index2 === 0 ? "left-button" : "right-button"];
          let dragIndex;
          if (dragging && Array.isArray(current2)) {
            dragIndex = current2[0] > current2[1] ? buttonIndex ^ 1 : buttonIndex;
          }
          if (slot) {
            return slot({
              value,
              dragging,
              dragIndex
            });
          }
        }
        if (slots.button) {
          return slots.button({
            value,
            dragging
          });
        }
        return vue.createVNode("div", {
          "class": bem$c("button"),
          "style": getSizeStyle(props2.buttonSize)
        }, null);
      };
      const renderButton = (index2) => {
        const current22 = typeof index2 === "number" ? props2.modelValue[index2] : props2.modelValue;
        return vue.createVNode("div", {
          "ref": slider[index2 != null ? index2 : 0],
          "role": "slider",
          "class": getButtonClassName(index2),
          "tabindex": props2.disabled ? void 0 : 0,
          "aria-valuemin": props2.min,
          "aria-valuenow": current22,
          "aria-valuemax": props2.max,
          "aria-disabled": props2.disabled || void 0,
          "aria-readonly": props2.readonly || void 0,
          "aria-orientation": props2.vertical ? "vertical" : "horizontal",
          "onTouchstartPassive": (event) => {
            if (typeof index2 === "number") {
              buttonIndex = index2;
            }
            onTouchStart(event);
          },
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd,
          "onClick": stopPropagation
        }, [renderButtonContent(current22, index2)]);
      };
      updateValue(props2.modelValue);
      useCustomFieldValue(() => props2.modelValue);
      slider.forEach((item) => {
        useEventListener("touchmove", onTouchMove, {
          target: item
        });
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "style": wrapperStyle.value,
        "class": bem$c({
          vertical: props2.vertical,
          disabled: props2.disabled
        }),
        "onClick": onClick
      }, [vue.createVNode("div", {
        "class": bem$c("bar"),
        "style": barStyle.value
      }, [props2.range ? [renderButton(0), renderButton(1)] : renderButton()])]);
    }
  });
  const Slider = withInstall(stdin_default$f);
  const [name$c, bem$b] = createNamespace("space");
  const spaceProps = {
    align: String,
    direction: {
      type: String,
      default: "horizontal"
    },
    size: {
      type: [Number, String, Array],
      default: 8
    },
    wrap: Boolean,
    fill: Boolean
  };
  function filterEmpty(children = []) {
    const nodes = [];
    children.forEach((child) => {
      if (Array.isArray(child)) {
        nodes.push(...child);
      } else if (child.type === vue.Fragment) {
        nodes.push(...filterEmpty(child.children));
      } else {
        nodes.push(child);
      }
    });
    return nodes.filter((c2) => {
      var _a;
      return !(c2 && (c2.type === vue.Comment || c2.type === vue.Fragment && ((_a = c2.children) == null ? void 0 : _a.length) === 0 || c2.type === vue.Text && c2.children.trim() === ""));
    });
  }
  var stdin_default$e = vue.defineComponent({
    name: name$c,
    props: spaceProps,
    setup(props2, {
      slots
    }) {
      const mergedAlign = vue.computed(() => {
        var _a;
        return (_a = props2.align) != null ? _a : props2.direction === "horizontal" ? "center" : "";
      });
      const getMargin = (size) => {
        if (typeof size === "number") {
          return size + "px";
        }
        return size;
      };
      const getMarginStyle = (isLast) => {
        const style = {};
        const marginRight = `${getMargin(Array.isArray(props2.size) ? props2.size[0] : props2.size)}`;
        const marginBottom = `${getMargin(Array.isArray(props2.size) ? props2.size[1] : props2.size)}`;
        if (isLast) {
          return props2.wrap ? {
            marginBottom
          } : {};
        }
        if (props2.direction === "horizontal") {
          style.marginRight = marginRight;
        }
        if (props2.direction === "vertical" || props2.wrap) {
          style.marginBottom = marginBottom;
        }
        return style;
      };
      return () => {
        var _a;
        const children = filterEmpty((_a = slots.default) == null ? void 0 : _a.call(slots));
        return vue.createVNode("div", {
          "class": [bem$b({
            [props2.direction]: props2.direction,
            [`align-${mergedAlign.value}`]: mergedAlign.value,
            wrap: props2.wrap,
            fill: props2.fill
          })]
        }, [children.map((c2, i2) => vue.createVNode("div", {
          "key": `item-${i2}`,
          "class": `${name$c}-item`,
          "style": getMarginStyle(i2 === children.length - 1)
        }, [c2]))]);
      };
    }
  });
  const Space = withInstall(stdin_default$e);
  const [name$b, bem$a] = createNamespace("steps");
  const stepsProps = {
    active: makeNumericProp(0),
    direction: makeStringProp("horizontal"),
    activeIcon: makeStringProp("checked"),
    iconPrefix: String,
    finishIcon: String,
    activeColor: String,
    inactiveIcon: String,
    inactiveColor: String
  };
  const STEPS_KEY = Symbol(name$b);
  var stdin_default$d = vue.defineComponent({
    name: name$b,
    props: stepsProps,
    emits: ["clickStep"],
    setup(props2, {
      emit,
      slots
    }) {
      const {
        linkChildren
      } = useChildren(STEPS_KEY);
      const onClickStep = (index2) => emit("clickStep", index2);
      linkChildren({
        props: props2,
        onClickStep
      });
      return () => {
        var _a;
        return vue.createVNode("div", {
          "class": bem$a([props2.direction])
        }, [vue.createVNode("div", {
          "class": bem$a("items")
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
      };
    }
  });
  const [name$a, bem$9] = createNamespace("step");
  var stdin_default$c = vue.defineComponent({
    name: name$a,
    setup(props2, {
      slots
    }) {
      const {
        parent,
        index: index2
      } = useParent(STEPS_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/step/Step.mjs:18", "[Vant] <Step> must be a child component of <Steps>.");
        }
        return;
      }
      const parentProps = parent.props;
      const getStatus = () => {
        const active = +parentProps.active;
        if (index2.value < active) {
          return "finish";
        }
        return index2.value === active ? "process" : "waiting";
      };
      const isActive = () => getStatus() === "process";
      const lineStyle = vue.computed(() => ({
        background: getStatus() === "finish" ? parentProps.activeColor : parentProps.inactiveColor
      }));
      const titleStyle = vue.computed(() => {
        if (isActive()) {
          return {
            color: parentProps.activeColor
          };
        }
        if (getStatus() === "waiting") {
          return {
            color: parentProps.inactiveColor
          };
        }
      });
      const onClickStep = () => parent.onClickStep(index2.value);
      const renderCircle = () => {
        const {
          iconPrefix,
          finishIcon,
          activeIcon,
          activeColor,
          inactiveIcon
        } = parentProps;
        if (isActive()) {
          if (slots["active-icon"]) {
            return slots["active-icon"]();
          }
          return vue.createVNode(Icon, {
            "class": bem$9("icon", "active"),
            "name": activeIcon,
            "color": activeColor,
            "classPrefix": iconPrefix
          }, null);
        }
        if (getStatus() === "finish" && (finishIcon || slots["finish-icon"])) {
          if (slots["finish-icon"]) {
            return slots["finish-icon"]();
          }
          return vue.createVNode(Icon, {
            "class": bem$9("icon", "finish"),
            "name": finishIcon,
            "color": activeColor,
            "classPrefix": iconPrefix
          }, null);
        }
        if (slots["inactive-icon"]) {
          return slots["inactive-icon"]();
        }
        if (inactiveIcon) {
          return vue.createVNode(Icon, {
            "class": bem$9("icon"),
            "name": inactiveIcon,
            "classPrefix": iconPrefix
          }, null);
        }
        return vue.createVNode("i", {
          "class": bem$9("circle"),
          "style": lineStyle.value
        }, null);
      };
      return () => {
        var _a;
        const status = getStatus();
        return vue.createVNode("div", {
          "class": [BORDER, bem$9([parentProps.direction, {
            [status]: status
          }])]
        }, [vue.createVNode("div", {
          "class": bem$9("title", {
            active: isActive()
          }),
          "style": titleStyle.value,
          "onClick": onClickStep
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), vue.createVNode("div", {
          "class": bem$9("circle-container"),
          "onClick": onClickStep
        }, [renderCircle()]), vue.createVNode("div", {
          "class": bem$9("line"),
          "style": lineStyle.value
        }, null)]);
      };
    }
  });
  const Step = withInstall(stdin_default$c);
  const [name$9, bem$8] = createNamespace("stepper");
  const LONG_PRESS_INTERVAL = 200;
  const isEqual = (value1, value2) => String(value1) === String(value2);
  const stepperProps = {
    min: makeNumericProp(1),
    max: makeNumericProp(Infinity),
    name: makeNumericProp(""),
    step: makeNumericProp(1),
    theme: String,
    integer: Boolean,
    disabled: Boolean,
    showPlus: truthProp,
    showMinus: truthProp,
    showInput: truthProp,
    longPress: truthProp,
    autoFixed: truthProp,
    allowEmpty: Boolean,
    modelValue: numericProp,
    inputWidth: numericProp,
    buttonSize: numericProp,
    placeholder: String,
    disablePlus: Boolean,
    disableMinus: Boolean,
    disableInput: Boolean,
    beforeChange: Function,
    defaultValue: makeNumericProp(1),
    decimalLength: numericProp
  };
  var stdin_default$b = vue.defineComponent({
    name: name$9,
    props: stepperProps,
    emits: ["plus", "blur", "minus", "focus", "change", "overlimit", "update:modelValue"],
    setup(props2, {
      emit
    }) {
      const format2 = (value, autoFixed = true) => {
        const {
          min,
          max,
          allowEmpty,
          decimalLength
        } = props2;
        if (allowEmpty && value === "") {
          return value;
        }
        value = formatNumber(String(value), !props2.integer);
        value = value === "" ? 0 : +value;
        value = Number.isNaN(value) ? +min : value;
        value = autoFixed ? Math.max(Math.min(+max, value), +min) : value;
        if (isDef(decimalLength)) {
          value = value.toFixed(+decimalLength);
        }
        return value;
      };
      const getInitialValue = () => {
        var _a;
        const defaultValue = (_a = props2.modelValue) != null ? _a : props2.defaultValue;
        const value = format2(defaultValue);
        if (!isEqual(value, props2.modelValue)) {
          emit("update:modelValue", value);
        }
        return value;
      };
      let actionType;
      const inputRef = vue.ref();
      const current2 = vue.ref(getInitialValue());
      const minusDisabled = vue.computed(() => props2.disabled || props2.disableMinus || +current2.value <= +props2.min);
      const plusDisabled = vue.computed(() => props2.disabled || props2.disablePlus || +current2.value >= +props2.max);
      const inputStyle = vue.computed(() => ({
        width: addUnit$2(props2.inputWidth),
        height: addUnit$2(props2.buttonSize)
      }));
      const buttonStyle = vue.computed(() => getSizeStyle(props2.buttonSize));
      const check = () => {
        const value = format2(current2.value);
        if (!isEqual(value, current2.value)) {
          current2.value = value;
        }
      };
      const setValue = (value) => {
        if (props2.beforeChange) {
          callInterceptor(props2.beforeChange, {
            args: [value],
            done() {
              current2.value = value;
            }
          });
        } else {
          current2.value = value;
        }
      };
      const onChange = () => {
        if (actionType === "plus" && plusDisabled.value || actionType === "minus" && minusDisabled.value) {
          emit("overlimit", actionType);
          return;
        }
        const diff = actionType === "minus" ? -props2.step : +props2.step;
        const value = format2(addNumber(+current2.value, diff));
        setValue(value);
        emit(actionType);
      };
      const onInput = (event) => {
        const input = event.target;
        const {
          value
        } = input;
        const {
          decimalLength
        } = props2;
        let formatted = formatNumber(String(value), !props2.integer);
        if (isDef(decimalLength) && formatted.includes(".")) {
          const pair = formatted.split(".");
          formatted = `${pair[0]}.${pair[1].slice(0, +decimalLength)}`;
        }
        if (props2.beforeChange) {
          input.value = String(current2.value);
        } else if (!isEqual(value, formatted)) {
          input.value = formatted;
        }
        const isNumeric2 = formatted === String(+formatted);
        setValue(isNumeric2 ? +formatted : formatted);
      };
      const onFocus = (event) => {
        var _a;
        if (props2.disableInput) {
          (_a = inputRef.value) == null ? void 0 : _a.blur();
        } else {
          emit("focus", event);
        }
      };
      const onBlur = (event) => {
        const input = event.target;
        const value = format2(input.value, props2.autoFixed);
        input.value = String(value);
        current2.value = value;
        vue.nextTick(() => {
          emit("blur", event);
          resetScroll();
        });
      };
      let isLongPress;
      let longPressTimer;
      const longPressStep = () => {
        longPressTimer = setTimeout(() => {
          onChange();
          longPressStep();
        }, LONG_PRESS_INTERVAL);
      };
      const onTouchStart = () => {
        if (props2.longPress) {
          isLongPress = false;
          clearTimeout(longPressTimer);
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            onChange();
            longPressStep();
          }, LONG_PRESS_START_TIME);
        }
      };
      const onTouchEnd = (event) => {
        if (props2.longPress) {
          clearTimeout(longPressTimer);
          if (isLongPress) {
            preventDefault(event);
          }
        }
      };
      const onMousedown = (event) => {
        if (props2.disableInput) {
          preventDefault(event);
        }
      };
      const createListeners = (type) => ({
        onClick: (event) => {
          preventDefault(event);
          actionType = type;
          onChange();
        },
        onTouchstartPassive: () => {
          actionType = type;
          onTouchStart();
        },
        onTouchend: onTouchEnd,
        onTouchcancel: onTouchEnd
      });
      vue.watch(() => [props2.max, props2.min, props2.integer, props2.decimalLength], check);
      vue.watch(() => props2.modelValue, (value) => {
        if (!isEqual(value, current2.value)) {
          current2.value = format2(value);
        }
      });
      vue.watch(current2, (value) => {
        emit("update:modelValue", value);
        emit("change", value, {
          name: props2.name
        });
      });
      useCustomFieldValue(() => props2.modelValue);
      return () => vue.createVNode("div", {
        "role": "group",
        "class": bem$8([props2.theme])
      }, [vue.withDirectives(vue.createVNode("button", vue.mergeProps({
        "type": "button",
        "style": buttonStyle.value,
        "class": [bem$8("minus", {
          disabled: minusDisabled.value
        }), {
          [HAPTICS_FEEDBACK]: !minusDisabled.value
        }],
        "aria-disabled": minusDisabled.value || void 0
      }, createListeners("minus")), null), [[vue.vShow, props2.showMinus]]), vue.withDirectives(vue.createVNode("input", {
        "ref": inputRef,
        "type": props2.integer ? "tel" : "text",
        "role": "spinbutton",
        "class": bem$8("input"),
        "value": current2.value,
        "style": inputStyle.value,
        "disabled": props2.disabled,
        "readonly": props2.disableInput,
        "inputmode": props2.integer ? "numeric" : "decimal",
        "placeholder": props2.placeholder,
        "autocomplete": "off",
        "aria-valuemax": props2.max,
        "aria-valuemin": props2.min,
        "aria-valuenow": current2.value,
        "onBlur": onBlur,
        "onInput": onInput,
        "onFocus": onFocus,
        "onMousedown": onMousedown
      }, null), [[vue.vShow, props2.showInput]]), vue.withDirectives(vue.createVNode("button", vue.mergeProps({
        "type": "button",
        "style": buttonStyle.value,
        "class": [bem$8("plus", {
          disabled: plusDisabled.value
        }), {
          [HAPTICS_FEEDBACK]: !plusDisabled.value
        }],
        "aria-disabled": plusDisabled.value || void 0
      }, createListeners("plus")), null), [[vue.vShow, props2.showPlus]])]);
    }
  });
  const Stepper = withInstall(stdin_default$b);
  const Steps = withInstall(stdin_default$d);
  const [name$8, bem$7, t$3] = createNamespace("submit-bar");
  const submitBarProps = {
    tip: String,
    label: String,
    price: Number,
    tipIcon: String,
    loading: Boolean,
    currency: makeStringProp(""),
    disabled: Boolean,
    textAlign: String,
    buttonText: String,
    buttonType: makeStringProp("danger"),
    buttonColor: String,
    suffixLabel: String,
    placeholder: Boolean,
    decimalLength: makeNumericProp(2),
    safeAreaInsetBottom: truthProp
  };
  var stdin_default$a = vue.defineComponent({
    name: name$8,
    props: submitBarProps,
    emits: ["submit"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const renderPlaceholder = usePlaceholder(root, bem$7);
      const renderText = () => {
        const {
          price,
          label,
          currency,
          textAlign,
          suffixLabel,
          decimalLength
        } = props2;
        if (typeof price === "number") {
          const pricePair = (price / 100).toFixed(+decimalLength).split(".");
          const decimal = decimalLength ? `.${pricePair[1]}` : "";
          return vue.createVNode("div", {
            "class": bem$7("text"),
            "style": {
              textAlign
            }
          }, [vue.createVNode("span", null, [label || t$3("label")]), vue.createVNode("span", {
            "class": bem$7("price")
          }, [currency, vue.createVNode("span", {
            "class": bem$7("price-integer")
          }, [pricePair[0]]), decimal]), suffixLabel && vue.createVNode("span", {
            "class": bem$7("suffix-label")
          }, [suffixLabel])]);
        }
      };
      const renderTip = () => {
        var _a;
        const {
          tip,
          tipIcon
        } = props2;
        if (slots.tip || tip) {
          return vue.createVNode("div", {
            "class": bem$7("tip")
          }, [tipIcon && vue.createVNode(Icon, {
            "class": bem$7("tip-icon"),
            "name": tipIcon
          }, null), tip && vue.createVNode("span", {
            "class": bem$7("tip-text")
          }, [tip]), (_a = slots.tip) == null ? void 0 : _a.call(slots)]);
        }
      };
      const onClickButton = () => emit("submit");
      const renderButton = () => {
        if (slots.button) {
          return slots.button();
        }
        return vue.createVNode(Button, {
          "round": true,
          "type": props2.buttonType,
          "text": props2.buttonText,
          "class": bem$7("button", props2.buttonType),
          "color": props2.buttonColor,
          "loading": props2.loading,
          "disabled": props2.disabled,
          "onClick": onClickButton
        }, null);
      };
      const renderSubmitBar = () => {
        var _a, _b;
        return vue.createVNode("div", {
          "ref": root,
          "class": [bem$7(), {
            "van-safe-area-bottom": props2.safeAreaInsetBottom
          }]
        }, [(_a = slots.top) == null ? void 0 : _a.call(slots), renderTip(), vue.createVNode("div", {
          "class": bem$7("bar")
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots), renderText(), renderButton()])]);
      };
      return () => {
        if (props2.placeholder) {
          return renderPlaceholder(renderSubmitBar);
        }
        return renderSubmitBar();
      };
    }
  });
  const SubmitBar = withInstall(stdin_default$a);
  const [name$7, bem$6] = createNamespace("swipe-cell");
  const swipeCellProps = {
    name: makeNumericProp(""),
    disabled: Boolean,
    leftWidth: numericProp,
    rightWidth: numericProp,
    beforeClose: Function,
    stopPropagation: Boolean
  };
  var stdin_default$9 = vue.defineComponent({
    name: name$7,
    props: swipeCellProps,
    emits: ["open", "close", "click"],
    setup(props2, {
      emit,
      slots
    }) {
      let opened;
      let lockClick2;
      let startOffset;
      let isInBeforeClosing;
      const root = vue.ref();
      const leftRef = vue.ref();
      const rightRef = vue.ref();
      const state = vue.reactive({
        offset: 0,
        dragging: false
      });
      const touch = useTouch();
      const getWidthByRef = (ref2) => ref2.value ? useRect(ref2).width : 0;
      const leftWidth = vue.computed(() => isDef(props2.leftWidth) ? +props2.leftWidth : getWidthByRef(leftRef));
      const rightWidth = vue.computed(() => isDef(props2.rightWidth) ? +props2.rightWidth : getWidthByRef(rightRef));
      const open2 = (side) => {
        state.offset = side === "left" ? leftWidth.value : -rightWidth.value;
        if (!opened) {
          opened = true;
          emit("open", {
            name: props2.name,
            position: side
          });
        }
      };
      const close = (position) => {
        state.offset = 0;
        if (opened) {
          opened = false;
          emit("close", {
            name: props2.name,
            position
          });
        }
      };
      const toggle = (side) => {
        const offset2 = Math.abs(state.offset);
        const THRESHOLD = 0.15;
        const threshold = opened ? 1 - THRESHOLD : THRESHOLD;
        const width2 = side === "left" ? leftWidth.value : rightWidth.value;
        if (width2 && offset2 > width2 * threshold) {
          open2(side);
        } else {
          close(side);
        }
      };
      const onTouchStart = (event) => {
        if (!props2.disabled) {
          startOffset = state.offset;
          touch.start(event);
        }
      };
      const onTouchMove = (event) => {
        if (props2.disabled) {
          return;
        }
        const {
          deltaX
        } = touch;
        touch.move(event);
        if (touch.isHorizontal()) {
          lockClick2 = true;
          state.dragging = true;
          const isEdge = !opened || deltaX.value * startOffset < 0;
          if (isEdge) {
            preventDefault(event, props2.stopPropagation);
          }
          state.offset = clamp(deltaX.value + startOffset, -rightWidth.value, leftWidth.value);
        }
      };
      const onTouchEnd = () => {
        if (state.dragging) {
          state.dragging = false;
          toggle(state.offset > 0 ? "left" : "right");
          setTimeout(() => {
            lockClick2 = false;
          }, 0);
        }
      };
      const onClick = (position = "outside", event) => {
        if (isInBeforeClosing)
          return;
        emit("click", position);
        if (opened && !lockClick2) {
          isInBeforeClosing = true;
          callInterceptor(props2.beforeClose, {
            args: [{
              event,
              name: props2.name,
              position
            }],
            done: () => {
              isInBeforeClosing = false;
              close(position);
            },
            canceled: () => isInBeforeClosing = false,
            error: () => isInBeforeClosing = false
          });
        }
      };
      const getClickHandler = (position, stop) => (event) => {
        if (stop) {
          event.stopPropagation();
        }
        if (lockClick2) {
          return;
        }
        onClick(position, event);
      };
      const renderSideContent = (side, ref2) => {
        const contentSlot = slots[side];
        if (contentSlot) {
          return vue.createVNode("div", {
            "ref": ref2,
            "class": bem$6(side),
            "onClick": getClickHandler(side, true)
          }, [contentSlot()]);
        }
      };
      useExpose({
        open: open2,
        close
      });
      useClickAway(root, (event) => onClick("outside", event), {
        eventName: "touchstart"
      });
      useEventListener("touchmove", onTouchMove, {
        target: root
      });
      return () => {
        var _a;
        const wrapperStyle = {
          transform: `translate3d(${state.offset}px, 0, 0)`,
          transitionDuration: state.dragging ? "0s" : ".6s"
        };
        return vue.createVNode("div", {
          "ref": root,
          "class": bem$6(),
          "onClick": getClickHandler("cell", lockClick2),
          "onTouchstartPassive": onTouchStart,
          "onTouchend": onTouchEnd,
          "onTouchcancel": onTouchEnd
        }, [vue.createVNode("div", {
          "class": bem$6("wrapper"),
          "style": wrapperStyle
        }, [renderSideContent("left", leftRef), (_a = slots.default) == null ? void 0 : _a.call(slots), renderSideContent("right", rightRef)])]);
      };
    }
  });
  const SwipeCell = withInstall(stdin_default$9);
  const [name$6, bem$5] = createNamespace("tabbar");
  const tabbarProps = {
    route: Boolean,
    fixed: truthProp,
    border: truthProp,
    zIndex: numericProp,
    placeholder: Boolean,
    activeColor: String,
    beforeChange: Function,
    inactiveColor: String,
    modelValue: makeNumericProp(0),
    safeAreaInsetBottom: {
      type: Boolean,
      default: null
    }
  };
  const TABBAR_KEY = Symbol(name$6);
  var stdin_default$8 = vue.defineComponent({
    name: name$6,
    props: tabbarProps,
    emits: ["change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const root = vue.ref();
      const {
        linkChildren
      } = useChildren(TABBAR_KEY);
      const renderPlaceholder = usePlaceholder(root, bem$5);
      const enableSafeArea = () => {
        var _a;
        return (_a = props2.safeAreaInsetBottom) != null ? _a : props2.fixed;
      };
      const renderTabbar = () => {
        var _a;
        const {
          fixed,
          zIndex,
          border
        } = props2;
        return vue.createVNode("div", {
          "ref": root,
          "role": "tablist",
          "style": getZIndexStyle(zIndex),
          "class": [bem$5({
            fixed
          }), {
            [BORDER_TOP_BOTTOM]: border,
            "van-safe-area-bottom": enableSafeArea()
          }]
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
      const setActive = (active, afterChange) => {
        callInterceptor(props2.beforeChange, {
          args: [active],
          done() {
            emit("update:modelValue", active);
            emit("change", active);
            afterChange();
          }
        });
      };
      linkChildren({
        props: props2,
        setActive
      });
      return () => {
        if (props2.fixed && props2.placeholder) {
          return renderPlaceholder(renderTabbar);
        }
        return renderTabbar();
      };
    }
  });
  const Tabbar = withInstall(stdin_default$8);
  const [name$5, bem$4] = createNamespace("tabbar-item");
  const tabbarItemProps = extend({}, routeProps, {
    dot: Boolean,
    icon: String,
    name: numericProp,
    badge: numericProp,
    badgeProps: Object,
    iconPrefix: String
  });
  var stdin_default$7 = vue.defineComponent({
    name: name$5,
    props: tabbarItemProps,
    emits: ["click"],
    setup(props2, {
      emit,
      slots
    }) {
      const route2 = useRoute();
      const vm = vue.getCurrentInstance().proxy;
      const {
        parent,
        index: index2
      } = useParent(TABBAR_KEY);
      if (!parent) {
        {
          formatAppLog("error", "at node_modules/vant/es/tabbar-item/TabbarItem.mjs:33", "[Vant] <TabbarItem> must be a child component of <Tabbar>.");
        }
        return;
      }
      const active = vue.computed(() => {
        var _a;
        const {
          route: route22,
          modelValue
        } = parent.props;
        if (route22 && "$route" in vm) {
          const {
            $route
          } = vm;
          const {
            to
          } = props2;
          const config2 = isObject$1(to) ? to : {
            path: to
          };
          return !!$route.matched.find((val) => {
            const pathMatched = "path" in config2 && config2.path === val.path;
            const nameMatched = "name" in config2 && config2.name === val.name;
            return pathMatched || nameMatched;
          });
        }
        return ((_a = props2.name) != null ? _a : index2.value) === modelValue;
      });
      const onClick = (event) => {
        var _a;
        if (!active.value) {
          parent.setActive((_a = props2.name) != null ? _a : index2.value, route2);
        }
        emit("click", event);
      };
      const renderIcon = () => {
        if (slots.icon) {
          return slots.icon({
            active: active.value
          });
        }
        if (props2.icon) {
          return vue.createVNode(Icon, {
            "name": props2.icon,
            "classPrefix": props2.iconPrefix
          }, null);
        }
      };
      return () => {
        var _a;
        const {
          dot,
          badge
        } = props2;
        const {
          activeColor,
          inactiveColor
        } = parent.props;
        const color = active.value ? activeColor : inactiveColor;
        return vue.createVNode("div", {
          "role": "tab",
          "class": bem$4({
            active: active.value
          }),
          "style": {
            color
          },
          "tabindex": 0,
          "aria-selected": active.value,
          "onClick": onClick
        }, [vue.createVNode(Badge, vue.mergeProps({
          "dot": dot,
          "class": bem$4("icon"),
          "content": badge
        }, props2.badgeProps), {
          default: renderIcon
        }), vue.createVNode("div", {
          "class": bem$4("text")
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots, {
          active: active.value
        })])]);
      };
    }
  });
  const TabbarItem = withInstall(stdin_default$7);
  const [name$4, bem$3] = createNamespace("text-ellipsis");
  const textEllipsisProps = {
    rows: makeNumericProp(1),
    dots: makeStringProp("..."),
    content: makeStringProp(""),
    expandText: makeStringProp(""),
    collapseText: makeStringProp(""),
    position: makeStringProp("end")
  };
  var stdin_default$6 = vue.defineComponent({
    name: name$4,
    props: textEllipsisProps,
    emits: ["clickAction"],
    setup(props2, {
      emit,
      slots
    }) {
      const text = vue.ref(props2.content);
      const expanded = vue.ref(false);
      const hasAction = vue.ref(false);
      const root = vue.ref();
      const actionRef = vue.ref();
      let needRecalculate = false;
      const actionText = vue.computed(() => expanded.value ? props2.collapseText : props2.expandText);
      const pxToNum = (value) => {
        if (!value)
          return 0;
        const match = value.match(/^\d*(\.\d*)?/);
        return match ? Number(match[0]) : 0;
      };
      const cloneContainer = () => {
        if (!root.value || !root.value.isConnected)
          return;
        const originStyle = window.getComputedStyle(root.value);
        const container = document.createElement("div");
        const styleNames = Array.prototype.slice.apply(originStyle);
        styleNames.forEach((name2) => {
          container.style.setProperty(name2, originStyle.getPropertyValue(name2));
        });
        container.style.position = "fixed";
        container.style.zIndex = "-9999";
        container.style.top = "-9999px";
        container.style.height = "auto";
        container.style.minHeight = "auto";
        container.style.maxHeight = "auto";
        container.innerText = props2.content;
        document.body.appendChild(container);
        return container;
      };
      const calcEllipsisText = (container, maxHeight) => {
        var _a, _b;
        const {
          content,
          position,
          dots
        } = props2;
        const end2 = content.length;
        const middle = 0 + end2 >> 1;
        const actionHTML = slots.action ? (_b = (_a = actionRef.value) == null ? void 0 : _a.outerHTML) != null ? _b : "" : props2.expandText;
        const calcEllipse = () => {
          const tail = (left2, right2) => {
            if (right2 - left2 <= 1) {
              if (position === "end") {
                return content.slice(0, left2) + dots;
              }
              return dots + content.slice(right2, end2);
            }
            const middle2 = Math.round((left2 + right2) / 2);
            if (position === "end") {
              container.innerText = content.slice(0, middle2) + dots;
            } else {
              container.innerText = dots + content.slice(middle2, end2);
            }
            container.innerHTML += actionHTML;
            if (container.offsetHeight > maxHeight) {
              if (position === "end") {
                return tail(left2, middle2);
              }
              return tail(middle2, right2);
            }
            if (position === "end") {
              return tail(middle2, right2);
            }
            return tail(left2, middle2);
          };
          return tail(0, end2);
        };
        const middleTail = (leftPart, rightPart) => {
          if (leftPart[1] - leftPart[0] <= 1 && rightPart[1] - rightPart[0] <= 1) {
            return content.slice(0, leftPart[0]) + dots + content.slice(rightPart[1], end2);
          }
          const leftMiddle = Math.floor((leftPart[0] + leftPart[1]) / 2);
          const rightMiddle = Math.ceil((rightPart[0] + rightPart[1]) / 2);
          container.innerText = props2.content.slice(0, leftMiddle) + props2.dots + props2.content.slice(rightMiddle, end2);
          container.innerHTML += actionHTML;
          if (container.offsetHeight >= maxHeight) {
            return middleTail([leftPart[0], leftMiddle], [rightMiddle, rightPart[1]]);
          }
          return middleTail([leftMiddle, leftPart[1]], [rightPart[0], rightMiddle]);
        };
        return props2.position === "middle" ? middleTail([0, middle], [middle, end2]) : calcEllipse();
      };
      const calcEllipsised = () => {
        const container = cloneContainer();
        if (!container) {
          needRecalculate = true;
          return;
        }
        const {
          paddingBottom,
          paddingTop,
          lineHeight
        } = container.style;
        const maxHeight = Math.ceil((Number(props2.rows) + 0.5) * pxToNum(lineHeight) + pxToNum(paddingTop) + pxToNum(paddingBottom));
        if (maxHeight < container.offsetHeight) {
          hasAction.value = true;
          text.value = calcEllipsisText(container, maxHeight);
        } else {
          hasAction.value = false;
          text.value = props2.content;
        }
        document.body.removeChild(container);
      };
      const toggle = (isExpanded = !expanded.value) => {
        expanded.value = isExpanded;
      };
      const onClickAction = (event) => {
        toggle();
        emit("clickAction", event);
      };
      const renderAction = () => {
        const action = slots.action ? slots.action({
          expanded: expanded.value
        }) : actionText.value;
        return vue.createVNode("span", {
          "ref": actionRef,
          "class": bem$3("action"),
          "onClick": onClickAction
        }, [action]);
      };
      vue.onMounted(() => {
        calcEllipsised();
        if (slots.action) {
          vue.nextTick(calcEllipsised);
        }
      });
      vue.onActivated(() => {
        if (needRecalculate) {
          needRecalculate = false;
          calcEllipsised();
        }
      });
      vue.watch([windowWidth, () => [props2.content, props2.rows, props2.position]], calcEllipsised);
      useExpose({
        toggle
      });
      return () => vue.createVNode("div", {
        "ref": root,
        "class": bem$3()
      }, [expanded.value ? props2.content : text.value, hasAction.value ? renderAction() : null]);
    }
  });
  const TextEllipsis = withInstall(stdin_default$6);
  const [name$3] = createNamespace("time-picker");
  const validateTime = (val) => /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/.test(val);
  const fullColumns = ["hour", "minute", "second"];
  const timePickerProps = extend({}, sharedProps, {
    minHour: makeNumericProp(0),
    maxHour: makeNumericProp(23),
    minMinute: makeNumericProp(0),
    maxMinute: makeNumericProp(59),
    minSecond: makeNumericProp(0),
    maxSecond: makeNumericProp(59),
    minTime: {
      type: String,
      validator: validateTime
    },
    maxTime: {
      type: String,
      validator: validateTime
    },
    columnsType: {
      type: Array,
      default: () => ["hour", "minute"]
    }
  });
  var stdin_default$5 = vue.defineComponent({
    name: name$3,
    props: timePickerProps,
    emits: ["confirm", "cancel", "change", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const currentValues = vue.ref(props2.modelValue);
      const pickerRef = vue.ref();
      const getValidTime = (time) => {
        const timeLimitArr = time.split(":");
        return fullColumns.map((col, i2) => props2.columnsType.includes(col) ? timeLimitArr[i2] : "00");
      };
      const confirm = () => {
        var _a;
        return (_a = pickerRef.value) == null ? void 0 : _a.confirm();
      };
      const getSelectedTime = () => currentValues.value;
      const columns = vue.computed(() => {
        let {
          minHour,
          maxHour,
          minMinute,
          maxMinute,
          minSecond,
          maxSecond
        } = props2;
        if (props2.minTime || props2.maxTime) {
          const fullTime = {
            hour: 0,
            minute: 0,
            second: 0
          };
          props2.columnsType.forEach((col, i2) => {
            var _a;
            fullTime[col] = (_a = currentValues.value[i2]) != null ? _a : 0;
          });
          const {
            hour,
            minute
          } = fullTime;
          if (props2.minTime) {
            const [minH, minM, minS] = getValidTime(props2.minTime);
            minHour = minH;
            minMinute = +hour <= +minHour ? minM : "00";
            minSecond = +hour <= +minHour && +minute <= +minMinute ? minS : "00";
          }
          if (props2.maxTime) {
            const [maxH, maxM, maxS] = getValidTime(props2.maxTime);
            maxHour = maxH;
            maxMinute = +hour >= +maxHour ? maxM : "59";
            maxSecond = +hour >= +maxHour && +minute >= +maxMinute ? maxS : "59";
          }
        }
        return props2.columnsType.map((type) => {
          const {
            filter,
            formatter
          } = props2;
          switch (type) {
            case "hour":
              return genOptions(+minHour, +maxHour, type, formatter, filter, currentValues.value);
            case "minute":
              return genOptions(+minMinute, +maxMinute, type, formatter, filter, currentValues.value);
            case "second":
              return genOptions(+minSecond, +maxSecond, type, formatter, filter, currentValues.value);
            default: {
              throw new Error(`[Vant] DatePicker: unsupported columns type: ${type}`);
            }
          }
        });
      });
      vue.watch(currentValues, (newValues) => {
        if (!isSameValue(newValues, props2.modelValue)) {
          emit("update:modelValue", newValues);
        }
      });
      vue.watch(() => props2.modelValue, (newValues) => {
        newValues = formatValueRange(newValues, columns.value);
        if (!isSameValue(newValues, currentValues.value)) {
          currentValues.value = newValues;
        }
      }, {
        immediate: true
      });
      const onChange = (...args) => emit("change", ...args);
      const onCancel = (...args) => emit("cancel", ...args);
      const onConfirm = (...args) => emit("confirm", ...args);
      useExpose({
        confirm,
        getSelectedTime
      });
      return () => vue.createVNode(Picker, vue.mergeProps({
        "ref": pickerRef,
        "modelValue": currentValues.value,
        "onUpdate:modelValue": ($event) => currentValues.value = $event,
        "columns": columns.value,
        "onChange": onChange,
        "onCancel": onCancel,
        "onConfirm": onConfirm
      }, pick(props2, pickerInheritKeys)), slots);
    }
  });
  const TimePicker = withInstall(stdin_default$5);
  const [name$2, bem$2] = createNamespace("tree-select");
  const treeSelectProps = {
    max: makeNumericProp(Infinity),
    items: makeArrayProp(),
    height: makeNumericProp(300),
    selectedIcon: makeStringProp("success"),
    mainActiveIndex: makeNumericProp(0),
    activeId: {
      type: [Number, String, Array],
      default: 0
    }
  };
  var stdin_default$4 = vue.defineComponent({
    name: name$2,
    props: treeSelectProps,
    emits: ["clickNav", "clickItem", "update:activeId", "update:mainActiveIndex"],
    setup(props2, {
      emit,
      slots
    }) {
      const isActiveItem = (id) => Array.isArray(props2.activeId) ? props2.activeId.includes(id) : props2.activeId === id;
      const renderSubItem = (item) => {
        const onClick = () => {
          if (item.disabled) {
            return;
          }
          let activeId;
          if (Array.isArray(props2.activeId)) {
            activeId = props2.activeId.slice();
            const index2 = activeId.indexOf(item.id);
            if (index2 !== -1) {
              activeId.splice(index2, 1);
            } else if (activeId.length < +props2.max) {
              activeId.push(item.id);
            }
          } else {
            activeId = item.id;
          }
          emit("update:activeId", activeId);
          emit("clickItem", item);
        };
        return vue.createVNode("div", {
          "key": item.id,
          "class": ["van-ellipsis", bem$2("item", {
            active: isActiveItem(item.id),
            disabled: item.disabled
          })],
          "onClick": onClick
        }, [item.text, isActiveItem(item.id) && vue.createVNode(Icon, {
          "name": props2.selectedIcon,
          "class": bem$2("selected")
        }, null)]);
      };
      const onSidebarChange = (index2) => {
        emit("update:mainActiveIndex", index2);
      };
      const onClickSidebarItem = (index2) => emit("clickNav", index2);
      const renderSidebar = () => {
        const Items = props2.items.map((item) => vue.createVNode(SidebarItem, {
          "dot": item.dot,
          "badge": item.badge,
          "class": [bem$2("nav-item"), item.className],
          "disabled": item.disabled,
          "onClick": onClickSidebarItem
        }, {
          title: () => slots["nav-text"] ? slots["nav-text"](item) : item.text
        }));
        return vue.createVNode(Sidebar, {
          "class": bem$2("nav"),
          "modelValue": props2.mainActiveIndex,
          "onChange": onSidebarChange
        }, {
          default: () => [Items]
        });
      };
      const renderContent = () => {
        if (slots.content) {
          return slots.content();
        }
        const selected = props2.items[+props2.mainActiveIndex] || {};
        if (selected.children) {
          return selected.children.map(renderSubItem);
        }
      };
      return () => vue.createVNode("div", {
        "class": bem$2(),
        "style": {
          height: addUnit$2(props2.height)
        }
      }, [renderSidebar(), vue.createVNode("div", {
        "class": bem$2("content")
      }, [renderContent()])]);
    }
  });
  const TreeSelect = withInstall(stdin_default$4);
  const [name$1, bem$1, t$2] = createNamespace("uploader");
  function readFileContent(file, resultType) {
    return new Promise((resolve) => {
      if (resultType === "file") {
        resolve();
        return;
      }
      const reader = new FileReader();
      reader.onload = (event) => {
        resolve(event.target.result);
      };
      if (resultType === "dataUrl") {
        reader.readAsDataURL(file);
      } else if (resultType === "text") {
        reader.readAsText(file);
      }
    });
  }
  function isOversize(items, maxSize) {
    return toArray(items).some((item) => {
      if (item.file) {
        if (isFunction(maxSize)) {
          return maxSize(item.file);
        }
        return item.file.size > +maxSize;
      }
      return false;
    });
  }
  function filterFiles(items, maxSize) {
    const valid = [];
    const invalid = [];
    items.forEach((item) => {
      if (isOversize(item, maxSize)) {
        invalid.push(item);
      } else {
        valid.push(item);
      }
    });
    return { valid, invalid };
  }
  const IMAGE_REGEXP = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg|avif)/i;
  const isImageUrl = (url2) => IMAGE_REGEXP.test(url2);
  function isImageFile(item) {
    if (item.isImage) {
      return true;
    }
    if (item.file && item.file.type) {
      return item.file.type.indexOf("image") === 0;
    }
    if (item.url) {
      return isImageUrl(item.url);
    }
    if (typeof item.content === "string") {
      return item.content.indexOf("data:image") === 0;
    }
    return false;
  }
  var stdin_default$3 = vue.defineComponent({
    props: {
      name: numericProp,
      item: makeRequiredProp(Object),
      index: Number,
      imageFit: String,
      lazyLoad: Boolean,
      deletable: Boolean,
      reupload: Boolean,
      previewSize: [Number, String, Array],
      beforeDelete: Function
    },
    emits: ["delete", "preview", "reupload"],
    setup(props2, {
      emit,
      slots
    }) {
      const renderMask = () => {
        const {
          status,
          message
        } = props2.item;
        if (status === "uploading" || status === "failed") {
          const MaskIcon = status === "failed" ? vue.createVNode(Icon, {
            "name": "close",
            "class": bem$1("mask-icon")
          }, null) : vue.createVNode(Loading, {
            "class": bem$1("loading")
          }, null);
          const showMessage = isDef(message) && message !== "";
          return vue.createVNode("div", {
            "class": bem$1("mask")
          }, [MaskIcon, showMessage && vue.createVNode("div", {
            "class": bem$1("mask-message")
          }, [message])]);
        }
      };
      const onDelete = (event) => {
        const {
          name: name2,
          item,
          index: index2,
          beforeDelete
        } = props2;
        event.stopPropagation();
        callInterceptor(beforeDelete, {
          args: [item, {
            name: name2,
            index: index2
          }],
          done: () => emit("delete")
        });
      };
      const onPreview = () => emit("preview");
      const onReupload = () => emit("reupload");
      const renderDeleteIcon = () => {
        if (props2.deletable && props2.item.status !== "uploading") {
          const slot = slots["preview-delete"];
          return vue.createVNode("div", {
            "role": "button",
            "class": bem$1("preview-delete", {
              shadow: !slot
            }),
            "tabindex": 0,
            "aria-label": t$2("delete"),
            "onClick": onDelete
          }, [slot ? slot() : vue.createVNode(Icon, {
            "name": "cross",
            "class": bem$1("preview-delete-icon")
          }, null)]);
        }
      };
      const renderCover = () => {
        if (slots["preview-cover"]) {
          const {
            index: index2,
            item
          } = props2;
          return vue.createVNode("div", {
            "class": bem$1("preview-cover")
          }, [slots["preview-cover"](extend({
            index: index2
          }, item))]);
        }
      };
      const renderPreview = () => {
        const {
          item,
          lazyLoad,
          imageFit,
          previewSize,
          reupload
        } = props2;
        if (isImageFile(item)) {
          return vue.createVNode(Image$1, {
            "fit": imageFit,
            "src": item.objectUrl || item.content || item.url,
            "class": bem$1("preview-image"),
            "width": Array.isArray(previewSize) ? previewSize[0] : previewSize,
            "height": Array.isArray(previewSize) ? previewSize[1] : previewSize,
            "lazyLoad": lazyLoad,
            "onClick": reupload ? onReupload : onPreview
          }, {
            default: renderCover
          });
        }
        return vue.createVNode("div", {
          "class": bem$1("file"),
          "style": getSizeStyle(props2.previewSize)
        }, [vue.createVNode(Icon, {
          "class": bem$1("file-icon"),
          "name": "description"
        }, null), vue.createVNode("div", {
          "class": [bem$1("file-name"), "van-ellipsis"]
        }, [item.file ? item.file.name : item.url]), renderCover()]);
      };
      return () => vue.createVNode("div", {
        "class": bem$1("preview")
      }, [renderPreview(), renderMask(), renderDeleteIcon()]);
    }
  });
  const uploaderProps = {
    name: makeNumericProp(""),
    accept: makeStringProp("image/*"),
    capture: String,
    multiple: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    lazyLoad: Boolean,
    maxCount: makeNumericProp(Infinity),
    imageFit: makeStringProp("cover"),
    resultType: makeStringProp("dataUrl"),
    uploadIcon: makeStringProp("photograph"),
    uploadText: String,
    deletable: truthProp,
    reupload: Boolean,
    afterRead: Function,
    showUpload: truthProp,
    modelValue: makeArrayProp(),
    beforeRead: Function,
    beforeDelete: Function,
    previewSize: [Number, String, Array],
    previewImage: truthProp,
    previewOptions: Object,
    previewFullImage: truthProp,
    maxSize: {
      type: [Number, String, Function],
      default: Infinity
    }
  };
  var stdin_default$2 = vue.defineComponent({
    name: name$1,
    props: uploaderProps,
    emits: ["delete", "oversize", "clickUpload", "closePreview", "clickPreview", "clickReupload", "update:modelValue"],
    setup(props2, {
      emit,
      slots
    }) {
      const inputRef = vue.ref();
      const urls = [];
      const reuploadIndex = vue.ref(-1);
      const isReuploading = vue.ref(false);
      const getDetail = (index2 = props2.modelValue.length) => ({
        name: props2.name,
        index: index2
      });
      const resetInput = () => {
        if (inputRef.value) {
          inputRef.value.value = "";
        }
      };
      const onAfterRead = (items) => {
        resetInput();
        if (isOversize(items, props2.maxSize)) {
          if (Array.isArray(items)) {
            const result = filterFiles(items, props2.maxSize);
            items = result.valid;
            emit("oversize", result.invalid, getDetail());
            if (!items.length) {
              return;
            }
          } else {
            emit("oversize", items, getDetail());
            return;
          }
        }
        items = vue.reactive(items);
        if (reuploadIndex.value > -1) {
          const arr = [...props2.modelValue];
          arr.splice(reuploadIndex.value, 1, items);
          emit("update:modelValue", arr);
          reuploadIndex.value = -1;
        } else {
          emit("update:modelValue", [...props2.modelValue, ...toArray(items)]);
        }
        if (props2.afterRead) {
          props2.afterRead(items, getDetail());
        }
      };
      const readFile = (files) => {
        const {
          maxCount,
          modelValue,
          resultType
        } = props2;
        if (Array.isArray(files)) {
          const remainCount = +maxCount - modelValue.length;
          if (files.length > remainCount) {
            files = files.slice(0, remainCount);
          }
          Promise.all(files.map((file) => readFileContent(file, resultType))).then((contents) => {
            const fileList = files.map((file, index2) => {
              const result = {
                file,
                status: "",
                message: "",
                objectUrl: URL.createObjectURL(file)
              };
              if (contents[index2]) {
                result.content = contents[index2];
              }
              return result;
            });
            onAfterRead(fileList);
          });
        } else {
          readFileContent(files, resultType).then((content) => {
            const result = {
              file: files,
              status: "",
              message: "",
              objectUrl: URL.createObjectURL(files)
            };
            if (content) {
              result.content = content;
            }
            onAfterRead(result);
          });
        }
      };
      const onChange = (event) => {
        const {
          files
        } = event.target;
        if (props2.disabled || !files || !files.length) {
          return;
        }
        const file = files.length === 1 ? files[0] : [].slice.call(files);
        if (props2.beforeRead) {
          const response = props2.beforeRead(file, getDetail());
          if (!response) {
            resetInput();
            return;
          }
          if (isPromise$1(response)) {
            response.then((data) => {
              if (data) {
                readFile(data);
              } else {
                readFile(file);
              }
            }).catch(resetInput);
            return;
          }
        }
        readFile(file);
      };
      let imagePreview;
      const onClosePreview = () => emit("closePreview");
      const previewImage = (item) => {
        if (props2.previewFullImage) {
          const imageFiles = props2.modelValue.filter(isImageFile);
          const images = imageFiles.map((item2) => {
            if (item2.objectUrl && !item2.url && item2.status !== "failed") {
              item2.url = item2.objectUrl;
              urls.push(item2.url);
            }
            return item2.url;
          }).filter(Boolean);
          imagePreview = showImagePreview(extend({
            images,
            startPosition: imageFiles.indexOf(item),
            onClose: onClosePreview
          }, props2.previewOptions));
        }
      };
      const closeImagePreview = () => {
        if (imagePreview) {
          imagePreview.close();
        }
      };
      const deleteFile = (item, index2) => {
        const fileList = props2.modelValue.slice(0);
        fileList.splice(index2, 1);
        emit("update:modelValue", fileList);
        emit("delete", item, getDetail(index2));
      };
      const reuploadFile = (index2) => {
        isReuploading.value = true;
        reuploadIndex.value = index2;
        vue.nextTick(() => chooseFile());
      };
      const onInputClick = () => {
        if (!isReuploading.value) {
          reuploadIndex.value = -1;
        }
        isReuploading.value = false;
      };
      const renderPreviewItem = (item, index2) => {
        const needPickData = ["imageFit", "deletable", "reupload", "previewSize", "beforeDelete"];
        const previewData = extend(pick(props2, needPickData), pick(item, needPickData, true));
        return vue.createVNode(stdin_default$3, vue.mergeProps({
          "item": item,
          "index": index2,
          "onClick": () => emit(props2.reupload ? "clickReupload" : "clickPreview", item, getDetail(index2)),
          "onDelete": () => deleteFile(item, index2),
          "onPreview": () => previewImage(item),
          "onReupload": () => reuploadFile(index2)
        }, pick(props2, ["name", "lazyLoad"]), previewData), pick(slots, ["preview-cover", "preview-delete"]));
      };
      const renderPreviewList = () => {
        if (props2.previewImage) {
          return props2.modelValue.map(renderPreviewItem);
        }
      };
      const onClickUpload = (event) => emit("clickUpload", event);
      const renderUpload = () => {
        const lessThanMax = props2.modelValue.length < +props2.maxCount;
        const Input = props2.readonly ? null : vue.createVNode("input", {
          "ref": inputRef,
          "type": "file",
          "class": bem$1("input"),
          "accept": props2.accept,
          "capture": props2.capture,
          "multiple": props2.multiple && reuploadIndex.value === -1,
          "disabled": props2.disabled,
          "onChange": onChange,
          "onClick": onInputClick
        }, null);
        if (slots.default) {
          return vue.withDirectives(vue.createVNode("div", {
            "class": bem$1("input-wrapper"),
            "onClick": onClickUpload
          }, [slots.default(), Input]), [[vue.vShow, lessThanMax]]);
        }
        return vue.withDirectives(vue.createVNode("div", {
          "class": bem$1("upload", {
            readonly: props2.readonly
          }),
          "style": getSizeStyle(props2.previewSize),
          "onClick": onClickUpload
        }, [vue.createVNode(Icon, {
          "name": props2.uploadIcon,
          "class": bem$1("upload-icon")
        }, null), props2.uploadText && vue.createVNode("span", {
          "class": bem$1("upload-text")
        }, [props2.uploadText]), Input]), [[vue.vShow, props2.showUpload && lessThanMax]]);
      };
      const chooseFile = () => {
        if (inputRef.value && !props2.disabled) {
          inputRef.value.click();
        }
      };
      vue.onBeforeUnmount(() => {
        urls.forEach((url2) => URL.revokeObjectURL(url2));
      });
      useExpose({
        chooseFile,
        reuploadFile,
        closeImagePreview
      });
      useCustomFieldValue(() => props2.modelValue);
      return () => vue.createVNode("div", {
        "class": bem$1()
      }, [vue.createVNode("div", {
        "class": bem$1("wrapper", {
          disabled: props2.disabled
        })
      }, [renderPreviewList(), renderUpload()])]);
    }
  });
  const Uploader = withInstall(stdin_default$2);
  const [name, bem] = createNamespace("watermark");
  const watermarkProps = {
    gapX: makeNumberProp(0),
    gapY: makeNumberProp(0),
    image: String,
    width: makeNumberProp(100),
    height: makeNumberProp(100),
    rotate: makeNumericProp(-22),
    zIndex: numericProp,
    content: String,
    opacity: numericProp,
    fullPage: truthProp,
    textColor: makeStringProp("#dcdee0")
  };
  var stdin_default$1 = vue.defineComponent({
    name,
    props: watermarkProps,
    setup(props2, {
      slots
    }) {
      const svgElRef = vue.ref();
      const watermarkUrl = vue.ref("");
      const imageBase64 = vue.ref("");
      const renderWatermark = () => {
        const rotateStyle = {
          transformOrigin: "center",
          transform: `rotate(${props2.rotate}deg)`
        };
        const svgInner = () => {
          if (props2.image && !slots.content) {
            return vue.createVNode("image", {
              "href": imageBase64.value,
              "xlink:href": imageBase64.value,
              "x": "0",
              "y": "0",
              "width": props2.width,
              "height": props2.height,
              "style": rotateStyle
            }, null);
          }
          return vue.createVNode("foreignObject", {
            "x": "0",
            "y": "0",
            "width": props2.width,
            "height": props2.height
          }, [vue.createVNode("div", {
            "xmlns": "http://www.w3.org/1999/xhtml",
            "style": rotateStyle
          }, [slots.content ? slots.content() : vue.createVNode("span", {
            "style": {
              color: props2.textColor
            }
          }, [props2.content])])]);
        };
        const svgWidth = props2.width + props2.gapX;
        const svgHeight = props2.height + props2.gapY;
        return vue.createVNode("svg", {
          "viewBox": `0 0 ${svgWidth} ${svgHeight}`,
          "width": svgWidth,
          "height": svgHeight,
          "xmlns": "http://www.w3.org/2000/svg",
          "xmlns:xlink": "http://www.w3.org/1999/xlink",
          "style": {
            padding: `0 ${props2.gapX}px ${props2.gapY}px 0`,
            opacity: props2.opacity
          }
        }, [svgInner()]);
      };
      const makeImageToBase64 = (url2) => {
        const canvas = document.createElement("canvas");
        const image2 = new Image();
        image2.crossOrigin = "anonymous";
        image2.referrerPolicy = "no-referrer";
        image2.onload = () => {
          canvas.width = image2.naturalWidth;
          canvas.height = image2.naturalHeight;
          const ctx = canvas.getContext("2d");
          ctx == null ? void 0 : ctx.drawImage(image2, 0, 0);
          imageBase64.value = canvas.toDataURL();
        };
        image2.src = url2;
      };
      const makeSvgToBlobUrl = (svgStr) => {
        const svgBlob = new Blob([svgStr], {
          type: "image/svg+xml"
        });
        return URL.createObjectURL(svgBlob);
      };
      vue.watchEffect(() => {
        if (props2.image) {
          makeImageToBase64(props2.image);
        }
      });
      vue.watch(() => [imageBase64.value, props2.content, props2.textColor, props2.height, props2.width, props2.rotate, props2.gapX, props2.gapY], () => {
        vue.nextTick(() => {
          if (svgElRef.value) {
            if (watermarkUrl.value) {
              URL.revokeObjectURL(watermarkUrl.value);
            }
            watermarkUrl.value = makeSvgToBlobUrl(svgElRef.value.innerHTML);
          }
        });
      }, {
        immediate: true
      });
      vue.onUnmounted(() => {
        if (watermarkUrl.value) {
          URL.revokeObjectURL(watermarkUrl.value);
        }
      });
      return () => {
        const style = extend({
          backgroundImage: `url(${watermarkUrl.value})`
        }, getZIndexStyle(props2.zIndex));
        return vue.createVNode("div", {
          "class": bem({
            full: props2.fullPage
          }),
          "style": style
        }, [vue.createVNode("div", {
          "class": bem("wrapper"),
          "ref": svgElRef
        }, [renderWatermark()])]);
      };
    }
  });
  const Watermark = withInstall(stdin_default$1);
  const version = "4.9.9";
  function install(app) {
    const components = [
      ActionBar,
      ActionBarButton,
      ActionBarIcon,
      ActionSheet,
      AddressEdit,
      AddressList,
      Area,
      BackTop,
      Badge,
      Barrage,
      Button,
      Calendar,
      Card,
      Cascader,
      Cell,
      CellGroup,
      Checkbox,
      CheckboxGroup,
      Circle,
      Col,
      Collapse,
      CollapseItem,
      ConfigProvider,
      ContactCard,
      ContactEdit,
      ContactList,
      CountDown,
      Coupon,
      CouponCell,
      CouponList,
      DatePicker,
      Dialog,
      Divider,
      DropdownItem,
      DropdownMenu,
      Empty,
      Field,
      FloatingBubble,
      FloatingPanel,
      Form,
      Grid,
      GridItem,
      Highlight,
      Icon,
      Image$1,
      ImagePreview,
      IndexAnchor,
      IndexBar,
      List,
      Loading,
      Locale,
      NavBar,
      NoticeBar,
      Notify,
      NumberKeyboard,
      Overlay,
      Pagination,
      PasswordInput,
      Picker,
      PickerGroup,
      Popover,
      Popup,
      Progress,
      PullRefresh,
      Radio,
      RadioGroup,
      Rate,
      RollingText,
      Row,
      Search,
      ShareSheet,
      Sidebar,
      SidebarItem,
      Signature,
      Skeleton,
      SkeletonAvatar,
      SkeletonImage,
      SkeletonParagraph,
      SkeletonTitle,
      Slider,
      Space,
      Step,
      Stepper,
      Steps,
      Sticky,
      SubmitBar,
      Swipe,
      SwipeCell,
      SwipeItem,
      Switch,
      Tab,
      Tabbar,
      TabbarItem,
      Tabs,
      Tag,
      TextEllipsis,
      TimePicker,
      Toast,
      TreeSelect,
      Uploader,
      Watermark
    ];
    components.forEach((item) => {
      if (item.install) {
        app.use(item);
      } else if (item.name) {
        app.component(item.name, item);
      }
    });
  }
  var stdin_default = {
    install,
    version
  };
  ({
    "authorization": uni.getStorageSync("token"),
    "lang": uni.getStorageSync("language"),
    "Authorization": ""
  });
  function request(options) {
    uni.getStorageSync("token");
    return new Promise(async (resolve, reject) => {
      function next() {
        uni.request({
          ...options,
          header: {
            Authorization: uni.getStorageSync("token") || "",
            "tenant-id": 1,
            "content-type": "application/json;charset=UTF-8"
          },
          method: options.methods,
          url: "https://dev.waisj.com:3003" + options.url,
          // url: 'http://192.168.1.13:48080' + options.url,
          success(res) {
            const { code: code2, data, msg } = res.data;
            if (res.statusCode === 401) {
              uni.clearStorageSync();
              uni.navigateTo({
                url: "/pages/login/login"
              });
              return;
            }
            if (res.statusCode === 502) {
              return reject({
                message: "Abnormal service"
              });
            }
            if (res.statusCode === 404) {
              return reject({
                message: `[404] ${options.url}`
              });
            }
            if (res.statusCode === 200) {
              switch (code2) {
                case 0:
                  resolve(data);
                  break;
                case 401:
                  refreshToken();
                  reject({ msg, code: code2 });
                  break;
                default:
                  showToast(msg);
                  uni.hideLoading();
                  reject({ msg, code: code2 });
              }
            }
          },
          fail(err) {
            showToast("Request fail");
            reject({ message: err.errMsg });
          }
        });
      }
      next();
    });
  }
  let requestList = [];
  const refreshToken = async (config2) => {
    const refreshToken2 = getRefreshToken();
    try {
      await request({
        url: "/app-api/member/auth/refresh-token?refreshToken=" + refreshToken2,
        methods: "POST"
      }).then((res) => {
        uni.setStorageSync("token", res.accessToken);
        uni.setStorageSync("refresh-token", res.refreshToken);
        return reload();
      });
    } catch (e2) {
      requestList.forEach((cb) => {
        cb();
      });
      return true;
    } finally {
      requestList = [];
    }
  };
  function reload() {
    const pages2 = getCurrentPages();
    const curPage = pages2[pages2.length - 1];
    curPage.onLoad(curPage.options);
    curPage.onShow();
    curPage.onReady();
  }
  const getRefreshToken = () => {
    return uni.getStorageSync("refresh-token");
  };
  const _sfc_main$o = {
    __name: "login",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        locale,
        t: t2
      } = useI18n();
      const mobile2 = vue.ref("");
      const code2 = vue.ref("");
      const confirmHandle = () => {
        request({
          url: "/admin-api/system/auth/login",
          methods: "POST",
          data: {
            username: mobile2.value,
            password: code2.value,
            captchaVerification: "iHy+rM5L3CGeqbeRh+Rq73DJkevrD8SZMgKdQOnG/GLnJk9RbJntjMgmmrZM2abW3XejjvmQQw51zFpBOp8oNw=="
          }
        }).then((res) => {
          uni.setStorageSync("token", res.accessToken);
          uni.setStorageSync("refresh-token", res.refreshToken);
          uni.showToast({
            title: "Login success",
            icon: "none"
          });
          uni.setStorageSync("staffType", res.staffType);
          uni.setStorageSync("username", res.username);
          uni.navigateTo({
            url: "../tab/index"
          });
          if (res.staffType == 1) {
            locale.value = "en";
            uni.setStorageSync("language", "en");
          } else {
            locale.value = "zh";
            uni.setStorageSync("language", "zh");
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const __returned__ = { locale, t: t2, mobile: mobile2, code: code2, confirmHandle, get request() {
        return request;
      }, get showToast() {
        return showToast;
      }, computed: vue.computed, ref: vue.ref, get useI18n() {
        return useI18n;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "white_bg" }, [
      vue.createElementVNode("view", { class: "pdlr30 mt40" }, [
        vue.createElementVNode(
          "view",
          { class: "f34 text_bold" },
          vue.toDisplayString($setup.t("login.l1")),
          1
          /* TEXT */
        ),
        vue.createElementVNode(
          "view",
          { class: "f20 mt10" },
          vue.toDisplayString($setup.t("login.l2")),
          1
          /* TEXT */
        ),
        vue.createElementVNode("view", { class: "mt50" }, [
          vue.createElementVNode("view", null, "Account"),
          vue.createElementVNode("view", { class: "mt12 pb9 borderB f13" }, [
            vue.withDirectives(vue.createElementVNode("input", {
              type: "text",
              placeholder: $setup.t("login.l4"),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.mobile = $event)
            }, null, 8, ["placeholder"]), [
              [vue.vModelText, $setup.mobile]
            ])
          ])
        ]),
        vue.createElementVNode("view", { class: "mt40" }, [
          vue.createElementVNode(
            "view",
            null,
            vue.toDisplayString($setup.t("login.l5")),
            1
            /* TEXT */
          ),
          vue.createElementVNode("view", { class: "mt12 pb9 borderB f13" }, [
            vue.withDirectives(vue.createElementVNode("input", {
              type: "password",
              placeholder: $setup.t("login.l6"),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.code = $event)
            }, null, 8, ["placeholder"]), [
              [vue.vModelText, $setup.code]
            ])
          ])
        ]),
        vue.createElementVNode("view", { class: "mt60" }, [
          vue.createElementVNode(
            "view",
            {
              class: "btns f14 text_white center",
              onClick: $setup.confirmHandle
            },
            vue.toDisplayString($setup.t("login.l7")),
            1
            /* TEXT */
          )
        ])
      ])
    ]);
  }
  const PagesHomeLogin = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$n], ["__scopeId", "data-v-6a5bfa47"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/login.vue"]]);
  const _sfc_main$n = {
    __name: "topNavbar",
    props: {
      title: {
        type: String
      },
      backIcon: {
        default: "/static/icons/right.png"
      },
      isBig: {
        default: true
      },
      backUrl: {
        default: ""
      },
      isWhiteBg: {
        default: false
      }
    },
    setup(__props, { expose: __expose }) {
      __expose();
      const props2 = __props;
      const isTopFixed = ref(false);
      const topChangeHandle = (e2) => {
        isTopFixed.value = e2;
      };
      const goBack = () => {
        uni.navigateBack();
        return;
      };
      const __returned__ = { props: props2, isTopFixed, topChangeHandle, goBack };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_sticky = vue.resolveComponent("van-sticky");
    return vue.openBlock(), vue.createBlock(_component_van_sticky, {
      "offset-top": 0,
      onChange: $setup.topChangeHandle
    }, {
      default: vue.withCtx(() => [
        vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
          vue.createElementVNode("view", {
            class: "left",
            onClick: $setup.goBack
          }, [
            vue.createElementVNode("image", {
              src: $props.backIcon,
              class: "ww32 hh32"
            }, null, 8, ["src"])
          ]),
          vue.createElementVNode("view", { class: "text_center f17" }, [
            vue.createVNode(_component_van_text_ellipsis, {
              rows: "1",
              content: $props.title,
              class: "text_bold",
              style: { "width": "100%" }
            }, null, 8, ["content"])
          ]),
          vue.createElementVNode("view", {
            class: "right",
            style: { "min-width": "24px" }
          }, [
            vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ])
        ])
      ]),
      _: 3
      /* FORWARDED */
    });
  }
  const topNavbar = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$m], ["__scopeId", "data-v-b9ca3ee9"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/components/topNavbar/topNavbar.vue"]]);
  const _imports_0$2 = "/static/icons/right.png";
  const _imports_1$a = "/static/icons/s1.png";
  const _imports_2$2 = "/static/icons/g_right.png";
  const _imports_3$2 = "/static/icons/s2.png";
  const _sfc_main$m = {
    __name: "index",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        t: t2
      } = useI18n();
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const showPopCenter = vue.ref(false);
      const popConfirmHandle = () => {
        let curLang = uni.getStorageSync("language");
        uni.clearStorageSync();
        uni.setStorageSync("language", curLang);
        uni.navigateTo({
          url: "../home/login"
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { t: t2, changePage, showPopCenter, popConfirmHandle, goBack, topNavbar, get request() {
        return request;
      }, get useI18n() {
        return useI18n;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: $setup.t("setting.s_s1"),
            class: "text_bold",
            style: { "width": "100%" }
          }, null, 8, ["content"])
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createElementVNode("view", { class: "contentBox" }, [
          vue.createElementVNode("view", {
            class: "setItem pb28 between borderB",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("./updatePwd"))
          }, [
            vue.createElementVNode("view", { class: "flex col_center" }, [
              vue.createElementVNode("image", {
                src: _imports_1$a,
                alt: "",
                class: "ww24 hh24"
              }),
              vue.createElementVNode(
                "view",
                { class: "ml8" },
                vue.toDisplayString($setup.t("setting.s_s2")),
                1
                /* TEXT */
              )
            ]),
            vue.createElementVNode("view", null, [
              vue.createElementVNode("image", {
                src: _imports_2$2,
                class: "ww24 hh24"
              })
            ])
          ]),
          vue.createElementVNode("view", {
            class: "setItem between pt28",
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.showPopCenter = true)
          }, [
            vue.createElementVNode("view", { class: "flex col_center" }, [
              vue.createElementVNode("image", {
                src: _imports_3$2,
                alt: "",
                class: "ww24 hh24"
              }),
              vue.createElementVNode(
                "view",
                { class: "ml8" },
                vue.toDisplayString($setup.t("setting.s_s3")),
                1
                /* TEXT */
              )
            ]),
            vue.createElementVNode("view", null, [
              vue.createElementVNode("image", {
                src: _imports_2$2,
                class: "ww24 hh24"
              })
            ])
          ])
        ])
      ]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPopCenter,
        "onUpdate:show": _cache[3] || (_cache[3] = ($event) => $setup.showPopCenter = $event),
        round: "",
        style: { "width": "280px" }
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "pt30 pdlr26" }, [
            vue.createElementVNode(
              "view",
              {
                class: "f15 text_center borderB pb24",
                style: { "line-height": "18px" }
              },
              vue.toDisplayString($setup.t("setting.s_s4")),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", { class: "pdlr20 pdtb16" }, [
            vue.createElementVNode("view", { class: "girdBtn" }, [
              vue.createElementVNode(
                "view",
                {
                  class: "botBtn cancelBtn center color7C",
                  onClick: _cache[2] || (_cache[2] = ($event) => $setup.showPopCenter = false)
                },
                vue.toDisplayString($setup.t("setting.s_s5")),
                1
                /* TEXT */
              ),
              vue.createElementVNode(
                "view",
                {
                  class: "botBtn center text_white confirmBtn",
                  onClick: $setup.popConfirmHandle
                },
                vue.toDisplayString($setup.t("setting.s_s6")),
                1
                /* TEXT */
              )
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"])
    ]);
  }
  const PagesSettingIndex = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$l], ["__scopeId", "data-v-861f37f2"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/setting/index.vue"]]);
  const _sfc_main$l = {
    __name: "updatePwd",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        t: t2
      } = useI18n();
      const username = uni.getStorageSync("username");
      const newPassword = vue.ref("");
      const oldPassword = vue.ref("");
      const confirmHandle = () => {
        request({
          url: "/admin-api/system/user/profile/update-password",
          methods: "PUT",
          data: {
            newPassword: newPassword.value,
            oldPassword: oldPassword.value
          }
        }).then((res) => {
          uni.showToast({
            title: t2("setting.s_j1"),
            icon: "none"
          });
          newPassword.value = "";
          oldPassword.value = "";
          uni.navigateTo({
            url: "../home/login"
          });
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { t: t2, username, newPassword, oldPassword, confirmHandle, goBack, topNavbar, get request() {
        return request;
      }, ref: vue.ref, get useI18n() {
        return useI18n;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: $setup.t("setting.s_t1"),
            class: "text_bold",
            style: { "width": "100%" }
          }, null, 8, ["content"])
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createElementVNode("view", { class: "contentBox" }, [
          vue.createElementVNode("view", { class: "setItem between f14 borderB" }, [
            vue.createElementVNode(
              "view",
              null,
              vue.toDisplayString($setup.t("setting.s_s7")),
              1
              /* TEXT */
            ),
            vue.createElementVNode(
              "view",
              null,
              vue.toDisplayString($setup.username),
              1
              /* TEXT */
            )
          ]),
          vue.createElementVNode("view", { class: "setItem between f14 borderB" }, [
            vue.createElementVNode(
              "view",
              null,
              vue.toDisplayString($setup.t("setting.s_s8")),
              1
              /* TEXT */
            ),
            vue.withDirectives(vue.createElementVNode("input", {
              type: "password",
              placeholder: $setup.t("setting.s_s9"),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.oldPassword = $event)
            }, null, 8, ["placeholder"]), [
              [vue.vModelText, $setup.oldPassword]
            ])
          ]),
          vue.createElementVNode("view", { class: "setItem between f14" }, [
            vue.createElementVNode(
              "view",
              null,
              vue.toDisplayString($setup.t("setting.s_s10")),
              1
              /* TEXT */
            ),
            vue.withDirectives(vue.createElementVNode("input", {
              type: "password",
              placeholder: $setup.t("setting.s_s9"),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.newPassword = $event)
            }, null, 8, ["placeholder"]), [
              [vue.vModelText, $setup.newPassword]
            ])
          ])
        ]),
        vue.createElementVNode(
          "view",
          {
            class: "btns f14 text_white center",
            onClick: $setup.confirmHandle
          },
          vue.toDisplayString($setup.t("setting.s_s6")),
          1
          /* TEXT */
        )
      ])
    ]);
  }
  const PagesSettingUpdatePwd = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$k], ["__scopeId", "data-v-27874a33"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/setting/updatePwd.vue"]]);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var clipboard = { exports: {} };
  /*!
   * clipboard.js v2.0.11
   * https://clipboardjs.com/
   *
   * Licensed MIT  Zeno Rocha
   */
  (function(module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
      module.exports = factory();
    })(commonjsGlobal, function() {
      return (
        /******/
        function() {
          var __webpack_modules__ = {
            /***/
            686: (
              /***/
              function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
                __webpack_require__2.d(__webpack_exports__, {
                  "default": function() {
                    return (
                      /* binding */
                      clipboard2
                    );
                  }
                });
                var tiny_emitter = __webpack_require__2(279);
                var tiny_emitter_default = /* @__PURE__ */ __webpack_require__2.n(tiny_emitter);
                var listen = __webpack_require__2(370);
                var listen_default = /* @__PURE__ */ __webpack_require__2.n(listen);
                var src_select = __webpack_require__2(817);
                var select_default = /* @__PURE__ */ __webpack_require__2.n(src_select);
                function command(type) {
                  try {
                    return document.execCommand(type);
                  } catch (err) {
                    return false;
                  }
                }
                var ClipboardActionCut = function ClipboardActionCut2(target) {
                  var selectedText = select_default()(target);
                  command("cut");
                  return selectedText;
                };
                var actions_cut = ClipboardActionCut;
                function createFakeElement(value) {
                  var isRTL = document.documentElement.getAttribute("dir") === "rtl";
                  var fakeElement = document.createElement("textarea");
                  fakeElement.style.fontSize = "12pt";
                  fakeElement.style.border = "0";
                  fakeElement.style.padding = "0";
                  fakeElement.style.margin = "0";
                  fakeElement.style.position = "absolute";
                  fakeElement.style[isRTL ? "right" : "left"] = "-9999px";
                  var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                  fakeElement.style.top = "".concat(yPosition, "px");
                  fakeElement.setAttribute("readonly", "");
                  fakeElement.value = value;
                  return fakeElement;
                }
                var fakeCopyAction = function fakeCopyAction2(value, options) {
                  var fakeElement = createFakeElement(value);
                  options.container.appendChild(fakeElement);
                  var selectedText = select_default()(fakeElement);
                  command("copy");
                  fakeElement.remove();
                  return selectedText;
                };
                var ClipboardActionCopy = function ClipboardActionCopy2(target) {
                  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                    container: document.body
                  };
                  var selectedText = "";
                  if (typeof target === "string") {
                    selectedText = fakeCopyAction(target, options);
                  } else if (target instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(target === null || target === void 0 ? void 0 : target.type)) {
                    selectedText = fakeCopyAction(target.value, options);
                  } else {
                    selectedText = select_default()(target);
                    command("copy");
                  }
                  return selectedText;
                };
                var actions_copy = ClipboardActionCopy;
                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof2(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof = function _typeof2(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof(obj);
                }
                var ClipboardActionDefault = function ClipboardActionDefault2() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var _options$action = options.action, action = _options$action === void 0 ? "copy" : _options$action, container = options.container, target = options.target, text = options.text;
                  if (action !== "copy" && action !== "cut") {
                    throw new Error('Invalid "action" value, use either "copy" or "cut"');
                  }
                  if (target !== void 0) {
                    if (target && _typeof(target) === "object" && target.nodeType === 1) {
                      if (action === "copy" && target.hasAttribute("disabled")) {
                        throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                      }
                      if (action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                        throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                      }
                    } else {
                      throw new Error('Invalid "target" value, use a valid Element');
                    }
                  }
                  if (text) {
                    return actions_copy(text, {
                      container
                    });
                  }
                  if (target) {
                    return action === "cut" ? actions_cut(target) : actions_copy(target, {
                      container
                    });
                  }
                };
                var actions_default = ClipboardActionDefault;
                function clipboard_typeof(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    clipboard_typeof = function _typeof2(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    clipboard_typeof = function _typeof2(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return clipboard_typeof(obj);
                }
                function _classCallCheck(instance2, Constructor) {
                  if (!(instance2 instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props2) {
                  for (var i2 = 0; i2 < props2.length; i2++) {
                    var descriptor = props2[i2];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o2, p2) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
                    o3.__proto__ = p3;
                    return o3;
                  };
                  return _setPrototypeOf(o2, p2);
                }
                function _createSuper(Derived) {
                  var hasNativeReflectConstruct = _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super = _getPrototypeOf(Derived), result;
                    if (hasNativeReflectConstruct) {
                      var NewTarget = _getPrototypeOf(this).constructor;
                      result = Reflect.construct(Super, arguments, NewTarget);
                    } else {
                      result = Super.apply(this, arguments);
                    }
                    return _possibleConstructorReturn(this, result);
                  };
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _isNativeReflectConstruct() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                    }));
                    return true;
                  } catch (e2) {
                    return false;
                  }
                }
                function _getPrototypeOf(o2) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
                    return o3.__proto__ || Object.getPrototypeOf(o3);
                  };
                  return _getPrototypeOf(o2);
                }
                function getAttributeValue(suffix, element) {
                  var attribute = "data-clipboard-".concat(suffix);
                  if (!element.hasAttribute(attribute)) {
                    return;
                  }
                  return element.getAttribute(attribute);
                }
                var Clipboard2 = /* @__PURE__ */ function(_Emitter) {
                  _inherits(Clipboard3, _Emitter);
                  var _super = _createSuper(Clipboard3);
                  function Clipboard3(trigger, options) {
                    var _this;
                    _classCallCheck(this, Clipboard3);
                    _this = _super.call(this);
                    _this.resolveOptions(options);
                    _this.listenClick(trigger);
                    return _this;
                  }
                  _createClass(Clipboard3, [{
                    key: "resolveOptions",
                    value: function resolveOptions() {
                      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                      this.action = typeof options.action === "function" ? options.action : this.defaultAction;
                      this.target = typeof options.target === "function" ? options.target : this.defaultTarget;
                      this.text = typeof options.text === "function" ? options.text : this.defaultText;
                      this.container = clipboard_typeof(options.container) === "object" ? options.container : document.body;
                    }
                    /**
                     * Adds a click event listener to the passed trigger.
                     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                     */
                  }, {
                    key: "listenClick",
                    value: function listenClick(trigger) {
                      var _this2 = this;
                      this.listener = listen_default()(trigger, "click", function(e2) {
                        return _this2.onClick(e2);
                      });
                    }
                    /**
                     * Defines a new `ClipboardAction` on each click event.
                     * @param {Event} e
                     */
                  }, {
                    key: "onClick",
                    value: function onClick(e2) {
                      var trigger = e2.delegateTarget || e2.currentTarget;
                      var action = this.action(trigger) || "copy";
                      var text = actions_default({
                        action,
                        container: this.container,
                        target: this.target(trigger),
                        text: this.text(trigger)
                      });
                      this.emit(text ? "success" : "error", {
                        action,
                        text,
                        trigger,
                        clearSelection: function clearSelection() {
                          if (trigger) {
                            trigger.focus();
                          }
                          window.getSelection().removeAllRanges();
                        }
                      });
                    }
                    /**
                     * Default `action` lookup function.
                     * @param {Element} trigger
                     */
                  }, {
                    key: "defaultAction",
                    value: function defaultAction(trigger) {
                      return getAttributeValue("action", trigger);
                    }
                    /**
                     * Default `target` lookup function.
                     * @param {Element} trigger
                     */
                  }, {
                    key: "defaultTarget",
                    value: function defaultTarget(trigger) {
                      var selector = getAttributeValue("target", trigger);
                      if (selector) {
                        return document.querySelector(selector);
                      }
                    }
                    /**
                     * Allow fire programmatically a copy action
                     * @param {String|HTMLElement} target
                     * @param {Object} options
                     * @returns Text copied.
                     */
                  }, {
                    key: "defaultText",
                    /**
                     * Default `text` lookup function.
                     * @param {Element} trigger
                     */
                    value: function defaultText(trigger) {
                      return getAttributeValue("text", trigger);
                    }
                    /**
                     * Destroy lifecycle.
                     */
                  }, {
                    key: "destroy",
                    value: function destroy() {
                      this.listener.destroy();
                    }
                  }], [{
                    key: "copy",
                    value: function copy(target) {
                      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                        container: document.body
                      };
                      return actions_copy(target, options);
                    }
                    /**
                     * Allow fire programmatically a cut action
                     * @param {String|HTMLElement} target
                     * @returns Text cutted.
                     */
                  }, {
                    key: "cut",
                    value: function cut(target) {
                      return actions_cut(target);
                    }
                    /**
                     * Returns the support of the given action, or all actions if no action is
                     * given.
                     * @param {String} [action]
                     */
                  }, {
                    key: "isSupported",
                    value: function isSupported() {
                      var action = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"];
                      var actions = typeof action === "string" ? [action] : action;
                      var support = !!document.queryCommandSupported;
                      actions.forEach(function(action2) {
                        support = support && !!document.queryCommandSupported(action2);
                      });
                      return support;
                    }
                  }]);
                  return Clipboard3;
                }(tiny_emitter_default());
                var clipboard2 = Clipboard2;
              }
            ),
            /***/
            828: (
              /***/
              function(module2) {
                var DOCUMENT_NODE_TYPE = 9;
                if (typeof Element !== "undefined" && !Element.prototype.matches) {
                  var proto = Element.prototype;
                  proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
                }
                function closest2(element, selector) {
                  while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                    if (typeof element.matches === "function" && element.matches(selector)) {
                      return element;
                    }
                    element = element.parentNode;
                  }
                }
                module2.exports = closest2;
              }
            ),
            /***/
            438: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var closest2 = __webpack_require__2(828);
                function _delegate(element, selector, type, callback, useCapture) {
                  var listenerFn = listener.apply(this, arguments);
                  element.addEventListener(type, listenerFn, useCapture);
                  return {
                    destroy: function() {
                      element.removeEventListener(type, listenerFn, useCapture);
                    }
                  };
                }
                function delegate(elements, selector, type, callback, useCapture) {
                  if (typeof elements.addEventListener === "function") {
                    return _delegate.apply(null, arguments);
                  }
                  if (typeof type === "function") {
                    return _delegate.bind(null, document).apply(null, arguments);
                  }
                  if (typeof elements === "string") {
                    elements = document.querySelectorAll(elements);
                  }
                  return Array.prototype.map.call(elements, function(element) {
                    return _delegate(element, selector, type, callback, useCapture);
                  });
                }
                function listener(element, selector, type, callback) {
                  return function(e2) {
                    e2.delegateTarget = closest2(e2.target, selector);
                    if (e2.delegateTarget) {
                      callback.call(element, e2);
                    }
                  };
                }
                module2.exports = delegate;
              }
            ),
            /***/
            879: (
              /***/
              function(__unused_webpack_module, exports2) {
                exports2.node = function(value) {
                  return value !== void 0 && value instanceof HTMLElement && value.nodeType === 1;
                };
                exports2.nodeList = function(value) {
                  var type = Object.prototype.toString.call(value);
                  return value !== void 0 && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports2.node(value[0]));
                };
                exports2.string = function(value) {
                  return typeof value === "string" || value instanceof String;
                };
                exports2.fn = function(value) {
                  var type = Object.prototype.toString.call(value);
                  return type === "[object Function]";
                };
              }
            ),
            /***/
            370: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var is = __webpack_require__2(879);
                var delegate = __webpack_require__2(438);
                function listen(target, type, callback) {
                  if (!target && !type && !callback) {
                    throw new Error("Missing required arguments");
                  }
                  if (!is.string(type)) {
                    throw new TypeError("Second argument must be a String");
                  }
                  if (!is.fn(callback)) {
                    throw new TypeError("Third argument must be a Function");
                  }
                  if (is.node(target)) {
                    return listenNode(target, type, callback);
                  } else if (is.nodeList(target)) {
                    return listenNodeList(target, type, callback);
                  } else if (is.string(target)) {
                    return listenSelector(target, type, callback);
                  } else {
                    throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
                  }
                }
                function listenNode(node, type, callback) {
                  node.addEventListener(type, callback);
                  return {
                    destroy: function() {
                      node.removeEventListener(type, callback);
                    }
                  };
                }
                function listenNodeList(nodeList, type, callback) {
                  Array.prototype.forEach.call(nodeList, function(node) {
                    node.addEventListener(type, callback);
                  });
                  return {
                    destroy: function() {
                      Array.prototype.forEach.call(nodeList, function(node) {
                        node.removeEventListener(type, callback);
                      });
                    }
                  };
                }
                function listenSelector(selector, type, callback) {
                  return delegate(document.body, selector, type, callback);
                }
                module2.exports = listen;
              }
            ),
            /***/
            817: (
              /***/
              function(module2) {
                function select(element) {
                  var selectedText;
                  if (element.nodeName === "SELECT") {
                    element.focus();
                    selectedText = element.value;
                  } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
                    var isReadOnly = element.hasAttribute("readonly");
                    if (!isReadOnly) {
                      element.setAttribute("readonly", "");
                    }
                    element.select();
                    element.setSelectionRange(0, element.value.length);
                    if (!isReadOnly) {
                      element.removeAttribute("readonly");
                    }
                    selectedText = element.value;
                  } else {
                    if (element.hasAttribute("contenteditable")) {
                      element.focus();
                    }
                    var selection = window.getSelection();
                    var range2 = document.createRange();
                    range2.selectNodeContents(element);
                    selection.removeAllRanges();
                    selection.addRange(range2);
                    selectedText = selection.toString();
                  }
                  return selectedText;
                }
                module2.exports = select;
              }
            ),
            /***/
            279: (
              /***/
              function(module2) {
                function E() {
                }
                E.prototype = {
                  on: function(name2, callback, ctx) {
                    var e2 = this.e || (this.e = {});
                    (e2[name2] || (e2[name2] = [])).push({
                      fn: callback,
                      ctx
                    });
                    return this;
                  },
                  once: function(name2, callback, ctx) {
                    var self2 = this;
                    function listener() {
                      self2.off(name2, listener);
                      callback.apply(ctx, arguments);
                    }
                    listener._ = callback;
                    return this.on(name2, listener, ctx);
                  },
                  emit: function(name2) {
                    var data = [].slice.call(arguments, 1);
                    var evtArr = ((this.e || (this.e = {}))[name2] || []).slice();
                    var i2 = 0;
                    var len = evtArr.length;
                    for (i2; i2 < len; i2++) {
                      evtArr[i2].fn.apply(evtArr[i2].ctx, data);
                    }
                    return this;
                  },
                  off: function(name2, callback) {
                    var e2 = this.e || (this.e = {});
                    var evts = e2[name2];
                    var liveEvents = [];
                    if (evts && callback) {
                      for (var i2 = 0, len = evts.length; i2 < len; i2++) {
                        if (evts[i2].fn !== callback && evts[i2].fn._ !== callback)
                          liveEvents.push(evts[i2]);
                      }
                    }
                    liveEvents.length ? e2[name2] = liveEvents : delete e2[name2];
                    return this;
                  }
                };
                module2.exports = E;
                module2.exports.TinyEmitter = E;
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            if (__webpack_module_cache__[moduleId]) {
              return __webpack_module_cache__[moduleId].exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          !function() {
            __webpack_require__.n = function(module2) {
              var getter = module2 && module2.__esModule ? (
                /******/
                function() {
                  return module2["default"];
                }
              ) : (
                /******/
                function() {
                  return module2;
                }
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          }();
          !function() {
            __webpack_require__.d = function(exports2, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          }();
          !function() {
            __webpack_require__.o = function(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            };
          }();
          return __webpack_require__(686);
        }().default
      );
    });
  })(clipboard);
  var clipboardExports = clipboard.exports;
  const Clipboard = /* @__PURE__ */ getDefaultExportFromCjs(clipboardExports);
  const useClipboard = (opts) => {
    const appendToBody = (opts === null || opts === void 0 ? void 0 : opts.appendToBody) === void 0 ? true : opts.appendToBody;
    return {
      toClipboard(text, container) {
        return new Promise((resolve, reject) => {
          const fakeEl = document.createElement("button");
          const clipboard2 = new Clipboard(fakeEl, {
            text: () => text,
            action: () => "copy",
            container: container !== void 0 ? container : document.body
          });
          clipboard2.on("success", (e2) => {
            clipboard2.destroy();
            resolve(e2);
          });
          clipboard2.on("error", (e2) => {
            clipboard2.destroy();
            reject(e2);
          });
          if (appendToBody)
            document.body.appendChild(fakeEl);
          fakeEl.click();
          if (appendToBody)
            document.body.removeChild(fakeEl);
        });
      }
    };
  };
  const _imports_1$9 = "/static/icons/b_copy.png";
  const _sfc_main$k = {
    __name: "recive",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const copyHandle = async (data) => {
        uni.setClipboardData({
          data,
          success: function() {
            uni.showToast({
              title: "Copy Success",
              icon: "none"
            });
          }
        });
      };
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const pages2 = vue.ref({
        pageSize: 10,
        pageNo: 1
      });
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pageData = vue.ref("");
      const codeVal = vue.ref("");
      onLoad((e2) => {
        if (e2.code) {
          codeVal.value = e2.code;
          queryList();
        }
      });
      const queryList = () => {
        request({
          url: "/admin-api/storage/local/goods/get-logistics-info/" + codeVal.value
        }).then((res) => {
          pageData.value = res;
          dataList.value = res.orderSheetList;
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { toClipboard, copyHandle, changePage, pages: pages2, dataList, paging, pageData, codeVal, queryList, goBack, get request() {
        return request;
      }, ref: vue.ref, get showToast() {
        return showToast;
      }, get useClipboard() {
        return useClipboard;
      }, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt20 pdlr12" }, [
        vue.createElementVNode("view", { class: "color7C" }, "  "),
        vue.createElementVNode("view", { class: "mt12 copyBox between" }, [
          vue.createElementVNode(
            "view",
            { class: "f20 text_bold" },
            vue.toDisplayString($setup.pageData.supplierLogisticsNo),
            1
            /* TEXT */
          ),
          vue.createElementVNode("image", {
            src: _imports_1$9,
            class: "ww18 hh18",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.copyHandle($setup.pageData.supplierLogisticsNo))
          })
        ]),
        vue.createElementVNode(
          "view",
          { class: "mt30 f13 color7C" },
          vue.toDisplayString($setup.pageData.categoryName) + " x" + vue.toDisplayString($setup.pageData.goodsNum),
          1
          /* TEXT */
        ),
        (vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList($setup.dataList, (item, index2) => {
            return vue.openBlock(), vue.createElementBlock("view", {
              class: "copyBox mt12 between",
              key: index2
            }, [
              vue.createElementVNode("view", null, [
                vue.createElementVNode(
                  "view",
                  { class: "f15" },
                  vue.toDisplayString(item.receiverName + " " + item.receiverMobile),
                  1
                  /* TEXT */
                ),
                vue.createElementVNode(
                  "view",
                  { class: "mt4 f12 colorAf" },
                  " :" + vue.toDisplayString(item.orderNo),
                  1
                  /* TEXT */
                )
              ])
            ]);
          }),
          128
          /* KEYED_FRAGMENT */
        )),
        vue.createCommentVNode(" </z-paging> ")
      ]),
      vue.createElementVNode("view", { style: { "height": "100px" } }),
      vue.createElementVNode("view", { class: "fixedBot" }, [
        vue.createElementVNode("view", { class: "pdlr12 pb10" }, [
          vue.createElementVNode("view", {
            class: "botBtn center text_white confirmBtn",
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.changePage("./reciveSuccess"))
          }, "Confirm")
        ])
      ])
    ]);
  }
  const PagesGdRecive = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$j], ["__scopeId", "data-v-be889817"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/recive.vue"]]);
  const _imports_0$1 = "/static/bg/recSuc.png";
  const _sfc_main$j = {
    __name: "reciveSuccess",
    setup(__props, { expose: __expose }) {
      __expose();
      const scanVal = vue.ref(0);
      onLoad((e2) => {
        if (e2.code) {
          scanVal.value = e2.code;
        }
      });
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const __returned__ = { scanVal, changePage, onMounted: vue.onMounted, ref: vue.ref, topNavbar, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10" }, [
        vue.createElementVNode("view", { class: "ww50" }),
        vue.createElementVNode("view", { class: "text_bold f17" }, ""),
        vue.createElementVNode("view", { class: "ww50" })
      ]),
      vue.createElementVNode("view", { class: "pdlr20 mt73" }, [
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("image", {
            src: _imports_0$1,
            style: { "width": "69px", "height": "94px" }
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f20 text_bold mt20" }, "  "),
        vue.createElementVNode("view", {
          class: "colorAf pdlr35 f12 mt8 text_center",
          style: { "line-height": "18px" }
        }, "  "),
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("view", {
            class: "center botBtn",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("../tab/index"))
          }, [
            vue.createElementVNode("view", { class: "f14 ml8" }, "  ")
          ])
        ])
      ])
    ]);
  }
  const PagesGdReciveSuccess = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$i], ["__scopeId", "data-v-4c341c0d"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/reciveSuccess.vue"]]);
  var isVue2 = false;
  function set(target, key, val) {
    if (Array.isArray(target)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    target[key] = val;
    return val;
  }
  function del(target, key) {
    if (Array.isArray(target)) {
      target.splice(key, 1);
      return;
    }
    delete target[key];
  }
  function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  }
  const isProxyAvailable = typeof Proxy === "function";
  const HOOK_SETUP = "devtools-plugin:setup";
  const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
  let supported;
  let perf;
  function isPerformanceSupported() {
    var _a;
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
      supported = true;
      perf = global.perf_hooks.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
  }
  class ApiProxy {
    constructor(plugin, hook) {
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      const defaultSettings = {};
      if (plugin.settings) {
        for (const id in plugin.settings) {
          const item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
      let currentSettings = Object.assign({}, defaultSettings);
      try {
        const raw = localStorage.getItem(localSettingsSaveId);
        const data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e2) {
      }
      this.fallbacks = {
        getSettings() {
          return currentSettings;
        },
        setSettings(value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e2) {
          }
          currentSettings = value;
        },
        now() {
          return now();
        }
      };
      if (hook) {
        hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
          if (pluginId === this.plugin.id) {
            this.fallbacks.setSettings(value);
          }
        });
      }
      this.proxiedOn = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target.on[prop];
          } else {
            return (...args) => {
              this.onQueue.push({
                method: prop,
                args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target[prop];
          } else if (prop === "on") {
            return this.proxiedOn;
          } else if (Object.keys(this.fallbacks).includes(prop)) {
            return (...args) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: () => {
                }
              });
              return this.fallbacks[prop](...args);
            };
          } else {
            return (...args) => {
              return new Promise((resolve) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve
                });
              });
            };
          }
        }
      });
    }
    async setRealTarget(target) {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(await this.target[item.method](...item.args));
      }
    }
  }
  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = getTarget();
    const hook = getDevtoolsGlobalHook();
    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    } else {
      const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
      const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor: descriptor,
        setupFn,
        proxy
      });
      if (proxy)
        setupFn(proxy.proxiedTarget);
    }
  }
  /*!
   * pinia v2.1.7
   * (c) 2023 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia2) => activePinia = pinia2;
  const piniaSymbol = Symbol("pinia");
  function isPlainObject(o2) {
    return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  const IS_CLIENT = typeof window !== "undefined";
  const USE_DEVTOOLS = IS_CLIENT;
  const _global = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
  function bom(blob, { autoBom = false } = {}) {
    if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
      return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
    }
    return blob;
  }
  function download(url2, name2, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url2);
    xhr.responseType = "blob";
    xhr.onload = function() {
      saveAs(xhr.response, name2, opts);
    };
    xhr.onerror = function() {
      console.error("could not download file");
    };
    xhr.send();
  }
  function corsEnabled(url2) {
    const xhr = new XMLHttpRequest();
    xhr.open("HEAD", url2, false);
    try {
      xhr.send();
    } catch (e2) {
    }
    return xhr.status >= 200 && xhr.status <= 299;
  }
  function click(node) {
    try {
      node.dispatchEvent(new MouseEvent("click"));
    } catch (e2) {
      const evt = document.createEvent("MouseEvents");
      evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      node.dispatchEvent(evt);
    }
  }
  const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
  const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
  const saveAs = !IS_CLIENT ? () => {
  } : (
    // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
    typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
      // Use msSaveOrOpenBlob as a second approach
      "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
        // Fallback to using FileReader and a popup
        fileSaverSaveAs
      )
    )
  );
  function downloadSaveAs(blob, name2 = "download", opts) {
    const a2 = document.createElement("a");
    a2.download = name2;
    a2.rel = "noopener";
    if (typeof blob === "string") {
      a2.href = blob;
      if (a2.origin !== location.origin) {
        if (corsEnabled(a2.href)) {
          download(blob, name2, opts);
        } else {
          a2.target = "_blank";
          click(a2);
        }
      } else {
        click(a2);
      }
    } else {
      a2.href = URL.createObjectURL(blob);
      setTimeout(function() {
        URL.revokeObjectURL(a2.href);
      }, 4e4);
      setTimeout(function() {
        click(a2);
      }, 0);
    }
  }
  function msSaveAs(blob, name2 = "download", opts) {
    if (typeof blob === "string") {
      if (corsEnabled(blob)) {
        download(blob, name2, opts);
      } else {
        const a2 = document.createElement("a");
        a2.href = blob;
        a2.target = "_blank";
        setTimeout(function() {
          click(a2);
        });
      }
    } else {
      navigator.msSaveOrOpenBlob(bom(blob, opts), name2);
    }
  }
  function fileSaverSaveAs(blob, name2, opts, popup) {
    popup = popup || open("", "_blank");
    if (popup) {
      popup.document.title = popup.document.body.innerText = "downloading...";
    }
    if (typeof blob === "string")
      return download(blob, name2, opts);
    const force = blob.type === "application/octet-stream";
    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== "undefined") {
      const reader = new FileReader();
      reader.onloadend = function() {
        let url2 = reader.result;
        if (typeof url2 !== "string") {
          popup = null;
          throw new Error("Wrong reader.result type");
        }
        url2 = isChromeIOS ? url2 : url2.replace(/^data:[^;]*;/, "data:attachment/file;");
        if (popup) {
          popup.location.href = url2;
        } else {
          location.assign(url2);
        }
        popup = null;
      };
      reader.readAsDataURL(blob);
    } else {
      const url2 = URL.createObjectURL(blob);
      if (popup)
        popup.location.assign(url2);
      else
        location.href = url2;
      popup = null;
      setTimeout(function() {
        URL.revokeObjectURL(url2);
      }, 4e4);
    }
  }
  function toastMessage(message, type) {
    const piniaMessage = " " + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
      __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    } else if (type === "error") {
      console.error(piniaMessage);
    } else if (type === "warn") {
      console.warn(piniaMessage);
    } else {
      console.log(piniaMessage);
    }
  }
  function isPinia(o2) {
    return "_a" in o2 && "install" in o2;
  }
  function checkClipboardAccess() {
    if (!("clipboard" in navigator)) {
      toastMessage(`Your browser doesn't support the Clipboard API`, "error");
      return true;
    }
  }
  function checkNotFocusedError(error2) {
    if (error2 instanceof Error && error2.message.toLowerCase().includes("document is not focused")) {
      toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
      return true;
    }
    return false;
  }
  async function actionGlobalCopyState(pinia2) {
    if (checkClipboardAccess())
      return;
    try {
      await navigator.clipboard.writeText(JSON.stringify(pinia2.state.value));
      toastMessage("Global state copied to clipboard.");
    } catch (error2) {
      if (checkNotFocusedError(error2))
        return;
      toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
      console.error(error2);
    }
  }
  async function actionGlobalPasteState(pinia2) {
    if (checkClipboardAccess())
      return;
    try {
      loadStoresState(pinia2, JSON.parse(await navigator.clipboard.readText()));
      toastMessage("Global state pasted from clipboard.");
    } catch (error2) {
      if (checkNotFocusedError(error2))
        return;
      toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
      console.error(error2);
    }
  }
  async function actionGlobalSaveState(pinia2) {
    try {
      saveAs(new Blob([JSON.stringify(pinia2.state.value)], {
        type: "text/plain;charset=utf-8"
      }), "pinia-state.json");
    } catch (error2) {
      toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
      console.error(error2);
    }
  }
  let fileInput;
  function getFileOpener() {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = ".json";
    }
    function openFile() {
      return new Promise((resolve, reject) => {
        fileInput.onchange = async () => {
          const files = fileInput.files;
          if (!files)
            return resolve(null);
          const file = files.item(0);
          if (!file)
            return resolve(null);
          return resolve({ text: await file.text(), file });
        };
        fileInput.oncancel = () => resolve(null);
        fileInput.onerror = reject;
        fileInput.click();
      });
    }
    return openFile;
  }
  async function actionGlobalOpenStateFile(pinia2) {
    try {
      const open2 = getFileOpener();
      const result = await open2();
      if (!result)
        return;
      const { text, file } = result;
      loadStoresState(pinia2, JSON.parse(text));
      toastMessage(`Global state imported from "${file.name}".`);
    } catch (error2) {
      toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
      console.error(error2);
    }
  }
  function loadStoresState(pinia2, state) {
    for (const key in state) {
      const storeState = pinia2.state.value[key];
      if (storeState) {
        Object.assign(storeState, state[key]);
      } else {
        pinia2.state.value[key] = state[key];
      }
    }
  }
  function formatDisplay(display) {
    return {
      _custom: {
        display
      }
    };
  }
  const PINIA_ROOT_LABEL = " Pinia (root)";
  const PINIA_ROOT_ID = "_root";
  function formatStoreForInspectorTree(store) {
    return isPinia(store) ? {
      id: PINIA_ROOT_ID,
      label: PINIA_ROOT_LABEL
    } : {
      id: store.$id,
      label: store.$id
    };
  }
  function formatStoreForInspectorState(store) {
    if (isPinia(store)) {
      const storeNames = Array.from(store._s.keys());
      const storeMap = store._s;
      const state2 = {
        state: storeNames.map((storeId) => ({
          editable: true,
          key: storeId,
          value: store.state.value[storeId]
        })),
        getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {
          const store2 = storeMap.get(id);
          return {
            editable: false,
            key: id,
            value: store2._getters.reduce((getters, key) => {
              getters[key] = store2[key];
              return getters;
            }, {})
          };
        })
      };
      return state2;
    }
    const state = {
      state: Object.keys(store.$state).map((key) => ({
        editable: true,
        key,
        value: store.$state[key]
      }))
    };
    if (store._getters && store._getters.length) {
      state.getters = store._getters.map((getterName) => ({
        editable: false,
        key: getterName,
        value: store[getterName]
      }));
    }
    if (store._customProperties.size) {
      state.customProperties = Array.from(store._customProperties).map((key) => ({
        editable: true,
        key,
        value: store[key]
      }));
    }
    return state;
  }
  function formatEventData(events) {
    if (!events)
      return {};
    if (Array.isArray(events)) {
      return events.reduce((data, event) => {
        data.keys.push(event.key);
        data.operations.push(event.type);
        data.oldValue[event.key] = event.oldValue;
        data.newValue[event.key] = event.newValue;
        return data;
      }, {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
      });
    } else {
      return {
        operation: formatDisplay(events.type),
        key: formatDisplay(events.key),
        oldValue: events.oldValue,
        newValue: events.newValue
      };
    }
  }
  function formatMutationType(type) {
    switch (type) {
      case MutationType.direct:
        return "mutation";
      case MutationType.patchFunction:
        return "$patch";
      case MutationType.patchObject:
        return "$patch";
      default:
        return "unknown";
    }
  }
  let isTimelineActive = true;
  const componentStateTypes = [];
  const MUTATIONS_LAYER_ID = "pinia:mutations";
  const INSPECTOR_ID = "pinia";
  const { assign: assign$1 } = Object;
  const getStoreType = (id) => " " + id;
  function registerPiniaDevtools(app, pinia2) {
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia ",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app
    }, (api) => {
      if (typeof api.now !== "function") {
        toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
      }
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: `Pinia `,
        color: 15064968
      });
      api.addInspector({
        id: INSPECTOR_ID,
        label: "Pinia ",
        icon: "storage",
        treeFilterPlaceholder: "Search stores",
        actions: [
          {
            icon: "content_copy",
            action: () => {
              actionGlobalCopyState(pinia2);
            },
            tooltip: "Serialize and copy the state"
          },
          {
            icon: "content_paste",
            action: async () => {
              await actionGlobalPasteState(pinia2);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Replace the state with the content of your clipboard"
          },
          {
            icon: "save",
            action: () => {
              actionGlobalSaveState(pinia2);
            },
            tooltip: "Save the state as a JSON file"
          },
          {
            icon: "folder_open",
            action: async () => {
              await actionGlobalOpenStateFile(pinia2);
              api.sendInspectorTree(INSPECTOR_ID);
              api.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Import the state from a JSON file"
          }
        ],
        nodeActions: [
          {
            icon: "restore",
            tooltip: 'Reset the state (with "$reset")',
            action: (nodeId) => {
              const store = pinia2._s.get(nodeId);
              if (!store) {
                toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
              } else if (typeof store.$reset !== "function") {
                toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
              } else {
                store.$reset();
                toastMessage(`Store "${nodeId}" reset.`);
              }
            }
          }
        ]
      });
      api.on.inspectComponent((payload, ctx) => {
        const proxy = payload.componentInstance && payload.componentInstance.proxy;
        if (proxy && proxy._pStores) {
          const piniaStores = payload.componentInstance.proxy._pStores;
          Object.values(piniaStores).forEach((store) => {
            payload.instanceData.state.push({
              type: getStoreType(store.$id),
              key: "state",
              editable: true,
              value: store._isOptionsAPI ? {
                _custom: {
                  value: vue.toRaw(store.$state),
                  actions: [
                    {
                      icon: "restore",
                      tooltip: "Reset the state of this store",
                      action: () => store.$reset()
                    }
                  ]
                }
              } : (
                // NOTE: workaround to unwrap transferred refs
                Object.keys(store.$state).reduce((state, key) => {
                  state[key] = store.$state[key];
                  return state;
                }, {})
              )
            });
            if (store._getters && store._getters.length) {
              payload.instanceData.state.push({
                type: getStoreType(store.$id),
                key: "getters",
                editable: false,
                value: store._getters.reduce((getters, key) => {
                  try {
                    getters[key] = store[key];
                  } catch (error2) {
                    getters[key] = error2;
                  }
                  return getters;
                }, {})
              });
            }
          });
        }
      });
      api.on.getInspectorTree((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          let stores = [pinia2];
          stores = stores.concat(Array.from(pinia2._s.values()));
          payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
        }
      });
      api.on.getInspectorState((payload) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
          if (!inspectedStore) {
            return;
          }
          if (inspectedStore) {
            payload.state = formatStoreForInspectorState(inspectedStore);
          }
        }
      });
      api.on.editInspectorState((payload, ctx) => {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
          if (!inspectedStore) {
            return toastMessage(`store "${payload.nodeId}" not found`, "error");
          }
          const { path } = payload;
          if (!isPinia(inspectedStore)) {
            if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
              path.unshift("$state");
            }
          } else {
            path.unshift("state");
          }
          isTimelineActive = false;
          payload.set(inspectedStore, path, payload.state.value);
          isTimelineActive = true;
        }
      });
      api.on.editComponentState((payload) => {
        if (payload.type.startsWith("")) {
          const storeId = payload.type.replace(/^\s*/, "");
          const store = pinia2._s.get(storeId);
          if (!store) {
            return toastMessage(`store "${storeId}" not found`, "error");
          }
          const { path } = payload;
          if (path[0] !== "state") {
            return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
          }
          path[0] = "$state";
          isTimelineActive = false;
          payload.set(store, path, payload.state.value);
          isTimelineActive = true;
        }
      });
    });
  }
  function addStoreToDevtools(app, store) {
    if (!componentStateTypes.includes(getStoreType(store.$id))) {
      componentStateTypes.push(getStoreType(store.$id));
    }
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia ",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app,
      settings: {
        logStoreChanges: {
          label: "Notify about new/deleted stores",
          type: "boolean",
          defaultValue: true
        }
        // useEmojis: {
        //   label: 'Use emojis in messages ',
        //   type: 'boolean',
        //   defaultValue: true,
        // },
      }
    }, (api) => {
      const now2 = typeof api.now === "function" ? api.now.bind(api) : Date.now;
      store.$onAction(({ after, onError, name: name2, args }) => {
        const groupId = runningActionId++;
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: " " + name2,
            subtitle: "start",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name2),
              args
            },
            groupId
          }
        });
        after((result) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: " " + name2,
              subtitle: "end",
              data: {
                store: formatDisplay(store.$id),
                action: formatDisplay(name2),
                args,
                result
              },
              groupId
            }
          });
        });
        onError((error2) => {
          activeAction = void 0;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              logType: "error",
              title: " " + name2,
              subtitle: "end",
              data: {
                store: formatDisplay(store.$id),
                action: formatDisplay(name2),
                args,
                error: error2
              },
              groupId
            }
          });
        });
      }, true);
      store._customProperties.forEach((name2) => {
        vue.watch(() => vue.unref(store[name2]), (newValue, oldValue) => {
          api.notifyComponentUpdate();
          api.sendInspectorState(INSPECTOR_ID);
          if (isTimelineActive) {
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                title: "Change",
                subtitle: name2,
                data: {
                  newValue,
                  oldValue
                },
                groupId: activeAction
              }
            });
          }
        }, { deep: true });
      });
      store.$subscribe(({ events, type }, state) => {
        api.notifyComponentUpdate();
        api.sendInspectorState(INSPECTOR_ID);
        if (!isTimelineActive)
          return;
        const eventData = {
          time: now2(),
          title: formatMutationType(type),
          data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
          groupId: activeAction
        };
        if (type === MutationType.patchFunction) {
          eventData.subtitle = "";
        } else if (type === MutationType.patchObject) {
          eventData.subtitle = "";
        } else if (events && !Array.isArray(events)) {
          eventData.subtitle = events.type;
        }
        if (events) {
          eventData.data["rawEvent(s)"] = {
            _custom: {
              display: "DebuggerEvent",
              type: "object",
              tooltip: "raw DebuggerEvent[]",
              value: events
            }
          };
        }
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: eventData
        });
      }, { detached: true, flush: "sync" });
      const hotUpdate = store._hotUpdate;
      store._hotUpdate = vue.markRaw((newStore) => {
        hotUpdate(newStore);
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: " " + store.$id,
            subtitle: "HMR update",
            data: {
              store: formatDisplay(store.$id),
              info: formatDisplay(`HMR update`)
            }
          }
        });
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
      });
      const { $dispose } = store;
      store.$dispose = () => {
        $dispose();
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store `);
      };
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed `);
    });
  }
  let runningActionId = 0;
  let activeAction;
  function patchActionForGrouping(store, actionNames, wrapWithProxy) {
    const actions = actionNames.reduce((storeActions, actionName) => {
      storeActions[actionName] = vue.toRaw(store)[actionName];
      return storeActions;
    }, {});
    for (const actionName in actions) {
      store[actionName] = function() {
        const _actionId = runningActionId;
        const trackedStore = wrapWithProxy ? new Proxy(store, {
          get(...args) {
            activeAction = _actionId;
            return Reflect.get(...args);
          },
          set(...args) {
            activeAction = _actionId;
            return Reflect.set(...args);
          }
        }) : store;
        activeAction = _actionId;
        const retValue = actions[actionName].apply(trackedStore, arguments);
        activeAction = void 0;
        return retValue;
      };
    }
  }
  function devtoolsPlugin({ app, store, options }) {
    if (store.$id.startsWith("__hot:")) {
      return;
    }
    store._isOptionsAPI = !!options.state;
    patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
    const originalHotUpdate = store._hotUpdate;
    vue.toRaw(store)._hotUpdate = function(newStore) {
      originalHotUpdate.apply(this, arguments);
      patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
    };
    addStoreToDevtools(
      app,
      // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
      store
    );
  }
  function createPinia() {
    const scope = vue.effectScope(true);
    const state = scope.run(() => vue.ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia2 = vue.markRaw({
      install(app) {
        setActivePinia(pinia2);
        {
          pinia2._a = app;
          app.provide(piniaSymbol, pinia2);
          app.config.globalProperties.$pinia = pinia2;
          if (USE_DEVTOOLS) {
            registerPiniaDevtools(app, pinia2);
          }
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
      pinia2.use(devtoolsPlugin);
    }
    return pinia2;
  }
  function patchObject(newState, oldState) {
    for (const key in oldState) {
      const subPatch = oldState[key];
      if (!(key in newState)) {
        continue;
      }
      const targetValue = newState[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
        newState[key] = patchObject(targetValue, subPatch);
      } else {
        {
          newState[key] = subPatch;
        }
      }
    }
    return newState;
  }
  const noop = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && vue.getCurrentScope()) {
      vue.onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    }
    if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = Symbol("pinia:skipHydration");
  function shouldHydrate(obj) {
    return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o2) {
    return !!(vue.isRef(o2) && o2.effect);
  }
  function createOptionsStore(id, options, pinia2, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia2.state.value[id];
    let store;
    function setup() {
      if (!initialState && !hot) {
        {
          pinia2.state.value[id] = state ? state() : {};
        }
      }
      const localState = hot ? (
        // use ref() to unwrap refs inside state TODO: check if this is still necessary
        vue.toRefs(vue.ref(state ? state() : {}).value)
      ) : vue.toRefs(pinia2.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name2) => {
        if (name2 in localState) {
          console.warn(`[]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name2}" in store "${id}".`);
        }
        computedGetters[name2] = vue.markRaw(vue.computed(() => {
          setActivePinia(pinia2);
          const store2 = pinia2._s.get(id);
          return getters[name2].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options, pinia2, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    if (!pinia2._e.active) {
      throw new Error("Pinia destroyed");
    }
    const $subscribeOptions = {
      deep: true
      // flush: 'post',
    };
    {
      $subscribeOptions.onTrigger = (event) => {
        if (isListening) {
          debuggerEvents = event;
        } else if (isListening == false && !store._hotUpdating) {
          if (Array.isArray(debuggerEvents)) {
            debuggerEvents.push(event);
          } else {
            console.error(" debuggerEvents should be an array. This is most likely an internal Pinia bug.");
          }
        }
      };
    }
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia2.state.value[$id];
    if (!isOptionsStore && !initialState && !hot) {
      {
        pinia2.state.value[$id] = {};
      }
    }
    const hotState = vue.ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      {
        debuggerEvents = [];
      }
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia2.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      vue.nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      () => {
        throw new Error(`: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
      }
    );
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia2._s.delete($id);
    }
    function wrapAction(name2, action) {
      return function() {
        setActivePinia(pinia2);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name: name2,
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = action.apply(this && this.$id === $id ? this : store, args);
        } catch (error2) {
          triggerSubscriptions(onErrorCallbackList, error2);
          throw error2;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error2) => {
            triggerSubscriptions(onErrorCallbackList, error2);
            return Promise.reject(error2);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
    }
    const _hmrPayload = /* @__PURE__ */ vue.markRaw({
      actions: {},
      getters: {},
      state: [],
      hotState
    });
    const partialStore = {
      _p: pinia2,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => vue.watch(() => pinia2.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = vue.reactive(assign(
      {
        _hmrPayload,
        _customProperties: vue.markRaw(/* @__PURE__ */ new Set())
        // devtools custom properties
      },
      partialStore
      // must be added later
      // setupStore
    ));
    pinia2._s.set($id, store);
    const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia2._e.run(() => (scope = vue.effectScope()).run(setup)));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (vue.isRef(prop) && !isComputed(prop) || vue.isReactive(prop)) {
        if (hot) {
          set(hotState.value, key, vue.toRef(setupStore, key));
        } else if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (vue.isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia2.state.value[$id][key] = prop;
          }
        }
        {
          _hmrPayload.state.push(key);
        }
      } else if (typeof prop === "function") {
        const actionValue = hot ? prop : wrapAction(key, prop);
        {
          setupStore[key] = actionValue;
        }
        {
          _hmrPayload.actions[key] = prop;
        }
        optionsForPlugin.actions[key] = prop;
      } else {
        if (isComputed(prop)) {
          _hmrPayload.getters[key] = isOptionsStore ? (
            // @ts-expect-error
            options.getters[key]
          ) : prop;
          if (IS_CLIENT) {
            const getters = setupStore._getters || // @ts-expect-error: same
            (setupStore._getters = vue.markRaw([]));
            getters.push(key);
          }
        }
      }
    }
    {
      assign(store, setupStore);
      assign(vue.toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => hot ? hotState.value : pinia2.state.value[$id],
      set: (state) => {
        if (hot) {
          throw new Error("cannot set hotState");
        }
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    {
      store._hotUpdate = vue.markRaw((newStore) => {
        store._hotUpdating = true;
        newStore._hmrPayload.state.forEach((stateKey) => {
          if (stateKey in store.$state) {
            const newStateTarget = newStore.$state[stateKey];
            const oldStateSource = store.$state[stateKey];
            if (typeof newStateTarget === "object" && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) {
              patchObject(newStateTarget, oldStateSource);
            } else {
              newStore.$state[stateKey] = oldStateSource;
            }
          }
          set(store, stateKey, vue.toRef(newStore.$state, stateKey));
        });
        Object.keys(store.$state).forEach((stateKey) => {
          if (!(stateKey in newStore.$state)) {
            del(store, stateKey);
          }
        });
        isListening = false;
        isSyncListening = false;
        pinia2.state.value[$id] = vue.toRef(newStore._hmrPayload, "hotState");
        isSyncListening = true;
        vue.nextTick().then(() => {
          isListening = true;
        });
        for (const actionName in newStore._hmrPayload.actions) {
          const action = newStore[actionName];
          set(store, actionName, wrapAction(actionName, action));
        }
        for (const getterName in newStore._hmrPayload.getters) {
          const getter = newStore._hmrPayload.getters[getterName];
          const getterValue = isOptionsStore ? (
            // special handling of options api
            vue.computed(() => {
              setActivePinia(pinia2);
              return getter.call(store, store);
            })
          ) : getter;
          set(store, getterName, getterValue);
        }
        Object.keys(store._hmrPayload.getters).forEach((key) => {
          if (!(key in newStore._hmrPayload.getters)) {
            del(store, key);
          }
        });
        Object.keys(store._hmrPayload.actions).forEach((key) => {
          if (!(key in newStore._hmrPayload.actions)) {
            del(store, key);
          }
        });
        store._hmrPayload = newStore._hmrPayload;
        store._getters = newStore._getters;
        store._hotUpdating = false;
      });
    }
    if (USE_DEVTOOLS) {
      const nonEnumerable = {
        writable: true,
        configurable: true,
        // avoid warning on devtools trying to display this property
        enumerable: false
      };
      ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
        Object.defineProperty(store, p2, assign({ value: store[p2] }, nonEnumerable));
      });
    }
    pinia2._p.forEach((extender) => {
      if (USE_DEVTOOLS) {
        const extensions = scope.run(() => extender({
          store,
          app: pinia2._a,
          pinia: pinia2,
          options: optionsForPlugin
        }));
        Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
        assign(store, extensions);
      } else {
        assign(store, scope.run(() => extender({
          store,
          app: pinia2._a,
          pinia: pinia2,
          options: optionsForPlugin
        })));
      }
    });
    if (store.$state && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) {
      console.warn(`[]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
    }
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    } else {
      options = idOrOptions;
      id = idOrOptions.id;
      if (typeof id !== "string") {
        throw new Error(`[]: "defineStore()" must be passed a store id as its first argument.`);
      }
    }
    function useStore(pinia2, hot) {
      const hasContext = vue.hasInjectionContext();
      pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia2 || (hasContext ? vue.inject(piniaSymbol, null) : null);
      if (pinia2)
        setActivePinia(pinia2);
      if (!activePinia) {
        throw new Error(`[]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
      }
      pinia2 = activePinia;
      if (!pinia2._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia2);
        } else {
          createOptionsStore(id, options, pinia2);
        }
        {
          useStore._pinia = pinia2;
        }
      }
      const store = pinia2._s.get(id);
      if (hot) {
        const hotId = "__hot:" + id;
        const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia2, true) : createOptionsStore(hotId, assign({}, options), pinia2, true);
        hot._hotUpdate(newStore);
        delete pinia2.state.value[hotId];
        pinia2._s.delete(hotId);
      }
      if (IS_CLIENT) {
        const currentInstance = vue.getCurrentInstance();
        if (currentInstance && currentInstance.proxy && // avoid adding stores that are just built for hot module replacement
        !hot) {
          const vm = currentInstance.proxy;
          const cache2 = "_pStores" in vm ? vm._pStores : vm._pStores = {};
          cache2[id] = store;
        }
      }
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  const GDHPStore = defineStore("GDHPStore", {
    //  
    state: () => {
      return {
        // 
        outboundList: [],
        reviceObj: {}
      };
    },
    actions: {
      addToList(obj) {
        this.outboundList.push(obj);
      },
      celByList(index2) {
        this.outboundList.splice(index2, 1);
      }
    }
  });
  const _imports_1$8 = "/static/icons/scan_blue.png";
  const _imports_2$1 = "/static/icons/delete.png";
  const _sfc_main$i = {
    __name: "warehouse",
    setup(__props, { expose: __expose }) {
      __expose();
      const GDHPStoreInfo = GDHPStore();
      const getData = () => {
        let storageType;
        try {
          storageType = GDHPStoreInfo.$state.outboundList[0].storageType;
        } catch (e2) {
        }
        request({
          url: "/admin-api/storage/local/goods/get-for-outbound",
          data: {
            orderNo: window.location.href.split("code=")[1],
            storageType
          }
        }).then((res) => {
          if (!GDHPStoreInfo.$state.outboundList.some((item) => item.orderNo == res.orderNo)) {
            GDHPStoreInfo.addToList(res);
          } else {
            uni.showToast({
              title: "",
              icon: "none"
            });
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const deleteHandle = (item, index2) => {
        GDHPStoreInfo.celByList(index2);
      };
      const uploadGoods = () => {
        const goodsIds = GDHPStoreInfo.$state.outboundList.map((item) => {
          return item.id;
        });
        request({
          url: "/admin-api/storage/local/goods/outbound/create",
          methods: "POST",
          data: {
            goodsIds
          }
        }).then((res) => {
          GDHPStoreInfo.$state.outboundList = [];
          changePage("./warehouseSuccess");
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const dataList = vue.computed(() => {
        return GDHPStoreInfo.$state.outboundList;
      });
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { GDHPStoreInfo, getData, deleteHandle, uploadGoods, changePage, dataList, goBack, topNavbar, get request() {
        return request;
      }, get GDHPStore() {
        return GDHPStore;
      }, get showToast() {
        return showToast;
      }, ref: vue.ref, computed: vue.computed };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "pdlr12 pt12" }, [
        vue.createElementVNode("view", { class: "topBox pdlr12 pt21 pb16" }, [
          vue.createElementVNode("view", { class: "f14" }, ""),
          vue.createElementVNode("view", { class: "mt19 shelfBox center flex-col" }, [
            vue.createElementVNode(
              "view",
              { class: "f20 text_bold colorBlue" },
              vue.toDisplayString((_a = $setup.GDHPStoreInfo.$state.outboundList[0]) == null ? void 0 : _a.storageTypeName),
              1
              /* TEXT */
            )
          ])
        ]),
        vue.createElementVNode("view", { class: "mt12 botBox" }, [
          vue.createElementVNode("view", { class: "between" }, [
            vue.createElementVNode(
              "view",
              { class: "f14" },
              " x" + vue.toDisplayString($setup.dataList.length),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", {
              class: "rightBtn flex col_center f12",
              onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("../home/scanCode?type=7"))
            }, [
              vue.createElementVNode("image", {
                src: _imports_1$8,
                class: "ww24 hh24"
              }),
              vue.createTextVNode("  ")
            ])
          ]),
          vue.createElementVNode("view", { class: "goodsBox pt12" }, [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "between goodsItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "flex col_center f14 text_bold" }, [
                    vue.createElementVNode(
                      "view",
                      null,
                      vue.toDisplayString(item.categoryName) + " -- " + vue.toDisplayString(item.orderNo),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "pl15" },
                      "x" + vue.toDisplayString(item.num),
                      1
                      /* TEXT */
                    )
                  ]),
                  vue.createElementVNode("image", {
                    src: _imports_2$1,
                    class: "ww24 hh24",
                    onClick: ($event) => $setup.deleteHandle(item, index2)
                  }, null, 8, ["onClick"])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ]),
        vue.createElementVNode("view", { class: "botFixed" }, [
          vue.createElementVNode("view", { class: "pdlr12 pb10" }, [
            vue.createElementVNode("view", {
              class: "btns f14 text_white center",
              onClick: $setup.uploadGoods
            }, "  ")
          ])
        ])
      ]),
      vue.createElementVNode("view", { style: { "height": "100px" } })
    ]);
  }
  const PagesGdWarehouse = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$h], ["__scopeId", "data-v-d0b5625b"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/warehouse.vue"]]);
  const _sfc_main$h = {
    __name: "warehouseSuccess",
    setup(__props, { expose: __expose }) {
      __expose();
      const scanVal = vue.ref(0);
      onLoad((e2) => {
        if (e2.code) {
          scanVal.value = e2.code;
        }
      });
      function changePage() {
        uni.navigateTo({
          url: "/pages/tab/index"
        });
      }
      const __returned__ = { scanVal, changePage, get onLoad() {
        return onLoad;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10" }, [
        vue.createElementVNode("view", { class: "ww50" }),
        vue.createElementVNode("view", { class: "text_bold f17" }, ""),
        vue.createElementVNode("view", { class: "ww50" })
      ]),
      vue.createElementVNode("view", { class: "pdlr20 mt73" }, [
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("image", {
            src: _imports_0$1,
            style: { "width": "69px", "height": "94px" }
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f20 text_bold mt20" }, "  "),
        vue.createElementVNode("view", {
          class: "colorAf pdlr35 f12 mt8 text_center",
          style: { "line-height": "18px" }
        }, "  "),
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("view", {
            class: "center botBtn",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("/pages/tab/index"))
          }, [
            vue.createElementVNode("view", { class: "f14 ml8" }, "  ")
          ])
        ])
      ])
    ]);
  }
  const PagesGdWarehouseSuccess = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$g], ["__scopeId", "data-v-a5e49ea5"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/warehouseSuccess.vue"]]);
  const zStatic = {
    base64Arrow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAD1BMVEVHcExRUVFMTExRUVFRUVE9CdWsAAAABHRSTlMAjjrY9ZnUjwAAAQFJREFUWMPt2MsNgzAMgGEEE1B1gKJmAIRYoCH7z9RCXrabh33iYktcIv35EEg5ZBh07pvxJU6MFSPOSRnjnBUjUsaciRUjMsb4xIoRCWNiYsUInzE5sWKEyxiYWDbyefqHx1zIeiYTk7mQYziTYecxHvEJjwmIT3hMQELCYSISEg4TkZj0mYTEpM8kJCU9JiMp6TEZyUmbAUhO2gxAQNJiIAKSFgMRmNQZhMCkziAEJTUGIyipMRjBSZkhCE7KDEFIUmTeGCHJxWz0zXaE0GTCG8ZFtEaS347r/1fe11YyHYVfubxayfjoHmc0YYwmmmiiiSaaaKLJ7ckyz5ve+dw3Xw2emdwm9xSbAAAAAElFTkSuQmCC",
    base64ArrowWhite: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAElBMVEVHcEz///////////////////+IGTx/AAAABnRSTlMA/dAkXZOhASU/AAABYElEQVRYw+2YwXLCIBCGsdAHWGbyAKZ4zxi9O017rxLf/1UaWFAgA1m8dcpedNSPf/l/Vh0Ya/Wn6hN0JcGvoCqRM4C8VBFiDwBqqNuJKV0rAnCgy3AUqZE57x0iqTL8Br4U3WBf/YWaIlTKfAcELU/h9w72CSVPa3C3OCDvhpHbRp/s2vq4fHhCeiCl2A3m4Qd71DQR257mFBlMcTlbFnFWzNtHxewYEfSiaLS4el8d8nyhmKJd1CF4eOS0keLMAuSxubLBIeIGQW8YHCFFo7EH9+YDcQt9FMZEswTheaNxTHwHT8SZorJjMrEVwo4Zo0U8HSEyZvJMOg4RjnmmRr8nDYeIz3OMkbfE/QhBo+U9RnZJxjGCRh/WKmHEMWLNkfPKsGh/CWJk1JjG0kcuJggTt34VDP8aWAFhp4nybVb5+9qQhjSkIQ1pSEMa8k+Q5U9rV3dF8MpFBK+/7miVq1/HZ2qmo9D+pAAAAABJRU5ErkJggg==",
    base64Flower: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAKlBMVEVHcEzDw8Ovr6+pqamUlJTCwsKenp61tbWxsbGysrLNzc2bm5u5ubmjo6MpovhuAAAACnRSTlMA/P79/sHDhiZS0DxZowAABBBJREFUWMPtl89rE0EUx7ctTXatB3MI1SWnDbUKPUgXqh4ED8Uf7KUVSm3ooVSpSii0Fn/gD4j4o+APiEoVmos9FO2celiqZVgwgaKHPQiCCkv+F99kM7Ozm5kxq1dfD91k9pPve9/3ZjbRNHHok/mKli4eIPNgSuRObuN9SqSEzM20iGnm0yIbqCuV7NSSSIV7uyPM6JMBYdeTOanh/QihJYZsUCSby+VkMj2AvOt0rAeQAwqE3lfKMZVlQCZk1QOCKkkVPadITCfIRNKxfoJI5+0OIFtJx14CMSg1mRSDko7VAfksRQzEbGYqxOJcVTWMCH2I1/IACNW0PWU2M8cmAVHtnH5mM1VRWtwKZjOd5JbF6s1IbaYqaotjNlPHgDAnlAizubTR6ovMYn052g/U5qcmOpi0WL8xTS/3IfSet5m8MEr5ajjF5le6dq/OJpobrdY0t3i9QgefWrxW9/1BLhk0E9m8FeUMhhXal499iD0eQRfDF+ts/tttORRerfp+oV7f4xJj82iUYm1Yzod+ZQEAlS/8mMBwKebVmCVp1f0JLS6zKd17+iwRKTARVg2SHtz3iEbBH+Q+U28zW2Jiza8Tjb1YFoYZMsJyjDqp3M9XBQdSdPLFdxEpvOB37JrHcmR/y9+LgoTlCFGZEa2sc6d4PGlweEa2JSVPoVm+IfGG3ZL037iV9oH+P+Jxc4HGVflNq1M0pivao/EopO4b/ojVCP9GjmiXOeS0DOn1o/iiccT4ORnyvBGF3yUywkQajW4Ti0SGuiy/wVSg/L8w+X/8Q+hvUx8Xd90z4oV5a1i88MbFWHz0WZZ1UrTwBGPX3Rat9AFiXRMRjoMdIdJLEOt2h7jrYOzgOamKZSWSNspOS0X8SAqRYmxRL7sg4eLzYmNehcxh3uoyud/BH2Udux4ywxFTc1xC7Mgf4vMhc5S+kSH3Y7yj+qpwIWSoPTVCOOPVthGx9FbGqrwFw6wSFxJr+17zeKcztt3u+2roAEVgUjDd+AHGuxHy2rZHaa8JMkTHEeyi85ANPO9j9BVuBRD2FY5LDMo/Sz/2hReqGIs/KiFin+CsPsYO/yvM3jL2vE8EbX7/Bf8ejtr2GLN65bioAdgLd8Bis/mD5GmP2qeqyo2ZwQEOtAjRIDH7mBKpUcMoApbZJ5UIxkEwxyMZyMxW/uKFvHCFR3SSmerHyDNQ2dF4JG6zIMpBgLfjSF9x1D6smFcYnGApjmSLICO3ecCDWrQ48geba9DI3STy2i7ax6WIB62fSyIZIiO3GFQqSURp8wCo7GhJBGwuSovJBNjb7kT6FPVnIa9qJ2Ko+l9mefGIdinaMp0yC1URYiwsdfNE45EuA5Cx9EhalfvN5s+UyItm81vaB3p4joniN+SCP7Qc1hblAAAAAElFTkSuQmCC",
    base64FlowerWhite: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAElBMVEX///9HcEz///////////////84chYNAAAABnRSTlP/AGzCOYZj5g1nAAACfklEQVRYw+2YTVPDIBCGtza9Jw25a0bvcax30o73OOr//yvma2F3YWlpPTijXNpAHrK8LLALVPFium2vNIFSbwGKTGQA2GUiHcD29yDNy3sMIdUBQl7r2H8mOEVqAHgPkYZUS6Qc2zYhQqtjyDZEximCZwWZLIBeIgYShs2NzxKpSUehYpMJhURGb+O+w5BpMCAREKPnCDHbIY20SzhM5yxziAXpOiBXydrekT9i5XDEq4NIIHHgyU5mRGqviII4mREJJA4QJzMiILwlRJzpKxJKvCBm8OsBBbLux0tsPl4RKYm5aPu6jw1U4mGxEUR9g8M1PcqBEp/WJliNgYOXueBzS4jZSIcgY5lCtevgDSgyzE+rAfuOTQMq0yzvoGH18qju27Mayzs4fPyMziCx81NJa5RNfW7vPYK9KOfDiVkBxFHG8hAj9txuoBuSWORsFfkpBf7xKFLSeaOefEojh5jz22DJEqMP8fUyaKdQx+RnG+yXMpe8Aars8ueR1pVH/bW3FyyvPRw90upLDHwpgBDtg4aUBNkxRLXMAi03IhcZtr1m+FeI/O/JNyDmmL1djLOauSlNflBpW18RQ2bPqXI22MXXEk75KRHTnkPkYbESbdKP2ZFk0r5sIwffAjy1lx+vx7NLjB6/E7Jfv5ERKhzpN0w8IDE8IGFDv5dhz10s7GFiXRZcUeLCEG5P5nDq9k4PFDcoMpE3GY4OuxuCXhmuyNB6k0RsLIAvqp9NE5r8ZCSS8gxnUp7ODdYhZTqxuiJ9uyJJtPmpqJ7wVj+XVieS903iViHziqAhchLEJAyb7jWU647EpUofQ0ziUuXXXhDddtlllSwjgSQu7r4BRWhQqfDPMVwAAAAASUVORK5CYII=",
    base64Success: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAElBMVEVRUVFHcExTU1NRUVFRUVFRUVFOSlSUAAAABnRSTlP/AI6+VySB3ZENAAACcElEQVRYw+2YyYKCMAyGI8hdpdxdZu7gcpdZ7jL6/s8yYheSNi0aPdqbwOffpGmaFOYPD3gj4bisN7vddv17N/JVgxn5x12IWgIaWTuO/IE3PseQbwjGPo2cgRmHFLJwdm/X643zwiqOKPPJ1nj3sjEP2iiifZWj5bhopSyGaEO2HX5fbQJzwJ+W7x/jw5ZFjsEU0PMph9xE8i5EqprKALW95eJQURkgzw98uJ/JvwGecR7bIjWWsUgVrrIfFZ2HlLy3sKETD1mmRLRMRhGVssRa0xJkdn3SpJBymBkM8+pSSDXMDNyDaToVHd2fgpNt0sjwiUZO19+jGQ+gQEg9Oq+bufmAVGihomNmjQG7UG3020vrlm7lkFnKFGU3kZ0KGAdmKe821pipQ+qEKcrZeTL2g5FsUks4cStjEZWwXg0b0n4GxmEpkWwIs5VBynjgK7xZaz1/0D7OxkVuLpsY5BQNFyLS84VBjjbg0iL2r2EQHBOxBhikuUOkdxODVF1cxHoWtPPsiyXO455Iv34hssCO8EV4ZIYTjS8SR4qYSHRiTiYQ4ZFbHi0iIhhBTi6dTCgSWRcnw4h4yGTuyTAiOGBIWGoZTgSHJQl+LcOJ4OCnW6yX2bMnJ9pidCOXtkTkTrIGpYuOynAiOF14SamMiOCk5Ke+mq8BcOrrvym8d0zKIQnWT+M1WwOQNO4fFiWb18hhERxJPx2fblbPHHyC41VyiAtKBUFBIih7JMWVoIQTFIr3lKPN80WvoLSWFPC653ioTZA0I0FrQ7qU6asaK0H7JmkSJa2ooOGVtNUsc3j9FYHkIkJy3SG6VHnfXKXGP9t4N9Q4Ye98AAAAAElFTkSuQmCC",
    base64SuccessWhite: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkBAMAAACCzIhnAAAAGFBMVEVHcEz///////////////////////////8dS1W+AAAAB3RSTlMAiVYk6KvDHLfaegAAAo1JREFUWMPtWEtzmzAQNhCTq910ytXpiyvxTNOr60zrayepx9d02gnX4sTm7xcEiJX2gdnkGJ1A4tOnfWqXyeR1vMRYzrcPD9v5h5MBl3/Ldvx4cxIg/FWC8X0xjLjalM54uhhCfCrRuJURX0pi3EmIqZV7O59vrRZmguStHL9b7S7ftfLwOtiZDw7AHMtmquAQ12b5Wwbnordm8g9zLLO49qc/m2n6aKnhwPOGZ08hAiNHhheiHae1lOUPGZpQkPKa3q0mOUjaRzSRaGUjpy/mmWSwySSpllcEteBKAT52KEnSbblA51pJEPxBQoiH1FP4E3s5+FJv07h6/ylD6ui7B+9fq/ehrFB98ghec9EoVtyjK8pqCHLmCBOwMWSCeWFNN4MbPAk55NhsvoFHSSVR0k5TCTTEzlUGcqV/nVp7n9oIVkmtaqbAEqEgfdgHJPwsEAyZ9r4VAZXFjpEwyaw3+H2v42KYxKhs1XvY/gSSGv+IHyUSuHXCeZhLAgVI3EjgSGo1Fb3xO0tGGU9S2/KAIbtjxpJASG73qox6w5LUq0cEOa+iIONIWIilQSQ0pPa2jgaRQAgQP7c0mITRWGxpMAmEQFN2NAQJNCV0mI6GIIEO47hlQ0ORQLd0nL+hoUjg1m6I1TRr8uYEAriBHLcVFQ5UEMiBe3XkTBEG04WXlGKGxPnMS305XQPA1Ocn2JiuAZwE66fxnKwBnDTuXxZTMq85lwW6kt5ndLqZPefiU1yvmktcUSooChJF2aMprhQlnKJQ5FxRKkcVRa+itNYU8Io2oVkY14w0NMWYlqft91Bj9VHq+ca3b43BxjWJmla0sfKohlfTVpPN+93L/yLQ/IjQ/O5Q/VR5HdL4D7mlxmjwVdELAAAAAElFTkSuQmCC",
    base64Empty: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAMAAAAL34HQAAALeGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0NDg4LCAyMDIwLzA3LzEwLTIyOjA2OjUzICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTIyVDIxOjIxOjQ1KzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTAxLTEzVDE5OjA5OjQwKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyNC0wMS0xM1QxOTowOTo0MCswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ZWQwMWYzNWQtOWRjOC00MDBiLWEyMmQtNjM5OGZiNzVhNGRiIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6ZDhlMzQ3ZmEtMDY2My1jYTRiLTgzNTctNTk4YjBkNGIzOTU2IiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZDA4MDI4MDItMzUyYS04NTRhLTkxYjctNmRlNmQ1MmViM2QwIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjMwMDAwMDAvMTAwMDAiIHRpZmY6WVJlc29sdXRpb249IjMwMDAwMDAvMTAwMDAiIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiIGV4aWY6Q29sb3JTcGFjZT0iMSIgZXhpZjpQaXhlbFhEaW1lbnNpb249IjMwMCIgZXhpZjpQaXhlbFlEaW1lbnNpb249IjMwMCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZDA4MDI4MDItMzUyYS04NTRhLTkxYjctNmRlNmQ1MmViM2QwIiBzdEV2dDp3aGVuPSIyMDIyLTAyLTIyVDIxOjIxOjQ1KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQwNjg2NzJkLWY5NDMtOTU0Mi1iMDBiLTVlMDExNmE1NmIzZSIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xM1QxMDoyNjoxNiswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphYmJkZmUyZC0xY2Q2LTJiNDgtYjUyNS05YzlhZjdlNjA4NDMiIHN0RXZ0OndoZW49IjIwMjQtMDEtMTNUMTE6MjM6NDArMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YTQ5MjM5MDAtNDhiZC03YTQ1LWI4NGItYmVlZTVjOWUxYTM1IiBzdEV2dDp3aGVuPSIyMDI0LTAxLTEzVDExOjIzOjQwKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmVkMDFmMzVkLTlkYzgtNDAwYi1hMjJkLTYzOThmYjc1YTRkYiIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xM1QxOTowOTo0MCswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmFiYmRmZTJkLTFjZDYtMmI0OC1iNTI1LTljOWFmN2U2MDg0MyIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjM2ZGQ4NTQxLWQ0MWEtYmY0Yy1iZjA3LWNmNjZhNjZhMDg2MSIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmQwODAyODAyLTM1MmEtODU0YS05MWI3LTZkZTZkNTJlYjNkMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pm30U/gAAAAJcEhZcwAALiMAAC4jAXilP3YAAAA/UExURUdwTODg4O3t7e7u7unp6d7e3uTk5M/Pz8nJyePj4+jo6Pj4+MrKyszMzO7u7unp6fb29vLy8vr6+v7+/sHBweag3xAAAAAOdFJOUwAxia5pF0n+/vzX3KbULQ2DYQAACG1JREFUeNrtm4l2o7gShi20IWFrAd7/WUc7EosDWKZ976Hc7WTmdMKXv0qlqpLyeNx222233Xbbbbfddtv/mOHn8xexSNsiRH5PrbFtW4p+DetpsF4v8Gs+HA3WEwOAfwzriYxaLTVsP8X1QK0z+vqQCzewYogi60aL9SEX5oyxphYVCFTGjfSJCTmN1jBruN5KTGCUS8bhySQGHRaohmW4glwtldbOeYJYKlgvbyUuA8aFFEKc++aIM4hrRnyiMnIZKq1PrihcM3GNKboMF1Naa9X9+8T1KrxIlVbGjv3cAEHOYYMqqgUsVuJqqehV3+sjDwB+DTJp0lYtMCyZpxqjF4e+74+sRcQSFZO8UonUSEFzuUY+DKo59A2kZDatGCjzCauy/2AmhSyCq0WHEj0KTNJDmVeNhErMt1Q8W4xti4/FwMJ4jaxl05TKFiNtD3kBGrHnhiph9V0eXQc6DkyE2xX830AlKshFTErXeuCZXK/9m41wFsGSfZ4lcGeyZ98PrylJ7MWCojQZ3qSukL2QslgdngqJnTEPdTJhXvbNBoR/+7wabIxWduN/Ja5dWEivm4XSZ2uQckNzmRlHrn2lc6eiafvS4V2Hd12tesau8toZW0CtWoZYb9t+OqxdCYKYjVPF16pVbILIy/gR7MVaWMHYPCoa2VkzkX4Iry2rirXbumGyAjGC1h62YLw6ApsNKZph3fpIWHt08JovRWD62sejpXhTrhWrPpl6zZ6PW2oTG5ltlvgtF6weNYCWKeJJSfg4W6PNJlj3sVZgOXV4lc8n4RlkMTLEBDVoYc3nI09kpyzzfgWsjyzBZSNDKF2/wjh+sxYvn8Y1scxlfLF9T1RBO3wVHsnq8Fk4oGkEh/0KJPSa8T2CeWE5X9BPmgLsaRIGeNL2kshCsWoLBmdPJW5Wbz1ndAKUXjPwxXYAUpSV3fy5BJg1aa1tyVXHHMgVH31ewDVrleHr9XqC684SUF4mecR3+wW5SC2QNvxUizRv98mLDhPgYiMDb+v8g0OADxqxcnf9w01mZYJF0fUVP5LcdswbsMmy1DVs5PlE5NpNiTR8M8qAWZkOy6aN13VcoOF2/s3xn3Mes8Xza05tgR/BuNz69nlNzMR0fH45p+G4R9oxh2mKt9MF4J7K/lvWUojwF5nCgCpuRUptnZMQ3au0nSo2UsHgV3xpmeLYzGml3ZFBBzYGPCpOQRwXs1/GG1J74dlZc6JKUOtjBAz9XjVxucGWHbZVJDPJQGYDRl1Qmf1ovk2Sbghb6MQlnF7mBzM1bgOqJAPpoOQaVe+4Skcit3uqHMyG/Sh1rHNN0gAfM0nnPrmulfLVBSm20TSZSdWa0LJl2ukVyE4vTYCgP3uQkwv1TKtQWgxDzBSg80OQjCs4klKvuUzHLCfIbDKIE/S5VIGqD1iD2819pkAqTWdmeina+oZABi7X5B1MGoTJqJSchuk6JNHcgUPAcsVFk0+N0oDN68Vo7FQSmCXjx46OEtUk1lpY2ZFQGr/AcpqVato4wPUD+RhfAeyQI5sJ6l2sDwnKqNFSJvpiyJbFl3kTOjZ2ievwCR7hkUoWeV2vOLAXvB39AJoyqYa81A5cvaAidXYTFTycKDBcalVK5f3XS89kzLVl9txfL+K+p6NUnitz5KkKm7D3DrRPNq4bk7l20aFRppNilmuQI+uzTtj9wPBkTsVwM7HbJ5pwGgujyRyZDzQLNoiRFluRtQ+GzEguqRxUL+ZMFqulMzIfaP3ARj2k/txB8c+2HyjmDizCaVWtNoE5MvMlKs/4VQ7HUJZCrU6qCKcNJ2aSWUZhJZu4VI0LB4CHFdj77DRuGi28WKAxoRyZyzGVrmc0jmk1nP5QaxZo1puqq1YIAqgZb8e/rABZJWNCNxV7DSTpOO7Aail9J9nYHtua/4ouE/aS0X1qtXQzwGx+rnbi2vhF/TfZG52oc6DPo1WCi3RTDnRk7TEntoEp38gg+DjYs2opkR3JW5EpL9rU0XSK5/6LOTAVS+72x7pm60zSf5HMdldjhzJqw1FRcxXdS3ZNZp0s92FiyluUvBPoD9ynZNkBiu2NF11ofnlnQbZgKqvusj9R/f6DOzgVsahbNlXxlsxU8y7qrbTupitRyxFBKG6H3aEPUqj7YrzAymq41FXlZLlO4WLbvG2Kg4vYB+wPfWS2B5Rq8TW9ROpAZbiF6MmCTsx1NLLsx7NOoOiZup2CNbZ36xc96ErcxzuILGrmmFhimjtwKo/yTm7feTVwB61IzbnW4967Kt3cDDotGt8JKrTiUyO3Uy2PZZt9tapXEfXhWmTgcoB+JchFWsiCKvYnhmn/tKuJDbgly897FnFfkE1rQLKy810OU7xW3bEJHCD5gERtuTGuxoJqA6qI9TNMa6MbvZomsiubbPYx78YXDaaRqqsyqfSaLZdjYGHLu65rDgydXCWm1P5EvcQ828f9pcBapTILSMv1nZCAc0WzFIFsGfUi/kmAxc6cFqDSYuPSMIbs1OVrwITTQM9HVRFJ5JL56qcoFzzT1uVcd2v9jFw8BHlcWtmEI86hp5Dy/zOlK8cUp/rVseRUBqawz6kmAcPLM9l5m8h4V53Iz/2mFJaTCvF8JbsMvPjU/7crbUXart0v4WyE0LnDPcAX95Knj4VUE8HCdNdUP8BDcOXKdPl4uSWbh4LfOV0HDdfipOmu+eIRrDsNPkIT7np/8ZAzVdOd1u8wHIqeXt8VqtgiO50ePeNaGG+uO9rHiKdL71pnIun8jxEKXv2r2HYBzO/mz96vFKoMM5WLk7tQXS9U5kwCu5lk7n6++kdCFWRaTUzm0/5fClWGWTrM/AGhCrJO/ZBQhTPFLwmV7ebgcdttt91222233Xbbbf+H9h+2WEtdHVinLAAAAABJRU5ErkJggg==",
    base64Error: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAMAAAAL34HQAAALeGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0NDg4LCAyMDIwLzA3LzEwLTIyOjA2OjUzICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTIyVDIxOjIxOjQ1KzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTAxLTEzVDE5OjEwOjEwKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyNC0wMS0xM1QxOToxMDoxMCswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTQ3NTExNjAtZDY5MC00ZTkzLWFhNGUtNGMwYTViNGU1ZGFjIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6YzRiNzlkYWMtZTJmYS1iNzQ0LWIxM2ItOWU1N2VjMDhhM2YwIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZDA4MDI4MDItMzUyYS04NTRhLTkxYjctNmRlNmQ1MmViM2QwIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjMwMDAwMDAvMTAwMDAiIHRpZmY6WVJlc29sdXRpb249IjMwMDAwMDAvMTAwMDAiIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiIGV4aWY6Q29sb3JTcGFjZT0iMSIgZXhpZjpQaXhlbFhEaW1lbnNpb249IjMwMCIgZXhpZjpQaXhlbFlEaW1lbnNpb249IjMwMCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZDA4MDI4MDItMzUyYS04NTRhLTkxYjctNmRlNmQ1MmViM2QwIiBzdEV2dDp3aGVuPSIyMDIyLTAyLTIyVDIxOjIxOjQ1KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQwNjg2NzJkLWY5NDMtOTU0Mi1iMDBiLTVlMDExNmE1NmIzZSIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xM1QxMDoyNjoxNiswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjZjk1NTE1OC04MjFiLTA4NDUtYWJmNS05YTE1NGM1ZTY4NjEiIHN0RXZ0OndoZW49IjIwMjQtMDEtMTNUMTE6MDQ6MDQrMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZGM1Y2IyNWItZDZlNC0yZjQ2LTgyODQtZmUwOTNlY2M2ZTkxIiBzdEV2dDp3aGVuPSIyMDI0LTAxLTEzVDExOjA0OjA0KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjE0NzUxMTYwLWQ2OTAtNGU5My1hYTRlLTRjMGE1YjRlNWRhYyIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xM1QxOToxMDoxMCswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmNmOTU1MTU4LTgyMWItMDg0NS1hYmY1LTlhMTU0YzVlNjg2MSIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjM2ZGQ4NTQxLWQ0MWEtYmY0Yy1iZjA3LWNmNjZhNjZhMDg2MSIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmQwODAyODAyLTM1MmEtODU0YS05MWI3LTZkZTZkNTJlYjNkMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Ph2LDQsAAAAJcEhZcwAACxMAAAsTAQCanBgAAAA5UExURUdwTNra2s7Ozq2tre3t7dPT087OzuPj4+3t7dbW1u/v79bW1vz8/MrKytDQ0Nzc3MPDw/X19bi4uMZQDnEAAAAKdFJOUwBqEPywotz+wzqApqiTAAAHW0lEQVR42u1b25akIAwcbx2UFoj//7HLTQVBRcSZfTDnbM/uTl/KSlEkwf75eeONN95444033njjjTduR9/0/yOsbqoevObL7101tYX1HFs9QFtfZalRP+rpQVgdAFx990ZnT8L6eZItUl99jeGpf1DxdV/VP9fV1f/PFlF1bYHoVFSRC60IyVjrFRnuB8IoxpExSrstsErKHpJw1eqybNLbAQvAYkKjUrjoBgKRqAaeIjG5+qaps6hKcMWmcdSwqAJWBbAgCZZaIYbsqggqqlHNbFFa5yVR4jKvrKEErOEjNCqNSwHrfE8lpLsod/u+cOPPMPBJ+Gz5dM0cXNgclre+pSxhYI1WW5Tf9ENSMIdLCiWs6q9hwQprBVYKFqyPlx4WtoSvrT9lC/wkGt8qlkQooC3hi6sgW3Bb8gtdpSV/za/mn49pC0oYhONbfyd5hzDLFivKFpTS1gKM0we0tQCEncfgQn7Rt+DC/299i1MSRJcBC0r7VviG5KZvwV5WIUobxHyrJKy8VRjXVgFYsPu5kOtbxdhycCDuihziXVLoW7xwEiUmDgd544B46luWLW+nugMLB2BimmC3cxTNxCDg8xFtuUSNqoFsDKzY8psa+XtBNWXr74N6qxwsS5T6VL5robKl10+ZRu5S9qBvUYuJwVHzjwjrE3G33qKh+WXBgmkmCvHYquTvZ8oo7rLFA4PJgYW0MdePIRQIGUPNbSMw5lubJMKtJI6+Wk6cVFMmACO+VVryeL7ZgI8MhwS2fnNPPK0geHBRd11eJSiyL4KjrL2umm1XIpRii1MKB/mU/iCZwF+pt5z3UJ7UiF3nQqadAXC3T3xEW2IyuDBe3yDTe0+A64it2WTyYSGVHymUI/EduvSWKJ80Dtv2NbYSoQxbMkVC7yzNGIWFvDF7gRD79RYrWW/BDGti4wwLtgvO7gWKUZ8Mt94qX8vLJE70+xVNwzDm9ghNM+FX7p/jlZUId2HJD+Tf79hMe3WNrAK/30E+C8/6xOCqbqxE5JNMYrNbnaLUvJAewfCg8zF0Ba/tbviWLvPYfsGFA1PVD8ZdnjlVc/DS/o7LK4NHjOjKKbfCTSCo5XmwKbaZM4jlc9NGEYd9Ijd0QS5ZGaOR2O+DPlGyRb2nXZzgnI1GdFWF+0gh3ifyTRqvzpXI2eElk58FeHziCF5hY+hSMV9Ge/mohUTGuQ4vzHYe8bW5sNdFQ58St22Vcf5zzJbtcGT4iYQ7iz8dFuxoWRYMjAM7KCnypHOTLSqdUwYIFpndOD/6B2FBzNQxYmW/zxYE4j8yLHga1s2Rbm/O5PXtGcuNDIW1dTj5hpjGsO+7z2Kk9NP1JWDlnWKAM4H6zCUNM05KyVPHBclYzUbgjE3N3tP2JWHBmbqD4GLeCs2jhMT13lMVljwcEbetwZgtHUxVQ21ho3fE7inf2s8vzMWq0EWpfOBg5hcDSGwaF2+LaysRIzNFqRgBv2sMhi/Ix0WiW8rBKNBv4ExBI7eorx9ANazsPCb5FkSNH+Reacos+AYxaFzX76KMH65c8ytzZ40YvpFAqtgC/otn1eCmMI5K8yVRQVVwq3aVtU+jJktwjyP7x+BKv8vtoH098vXYSJcrWGJcAW11r8WVRxe5vgcuFbXqwnaEZejS6mrLwYKUg1ch2RJswTFYgMOwoau+AQsSp/FuDhVZi7J402ifgGla/GJIzGLYG5H4rnKMCUydL9wcsmZSuPikR2QmjQbWqaV2ob2RdMvaLEvFlRiXpYeTwqVOtMZF+qi0dS4uEjJKMvWuYK3S0jHZwaq7BylYp/O2uu3q04lNqudLWEJQd/3paTBz12IaLIPtzE5P1AUuW9TB8NVzaG9/TIfV+eXsWeezz6HWlptEbo4SIAeWur/Y/RZC/gmZTiLzUY2j5ct6fjKsFvxqgyQxE9sbmfYtnJMIciEKo6+FL0wziJmtkzspIcUl0PgWrL7VCKP7hl61U4WLeN+7Ieli2vZhmq0VgjDOgIyhJ62sSpDkWNZa1wiB8WoLlxzy29XpGVPgn1ut5VYcGyRLK7OCiJaDYMrAneJUkZWdw0yDgNm5nDowqLc0Kp581FO7QS4pC9S/YRW9xkVdNOj0ZHCp9anEZw3VEK/fopiDrkMObkcdJtT1g6+uzQ60bIdUPztdWZWy53m+v/zFYPOGHO4AZsalmtJNkyHrCAx1RXX7mt5g1L1pDezpkXv8wJwpVRSSaf2c26Y0rrXXxyWBptu/ovdak+VhkqjGBZUdvKygqANKA/MqZ/36kcGwFn90RnWp66ksKuHgitLFY8BU+F2ZvqpxpMY9qR3YwOUJ12fc0KUHVKdswcKXuwetErCnwvMKuXxfc/3RVJ2yFc+iosQd3X+WGSVz1UiuN2J156FyVyHbsOUp3krezaPUT/VxXqdfwvknb/Zgp+idTxTbrkLqYuKreRnhy65Gf4W0NsDoYiqf6uZsvr8V9eo6XWc5+3TVf/3N1TfeeOONN95444033njjjTfeSI1/IeOYOeO4fGAAAAAASUVORK5CYII=",
    base64BackToTop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIBAMAAABfdrOtAAAAElBMVEVRUVH+/v5HcEyZmZlRUVFRUVGm1ByOAAAABnRSTlPMzADMTZAJBBGsAAAEnElEQVR42t2cS27jMAyGf7/2U+QCQeDsbeQCgZDujaC5/1UmkzaJn+JDFGcw3LdfflKibJkkDnxrL7dbg7sNt6+L4O8OYBM+B0ys+QrGkHZG+OEEQ8g6go8Bx1GIGMdpNOQyIG6XdMgnSPtKhLQDGEZFBgYMkhKFtGBb0EIEjDgFRowoBVaMGAWpMedEfxMiZtwpUsgZCqtlkCNUdpVAWigtCCCDFtLwIWeoreZCWiRYYEKGFEjDg+yRZCUH0iLRAgNyToXUNCRZyMqWhGnUN2IPm3wSlwJ7IUspyCBkIQUZhCykIIeQuRTkEDKXAuM9srrtYbrZN7Y98giZSoFd+t1OxmMITG0dcrSFXFchZ1tIvQZpYWxhBbK3hpQrkMEa0iwh5t4a+QvZvDXyF7J5a+Qv5PPW21/I5623v5DPW29/IaO3Xv5Clrw1y1/Ikrdm+Qs5svw83yNnSJ5BQb4F/F7EIEJSnThGBAXxkFQfLOviQUE8JAUPsosHBfGQfDAtHhREQ1JxIV00KIgmrnRI84S0yAd5BAXxxJUck0f6Qnwr9qmr6xF5xLMjcwn/iudIEAdWnyjkEXlQKZiRVzoqRyLbgeUKKR8Q4alY7cSnoxzSf2ggsqehKr6YVpcXpOd7H93f60cKhOd7Re2LteUF4eLqiVS1mr0ge4io6C2+soaFkJ7MuuuQs1yITEp9hwwKISIpzR2iESKSIoT0rLNwuVHQqoSIpAQJpGce60vIUSdEIuUqgPTsJ5QFZK8UIpBS8iG94GFrDjlrhfCl8CG96Llxmle4kEr6vKWBPIVo9kqDQSRk9/3cWoikcCFPAd33v4dIChPyEvLzBA6RlEYWke4JEUnhKXkLeUEKxRHJFfKCQHGucIW8IdZSRkLeEGMpYyEjiK2UsZARxFTKRMgYYillImQMMZQyFTKB2EmZCplAuFLIHT8TMoWwpQwiIVMIUwqpZP5bp5CCvCTiQKr5f5lCQN+tPCBn2ZvVDFJwIDUP0m1BYAfZYRNSsCB7BqTbhoARePIxtZ9tgwWkoJcwCalmv3MBAemtO4R6dah2HaKQqj8Zvp9sQDjvJ21+SPCBHPJDDk6QITekEV7gqCC19CpKAym9IMfckKv4olMBCeIrWwVEfvkshzQekO9r9P1/ALk+IG1eSPCDiCJfyG+FyU+A6ZCa/piZDinpz7LpkCv5gdkAEshP5emQhv7onw6pGeULyZCSUYiRDAmMkpJkCKs4JhFSq8p8hJBSVbAkhARV6ZUQoisik0FqXTmcDHLVFfbJIEFXoiiCNMpiSxGkVJaNiiBBWQArgTTaUl4JpNQWJUsgQVteXQg+AKkLxQWFGKW+5J2+eVp4S168X3CF1CltCKdTJ8lb84YK2bUBO+wZW0Pqv9nk4tKu49N45NJC5dMM5tLW5tOg59Jq6NM06dL+abFXwr/RkuvTXJwae1abtE/Dt0/ruksTvs84AZ/BCC4jHnyGVfiM3VBQFANEXEah+Ax18RlP4zNox2dkkM/wI58xTn8yDCXGYCDV3W5RGSajtXyGhG1jbpbjzpwGt/0MJft8jqC7iUbQ/QZaxdnKqcIftwAAAABJRU5ErkJggg=="
  };
  const _sfc_main$g = {
    name: "z-paging-empty-view",
    data() {
      return {};
    },
    props: {
      // 
      emptyViewText: {
        type: String,
        default: "~"
      },
      // 
      emptyViewImg: {
        type: String,
        default: ""
      },
      // 
      showEmptyViewReload: {
        type: Boolean,
        default: false
      },
      // 
      emptyViewReloadText: {
        type: String,
        default: ""
      },
      // 
      isLoadFailed: {
        type: Boolean,
        default: false
      },
      // 
      emptyViewStyle: {
        type: Object,
        default: function() {
          return {};
        }
      },
      // img
      emptyViewImgStyle: {
        type: Object,
        default: function() {
          return {};
        }
      },
      // 
      emptyViewTitleStyle: {
        type: Object,
        default: function() {
          return {};
        }
      },
      // 
      emptyViewReloadStyle: {
        type: Object,
        default: function() {
          return {};
        }
      },
      // z-index
      emptyViewZIndex: {
        type: Number,
        default: 9
      },
      // fixedz-paging
      emptyViewFixed: {
        type: Boolean,
        default: true
      },
      // rpx
      unit: {
        type: String,
        default: "rpx"
      }
    },
    computed: {
      emptyImg() {
        return this.isLoadFailed ? zStatic.base64Error : zStatic.base64Empty;
      },
      finalEmptyViewStyle() {
        this.emptyViewStyle["z-index"] = this.emptyViewZIndex;
        return this.emptyViewStyle;
      }
    },
    methods: {
      // reload
      reloadClick() {
        this.$emit("reload");
      },
      // view
      emptyViewClick() {
        this.$emit("viewClick");
      }
    }
  };
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass({ "zp-container": true, "zp-container-fixed": $props.emptyViewFixed }),
        style: vue.normalizeStyle([$options.finalEmptyViewStyle]),
        onClick: _cache[1] || (_cache[1] = (...args) => $options.emptyViewClick && $options.emptyViewClick(...args))
      },
      [
        vue.createElementVNode("view", { class: "zp-main" }, [
          !$props.emptyViewImg.length ? (vue.openBlock(), vue.createElementBlock("image", {
            key: 0,
            class: vue.normalizeClass({ "zp-main-image-rpx": $props.unit === "rpx", "zp-main-image-px": $props.unit === "px" }),
            style: vue.normalizeStyle([$props.emptyViewImgStyle]),
            src: $options.emptyImg
          }, null, 14, ["src"])) : (vue.openBlock(), vue.createElementBlock("image", {
            key: 1,
            class: vue.normalizeClass({ "zp-main-image-rpx": $props.unit === "rpx", "zp-main-image-px": $props.unit === "px" }),
            mode: "aspectFit",
            style: vue.normalizeStyle([$props.emptyViewImgStyle]),
            src: $props.emptyViewImg
          }, null, 14, ["src"])),
          vue.createElementVNode(
            "text",
            {
              class: vue.normalizeClass(["zp-main-title", { "zp-main-title-rpx": $props.unit === "rpx", "zp-main-title-px": $props.unit === "px" }]),
              style: vue.normalizeStyle([$props.emptyViewTitleStyle])
            },
            vue.toDisplayString($props.emptyViewText),
            7
            /* TEXT, CLASS, STYLE */
          ),
          $props.showEmptyViewReload ? (vue.openBlock(), vue.createElementBlock(
            "text",
            {
              key: 2,
              class: vue.normalizeClass({ "zp-main-error-btn": true, "zp-main-error-btn-rpx": $props.unit === "rpx", "zp-main-error-btn-px": $props.unit === "px" }),
              style: vue.normalizeStyle([$props.emptyViewReloadStyle]),
              onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => $options.reloadClick && $options.reloadClick(...args), ["stop"]))
            },
            vue.toDisplayString($props.emptyViewReloadText),
            7
            /* TEXT, CLASS, STYLE */
          )) : vue.createCommentVNode("v-if", true)
        ])
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const __easycom_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$f], ["__scopeId", "data-v-b55bdf15"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/z-paging/components/z-paging-empty-view/z-paging-empty-view.vue"]]);
  const c$1 = {
    // 
    version: "2.7.12",
    // 
    delayTime: 100,
    // emitkey
    errorUpdateKey: "z-paging-error-emit",
    // emit completekey
    completeUpdateKey: "z-paging-complete-emit",
    // z-pagingkey
    cachePrefixKey: "z-paging-cache",
    // indexkey
    listCellIndexKey: "zp_index",
    // key
    listCellIndexUniqueKey: "zp_unique_index"
  };
  const zLocalConfig = {};
  const storageKey = "Z-PAGING-REFRESHER-TIME-STORAGE-KEY";
  let config = null;
  let configLoaded = false;
  const timeoutMap = {};
  function gc(key, defaultValue) {
    return () => {
      _handleDefaultConfig();
      if (!config)
        return defaultValue;
      const value = config[key];
      return value === void 0 ? defaultValue : value;
    };
  }
  function getTouch(e2) {
    let touch = null;
    if (e2.touches && e2.touches.length) {
      touch = e2.touches[0];
    } else if (e2.changedTouches && e2.changedTouches.length) {
      touch = e2.changedTouches[0];
    } else if (e2.datail && e2.datail != {}) {
      touch = e2.datail;
    } else {
      return { touchX: 0, touchY: 0 };
    }
    return {
      touchX: touch.clientX,
      touchY: touch.clientY
    };
  }
  function getTouchFromZPaging(target) {
    if (target && target.tagName && target.tagName !== "BODY" && target.tagName !== "UNI-PAGE-BODY") {
      const classList = target.classList;
      if (classList && classList.contains("z-paging-content")) {
        return {
          isFromZp: true,
          isPageScroll: classList.contains("z-paging-content-page"),
          isReachedTop: classList.contains("z-paging-reached-top"),
          isUseChatRecordMode: classList.contains("z-paging-use-chat-record-mode")
        };
      } else {
        return getTouchFromZPaging(target.parentNode);
      }
    } else {
      return { isFromZp: false };
    }
  }
  function getParent(parent) {
    if (!parent)
      return null;
    if (parent.$refs.paging)
      return parent;
    return getParent(parent.$parent);
  }
  function consoleErr(err) {
    formatAppLog("error", "at node_modules/z-paging/components/z-paging/js/z-paging-utils.js:72", `[z-paging]${err}`);
  }
  function delay(callback, ms = c$1.delayTime, key) {
    const timeout2 = setTimeout(callback, ms);
    if (!!key) {
      timeoutMap[key] && clearTimeout(timeoutMap[key]);
      timeoutMap[key] = timeout2;
    }
    return timeout2;
  }
  function setRefesrherTime(time, key) {
    const datas = getRefesrherTime() || {};
    datas[key] = time;
    uni.setStorageSync(storageKey, datas);
  }
  function getRefesrherTime() {
    return uni.getStorageSync(storageKey);
  }
  function getRefesrherTimeByKey(key) {
    const datas = getRefesrherTime();
    return datas && datas[key] ? datas[key] : null;
  }
  function getRefesrherFormatTimeByKey(key, textMap) {
    const time = getRefesrherTimeByKey(key);
    const timeText = time ? _timeFormat(time, textMap) : textMap.none;
    return `${textMap.title}${timeText}`;
  }
  function convertToPx(text) {
    const dataType = Object.prototype.toString.call(text);
    if (dataType === "[object Number]")
      return text;
    let isRpx = false;
    if (text.indexOf("rpx") !== -1 || text.indexOf("upx") !== -1) {
      text = text.replace("rpx", "").replace("upx", "");
      isRpx = true;
    } else if (text.indexOf("px") !== -1) {
      text = text.replace("px", "");
    }
    if (!isNaN(text)) {
      if (isRpx)
        return Number(uni.upx2px(text));
      return Number(text);
    }
    return 0;
  }
  function getTime() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function getInstanceId() {
    const s2 = [];
    const hexDigits = "0123456789abcdef";
    for (let i2 = 0; i2 < 10; i2++) {
      s2[i2] = hexDigits.substr(Math.floor(Math.random() * 16), 1);
    }
    return s2.join("") + getTime();
  }
  function wait(ms) {
    return new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
  }
  function isPromise(func2) {
    return Object.prototype.toString.call(func2) === "[object Promise]";
  }
  function addUnit$1(value, unit) {
    if (Object.prototype.toString.call(value) === "[object String]") {
      let tempValue = value;
      tempValue = tempValue.replace("rpx", "").replace("upx", "").replace("px", "");
      if (value.indexOf("rpx") === -1 && value.indexOf("upx") === -1 && value.indexOf("px") !== -1) {
        tempValue = parseFloat(tempValue) * 2;
      }
      value = tempValue;
    }
    return unit === "rpx" ? value + "rpx" : value / 2 + "px";
  }
  function deepCopy(obj) {
    if (typeof obj !== "object" || obj === null)
      return obj;
    let newObj = Array.isArray(obj) ? [] : {};
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        newObj[key] = deepCopy(obj[key]);
      }
    }
    return newObj;
  }
  function _handleDefaultConfig() {
    if (configLoaded)
      return;
    if (zLocalConfig && Object.keys(zLocalConfig).length) {
      config = zLocalConfig;
    }
    if (!config && uni.$zp) {
      config = uni.$zp.config;
    }
    config = config ? Object.keys(config).reduce((result, key) => {
      result[_toCamelCase(key)] = config[key];
      return result;
    }, {}) : null;
    configLoaded = true;
  }
  function _timeFormat(time, textMap) {
    const date2 = new Date(time);
    const currentDate = /* @__PURE__ */ new Date();
    const dateDay = new Date(time).setHours(0, 0, 0, 0);
    const currentDateDay = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
    const disTime = dateDay - currentDateDay;
    let dayStr = "";
    const timeStr = _dateTimeFormat(date2);
    if (disTime === 0) {
      dayStr = textMap.today;
    } else if (disTime === -864e5) {
      dayStr = textMap.yesterday;
    } else {
      dayStr = _dateDayFormat(date2, date2.getFullYear() !== currentDate.getFullYear());
    }
    return `${dayStr} ${timeStr}`;
  }
  function _dateDayFormat(date2, showYear = true) {
    const year = date2.getFullYear();
    const month = date2.getMonth() + 1;
    const day = date2.getDate();
    return showYear ? `${year}-${_fullZeroToTwo(month)}-${_fullZeroToTwo(day)}` : `${_fullZeroToTwo(month)}-${_fullZeroToTwo(day)}`;
  }
  function _dateTimeFormat(date2) {
    const hour = date2.getHours();
    const minute = date2.getMinutes();
    return `${_fullZeroToTwo(hour)}:${_fullZeroToTwo(minute)}`;
  }
  function _fullZeroToTwo(str) {
    str = str.toString();
    return str.length === 1 ? "0" + str : str;
  }
  function _toCamelCase(value) {
    return value.replace(/-([a-z])/g, (_, group1) => group1.toUpperCase());
  }
  const u$1 = {
    gc,
    setRefesrherTime,
    getRefesrherFormatTimeByKey,
    getTouch,
    getTouchFromZPaging,
    getParent,
    convertToPx,
    getTime,
    getInstanceId,
    consoleErr,
    delay,
    wait,
    isPromise,
    addUnit: addUnit$1,
    deepCopy
  };
  const Enum = {
    //  0. 1.
    LoadingType: {
      Refresher: 0,
      LoadingMore: 1
    },
    //  0. 1. 2. 3. 4.
    Refresher: {
      Default: 0,
      ReleaseToRefresh: 1,
      Loading: 2,
      Complete: 3,
      GoF2: 4
    },
    //  0. 1. 2. 3.
    More: {
      Default: 0,
      Loading: 1,
      NoMore: 2,
      Fail: 3
    },
    // @query 0. 1.reload 2.refresh 3.
    QueryFrom: {
      UserPullDown: 0,
      Reload: 1,
      Refresh: 2,
      LoadingMore: 3
    },
    // cell
    CellHeightMode: {
      // 
      Fixed: "fixed",
      // 
      Dynamic: "dynamic"
    },
    // 
    CacheMode: {
      // 
      Default: "default",
      // (reload)
      Always: "always"
    }
  };
  const _sfc_main$f = {
    name: "z-paging-refresh",
    data() {
      return {
        R: Enum.Refresher,
        isIos: uni.getSystemInfoSync().platform === "ios",
        refresherTimeText: "",
        zTheme: {
          title: { white: "#efefef", black: "#555555" },
          arrow: { white: zStatic.base64ArrowWhite, black: zStatic.base64Arrow },
          flower: { white: zStatic.base64FlowerWhite, black: zStatic.base64Flower },
          success: { white: zStatic.base64SuccessWhite, black: zStatic.base64Success },
          indicator: { white: "#eeeeee", black: "#777777" }
        }
      };
    },
    props: [
      "status",
      "defaultThemeStyle",
      "defaultText",
      "pullingText",
      "refreshingText",
      "completeText",
      "goF2Text",
      "defaultImg",
      "pullingImg",
      "refreshingImg",
      "completeImg",
      "refreshingAnimated",
      "showUpdateTime",
      "updateTimeKey",
      "imgStyle",
      "titleStyle",
      "updateTimeStyle",
      "updateTimeTextMap",
      "unit"
    ],
    computed: {
      ts() {
        return this.defaultThemeStyle;
      },
      // 
      statusTextArr() {
        this.updateTime();
        return [this.defaultText, this.pullingText, this.refreshingText, this.completeText, this.goF2Text];
      },
      // 
      currentTitle() {
        return this.statusTextArr[this.status] || this.defaultText;
      },
      // class
      leftImageClass() {
        const preSizeClass = `zp-r-left-image-pre-size-${this.unit}`;
        if (this.status === this.R.Complete)
          return preSizeClass;
        return `zp-r-left-image ${preSizeClass} ${this.status === this.R.Default ? "zp-r-arrow-down" : "zp-r-arrow-top"}`;
      },
      // style
      leftImageStyle() {
        const showUpdateTime = this.showUpdateTime;
        const size = showUpdateTime ? u$1.addUnit(36, this.unit) : u$1.addUnit(34, this.unit);
        return { width: size, height: size, "margin-right": showUpdateTime ? u$1.addUnit(20, this.unit) : u$1.addUnit(9, this.unit) };
      },
      // src
      leftImageSrc() {
        const R = this.R;
        const status = this.status;
        if (status === R.Default) {
          if (!!this.defaultImg)
            return this.defaultImg;
          return this.zTheme.arrow[this.ts];
        } else if (status === R.ReleaseToRefresh) {
          if (!!this.pullingImg)
            return this.pullingImg;
          if (!!this.defaultImg)
            return this.defaultImg;
          return this.zTheme.arrow[this.ts];
        } else if (status === R.Loading) {
          if (!!this.refreshingImg)
            return this.refreshingImg;
          return this.zTheme.flower[this.ts];
        } else if (status === R.Complete) {
          if (!!this.completeImg)
            return this.completeImg;
          return this.zTheme.success[this.ts];
        } else if (status === R.GoF2) {
          return this.zTheme.arrow[this.ts];
        }
        return "";
      },
      // style
      rightTextStyle() {
        let stl = {};
        stl["color"] = this.zTheme.title[this.ts];
        stl["font-size"] = u$1.addUnit(30, this.unit);
        return stl;
      }
    },
    methods: {
      // 
      addUnit(value, unit) {
        return u$1.addUnit(value, unit);
      },
      // 
      updateTime() {
        if (this.showUpdateTime) {
          this.refresherTimeText = u$1.getRefesrherFormatTimeByKey(this.updateTimeKey, this.updateTimeTextMap);
        }
      }
    }
  };
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { style: { "height": "100%" } }, [
      vue.createElementVNode(
        "view",
        {
          class: vue.normalizeClass($props.showUpdateTime ? "zp-r-container zp-r-container-padding" : "zp-r-container")
        },
        [
          vue.createElementVNode("view", { class: "zp-r-left" }, [
            vue.createCommentVNode(" () "),
            $props.status !== $data.R.Loading ? (vue.openBlock(), vue.createElementBlock("image", {
              key: 0,
              class: vue.normalizeClass($options.leftImageClass),
              style: vue.normalizeStyle([$options.leftImageStyle, $props.imgStyle]),
              src: $options.leftImageSrc
            }, null, 14, ["src"])) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode("  "),
                vue.createElementVNode("image", {
                  class: vue.normalizeClass({ "zp-line-loading-image": $props.refreshingAnimated, "zp-r-left-image": true, "zp-r-left-image-pre-size-rpx": $props.unit === "rpx", "zp-r-left-image-pre-size-px": $props.unit === "px" }),
                  style: vue.normalizeStyle([$options.leftImageStyle, $props.imgStyle]),
                  src: $options.leftImageSrc
                }, null, 14, ["src"])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )),
            vue.createCommentVNode(" nvueloadingloading ")
          ]),
          vue.createCommentVNode("  "),
          vue.createElementVNode("view", { class: "zp-r-right" }, [
            vue.createCommentVNode("  "),
            vue.createElementVNode(
              "text",
              {
                class: "zp-r-right-text",
                style: vue.normalizeStyle([$options.rightTextStyle, $props.titleStyle])
              },
              vue.toDisplayString($options.currentTitle),
              5
              /* TEXT, STYLE */
            ),
            vue.createCommentVNode("  "),
            $props.showUpdateTime && $data.refresherTimeText.length ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 0,
                class: vue.normalizeClass(["zp-r-right-text", { "zp-r-right-time-text-rpx": $props.unit === "rpx", "zp-r-right-time-text-px": $props.unit === "px" }]),
                style: vue.normalizeStyle([{ color: $data.zTheme.title[$options.ts] }, $props.updateTimeStyle])
              },
              vue.toDisplayString($data.refresherTimeText),
              7
              /* TEXT, CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true)
          ])
        ],
        2
        /* CLASS */
      )
    ]);
  }
  const zPagingRefresh = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$e], ["__scopeId", "data-v-fff6d205"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/z-paging/components/z-paging/components/z-paging-refresh.vue"]]);
  const _sfc_main$e = {
    name: "z-paging-load-more",
    data() {
      return {
        M: Enum.More,
        zTheme: {
          title: { white: "#efefef", black: "#a4a4a4" },
          line: { white: "#efefef", black: "#eeeeee" },
          circleBorder: { white: "#aaaaaa", black: "#c8c8c8" },
          circleBorderTop: { white: "#ffffff", black: "#444444" },
          flower: { white: zStatic.base64FlowerWhite, black: zStatic.base64Flower },
          indicator: { white: "#eeeeee", black: "#777777" }
        }
      };
    },
    props: ["zConfig"],
    computed: {
      ts() {
        return this.c.defaultThemeStyle;
      },
      // 
      c() {
        return this.zConfig || {};
      },
      // 
      ownLoadingMoreText() {
        const statusTextArr = [this.c.defaultText, this.c.loadingText, this.c.noMoreText, this.c.failText];
        return statusTextArr[this.finalStatus];
      },
      // 
      finalStatus() {
        if (this.c.defaultAsLoading && this.c.status === this.M.Default)
          return this.M.Loading;
        return this.c.status;
      },
      // icon
      finalLoadingIconType() {
        return this.c.loadingIconType;
      }
    },
    methods: {
      // 
      doClick() {
        this.$emit("doClick");
      }
    }
  };
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["zp-l-container", { "zp-l-container-rpx": $options.c.unit === "rpx", "zp-l-container-px": $options.c.unit === "px" }]),
        style: vue.normalizeStyle([$options.c.customStyle]),
        onClick: _cache[0] || (_cache[0] = (...args) => $options.doClick && $options.doClick(...args))
      },
      [
        !$options.c.hideContent ? (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          { key: 0 },
          [
            vue.createCommentVNode("  "),
            $options.c.showNoMoreLine && $options.finalStatus === $data.M.NoMore ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 0,
                class: vue.normalizeClass({ "zp-l-line-rpx": $options.c.unit === "rpx", "zp-l-line-px": $options.c.unit === "px" }),
                style: vue.normalizeStyle([{ backgroundColor: $data.zTheme.line[$options.ts] }, $options.c.noMoreLineCustomStyle])
              },
              null,
              6
              /* CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode(" loading "),
            $options.finalStatus === $data.M.Loading && !!$options.c.loadingIconCustomImage ? (vue.openBlock(), vue.createElementBlock("image", {
              key: 1,
              src: $options.c.loadingIconCustomImage,
              style: vue.normalizeStyle([$options.c.iconCustomStyle]),
              class: vue.normalizeClass({ "zp-l-line-loading-custom-image": true, "zp-l-line-loading-custom-image-animated": $options.c.loadingAnimated, "zp-l-line-loading-custom-image-rpx": $options.c.unit === "rpx", "zp-l-line-loading-custom-image-px": $options.c.unit === "px" })
            }, null, 14, ["src"])) : vue.createCommentVNode("v-if", true),
            $options.finalStatus === $data.M.Loading && $options.finalLoadingIconType === "flower" && !$options.c.loadingIconCustomImage.length ? (vue.openBlock(), vue.createElementBlock("image", {
              key: 2,
              class: vue.normalizeClass({ "zp-line-loading-image": true, "zp-line-loading-image-rpx": $options.c.unit === "rpx", "zp-line-loading-image-px": $options.c.unit === "px" }),
              style: vue.normalizeStyle([$options.c.iconCustomStyle]),
              src: $data.zTheme.flower[$options.ts]
            }, null, 14, ["src"])) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode("  "),
            $options.finalStatus === $data.M.Loading && $options.finalLoadingIconType === "circle" && !$options.c.loadingIconCustomImage.length ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 3,
                class: vue.normalizeClass(["zp-l-circle-loading-view", { "zp-l-circle-loading-view-rpx": $options.c.unit === "rpx", "zp-l-circle-loading-view-px": $options.c.unit === "px" }]),
                style: vue.normalizeStyle([{ borderColor: $data.zTheme.circleBorder[$options.ts], borderTopColor: $data.zTheme.circleBorderTop[$options.ts] }, $options.c.iconCustomStyle])
              },
              null,
              6
              /* CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true),
            !$options.c.isChat || !$options.c.chatDefaultAsLoading && $options.finalStatus === $data.M.Default || $options.finalStatus === $data.M.Fail ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 4,
                class: vue.normalizeClass({ "zp-l-text-rpx": $options.c.unit === "rpx", "zp-l-text-px": $options.c.unit === "px" }),
                style: vue.normalizeStyle([{ color: $data.zTheme.title[$options.ts] }, $options.c.titleCustomStyle])
              },
              vue.toDisplayString($options.ownLoadingMoreText),
              7
              /* TEXT, CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode("  "),
            $options.c.showNoMoreLine && $options.finalStatus === $data.M.NoMore ? (vue.openBlock(), vue.createElementBlock(
              "text",
              {
                key: 5,
                class: vue.normalizeClass({ "zp-l-line-rpx": $options.c.unit === "rpx", "zp-l-line-px": $options.c.unit === "px" }),
                style: vue.normalizeStyle([{ backgroundColor: $data.zTheme.line[$options.ts] }, $options.c.noMoreLineCustomStyle])
              },
              null,
              6
              /* CLASS, STYLE */
            )) : vue.createCommentVNode("v-if", true)
          ],
          64
          /* STABLE_FRAGMENT */
        )) : vue.createCommentVNode("v-if", true)
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const zPagingLoadMore = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d], ["__scopeId", "data-v-0a5fd7d6"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/z-paging/components/z-paging/components/z-paging-load-more.vue"]]);
  const commonLayoutModule = {
    data() {
      return {
        systemInfo: null,
        cssSafeAreaInsetBottom: -1,
        isReadyDestroy: false
      };
    },
    computed: {
      // 
      windowTop() {
        if (!this.systemInfo)
          return 0;
        return this.systemInfo.windowTop || 0;
      },
      // 
      safeAreaBottom() {
        if (!this.systemInfo)
          return 0;
        let safeAreaBottom = 0;
        safeAreaBottom = this.systemInfo.safeAreaInsets.bottom || 0;
        return safeAreaBottom;
      },
      // webviewwebview
      isOldWebView() {
        try {
          const systemInfos = uni.getSystemInfoSync().system.split(" ");
          const deviceType = systemInfos[0];
          const version2 = parseInt(systemInfos[1]);
          if (deviceType === "iOS" && version2 <= 10 || deviceType === "Android" && version2 <= 6) {
            return true;
          }
        } catch (e2) {
          return false;
        }
        return false;
      },
      // $slots
      zSlots() {
        return this.$slots;
      }
    },
    beforeDestroy() {
      this.isReadyDestroy = true;
    },
    unmounted() {
      this.isReadyDestroy = true;
    },
    methods: {
      // fixedz-paging
      updateFixedLayout() {
        this.fixed && this.$nextTick(() => {
          this.systemInfo = uni.getSystemInfoSync();
        });
      },
      // 
      _getNodeClientRect(select, inDom = true, scrollOffset = false) {
        if (this.isReadyDestroy) {
          return Promise.resolve(false);
        }
        let res = !!inDom ? uni.createSelectorQuery().in(inDom === true ? this : inDom) : uni.createSelectorQuery();
        scrollOffset ? res.select(select).scrollOffset() : res.select(select).boundingClientRect();
        return new Promise((resolve, reject) => {
          res.exec((data) => {
            resolve(data && data != "" && data != void 0 && data.length ? data : false);
          });
        });
      },
      // slot="left"slot="right"
      _updateLeftAndRightWidth(targetStyle, parentNodePrefix) {
        this.$nextTick(() => {
          let delayTime = 0;
          setTimeout(() => {
            ["left", "right"].map((position) => {
              this._getNodeClientRect(`.${parentNodePrefix}-${position}`).then((res) => {
                this.$set(targetStyle, position, res ? res[0].width + "px" : "0px");
              });
            });
          }, delayTime);
        });
      },
      // cssviewbottomsystemInfo
      _getCssSafeAreaInsetBottom(success) {
        this._getNodeClientRect(".zp-safe-area-inset-bottom").then((res) => {
          this.cssSafeAreaInsetBottom = res ? res[0].height : -1;
          res && success && success();
        });
      }
    }
  };
  const queryKey = "Query";
  const fetchParamsKey = "FetchParams";
  const fetchResultKey = "FetchResult";
  const language2LocalKey = "Language2Local";
  function handleQuery(callback) {
    _addHandleByKey(queryKey, callback);
    return this;
  }
  function _handleQuery(pageNo, pageSize, from, lastItem) {
    const callback = _getHandleByKey(queryKey);
    return callback ? callback(pageNo, pageSize, from, lastItem) : [pageNo, pageSize, from];
  }
  function handleFetchParams(callback) {
    _addHandleByKey(fetchParamsKey, callback);
    return this;
  }
  function _handleFetchParams(parmas, extraParams) {
    const callback = _getHandleByKey(fetchParamsKey);
    return callback ? callback(parmas, extraParams || {}) : { pageNo: parmas.pageNo, pageSize: parmas.pageSize, ...extraParams || {} };
  }
  function handleFetchResult(callback) {
    _addHandleByKey(fetchResultKey, callback);
    return this;
  }
  function _handleFetchResult(result, paging, params) {
    const callback = _getHandleByKey(fetchResultKey);
    callback && callback(result, paging, params);
    return callback ? true : false;
  }
  function handleLanguage2Local(callback) {
    _addHandleByKey(language2LocalKey, callback);
    return this;
  }
  function _handleLanguage2Local(language2, local) {
    const callback = _getHandleByKey(language2LocalKey);
    return callback ? callback(language2, local) : local;
  }
  function _getApp() {
    return getApp();
  }
  function _hasGlobalData() {
    return _getApp() && _getApp().globalData;
  }
  function _addHandleByKey(key, callback) {
    try {
      setTimeout(function() {
        if (_hasGlobalData()) {
          _getApp().globalData[`zp_handle${key}Callback`] = callback;
        }
      }, 1);
    } catch (_) {
    }
  }
  function _getHandleByKey(key) {
    return _hasGlobalData() ? _getApp().globalData[`zp_handle${key}Callback`] : null;
  }
  const interceptor = {
    handleQuery,
    _handleQuery,
    handleFetchParams,
    _handleFetchParams,
    handleFetchResult,
    _handleFetchResult,
    handleLanguage2Local,
    _handleLanguage2Local
  };
  const dataHandleModule = {
    props: {
      // pageNo1
      defaultPageNo: {
        type: [Number, String],
        default: u$1.gc("defaultPageNo", 1),
        observer: function(newVal) {
          this.pageNo = newVal;
        }
      },
      // pageSize10
      defaultPageSize: {
        type: [Number, String],
        default: u$1.gc("defaultPageSize", 10),
        validator: (value) => {
          if (value <= 0)
            u$1.consoleErr("default-page-size0");
          return value > 0;
        }
      },
      // tabkeycompletekeycomplete
      dataKey: {
        type: [Number, String, Object],
        default: u$1.gc("dataKey", null)
      },
      // tabtab
      useCache: {
        type: Boolean,
        default: u$1.gc("useCache", false)
      },
      // keyuseCachetrue
      cacheKey: {
        type: String,
        default: u$1.gc("cacheKey", null)
      },
      // always(reload)
      cacheMode: {
        type: String,
        default: u$1.gc("cacheMode", Enum.CacheMode.Default)
      },
      // listview(ref="paging")namelist
      autowireListName: {
        type: String,
        default: u$1.gc("autowireListName", "")
      },
      // queryview(ref="paging")query
      autowireQueryName: {
        type: String,
        default: u$1.gc("autowireQueryName", "")
      },
      // Function@queryfetch@query
      fetch: {
        type: Function,
        default: null
      },
      // fetchfetch
      fetchParams: {
        type: Object,
        default: u$1.gc("fetchParams", null)
      },
      // z-paging mountedreload(mounted)
      auto: {
        type: Boolean,
        default: u$1.gc("auto", true)
      },
      // reload
      reloadWhenRefresh: {
        type: Boolean,
        default: u$1.gc("reloadWhenRefresh", true)
      },
      // reload
      autoScrollToTopWhenReload: {
        type: Boolean,
        default: u$1.gc("autoScrollToTopWhenReload", true)
      },
      // reloadlistreload
      autoCleanListWhenReload: {
        type: Boolean,
        default: u$1.gc("autoCleanListWhenReload", true)
      },
      // view
      showRefresherWhenReload: {
        type: Boolean,
        default: u$1.gc("showRefresherWhenReload", false)
      },
      // view
      showLoadingMoreWhenReload: {
        type: Boolean,
        default: u$1.gc("showLoadingMoreWhenReload", false)
      },
      // createdreload(loading)autotruemounted+nextTickreload
      createdReload: {
        type: Boolean,
        default: u$1.gc("createdReload", false)
      },
      // 200
      localPagingLoadingTime: {
        type: [Number, String],
        default: u$1.gc("localPagingLoadingTime", 200)
      },
      // complete()
      concat: {
        type: Boolean,
        default: u$1.gc("concat", true)
      },
      // reject
      callNetworkReject: {
        type: Boolean,
        default: u$1.gc("callNetworkReject", true)
      },
      // v-modellist
      value: {
        type: Array,
        default: function() {
          return [];
        }
      },
      modelValue: {
        type: Array,
        default: function() {
          return [];
        }
      }
    },
    data() {
      return {
        currentData: [],
        totalData: [],
        realTotalData: [],
        totalLocalPagingList: [],
        dataPromiseResultMap: {
          reload: null,
          complete: null,
          localPaging: null
        },
        isSettingCacheList: false,
        pageNo: 1,
        currentRefreshPageSize: 0,
        isLocalPaging: false,
        isAddedData: false,
        isTotalChangeFromAddData: false,
        privateConcat: true,
        myParentQuery: -1,
        firstPageLoaded: false,
        pagingLoaded: false,
        loaded: false,
        isUserReload: true,
        fromEmptyViewReload: false,
        queryFrom: "",
        listRendering: false,
        isHandlingRefreshToPage: false,
        isFirstPageAndNoMore: false,
        totalDataChangeThrow: true
      };
    },
    computed: {
      pageSize() {
        return this.defaultPageSize;
      },
      finalConcat() {
        return this.concat && this.privateConcat;
      },
      finalUseCache() {
        if (this.useCache && !this.cacheKey) {
          u$1.consoleErr("use-cachetruecache-key");
        }
        return this.useCache && !!this.cacheKey;
      },
      finalCacheKey() {
        return this.cacheKey ? `${c$1.cachePrefixKey}-${this.cacheKey}` : null;
      },
      isFirstPage() {
        return this.pageNo === this.defaultPageNo;
      }
    },
    watch: {
      totalData(newVal, oldVal) {
        this._totalDataChange(newVal, oldVal, this.totalDataChangeThrow);
        this.totalDataChangeThrow = true;
      },
      currentData(newVal, oldVal) {
        this._currentDataChange(newVal, oldVal);
      },
      useChatRecordMode(newVal, oldVal) {
        if (newVal) {
          this.nLoadingMoreFixedHeight = false;
        }
      },
      value: {
        handler(newVal) {
          if (newVal !== this.totalData) {
            this.totalDataChangeThrow = false;
            this.totalData = newVal;
          }
        },
        immediate: true
      },
      modelValue: {
        handler(newVal) {
          if (newVal !== this.totalData) {
            this.totalDataChangeThrow = false;
            this.totalData = newVal;
          }
        },
        immediate: true
      }
    },
    methods: {
      // ()z-paging(
      complete(data, success = true) {
        this.customNoMore = -1;
        return this.addData(data, success);
      },
      //()z-pagingdataKey:data-key(
      completeByKey(data, dataKey = null, success = true) {
        if (dataKey !== null && this.dataKey !== null && dataKey !== this.dataKey) {
          this.isFirstPage && this.endRefresh();
          return new Promise((resolve) => resolve());
        }
        this.customNoMore = -1;
        return this.addData(data, success);
      },
      //total()z-pagingtotal()(
      completeByTotal(data, total, success = true) {
        if (total == "undefined") {
          this.customNoMore = -1;
        } else {
          const dataTypeRes = this._checkDataType(data, success, false);
          data = dataTypeRes.data;
          success = dataTypeRes.success;
          if (total >= 0 && success) {
            return new Promise((resolve, reject) => {
              this.$nextTick(() => {
                let nomore = false;
                const realTotalDataCount = this.pageNo == this.defaultPageNo ? 0 : this.realTotalData.length;
                const dataLength = this.privateConcat ? data.length : 0;
                let exceedCount = realTotalDataCount + dataLength - total;
                if (exceedCount >= 0) {
                  nomore = true;
                  exceedCount = this.defaultPageSize - exceedCount;
                  if (this.privateConcat && exceedCount > 0 && exceedCount < data.length) {
                    data = data.splice(0, exceedCount);
                  }
                }
                this.completeByNoMore(data, nomore, success).then((res) => resolve(res)).catch(() => reject());
              });
            });
          }
        }
        return this.addData(data, success);
      },
      //()z-paging(
      completeByNoMore(data, nomore, success = true) {
        if (nomore != "undefined") {
          this.customNoMore = nomore == true ? 1 : 0;
        }
        return this.addData(data, success);
      },
      // 
      completeByError(errorMsg) {
        this.customerEmptyViewErrorText = errorMsg;
        return this.complete(false);
      },
      // completecomplete
      addData(data, success = true) {
        if (!this.fromCompleteEmit) {
          this.disabledCompleteEmit = true;
          this.fromCompleteEmit = false;
        }
        const currentTimeStamp = u$1.getTime();
        const disTime = currentTimeStamp - this.requestTimeStamp;
        let minDelay = this.minDelay;
        if (this.isFirstPage && this.finalShowRefresherWhenReload) {
          minDelay = Math.max(400, minDelay);
        }
        const addDataDalay = this.requestTimeStamp > 0 && disTime < minDelay ? minDelay - disTime : 0;
        this.$nextTick(() => {
          u$1.delay(() => {
            this._addData(data, success, false);
          }, this.delay > 0 ? this.delay : addDataDalay);
        });
        return new Promise((resolve, reject) => {
          this.dataPromiseResultMap.complete = { resolve, reject };
        });
      },
      // pageNopageSize
      addDataFromTop(data, toTop = true, toTopWithAnimate = true) {
        let addFromTop = !this.isChatRecordModeAndNotInversion;
        data = Object.prototype.toString.call(data) !== "[object Array]" ? [data] : addFromTop ? data.reverse() : data;
        this.finalUseVirtualList && this._setCellIndex(data, "top");
        this.totalData = addFromTop ? [...data, ...this.totalData] : [...this.totalData, ...data];
        if (toTop) {
          u$1.delay(() => this.useChatRecordMode ? this.scrollToBottom(toTopWithAnimate) : this.scrollToTop(toTopWithAnimate));
        }
      },
      // pageNopageSizez-paging(page:list.sync)
      resetTotalData(data) {
        this.isTotalChangeFromAddData = true;
        data = Object.prototype.toString.call(data) !== "[object Array]" ? [data] : data;
        this.totalData = data;
      },
      // ()z-paging@query
      setLocalPaging(data, success = true) {
        this.isLocalPaging = true;
        this.$nextTick(() => {
          this._addData(data, success, true);
        });
        return new Promise((resolve, reject) => {
          this.dataPromiseResultMap.localPaging = { resolve, reject };
        });
      },
      // pageNo(animatetruefalse)
      reload(animate = this.showRefresherWhenReload) {
        if (animate) {
          this.privateShowRefresherWhenReload = animate;
          this.isUserPullDown = true;
        }
        if (!this.showLoadingMoreWhenReload) {
          this.listRendering = true;
        }
        this.$nextTick(() => {
          this._preReload(animate, false);
        });
        return new Promise((resolve, reject) => {
          this.dataPromiseResultMap.reload = { resolve, reject };
        });
      },
      // pageNopageSize@querypageNopageSize
      refresh() {
        return this._handleRefreshWithDisPageNo(this.pageNo - this.defaultPageNo + 1);
      },
      // pageNo=55pageNo55@querypageNopageSize
      refreshToPage(pageNo) {
        this.isHandlingRefreshToPage = true;
        return this._handleRefreshWithDisPageNo(pageNo + this.defaultPageNo - 1);
      },
      // v-modellistpageSizelist
      updateCache() {
        if (this.finalUseCache && this.totalData.length) {
          this._saveLocalCache(this.totalData.slice(0, Math.min(this.totalData.length, this.pageSize)));
        }
      },
      // 
      clean() {
        this._reload(true);
        this._addData([], true, false);
      },
      // 
      clear() {
        this.clean();
      },
      // reload
      _preReload(animate = this.showRefresherWhenReload, isFromMounted = true, retryCount = 0) {
        const showRefresher = this.finalRefresherEnabled && this.useCustomRefresher;
        if (this.customRefresherHeight === -1 && showRefresher) {
          u$1.delay(() => {
            retryCount++;
            if (retryCount % 10 === 0) {
              this._updateCustomRefresherHeight();
            }
            this._preReload(animate, isFromMounted, retryCount);
          }, c$1.delayTime / 2);
          return;
        }
        this.isUserReload = true;
        this.loadingType = Enum.LoadingType.Refresher;
        if (animate) {
          this.privateShowRefresherWhenReload = animate;
          if (this.useCustomRefresher) {
            this._doRefresherRefreshAnimate();
          } else {
            this.refresherTriggered = true;
          }
        } else {
          this._refresherEnd(false, false, false, false);
        }
        this._reload(false, isFromMounted);
      },
      // 
      _reload(isClean = false, isFromMounted = false, isUserPullDown = false) {
        this.isAddedData = false;
        this.insideOfPaging = -1;
        this.cacheScrollNodeHeight = -1;
        this.pageNo = this.defaultPageNo;
        this._cleanRefresherEndTimeout();
        !this.privateShowRefresherWhenReload && !isClean && this._startLoading(true);
        this.firstPageLoaded = true;
        this.isTotalChangeFromAddData = false;
        if (!this.isSettingCacheList) {
          this.totalData = [];
        }
        if (!isClean) {
          this._emitQuery(this.pageNo, this.defaultPageSize, isUserPullDown ? Enum.QueryFrom.UserPullDown : Enum.QueryFrom.Reload);
          let delay2 = 0;
          u$1.delay(this._callMyParentQuery, delay2);
          if (!isFromMounted && this.autoScrollToTopWhenReload) {
            this._scrollToTop(false);
          }
        }
      },
      // 
      _addData(data, success, isLocal) {
        this.isAddedData = true;
        this.fromEmptyViewReload = false;
        this.isTotalChangeFromAddData = true;
        this.refresherTriggered = false;
        this._endSystemLoadingAndRefresh();
        const tempIsUserPullDown = this.isUserPullDown;
        if (this.showRefresherUpdateTime && this.isFirstPage) {
          u$1.setRefesrherTime(u$1.getTime(), this.refresherUpdateTimeKey);
          this.$refs.refresh && this.$refs.refresh.updateTime();
        }
        if (!isLocal && tempIsUserPullDown && this.isFirstPage) {
          this.isUserPullDown = false;
        }
        if (!this.isFirstPage) {
          this.listRendering = true;
          this.$nextTick(() => {
            u$1.delay(() => this.listRendering = false);
          });
        } else {
          this.listRendering = false;
        }
        let dataTypeRes = this._checkDataType(data, success, isLocal);
        data = dataTypeRes.data;
        success = dataTypeRes.success;
        let delayTime = c$1.delayTime;
        if (this.useChatRecordMode)
          delayTime = 0;
        this.loadingForNow = false;
        u$1.delay(() => {
          this.pagingLoaded = true;
          this.$nextTick(() => {
            !isLocal && this._refresherEnd(delayTime > 0, true, tempIsUserPullDown);
          });
        });
        if (this.isFirstPage) {
          this.isLoadFailed = !success;
          this.$emit("isLoadFailedChange", this.isLoadFailed);
          if (this.finalUseCache && success && (this.cacheMode === Enum.CacheMode.Always ? true : this.isSettingCacheList)) {
            this._saveLocalCache(data);
          }
        }
        this.isSettingCacheList = false;
        if (success) {
          if (!(this.privateConcat === false && !this.isHandlingRefreshToPage && this.loadingStatus === Enum.More.NoMore)) {
            this.loadingStatus = Enum.More.Default;
          }
          if (isLocal) {
            this.totalLocalPagingList = data;
            const localPageNo = this.defaultPageNo;
            const localPageSize = this.queryFrom !== Enum.QueryFrom.Refresh ? this.defaultPageSize : this.currentRefreshPageSize;
            this._localPagingQueryList(localPageNo, localPageSize, 0, (res) => {
              u$1.delay(() => {
                this.completeByTotal(res, this.totalLocalPagingList.length);
              }, 0);
            });
          } else {
            let dataChangeDelayTime = 0;
            u$1.delay(() => {
              this._currentDataChange(data, this.currentData);
              this._callDataPromise(true, this.totalData);
            }, dataChangeDelayTime);
          }
          if (this.isHandlingRefreshToPage) {
            this.isHandlingRefreshToPage = false;
            this.pageNo = this.defaultPageNo + Math.ceil(data.length / this.pageSize) - 1;
            if (data.length % this.pageSize !== 0) {
              this.customNoMore = 1;
            }
          }
        } else {
          this._currentDataChange(data, this.currentData);
          this._callDataPromise(false);
          this.loadingStatus = Enum.More.Fail;
          this.isHandlingRefreshToPage = false;
          if (this.loadingType === Enum.LoadingType.LoadingMore) {
            this.pageNo--;
          }
        }
      },
      // 
      _totalDataChange(newVal, oldVal, eventThrow = true) {
        if ((!this.isUserReload || !this.autoCleanListWhenReload) && this.firstPageLoaded && !newVal.length && oldVal.length) {
          return;
        }
        this._doCheckScrollViewShouldFullHeight(newVal);
        if (!this.realTotalData.length && !newVal.length) {
          eventThrow = false;
        }
        this.realTotalData = newVal;
        if (eventThrow) {
          this.$emit("input", newVal);
          this.$emit("update:modelValue", newVal);
          this.$emit("update:list", newVal);
          this.$emit("listChange", newVal);
          this._callMyParentList(newVal);
        }
        this.firstPageLoaded = false;
        this.isTotalChangeFromAddData = false;
        this.$nextTick(() => {
          u$1.delay(() => {
            this._getNodeClientRect(".zp-paging-container-content").then((res) => {
              res && this.$emit("contentHeightChanged", res[0].height);
            });
          }, c$1.delayTime * (this.isIos ? 1 : 3));
        });
      },
      // 
      _currentDataChange(newVal, oldVal) {
        newVal = [...newVal];
        this.finalUseVirtualList && this._setCellIndex(newVal, "bottom");
        if (this.isFirstPage && this.finalConcat) {
          this.totalData = [];
        }
        if (this.customNoMore !== -1) {
          if (this.customNoMore === 1 || this.customNoMore !== 0 && !newVal.length) {
            this.loadingStatus = Enum.More.NoMore;
          }
        } else {
          if (!newVal.length || newVal.length && newVal.length < this.defaultPageSize) {
            this.loadingStatus = Enum.More.NoMore;
          }
        }
        if (!this.totalData.length) {
          this.totalData = newVal;
        } else {
          if (this.finalConcat) {
            this.oldScrollTop;
            this.totalData = [...this.totalData, ...newVal];
          } else {
            this.totalData = newVal;
          }
        }
        this.privateConcat = true;
      },
      // pageNorefresh
      _handleRefreshWithDisPageNo(pageNo) {
        if (!this.isHandlingRefreshToPage && !this.realTotalData.length)
          return this.reload();
        if (pageNo >= 1) {
          this.loading = true;
          this.privateConcat = false;
          const totalPageSize = pageNo * this.pageSize;
          this.currentRefreshPageSize = totalPageSize;
          if (this.isLocalPaging && this.isHandlingRefreshToPage) {
            this._localPagingQueryList(this.defaultPageNo, totalPageSize, 0, (res) => {
              this.complete(res);
            });
          } else {
            this._emitQuery(this.defaultPageNo, totalPageSize, Enum.QueryFrom.Refresh);
            this._callMyParentQuery(this.defaultPageNo, totalPageSize);
          }
        }
        return new Promise((resolve, reject) => {
          this.dataPromiseResultMap.reload = { resolve, reject };
        });
      },
      // 
      _localPagingQueryList(pageNo, pageSize, localPagingLoadingTime, callback) {
        pageNo = Math.max(1, pageNo);
        pageSize = Math.max(1, pageSize);
        const totalPagingList = [...this.totalLocalPagingList];
        const pageNoIndex = (pageNo - 1) * pageSize;
        const finalPageNoIndex = Math.min(totalPagingList.length, pageNoIndex + pageSize);
        const resultPagingList = totalPagingList.splice(pageNoIndex, finalPageNoIndex - pageNoIndex);
        u$1.delay(() => callback(resultPagingList), localPagingLoadingTime);
      },
      // 
      _saveLocalCache(data) {
        uni.setStorageSync(this.finalCacheKey, data);
      },
      // 
      _setListByLocalCache() {
        this.totalData = uni.getStorageSync(this.finalCacheKey) || [];
        this.isSettingCacheList = true;
      },
      // viewlist
      _callMyParentList(newVal) {
        if (this.autowireListName.length) {
          const myParent = u$1.getParent(this.$parent);
          if (myParent && myParent[this.autowireListName]) {
            myParent[this.autowireListName] = newVal;
          }
        }
      },
      // viewquery
      _callMyParentQuery(customPageNo = 0, customPageSize = 0) {
        if (this.autowireQueryName) {
          if (this.myParentQuery === -1) {
            const myParent = u$1.getParent(this.$parent);
            if (myParent && myParent[this.autowireQueryName]) {
              this.myParentQuery = myParent[this.autowireQueryName];
            }
          }
          if (this.myParentQuery !== -1) {
            customPageSize > 0 ? this.myParentQuery(customPageNo, customPageSize) : this.myParentQuery(this.pageNo, this.defaultPageSize);
          }
        }
      },
      // emit query
      _emitQuery(pageNo, pageSize, from) {
        this.queryFrom = from;
        this.requestTimeStamp = u$1.getTime();
        const [lastItem] = this.realTotalData.slice(-1);
        if (this.fetch) {
          const fetchParams = interceptor._handleFetchParams({ pageNo, pageSize, from, lastItem: lastItem || null }, this.fetchParams);
          const fetchResult = this.fetch(fetchParams);
          if (!interceptor._handleFetchResult(fetchResult, this, fetchParams)) {
            u$1.isPromise(fetchResult) ? fetchResult.then((res) => {
              this.complete(res);
            }).catch((err) => {
              this.complete(false);
            }) : this.complete(fetchResult);
          }
        } else {
          this.$emit("query", ...interceptor._handleQuery(pageNo, pageSize, from, lastItem || null));
        }
      },
      // promise
      _callDataPromise(success, totalList) {
        for (const key in this.dataPromiseResultMap) {
          const obj = this.dataPromiseResultMap[key];
          if (!obj)
            continue;
          success ? obj.resolve({ totalList, noMore: this.loadingStatus === Enum.More.NoMore }) : this.callNetworkReject && obj.reject(`z-paging-${key}-error`);
        }
      },
      // complete data
      _checkDataType(data, success, isLocal) {
        const dataType = Object.prototype.toString.call(data);
        if (dataType === "[object Boolean]") {
          success = data;
          data = [];
        } else if (dataType !== "[object Array]") {
          data = [];
          if (dataType !== "[object Undefined]" && dataType !== "[object Null]") {
            u$1.consoleErr(`${isLocal ? "setLocalPaging" : "complete"}Array!`);
          }
        }
        return { data, success };
      }
    }
  };
  const isObject = (val) => val !== null && typeof val === "object";
  const defaultDelimiters = ["{", "}"];
  class BaseFormatter {
    constructor() {
      this._caches = /* @__PURE__ */ Object.create(null);
    }
    interpolate(message, values, delimiters = defaultDelimiters) {
      if (!values) {
        return [message];
      }
      let tokens = this._caches[message];
      if (!tokens) {
        tokens = parse(message, delimiters);
        this._caches[message] = tokens;
      }
      return compile(tokens, values);
    }
  }
  const RE_TOKEN_LIST_VALUE = /^(?:\d)+/;
  const RE_TOKEN_NAMED_VALUE = /^(?:\w)+/;
  function parse(format2, [startDelimiter, endDelimiter]) {
    const tokens = [];
    let position = 0;
    let text = "";
    while (position < format2.length) {
      let char = format2[position++];
      if (char === startDelimiter) {
        if (text) {
          tokens.push({ type: "text", value: text });
        }
        text = "";
        let sub = "";
        char = format2[position++];
        while (char !== void 0 && char !== endDelimiter) {
          sub += char;
          char = format2[position++];
        }
        const isClosed = char === endDelimiter;
        const type = RE_TOKEN_LIST_VALUE.test(sub) ? "list" : isClosed && RE_TOKEN_NAMED_VALUE.test(sub) ? "named" : "unknown";
        tokens.push({ value: sub, type });
      } else {
        text += char;
      }
    }
    text && tokens.push({ type: "text", value: text });
    return tokens;
  }
  function compile(tokens, values) {
    const compiled = [];
    let index2 = 0;
    const mode = Array.isArray(values) ? "list" : isObject(values) ? "named" : "unknown";
    if (mode === "unknown") {
      return compiled;
    }
    while (index2 < tokens.length) {
      const token = tokens[index2];
      switch (token.type) {
        case "text":
          compiled.push(token.value);
          break;
        case "list":
          compiled.push(values[parseInt(token.value, 10)]);
          break;
        case "named":
          if (mode === "named") {
            compiled.push(values[token.value]);
          } else {
            {
              console.warn(`Type of token '${token.type}' and format of value '${mode}' don't match!`);
            }
          }
          break;
        case "unknown":
          {
            console.warn(`Detect 'unknown' type of token!`);
          }
          break;
      }
      index2++;
    }
    return compiled;
  }
  const LOCALE_ZH_HANS = "zh-Hans";
  const LOCALE_ZH_HANT = "zh-Hant";
  const LOCALE_EN = "en";
  const LOCALE_FR = "fr";
  const LOCALE_ES = "es";
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty.call(val, key);
  const defaultFormatter = new BaseFormatter();
  function include(str, parts) {
    return !!parts.find((part) => str.indexOf(part) !== -1);
  }
  function startsWith(str, parts) {
    return parts.find((part) => str.indexOf(part) === 0);
  }
  function normalizeLocale(locale, messages2) {
    if (!locale) {
      return;
    }
    locale = locale.trim().replace(/_/g, "-");
    if (messages2 && messages2[locale]) {
      return locale;
    }
    locale = locale.toLowerCase();
    if (locale === "chinese") {
      return LOCALE_ZH_HANS;
    }
    if (locale.indexOf("zh") === 0) {
      if (locale.indexOf("-hans") > -1) {
        return LOCALE_ZH_HANS;
      }
      if (locale.indexOf("-hant") > -1) {
        return LOCALE_ZH_HANT;
      }
      if (include(locale, ["-tw", "-hk", "-mo", "-cht"])) {
        return LOCALE_ZH_HANT;
      }
      return LOCALE_ZH_HANS;
    }
    let locales = [LOCALE_EN, LOCALE_FR, LOCALE_ES];
    if (messages2 && Object.keys(messages2).length > 0) {
      locales = Object.keys(messages2);
    }
    const lang2 = startsWith(locale, locales);
    if (lang2) {
      return lang2;
    }
  }
  class I18n {
    constructor({ locale, fallbackLocale, messages: messages2, watcher, formater: formater2 }) {
      this.locale = LOCALE_EN;
      this.fallbackLocale = LOCALE_EN;
      this.message = {};
      this.messages = {};
      this.watchers = [];
      if (fallbackLocale) {
        this.fallbackLocale = fallbackLocale;
      }
      this.formater = formater2 || defaultFormatter;
      this.messages = messages2 || {};
      this.setLocale(locale || LOCALE_EN);
      if (watcher) {
        this.watchLocale(watcher);
      }
    }
    setLocale(locale) {
      const oldLocale = this.locale;
      this.locale = normalizeLocale(locale, this.messages) || this.fallbackLocale;
      if (!this.messages[this.locale]) {
        this.messages[this.locale] = {};
      }
      this.message = this.messages[this.locale];
      if (oldLocale !== this.locale) {
        this.watchers.forEach((watcher) => {
          watcher(this.locale, oldLocale);
        });
      }
    }
    getLocale() {
      return this.locale;
    }
    watchLocale(fn) {
      const index2 = this.watchers.push(fn) - 1;
      return () => {
        this.watchers.splice(index2, 1);
      };
    }
    add(locale, message, override = true) {
      const curMessages = this.messages[locale];
      if (curMessages) {
        if (override) {
          Object.assign(curMessages, message);
        } else {
          Object.keys(message).forEach((key) => {
            if (!hasOwn(curMessages, key)) {
              curMessages[key] = message[key];
            }
          });
        }
      } else {
        this.messages[locale] = message;
      }
    }
    f(message, values, delimiters) {
      return this.formater.interpolate(message, values, delimiters).join("");
    }
    t(key, locale, values) {
      let message = this.message;
      if (typeof locale === "string") {
        locale = normalizeLocale(locale, this.messages);
        locale && (message = this.messages[locale]);
      } else {
        values = locale;
      }
      if (!hasOwn(message, key)) {
        console.warn(`Cannot translate the value of keypath ${key}. Use the value of keypath as default.`);
        return key;
      }
      return this.formater.interpolate(message[key], values).join("");
    }
  }
  function watchAppLocale(appVm, i18n2) {
    if (appVm.$watchLocale) {
      appVm.$watchLocale((newLocale) => {
        i18n2.setLocale(newLocale);
      });
    } else {
      appVm.$watch(() => appVm.$locale, (newLocale) => {
        i18n2.setLocale(newLocale);
      });
    }
  }
  function getDefaultLocale() {
    if (typeof uni !== "undefined" && uni.getLocale) {
      return uni.getLocale();
    }
    if (typeof global !== "undefined" && global.getLocale) {
      return global.getLocale();
    }
    return LOCALE_EN;
  }
  function initVueI18n(locale, messages2 = {}, fallbackLocale, watcher) {
    if (typeof locale !== "string") {
      const options = [
        messages2,
        locale
      ];
      locale = options[0];
      messages2 = options[1];
    }
    if (typeof locale !== "string") {
      locale = getDefaultLocale();
    }
    if (typeof fallbackLocale !== "string") {
      fallbackLocale = typeof __uniConfig !== "undefined" && __uniConfig.fallbackLocale || LOCALE_EN;
    }
    const i18n2 = new I18n({
      locale,
      fallbackLocale,
      messages: messages2,
      watcher
    });
    let t2 = (key, values) => {
      if (typeof getApp !== "function") {
        t2 = function(key2, values2) {
          return i18n2.t(key2, values2);
        };
      } else {
        let isWatchedAppLocale = false;
        t2 = function(key2, values2) {
          const appVm = getApp().$vm;
          if (appVm) {
            appVm.$locale;
            if (!isWatchedAppLocale) {
              isWatchedAppLocale = true;
              watchAppLocale(appVm, i18n2);
            }
          }
          return i18n2.t(key2, values2);
        };
      }
      return t2(key, values);
    };
    return {
      i18n: i18n2,
      f(message, values, delimiters) {
        return i18n2.f(message, values, delimiters);
      },
      t(key, values) {
        return t2(key, values);
      },
      add(locale2, message, override = true) {
        return i18n2.add(locale2, message, override);
      },
      watch(fn) {
        return i18n2.watchLocale(fn);
      },
      getLocale() {
        return i18n2.getLocale();
      },
      setLocale(newLocale) {
        return i18n2.setLocale(newLocale);
      }
    };
  }
  const en$1 = {
    "zp.refresher.default": "Pull down to refresh",
    "zp.refresher.pulling": "Release to refresh",
    "zp.refresher.refreshing": "Refreshing...",
    "zp.refresher.complete": "Refresh succeeded",
    "zp.refresher.f2": "Refresh to enter 2f",
    "zp.loadingMore.default": "Click to load more",
    "zp.loadingMore.loading": "Loading...",
    "zp.loadingMore.noMore": "No more data",
    "zp.loadingMore.fail": "Load failed,click to reload",
    "zp.emptyView.title": "No data",
    "zp.emptyView.reload": "Reload",
    "zp.emptyView.error": "Sorry,load failed",
    "zp.refresherUpdateTime.title": "Last update: ",
    "zp.refresherUpdateTime.none": "None",
    "zp.refresherUpdateTime.today": "Today",
    "zp.refresherUpdateTime.yesterday": "Yesterday",
    "zp.systemLoading.title": "Loading..."
  };
  const zhHans = {
    "zp.refresher.default": "",
    "zp.refresher.pulling": "",
    "zp.refresher.refreshing": "...",
    "zp.refresher.complete": "",
    "zp.refresher.f2": "",
    "zp.loadingMore.default": "",
    "zp.loadingMore.loading": "...",
    "zp.loadingMore.noMore": "",
    "zp.loadingMore.fail": "",
    "zp.emptyView.title": "~",
    "zp.emptyView.reload": "",
    "zp.emptyView.error": "",
    "zp.refresherUpdateTime.title": "",
    "zp.refresherUpdateTime.none": "",
    "zp.refresherUpdateTime.today": "",
    "zp.refresherUpdateTime.yesterday": "",
    "zp.systemLoading.title": "..."
  };
  const zhHant = {
    "zp.refresher.default": "",
    "zp.refresher.pulling": "",
    "zp.refresher.refreshing": "...",
    "zp.refresher.complete": "",
    "zp.refresher.f2": "",
    "zp.loadingMore.default": "",
    "zp.loadingMore.loading": "...",
    "zp.loadingMore.noMore": "",
    "zp.loadingMore.fail": "",
    "zp.emptyView.title": "~",
    "zp.emptyView.reload": "",
    "zp.emptyView.error": "",
    "zp.refresherUpdateTime.title": "",
    "zp.refresherUpdateTime.none": "",
    "zp.refresherUpdateTime.today": "",
    "zp.refresherUpdateTime.yesterday": "",
    "zp.systemLoading.title": "..."
  };
  const messages = {
    en: en$1,
    "zh-Hans": zhHans,
    "zh-Hant": zhHant
  };
  const { t: t$1 } = initVueI18n(messages);
  const language = uni.getSystemInfoSync().language;
  const i18nModule = {
    data() {
      return {
        language
      };
    },
    computed: {
      finalLanguage() {
        try {
          const local = uni.getLocale();
          const language2 = this.language;
          return local === "auto" ? interceptor._handleLanguage2Local(language2, this._language2Local(language2)) : local;
        } catch (e2) {
          return "zh-Hans";
        }
      },
      // 
      finalRefresherDefaultText() {
        return this._getI18nText("zp.refresher.default", this.refresherDefaultText);
      },
      // 
      finalRefresherPullingText() {
        return this._getI18nText("zp.refresher.pulling", this.refresherPullingText);
      },
      // 
      finalRefresherRefreshingText() {
        return this._getI18nText("zp.refresher.refreshing", this.refresherRefreshingText);
      },
      // 
      finalRefresherCompleteText() {
        return this._getI18nText("zp.refresher.complete", this.refresherCompleteText);
      },
      // 
      finalRefresherUpdateTimeTextMap() {
        return {
          title: t$1("zp.refresherUpdateTime.title"),
          none: t$1("zp.refresherUpdateTime.none"),
          today: t$1("zp.refresherUpdateTime.today"),
          yesterday: t$1("zp.refresherUpdateTime.yesterday")
        };
      },
      // 
      finalRefresherGoF2Text() {
        return this._getI18nText("zp.refresher.f2", this.refresherGoF2Text);
      },
      // 
      finalLoadingMoreDefaultText() {
        return this._getI18nText("zp.loadingMore.default", this.loadingMoreDefaultText);
      },
      // 
      finalLoadingMoreLoadingText() {
        return this._getI18nText("zp.loadingMore.loading", this.loadingMoreLoadingText);
      },
      // 
      finalLoadingMoreNoMoreText() {
        return this._getI18nText("zp.loadingMore.noMore", this.loadingMoreNoMoreText);
      },
      // 
      finalLoadingMoreFailText() {
        return this._getI18nText("zp.loadingMore.fail", this.loadingMoreFailText);
      },
      // title
      finalEmptyViewText() {
        return this.isLoadFailed ? this.finalEmptyViewErrorText : this._getI18nText("zp.emptyView.title", this.emptyViewText);
      },
      // reload title
      finalEmptyViewReloadText() {
        return this._getI18nText("zp.emptyView.reload", this.emptyViewReloadText);
      },
      // 
      finalEmptyViewErrorText() {
        return this.customerEmptyViewErrorText || this._getI18nText("zp.emptyView.error", this.emptyViewErrorText);
      },
      // loading title
      finalSystemLoadingText() {
        return this._getI18nText("zp.systemLoading.title", this.systemLoadingText);
      }
    },
    methods: {
      // z-paging
      getLanguage() {
        return this.finalLanguage;
      },
      // 
      _getI18nText(key, value) {
        const dataType = Object.prototype.toString.call(value);
        if (dataType === "[object Object]") {
          const nextValue = value[this.finalLanguage];
          if (nextValue)
            return nextValue;
        } else if (dataType === "[object String]") {
          return value;
        }
        return t$1(key);
      },
      // languagei18n local
      _language2Local(language2) {
        const formatedLanguage = language2.toLowerCase().replace(new RegExp("_", ""), "-");
        if (formatedLanguage.indexOf("zh") !== -1) {
          if (formatedLanguage === "zh" || formatedLanguage === "zh-cn" || formatedLanguage.indexOf("zh-hans") !== -1) {
            return "zh-Hans";
          }
          return "zh-Hant";
        }
        if (formatedLanguage.indexOf("en") !== -1)
          return "en";
        return language2;
      }
    }
  };
  const nvueModule = {
    props: {},
    data() {
      return {
        nRefresherLoading: false,
        nListIsDragging: false,
        nShowBottom: true,
        nFixFreezing: false,
        nShowRefresherReveal: false,
        nLoadingMoreFixedHeight: false,
        nShowRefresherRevealHeight: 0,
        nOldShowRefresherRevealHeight: -1,
        nRefresherWidth: uni.upx2px(750),
        nF2Opacity: 0
      };
    },
    computed: {},
    mounted() {
    },
    methods: {}
  };
  const emptyModule = {
    props: {
      // 
      hideEmptyView: {
        type: Boolean,
        default: u$1.gc("hideEmptyView", false)
      },
      // ~
      emptyViewText: {
        type: [String, Object],
        default: u$1.gc("emptyViewText", null)
      },
      // ()
      showEmptyViewReload: {
        type: Boolean,
        default: u$1.gc("showEmptyViewReload", false)
      },
      // 
      showEmptyViewReloadWhenError: {
        type: Boolean,
        default: u$1.gc("showEmptyViewReloadWhenError", true)
      },
      // 
      emptyViewReloadText: {
        type: [String, Object],
        default: u$1.gc("emptyViewReloadText", null)
      },
      // z-paging
      emptyViewImg: {
        type: String,
        default: u$1.gc("emptyViewImg", "")
      },
      // 
      emptyViewErrorText: {
        type: [String, Object],
        default: u$1.gc("emptyViewErrorText", null)
      },
      // z-paging
      emptyViewErrorImg: {
        type: String,
        default: u$1.gc("emptyViewErrorImg", "")
      },
      // 
      emptyViewStyle: {
        type: Object,
        default: u$1.gc("emptyViewStyle", {})
      },
      // 
      emptyViewSuperStyle: {
        type: Object,
        default: u$1.gc("emptyViewSuperStyle", {})
      },
      // img
      emptyViewImgStyle: {
        type: Object,
        default: u$1.gc("emptyViewImgStyle", {})
      },
      // 
      emptyViewTitleStyle: {
        type: Object,
        default: u$1.gc("emptyViewTitleStyle", {})
      },
      // 
      emptyViewReloadStyle: {
        type: Object,
        default: u$1.gc("emptyViewReloadStyle", {})
      },
      // z-pagingz-paging()z-paging
      emptyViewFixed: {
        type: Boolean,
        default: u$1.gc("emptyViewFixed", false)
      },
      // emptyViewFixedfalse
      emptyViewCenter: {
        type: Boolean,
        default: u$1.gc("emptyViewCenter", true)
      },
      // 
      autoHideEmptyViewWhenLoading: {
        type: Boolean,
        default: u$1.gc("autoHideEmptyViewWhenLoading", true)
      },
      // 
      autoHideEmptyViewWhenPull: {
        type: Boolean,
        default: u$1.gc("autoHideEmptyViewWhenPull", true)
      },
      // viewz-index9
      emptyViewZIndex: {
        type: Number,
        default: u$1.gc("emptyViewZIndex", 9)
      }
    },
    data() {
      return {
        customerEmptyViewErrorText: ""
      };
    },
    computed: {
      finalEmptyViewImg() {
        return this.isLoadFailed ? this.emptyViewErrorImg : this.emptyViewImg;
      },
      finalShowEmptyViewReload() {
        return this.isLoadFailed ? this.showEmptyViewReloadWhenError : this.showEmptyViewReload;
      },
      // 
      showEmpty() {
        if (this.refresherOnly || this.hideEmptyView || this.realTotalData.length)
          return false;
        if (this.autoHideEmptyViewWhenLoading) {
          if (this.isAddedData && !this.firstPageLoaded && !this.loading)
            return true;
        } else {
          return true;
        }
        return !this.autoHideEmptyViewWhenPull && !this.isUserReload;
      }
    },
    methods: {
      // view
      _emptyViewReload() {
        let callbacked = false;
        this.$emit("emptyViewReload", (reload2) => {
          if (reload2 === void 0 || reload2 === true) {
            this.fromEmptyViewReload = true;
            this.reload().catch(() => {
            });
          }
          callbacked = true;
        });
        this.$nextTick(() => {
          if (!callbacked) {
            this.fromEmptyViewReload = true;
            this.reload().catch(() => {
            });
          }
        });
      },
      // view
      _emptyViewClick() {
        this.$emit("emptyViewClick");
      }
    }
  };
  const refresherModule = {
    props: {
      // blackwhiteblack
      refresherThemeStyle: {
        type: String,
        default: u$1.gc("refresherThemeStyle", "")
      },
      // 
      refresherImgStyle: {
        type: Object,
        default: u$1.gc("refresherImgStyle", {})
      },
      // 
      refresherTitleStyle: {
        type: Object,
        default: u$1.gc("refresherTitleStyle", {})
      },
      // (show-refresher-update-timetrue)
      refresherUpdateTimeStyle: {
        type: Object,
        default: u$1.gc("refresherUpdateTimeStyle", {})
      },
      // QQ
      watchRefresherTouchmove: {
        type: Boolean,
        default: u$1.gc("watchRefresherTouchmove", false)
      },
      // blackwhiteblack
      loadingMoreThemeStyle: {
        type: String,
        default: u$1.gc("loadingMoreThemeStyle", "")
      },
      // truemounted
      refresherOnly: {
        type: Boolean,
        default: u$1.gc("refresherOnly", false)
      },
      // 100nvue
      refresherDefaultDuration: {
        type: [Number, String],
        default: u$1.gc("refresherDefaultDuration", 100)
      },
      // 0
      refresherCompleteDelay: {
        type: [Number, String],
        default: u$1.gc("refresherCompleteDelay", 0)
      },
      // 300(refresherEndBounceEnabledfalserefresherCompleteDuration1/3)nvue
      refresherCompleteDuration: {
        type: [Number, String],
        default: u$1.gc("refresherCompleteDuration", 300)
      },
      // 
      refresherRefreshingScrollable: {
        type: Boolean,
        default: u$1.gc("refresherRefreshingScrollable", true)
      },
      // 
      refresherCompleteScrollable: {
        type: Boolean,
        default: u$1.gc("refresherCompleteScrollable", false)
      },
      // z-pagingfalseuni scroll-viewh5Appuni scroll-view
      useCustomRefresher: {
        type: Boolean,
        default: u$1.gc("useCustomRefresher", true)
      },
      // 40
      refresherFps: {
        type: [Number, String],
        default: u$1.gc("refresherFps", 40)
      },
      // 40
      refresherMaxAngle: {
        type: [Number, String],
        default: u$1.gc("refresherMaxAngle", 40)
      },
      // 
      refresherAngleEnableChangeContinued: {
        type: Boolean,
        default: u$1.gc("refresherAngleEnableChangeContinued", false)
      },
      // 
      refresherDefaultText: {
        type: [String, Object],
        default: u$1.gc("refresherDefaultText", null)
      },
      // 
      refresherPullingText: {
        type: [String, Object],
        default: u$1.gc("refresherPullingText", null)
      },
      // 
      refresherRefreshingText: {
        type: [String, Object],
        default: u$1.gc("refresherRefreshingText", null)
      },
      // 
      refresherCompleteText: {
        type: [String, Object],
        default: u$1.gc("refresherCompleteText", null)
      },
      // 
      refresherGoF2Text: {
        type: [String, Object],
        default: u$1.gc("refresherGoF2Text", null)
      },
      // 
      refresherDefaultImg: {
        type: String,
        default: u$1.gc("refresherDefaultImg", null)
      },
      // refresherDefaultImg
      refresherPullingImg: {
        type: String,
        default: u$1.gc("refresherPullingImg", null)
      },
      // 
      refresherRefreshingImg: {
        type: String,
        default: u$1.gc("refresherRefreshingImg", null)
      },
      // 
      refresherCompleteImg: {
        type: String,
        default: u$1.gc("refresherCompleteImg", null)
      },
      // 
      refresherRefreshingAnimated: {
        type: Boolean,
        default: u$1.gc("refresherRefreshingAnimated", true)
      },
      // 
      refresherEndBounceEnabled: {
        type: Boolean,
        default: u$1.gc("refresherEndBounceEnabled", true)
      },
      // 
      refresherEnabled: {
        type: Boolean,
        default: u$1.gc("refresherEnabled", true)
      },
      // 80rpx
      refresherThreshold: {
        type: [Number, String],
        default: u$1.gc("refresherThreshold", "80rpx")
      },
      //  blackwhitenonenone black
      refresherDefaultStyle: {
        type: String,
        default: u$1.gc("refresherDefaultStyle", "black")
      },
      // 
      refresherBackground: {
        type: String,
        default: u$1.gc("refresherBackground", "transparent")
      },
      // 
      refresherFixedBackground: {
        type: String,
        default: u$1.gc("refresherFixedBackground", "transparent")
      },
      // 0
      refresherFixedBacHeight: {
        type: [Number, String],
        default: u$1.gc("refresherFixedBacHeight", 0)
      },
      // 0-10.65(nvue)
      refresherOutRate: {
        type: Number,
        default: u$1.gc("refresherOutRate", 0.65)
      },
      // 
      refresherF2Enabled: {
        type: Boolean,
        default: u$1.gc("refresherF2Enabled", false)
      },
      // 200rpx
      refresherF2Threshold: {
        type: [Number, String],
        default: u$1.gc("refresherF2Threshold", "200rpx")
      },
      // 200
      refresherF2Duration: {
        type: [Number, String],
        default: u$1.gc("refresherF2Duration", 200)
      },
      // 
      showRefresherF2: {
        type: Boolean,
        default: u$1.gc("showRefresherF2", true)
      },
      // 0.7510px7.5px(nvue)
      refresherPullRate: {
        type: Number,
        default: u$1.gc("refresherPullRate", 0.75)
      },
      // 
      showRefresherUpdateTime: {
        type: Boolean,
        default: u$1.gc("showRefresherUpdateTime", false)
      },
      // z-paging`refresher-update-time-key`
      refresherUpdateTimeKey: {
        type: String,
        default: u$1.gc("refresherUpdateTimeKey", "default")
      },
      // h5
      refresherVibrate: {
        type: Boolean,
        default: u$1.gc("refresherVibrate", false)
      },
      // viewview
      refresherNoTransform: {
        type: Boolean,
        default: u$1.gc("refresherNoTransform", false)
      },
      // 
      useRefresherStatusBarPlaceholder: {
        type: Boolean,
        default: u$1.gc("useRefresherStatusBarPlaceholder", false)
      }
    },
    data() {
      return {
        R: Enum.Refresher,
        //
        refresherStatus: Enum.Refresher.Default,
        refresherTouchstartY: 0,
        lastRefresherTouchmove: null,
        refresherReachMaxAngle: true,
        refresherTransform: "translateY(0px)",
        refresherTransition: "",
        finalRefresherDefaultStyle: "black",
        refresherRevealStackCount: 0,
        refresherCompleteTimeout: null,
        refresherCompleteSubTimeout: null,
        refresherEndTimeout: null,
        isTouchmovingTimeout: null,
        refresherTriggered: false,
        isTouchmoving: false,
        isTouchEnded: false,
        isUserPullDown: false,
        privateRefresherEnabled: -1,
        privateShowRefresherWhenReload: false,
        customRefresherHeight: -1,
        showCustomRefresher: false,
        doRefreshAnimateAfter: false,
        isRefresherInComplete: false,
        showF2: false,
        f2Transform: "",
        pullDownTimeStamp: 0,
        moveDis: 0,
        oldMoveDis: 0,
        currentDis: 0,
        oldCurrentMoveDis: 0,
        oldRefresherTouchmoveY: 0,
        oldTouchDirection: "",
        oldEmitedTouchDirection: "",
        oldPullingDistance: -1,
        refresherThresholdUpdateTag: 0
      };
    },
    watch: {
      refresherDefaultStyle: {
        handler(newVal) {
          if (newVal.length) {
            this.finalRefresherDefaultStyle = newVal;
          }
        },
        immediate: true
      },
      refresherStatus(newVal) {
        newVal === Enum.Refresher.Loading && this._cleanRefresherEndTimeout();
        this.refresherVibrate && (newVal === Enum.Refresher.ReleaseToRefresh || newVal === Enum.Refresher.GoF2) && this._doVibrateShort();
        this.$emit("refresherStatusChange", newVal);
        this.$emit("update:refresherStatus", newVal);
      },
      // /
      refresherEnabled(newVal) {
        !newVal && this.endRefresh();
      }
    },
    computed: {
      pullDownDisTimeStamp() {
        return 1e3 / this.refresherFps;
      },
      refresherThresholdUnitConverted() {
        return u$1.addUnit(this.refresherThreshold, this.unit);
      },
      finalRefresherEnabled() {
        if (this.useChatRecordMode)
          return false;
        if (this.privateRefresherEnabled === -1)
          return this.refresherEnabled;
        return this.privateRefresherEnabled === 1;
      },
      finalRefresherThreshold() {
        let refresherThreshold = this.refresherThresholdUnitConverted;
        let idDefault = false;
        if (refresherThreshold === u$1.addUnit(80, this.unit)) {
          idDefault = true;
          if (this.showRefresherUpdateTime) {
            refresherThreshold = u$1.addUnit(120, this.unit);
          }
        }
        if (idDefault && this.customRefresherHeight > 0)
          return this.customRefresherHeight + this.finalRefresherThresholdPlaceholder;
        return u$1.convertToPx(refresherThreshold) + this.finalRefresherThresholdPlaceholder;
      },
      finalRefresherF2Threshold() {
        return u$1.convertToPx(u$1.addUnit(this.refresherF2Threshold, this.unit));
      },
      finalRefresherThresholdPlaceholder() {
        return this.useRefresherStatusBarPlaceholder ? this.statusBarHeight : 0;
      },
      finalRefresherFixedBacHeight() {
        return u$1.convertToPx(this.refresherFixedBacHeight);
      },
      finalRefresherThemeStyle() {
        return this.refresherThemeStyle.length ? this.refresherThemeStyle : this.defaultThemeStyle;
      },
      finalRefresherOutRate() {
        let rate = this.refresherOutRate;
        rate = Math.max(0, rate);
        rate = Math.min(1, rate);
        return rate;
      },
      finalRefresherPullRate() {
        let rate = this.refresherPullRate;
        rate = Math.max(0, rate);
        return rate;
      },
      finalRefresherTransform() {
        if (this.refresherNoTransform || this.refresherTransform === "translateY(0px)")
          return "none";
        return this.refresherTransform;
      },
      finalShowRefresherWhenReload() {
        return this.showRefresherWhenReload || this.privateShowRefresherWhenReload;
      },
      finalRefresherTriggered() {
        if (!(this.finalRefresherEnabled && !this.useCustomRefresher))
          return false;
        return this.refresherTriggered;
      },
      showRefresher() {
        const showRefresher = this.finalRefresherEnabled || this.useCustomRefresher && !this.useChatRecordMode;
        this.active && this.customRefresherHeight === -1 && showRefresher && this.updateCustomRefresherHeight();
        return showRefresher;
      },
      hasTouchmove() {
        return this.watchRefresherTouchmove;
      }
    },
    methods: {
      // 
      endRefresh() {
        this.totalData = this.realTotalData;
        this._refresherEnd();
        this._endSystemLoadingAndRefresh();
        this._handleScrollViewBounce({ bounce: true });
        this.$nextTick(() => {
          this.refresherTriggered = false;
        });
      },
      // view
      updateCustomRefresherHeight() {
        u$1.delay(() => this.$nextTick(this._updateCustomRefresherHeight));
      },
      // 
      closeF2() {
        this._handleCloseF2();
      },
      // 
      _onRefresh(fromScrollView = false, isUserPullDown = true) {
        if (fromScrollView && !(this.finalRefresherEnabled && !this.useCustomRefresher))
          return;
        this.$emit("onRefresh");
        this.$emit("Refresh");
        if (this.loading || this.isRefresherInComplete)
          return;
        this.loadingType = Enum.LoadingType.Refresher;
        if (this.nShowRefresherReveal)
          return;
        this.isUserPullDown = isUserPullDown;
        this.isUserReload = !isUserPullDown;
        this._startLoading(true);
        this.refresherTriggered = true;
        if (this.reloadWhenRefresh && isUserPullDown) {
          this.useChatRecordMode ? this._onLoadingMore("click") : this._reload(false, false, isUserPullDown);
        }
      },
      // 
      _onRestore() {
        this.refresherTriggered = "restore";
        this.$emit("onRestore");
        this.$emit("Restore");
      },
      // touch
      _handleRefresherTouchstart(touch) {
        if (!this.loading && this.isTouchEnded) {
          this.isTouchmoving = false;
        }
        this.loadingType = Enum.LoadingType.Refresher;
        this.isTouchmovingTimeout && clearTimeout(this.isTouchmovingTimeout);
        this.isTouchEnded = false;
        this.refresherTransition = "";
        this.refresherTouchstartY = touch.touchY;
        this.$emit("refresherTouchstart", this.refresherTouchstartY);
        this.lastRefresherTouchmove = touch;
        this._cleanRefresherCompleteTimeout();
        this._cleanRefresherEndTimeout();
      },
      // appvueQQh5js
      // touch
      _handleRefresherTouchmove(moveDis, touch) {
        this.refresherReachMaxAngle = true;
        this.isTouchmovingTimeout && clearTimeout(this.isTouchmovingTimeout);
        this.isTouchmoving = true;
        this.isTouchEnded = false;
        if (moveDis >= this.finalRefresherThreshold) {
          this.refresherStatus = this.refresherF2Enabled && moveDis >= this.finalRefresherF2Threshold ? Enum.Refresher.GoF2 : Enum.Refresher.ReleaseToRefresh;
        } else {
          this.refresherStatus = Enum.Refresher.Default;
        }
        this.moveDis = moveDis;
      },
      // touch
      _handleRefresherTouchend(moveDis) {
        this.isTouchmovingTimeout && clearTimeout(this.isTouchmovingTimeout);
        this.refresherReachMaxAngle = true;
        this.isTouchEnded = true;
        const refresherThreshold = this.finalRefresherThreshold;
        if (moveDis >= refresherThreshold && (this.refresherStatus === Enum.Refresher.ReleaseToRefresh || this.refresherStatus === Enum.Refresher.GoF2)) {
          if (this.refresherStatus === Enum.Refresher.GoF2) {
            this._handleGoF2();
            this._refresherEnd();
          } else {
            u$1.delay(() => {
              this._emitTouchmove({ pullingDistance: refresherThreshold, dy: this.moveDis - refresherThreshold });
            }, 0.1);
            this.moveDis = refresherThreshold;
            this.refresherStatus = Enum.Refresher.Loading;
            this._doRefresherLoad();
          }
        } else {
          this._refresherEnd();
          this.isTouchmovingTimeout = u$1.delay(() => {
            this.isTouchmoving = false;
          }, this.refresherDefaultDuration);
        }
        this.scrollEnable = true;
        this.$emit("refresherTouchend", moveDis);
      },
      // 
      _handleListTouchstart() {
        if (this.useChatRecordMode && this.autoHideKeyboardWhenChat) {
          uni.hideKeyboard();
          this.$emit("hidedKeyboard");
        }
      },
      // scroll-view bounce
      _handleScrollViewBounce({ bounce }) {
        if (!this.usePageScroll && !this.scrollToTopBounceEnabled) {
          if (this.wxsScrollTop <= 5) {
            this.refresherTransition = "";
            this.scrollEnable = bounce;
          } else if (bounce) {
            this.scrollEnable = bounce;
          }
        }
      },
      // wxs
      _handleWxsPullingDownStatusChange(onPullingDown) {
        this.wxsOnPullingDown = onPullingDown;
        if (onPullingDown && !this.useChatRecordMode) {
          this.renderPropScrollTop = 0;
        }
      },
      // wxs
      _handleWxsPullingDown({ moveDis, diffDis }) {
        this._emitTouchmove({ pullingDistance: moveDis, dy: diffDis });
      },
      // wxs
      _handleTouchDirectionChange({ direction }) {
        this.$emit("touchDirectionChange", direction);
      },
      // wxsprops
      _handlePropUpdate() {
        this.wxsPropType = u$1.getTime().toString();
      },
      // 
      _refresherEnd(shouldEndLoadingDelay = true, fromAddData = false, isUserPullDown = false, setLoading = true) {
        if (this.loadingType === Enum.LoadingType.Refresher) {
          const refresherCompleteDelay = fromAddData && (isUserPullDown || this.showRefresherWhenReload) ? this.refresherCompleteDelay : 0;
          const refresherStatus = refresherCompleteDelay > 0 ? Enum.Refresher.Complete : Enum.Refresher.Default;
          if (this.finalShowRefresherWhenReload) {
            const stackCount = this.refresherRevealStackCount;
            this.refresherRevealStackCount--;
            if (stackCount > 1)
              return;
          }
          this._cleanRefresherEndTimeout();
          this.refresherEndTimeout = u$1.delay(() => {
            this.refresherStatus = refresherStatus;
          }, this.refresherStatus !== Enum.Refresher.Default && refresherStatus === Enum.Refresher.Default ? this.refresherCompleteDuration : 0);
          if (refresherCompleteDelay > 0) {
            this.isRefresherInComplete = true;
          }
          this._cleanRefresherCompleteTimeout();
          this.refresherCompleteTimeout = u$1.delay(() => {
            let animateDuration = 1;
            const animateType = this.refresherEndBounceEnabled && fromAddData ? "cubic-bezier(0.19,1.64,0.42,0.72)" : "linear";
            if (fromAddData) {
              animateDuration = this.refresherEndBounceEnabled ? this.refresherCompleteDuration / 1e3 : this.refresherCompleteDuration / 3e3;
            }
            this.refresherTransition = `transform ${fromAddData ? animateDuration : this.refresherDefaultDuration / 1e3}s ${animateType}`;
            this.wxsPropType = this.refresherTransition + "end" + u$1.getTime();
            this.moveDis = 0;
            if (refresherStatus === Enum.Refresher.Complete) {
              if (this.refresherCompleteSubTimeout) {
                clearTimeout(this.refresherCompleteSubTimeout);
                this.refresherCompleteSubTimeout = null;
              }
              this.refresherCompleteSubTimeout = u$1.delay(() => {
                this.$nextTick(() => {
                  this.refresherStatus = Enum.Refresher.Default;
                  this.isRefresherInComplete = false;
                });
              }, animateDuration * 800);
            }
            this._emitTouchmove({ pullingDistance: 0, dy: this.moveDis });
          }, refresherCompleteDelay);
        }
        if (setLoading) {
          u$1.delay(() => this.loading = false, shouldEndLoadingDelay ? 10 : 0);
          isUserPullDown && this._onRestore();
        }
      },
      // 
      _handleGoF2() {
        if (this.showF2 || !this.refresherF2Enabled)
          return;
        this.$emit("refresherF2Change", "go");
        if (!this.showRefresherF2)
          return;
        this.f2Transform = `translateY(${-this.superContentHeight}px)`;
        this.showF2 = true;
        u$1.delay(() => {
          this.f2Transform = "translateY(0px)";
        }, 100, "f2ShowDelay");
      },
      // 
      _handleCloseF2() {
        if (!this.showF2 || !this.refresherF2Enabled)
          return;
        this.$emit("refresherF2Change", "close");
        if (!this.showRefresherF2)
          return;
        this.f2Transform = `translateY(${-this.superContentHeight}px)`;
        u$1.delay(() => {
          this.showF2 = false;
          this.nF2Opacity = 0;
        }, this.refresherF2Duration, "f2CloseDelay");
      },
      // 
      _doRefresherRefreshAnimate() {
        this._cleanRefresherCompleteTimeout();
        const doRefreshAnimateAfter = !this.doRefreshAnimateAfter && this.finalShowRefresherWhenReload && this.customRefresherHeight === -1 && this.refresherThreshold === u$1.addUnit(80, this.unit);
        if (doRefreshAnimateAfter) {
          this.doRefreshAnimateAfter = true;
          return;
        }
        this.refresherRevealStackCount++;
        this.wxsPropType = "begin" + u$1.getTime();
        this.moveDis = this.finalRefresherThreshold;
        this.refresherStatus = Enum.Refresher.Loading;
        this.isTouchmoving = true;
        this.isTouchmovingTimeout && clearTimeout(this.isTouchmovingTimeout);
        this._doRefresherLoad(false);
      },
      // 
      _doRefresherLoad(isUserPullDown = true) {
        this._onRefresh(false, isUserPullDown);
        this.loading = true;
      },
      // view
      _updateCustomRefresherHeight() {
        this._getNodeClientRect(".zp-custom-refresher-slot-view").then((res) => {
          this.customRefresherHeight = res ? res[0].height : 0;
          this.showCustomRefresher = this.customRefresherHeight > 0;
          if (this.doRefreshAnimateAfter) {
            this.doRefreshAnimateAfter = false;
            this._doRefresherRefreshAnimate();
          }
        });
      },
      // emit pullingDown
      _emitTouchmove(e2) {
        e2.viewHeight = this.finalRefresherThreshold;
        e2.rate = e2.viewHeight > 0 ? e2.pullingDistance / e2.viewHeight : 0;
        this.hasTouchmove && this.oldPullingDistance !== e2.pullingDistance && this.$emit("refresherTouchmove", e2);
        this.oldPullingDistance = e2.pullingDistance;
      },
      // refresherCompleteTimeout
      _cleanRefresherCompleteTimeout() {
        this.refresherCompleteTimeout = this._cleanTimeout(this.refresherCompleteTimeout);
      },
      // refresherEndTimeout
      _cleanRefresherEndTimeout() {
        this.refresherEndTimeout = this._cleanTimeout(this.refresherEndTimeout);
      }
    }
  };
  const loadMoreModule = {
    props: {
      // 
      loadingMoreCustomStyle: {
        type: Object,
        default: u$1.gc("loadingMoreCustomStyle", {})
      },
      // 
      loadingMoreTitleCustomStyle: {
        type: Object,
        default: u$1.gc("loadingMoreTitleCustomStyle", {})
      },
      // 
      loadingMoreLoadingIconCustomStyle: {
        type: Object,
        default: u$1.gc("loadingMoreLoadingIconCustomStyle", {})
      },
      // flowercircleflower
      loadingMoreLoadingIconType: {
        type: String,
        default: u$1.gc("loadingMoreLoadingIconType", "flower")
      },
      // 
      loadingMoreLoadingIconCustomImage: {
        type: String,
        default: u$1.gc("loadingMoreLoadingIconCustomImage", "")
      },
      // view
      loadingMoreLoadingAnimated: {
        type: Boolean,
        default: u$1.gc("loadingMoreLoadingAnimated", true)
      },
      // ()
      loadingMoreEnabled: {
        type: Boolean,
        default: u$1.gc("loadingMoreEnabled", true)
      },
      // 
      toBottomLoadingMoreEnabled: {
        type: Boolean,
        default: u$1.gc("toBottomLoadingMoreEnabled", true)
      },
      // 
      loadingMoreDefaultAsLoading: {
        type: Boolean,
        default: u$1.gc("loadingMoreDefaultAsLoading", false)
      },
      // ""
      loadingMoreDefaultText: {
        type: [String, Object],
        default: u$1.gc("loadingMoreDefaultText", null)
      },
      // ""...
      loadingMoreLoadingText: {
        type: [String, Object],
        default: u$1.gc("loadingMoreLoadingText", null)
      },
      // ""
      loadingMoreNoMoreText: {
        type: [String, Object],
        default: u$1.gc("loadingMoreNoMoreText", null)
      },
      // ""
      loadingMoreFailText: {
        type: [String, Object],
        default: u$1.gc("loadingMoreFailText", null)
      },
      // z-pagingview
      hideNoMoreInside: {
        type: Boolean,
        default: u$1.gc("hideNoMoreInside", false)
      },
      // view0
      hideNoMoreByLimit: {
        type: Number,
        default: u$1.gc("hideNoMoreByLimit", 0)
      },
      // text
      showDefaultLoadingMoreText: {
        type: Boolean,
        default: u$1.gc("showDefaultLoadingMoreText", true)
      },
      // view
      showLoadingMoreNoMoreView: {
        type: Boolean,
        default: u$1.gc("showLoadingMoreNoMoreView", true)
      },
      // 
      showLoadingMoreNoMoreLine: {
        type: Boolean,
        default: u$1.gc("showLoadingMoreNoMoreLine", true)
      },
      // 
      loadingMoreNoMoreLineCustomStyle: {
        type: Object,
        default: u$1.gc("loadingMoreNoMoreLineCustomStyle", {})
      },
      // (nvue)
      insideMore: {
        type: Boolean,
        default: u$1.gc("insideMore", false)
      },
      // /px scrolltolower 100rpx
      lowerThreshold: {
        type: [Number, String],
        default: u$1.gc("lowerThreshold", "100rpx")
      }
    },
    data() {
      return {
        M: Enum.More,
        // 
        loadingStatus: Enum.More.Default,
        // 
        loadingStatusAfterRender: Enum.More.Default,
        // 
        loadingMoreTimeStamp: 0,
        // slot
        loadingMoreDefaultSlot: null,
        // 
        showLoadingMore: false,
        // -1z-paging10
        customNoMore: -1
      };
    },
    computed: {
      // 
      zLoadMoreConfig() {
        return {
          status: this.loadingStatusAfterRender,
          defaultAsLoading: this.loadingMoreDefaultAsLoading || this.useChatRecordMode && this.chatLoadingMoreDefaultAsLoading,
          defaultThemeStyle: this.finalLoadingMoreThemeStyle,
          customStyle: this.loadingMoreCustomStyle,
          titleCustomStyle: this.loadingMoreTitleCustomStyle,
          iconCustomStyle: this.loadingMoreLoadingIconCustomStyle,
          loadingIconType: this.loadingMoreLoadingIconType,
          loadingIconCustomImage: this.loadingMoreLoadingIconCustomImage,
          loadingAnimated: this.loadingMoreLoadingAnimated,
          showNoMoreLine: this.showLoadingMoreNoMoreLine,
          noMoreLineCustomStyle: this.loadingMoreNoMoreLineCustomStyle,
          defaultText: this.finalLoadingMoreDefaultText,
          loadingText: this.finalLoadingMoreLoadingText,
          noMoreText: this.finalLoadingMoreNoMoreText,
          failText: this.finalLoadingMoreFailText,
          hideContent: !this.loadingMoreDefaultAsLoading && this.listRendering,
          unit: this.unit,
          isChat: this.useChatRecordMode,
          chatDefaultAsLoading: this.chatLoadingMoreDefaultAsLoading
        };
      },
      // 
      finalLoadingMoreThemeStyle() {
        return this.loadingMoreThemeStyle.length ? this.loadingMoreThemeStyle : this.defaultThemeStyle;
      },
      // 
      finalLowerThreshold() {
        return u$1.convertToPx(this.lowerThreshold);
      },
      // 
      showLoadingMoreDefault() {
        return this._showLoadingMore("Default");
      },
      // 
      showLoadingMoreLoading() {
        return this._showLoadingMore("Loading");
      },
      // 
      showLoadingMoreNoMore() {
        return this._showLoadingMore("NoMore");
      },
      // 
      showLoadingMoreFail() {
        return this._showLoadingMore("Fail");
      },
      // 
      showLoadingMoreCustom() {
        return this._showLoadingMore("Custom");
      },
      // 
      loadingMoreFixedHeight() {
        return u$1.addUnit("80rpx", this.unit);
      }
    },
    methods: {
      // z-paging
      pageReachBottom() {
        !this.useChatRecordMode && this.toBottomLoadingMoreEnabled && this._onLoadingMore("toBottom");
      },
      // ()
      doLoadMore(type) {
        this._onLoadingMore(type);
      },
      // @scroll()
      _checkScrolledToBottom(scrollDiff, checked = false) {
        if (this.cacheScrollNodeHeight === -1) {
          this._getNodeClientRect(".zp-scroll-view").then((res) => {
            if (res) {
              const scrollNodeHeight = res[0].height;
              this.cacheScrollNodeHeight = scrollNodeHeight;
              if (scrollDiff - scrollNodeHeight <= this.finalLowerThreshold) {
                this._onLoadingMore("toBottom");
              }
            }
          });
        } else {
          if (scrollDiff - this.cacheScrollNodeHeight <= this.finalLowerThreshold) {
            this._onLoadingMore("toBottom");
          } else if (scrollDiff - this.cacheScrollNodeHeight <= 500 && !checked) {
            u$1.delay(() => {
              this._getNodeClientRect(".zp-scroll-view", true, true).then((res) => {
                if (res) {
                  this.oldScrollTop = res[0].scrollTop;
                  const newScrollDiff = res[0].scrollHeight - this.oldScrollTop;
                  this._checkScrolledToBottom(newScrollDiff, true);
                }
              });
            }, 150, "checkScrolledToBottomDelay");
          }
          if (this.oldScrollTop <= 150 && this.oldScrollTop !== 0) {
            u$1.delay(() => {
              if (this.oldScrollTop !== 0) {
                this._getNodeClientRect(".zp-scroll-view", true, true).then((res) => {
                  if (res && res[0].scrollTop === 0 && this.oldScrollTop !== 0) {
                    this._onScrollToUpper();
                  }
                });
              }
            }, 150, "checkScrolledToTopDelay");
          }
        }
      },
      // ,from:toBottom-1click-
      _onLoadingMore(from = "click") {
        if (this.isIos && from === "toBottom" && !this.scrollToBottomBounceEnabled && this.scrollEnable) {
          this.scrollEnable = false;
          this.$nextTick(() => {
            this.scrollEnable = true;
          });
        }
        this.$emit("scrolltolower", from);
        if (this.refresherOnly || !this.loadingMoreEnabled || !(this.loadingStatus === Enum.More.Default || this.loadingStatus === Enum.More.Fail) || this.loading || this.showEmpty)
          return;
        this._doLoadingMore();
      },
      // 
      _doLoadingMore() {
        if (this.pageNo >= this.defaultPageNo && this.loadingStatus !== Enum.More.NoMore) {
          this.pageNo++;
          this._startLoading(false);
          if (this.isLocalPaging) {
            this._localPagingQueryList(this.pageNo, this.defaultPageSize, this.localPagingLoadingTime, (res) => {
              this.completeByTotal(res, this.totalLocalPagingList.length);
              this.queryFrom = Enum.QueryFrom.LoadingMore;
            });
          } else {
            this._emitQuery(this.pageNo, this.defaultPageSize, Enum.QueryFrom.LoadingMore);
            this._callMyParentQuery();
          }
          this.loadingType = Enum.LoadingType.LoadingMore;
        }
      },
      // ()z-pagingview
      _preCheckShowNoMoreInside(newVal, scrollViewNode, pagingContainerNode) {
        if (this.loadingStatus === Enum.More.NoMore && this.hideNoMoreByLimit > 0 && newVal.length) {
          this.showLoadingMore = newVal.length > this.hideNoMoreByLimit;
        } else if (this.loadingStatus === Enum.More.NoMore && this.hideNoMoreInside && newVal.length || this.insideMore && this.insideOfPaging !== false && newVal.length) {
          this.$nextTick(() => {
            this._checkShowNoMoreInside(newVal, scrollViewNode, pagingContainerNode);
          });
          if (this.insideMore && this.insideOfPaging !== false && newVal.length) {
            this.showLoadingMore = newVal.length;
          }
        } else {
          this.showLoadingMore = newVal.length;
        }
      },
      // z-pagingview
      async _checkShowNoMoreInside(totalData, oldScrollViewNode, oldPagingContainerNode) {
        try {
          const scrollViewNode = oldScrollViewNode || await this._getNodeClientRect(".zp-scroll-view");
          if (this.usePageScroll) {
            if (scrollViewNode) {
              const scrollViewTotalH = scrollViewNode[0].top + scrollViewNode[0].height;
              this.insideOfPaging = scrollViewTotalH < this.windowHeight;
              if (this.hideNoMoreInside) {
                this.showLoadingMore = !this.insideOfPaging;
              }
              this._updateInsideOfPaging();
            }
          } else {
            const pagingContainerNode = oldPagingContainerNode || await this._getNodeClientRect(".zp-paging-container-content");
            const pagingContainerH = pagingContainerNode ? pagingContainerNode[0].height : 0;
            const scrollViewH = scrollViewNode ? scrollViewNode[0].height : 0;
            this.insideOfPaging = pagingContainerH < scrollViewH;
            if (this.hideNoMoreInside) {
              this.showLoadingMore = !this.insideOfPaging;
            }
            this._updateInsideOfPaging();
          }
        } catch (e2) {
          this.insideOfPaging = !totalData.length;
          if (this.hideNoMoreInside) {
            this.showLoadingMore = !this.insideOfPaging;
          }
          this._updateInsideOfPaging();
        }
      },
      // view
      _showLoadingMore(type) {
        if (!this.showLoadingMoreWhenReload && (!(this.loadingStatus === Enum.More.Default ? this.nShowBottom : true) || !this.realTotalData.length))
          return false;
        if ((!this.showLoadingMoreWhenReload || this.isUserPullDown || this.loadingStatus !== Enum.More.Loading) && !this.showLoadingMore || !this.loadingMoreEnabled && (!this.showLoadingMoreWhenReload || this.isUserPullDown || this.loadingStatus !== Enum.More.Loading) || this.refresherOnly) {
          return false;
        }
        if (this.useChatRecordMode && type !== "Loading")
          return false;
        if (!this.zSlots)
          return false;
        if (type === "Custom") {
          return this.showDefaultLoadingMoreText && !(this.loadingStatus === Enum.More.NoMore && !this.showLoadingMoreNoMoreView);
        }
        const res = this.loadingStatus === Enum.More[type] && this.zSlots[`loadingMore${type}`] && (type === "NoMore" ? this.showLoadingMoreNoMoreView : true);
        return res;
      }
    }
  };
  const loadingModule = {
    props: {
      // loading slot
      autoHideLoadingAfterFirstLoaded: {
        type: Boolean,
        default: u$1.gc("autoHideLoadingAfterFirstLoaded", true)
      },
      // loading slot
      loadingFullFixed: {
        type: Boolean,
        default: u$1.gc("loadingFullFixed", false)
      },
      // Loadinguni.showLoading(reloadrefresh)false
      autoShowSystemLoading: {
        type: Boolean,
        default: u$1.gc("autoShowSystemLoading", false)
      },
      // Loading(H5App)
      systemLoadingMask: {
        type: Boolean,
        default: u$1.gc("systemLoadingMask", true)
      },
      // Loading""
      systemLoadingText: {
        type: [String, Object],
        default: u$1.gc("systemLoadingText", null)
      }
    },
    data() {
      return {
        loading: false,
        loadingForNow: false
      };
    },
    watch: {
      // loading
      loadingStatus(newVal) {
        this.$emit("loadingStatusChange", newVal);
        this.$nextTick(() => {
          this.loadingStatusAfterRender = newVal;
        });
        if (this.useChatRecordMode) {
          if (this.isFirstPage && (newVal === Enum.More.NoMore || newVal === Enum.More.Fail)) {
            this.isFirstPageAndNoMore = true;
            return;
          }
        }
        this.isFirstPageAndNoMore = false;
      },
      loading(newVal) {
        if (newVal) {
          this.loadingForNow = newVal;
        }
      }
    },
    computed: {
      // loading
      showLoading() {
        if (this.firstPageLoaded || !this.loading || !this.loadingForNow)
          return false;
        if (this.finalShowSystemLoading) {
          uni.showLoading({
            title: this.finalSystemLoadingText,
            mask: this.systemLoadingMask
          });
        }
        return this.autoHideLoadingAfterFirstLoaded ? this.fromEmptyViewReload ? true : !this.pagingLoaded : this.loadingType === Enum.LoadingType.Refresher;
      },
      // loading
      finalShowSystemLoading() {
        return this.autoShowSystemLoading && this.loadingType === Enum.LoadingType.Refresher;
      }
    },
    methods: {
      // 
      _startLoading(isReload = false) {
        if (this.showLoadingMoreWhenReload && !this.isUserPullDown || !isReload) {
          this.loadingStatus = Enum.More.Loading;
        }
        this.loading = true;
      },
      // loadingrefresh
      _endSystemLoadingAndRefresh() {
        this.finalShowSystemLoading && uni.hideLoading();
        !this.useCustomRefresher && uni.stopPullDownRefresh();
      }
    }
  };
  const chatRecordModerModule = {
    props: {
      // 
      useChatRecordMode: {
        type: Boolean,
        default: u$1.gc("useChatRecordMode", false)
      },
      // 0rpxpx
      chatRecordMoreOffset: {
        type: [Number, String],
        default: u$1.gc("chatRecordMoreOffset", "0rpx")
      },
      // 
      autoHideKeyboardWhenChat: {
        type: Boolean,
        default: u$1.gc("autoHideKeyboardWhenChat", true)
      },
      // slot="bottom"
      autoAdjustPositionWhenChat: {
        type: Boolean,
        default: u$1.gc("autoAdjustPositionWhenChat", true)
      },
      // 0rpxpx
      chatAdjustPositionOffset: {
        type: [Number, String],
        default: u$1.gc("chatAdjustPositionOffset", "0rpx")
      },
      // 
      autoToBottomWhenChat: {
        type: Boolean,
        default: u$1.gc("autoToBottomWhenChat", false)
      },
      // reloadchatLoading
      showChatLoadingWhenReload: {
        type: Boolean,
        default: u$1.gc("showChatLoadingWhenReload", false)
      },
      // loading
      chatLoadingMoreDefaultAsLoading: {
        type: Boolean,
        default: u$1.gc("chatLoadingMoreDefaultAsLoading", true)
      }
    },
    data() {
      return {
        // 
        keyboardHeight: 0,
        // 
        isKeyboardHeightChanged: false
      };
    },
    computed: {
      finalChatRecordMoreOffset() {
        return u$1.convertToPx(this.chatRecordMoreOffset);
      },
      finalChatAdjustPositionOffset() {
        return u$1.convertToPx(this.chatAdjustPositionOffset);
      },
      // 180style
      chatRecordRotateStyle() {
        let cellStyle;
        cellStyle = this.useChatRecordMode ? { transform: "scaleY(-1)" } : {};
        this.$emit("update:cellStyle", cellStyle);
        this.$emit("cellStyleChange", cellStyle);
        this.$nextTick(() => {
          if (this.isFirstPage && this.isChatRecordModeAndNotInversion) {
            this.$nextTick(() => {
              this._scrollToBottom(false);
              u$1.delay(() => {
                this._scrollToBottom(false);
                u$1.delay(() => {
                  this._scrollToBottom(false);
                }, 50);
              }, 50);
            });
          }
        });
        return cellStyle;
      },
      // transform
      isChatRecordModeHasTransform() {
        return this.useChatRecordMode && this.chatRecordRotateStyle && this.chatRecordRotateStyle.transform;
      },
      // 
      isChatRecordModeAndNotInversion() {
        return this.isChatRecordModeHasTransform && this.chatRecordRotateStyle.transform === "scaleY(1)";
      },
      // 
      isChatRecordModeAndInversion() {
        return this.isChatRecordModeHasTransform && this.chatRecordRotateStyle.transform === "scaleY(-1)";
      },
      // 
      chatRecordModeSafeAreaBottom() {
        return this.safeAreaInsetBottom && !this.keyboardHeight ? this.safeAreaBottom : 0;
      }
    },
    mounted() {
      if (this.useChatRecordMode) {
        uni.onKeyboardHeightChange(this._handleKeyboardHeightChange);
      }
    },
    methods: {
      // 
      addChatRecordData(data, toBottom = true, toBottomWithAnimate = true) {
        if (!this.useChatRecordMode)
          return;
        this.isTotalChangeFromAddData = true;
        this.addDataFromTop(data, toBottom, toBottomWithAnimate);
      },
      // 
      doChatRecordLoadMore() {
        this.useChatRecordMode && this._onLoadingMore("click");
      },
      // 
      _handleKeyboardHeightChange(res) {
        this.$emit("keyboardHeightChange", res);
        if (this.autoAdjustPositionWhenChat) {
          this.isKeyboardHeightChanged = true;
          this.keyboardHeight = res.height > 0 ? res.height + this.finalChatAdjustPositionOffset : res.height;
        }
        if (this.autoToBottomWhenChat && this.keyboardHeight > 0) {
          u$1.delay(() => {
            this.scrollToBottom(false);
            u$1.delay(() => {
              this.scrollToBottom(false);
            });
          });
        }
      }
    }
  };
  const scrollerModule = {
    props: {
      // scroll-viewz-paging
      usePageScroll: {
        type: Boolean,
        default: u$1.gc("usePageScroll", false)
      },
      // scroll-viewnvue
      scrollable: {
        type: Boolean,
        default: u$1.gc("scrollable", true)
      },
      // 
      showScrollbar: {
        type: Boolean,
        default: u$1.gc("showScrollbar", true)
      },
      // 
      scrollX: {
        type: Boolean,
        default: u$1.gc("scrollX", false)
      },
      // iOSview
      scrollToTopBounceEnabled: {
        type: Boolean,
        default: u$1.gc("scrollToTopBounceEnabled", false)
      },
      // iOS
      scrollToBottomBounceEnabled: {
        type: Boolean,
        default: u$1.gc("scrollToBottomBounceEnabled", true)
      },
      // 
      scrollWithAnimation: {
        type: Boolean,
        default: u$1.gc("scrollWithAnimation", false)
      },
      // idid
      scrollIntoView: {
        type: String,
        default: u$1.gc("scrollIntoView", "")
      }
    },
    data() {
      return {
        scrollTop: 0,
        oldScrollTop: 0,
        scrollViewStyle: {},
        scrollViewContainerStyle: {},
        scrollViewInStyle: {},
        pageScrollTop: -1,
        scrollEnable: true,
        privateScrollWithAnimation: -1,
        cacheScrollNodeHeight: -1,
        superContentHeight: 0
      };
    },
    watch: {
      oldScrollTop(newVal) {
        !this.usePageScroll && this._scrollTopChange(newVal, false);
      },
      pageScrollTop(newVal) {
        this.usePageScroll && this._scrollTopChange(newVal, true);
      },
      usePageScroll: {
        handler(newVal) {
          this.loaded && this.autoHeight && this._setAutoHeight(!newVal);
        },
        immediate: true
      },
      finalScrollTop(newVal) {
        this.renderPropScrollTop = newVal < 6 ? 0 : 10;
      }
    },
    computed: {
      finalScrollWithAnimation() {
        if (this.privateScrollWithAnimation !== -1) {
          return this.privateScrollWithAnimation === 1;
        }
        return this.scrollWithAnimation;
      },
      finalScrollViewStyle() {
        if (this.superContentZIndex != 1) {
          this.scrollViewStyle["z-index"] = this.superContentZIndex;
          this.scrollViewStyle["position"] = "relative";
        }
        return this.scrollViewStyle;
      },
      finalScrollTop() {
        return this.usePageScroll ? this.pageScrollTop : this.oldScrollTop;
      },
      // webview
      finalIsOldWebView() {
        return this.isOldWebView && !this.usePageScroll;
      },
      // scroll-view/list-view
      finalScrollable() {
        return this.scrollable && !this.usePageScroll && this.scrollEnable && (this.refresherCompleteScrollable ? true : this.refresherStatus !== Enum.Refresher.Complete) && (this.refresherRefreshingScrollable ? true : this.refresherStatus !== Enum.Refresher.Loading);
      }
    },
    methods: {
      // animate
      scrollToTop(animate, checkReverse = true) {
        if (this.useChatRecordMode && checkReverse && !this.isChatRecordModeAndNotInversion) {
          this.scrollToBottom(animate, false);
          return;
        }
        this.$nextTick(() => {
          this._scrollToTop(animate, false);
        });
      },
      // animate
      scrollToBottom(animate, checkReverse = true) {
        if (this.useChatRecordMode && checkReverse && !this.isChatRecordModeAndNotInversion) {
          this.scrollToTop(animate, false);
          return;
        }
        this.$nextTick(() => {
          this._scrollToBottom(animate);
        });
      },
      // view(vue)selviewid"#"offsetpxanimate
      scrollIntoViewById(sel, offset2, animate) {
        this._scrollIntoView(sel, offset2, animate);
      },
      // view(vue)nodeTopviewtop(uni.createSelectorQuery())offsetpxanimate
      scrollIntoViewByNodeTop(nodeTop, offset2, animate) {
        this.scrollTop = this.oldScrollTop;
        this.$nextTick(() => {
          this._scrollIntoViewByNodeTop(nodeTop, offset2, animate);
        });
      },
      // (vue)ypxoffsetpxanimate
      scrollToY(y, offset2, animate) {
        this.scrollTop = this.oldScrollTop;
        this.$nextTick(() => {
          this._scrollToY(y, offset2, animate);
        });
      },
      // view(nvue)indexviewindex(0)offsetpxanimate
      scrollIntoViewByIndex(index2, offset2, animate) {
        if (index2 >= this.realTotalData.length) {
          u$1.consoleErr("indexrefreshToPageindex");
          return;
        }
        this.$nextTick(() => {
          if (this.finalUseVirtualList) {
            const isCellFixed = this.cellHeightMode === Enum.CellHeightMode.Fixed;
            u$1.delay(() => {
              if (this.finalUseVirtualList) {
                const scrollTop = isCellFixed ? this.virtualCellHeight * index2 : this.virtualHeightCacheList[index2].lastTotalHeight;
                this.scrollToY(scrollTop, offset2, animate);
              }
            }, isCellFixed ? 0 : 100);
          }
        });
      },
      // view(nvue)viewview(`this.$refs.xxx`)"#"offsetpxanimate
      scrollIntoViewByView(view, offset2, animate) {
        this._scrollIntoView(view, offset2, animate);
      },
      // onPageScrollz-pagingpageScrollTop
      updatePageScrollTop(value) {
        this.pageScrollTop = value;
      },
      // slot="top"slot="top"view
      updatePageScrollTopHeight() {
        this._updatePageScrollTopOrBottomHeight("top");
      },
      // slot="bottom"slot="bottom"view
      updatePageScrollBottomHeight() {
        this._updatePageScrollTopOrBottomHeight("bottom");
      },
      // slot="left"slot="right"slot="left"slot="right"
      updateLeftAndRightWidth() {
        if (!this.finalIsOldWebView)
          return;
        this.$nextTick(() => this._updateLeftAndRightWidth(this.scrollViewContainerStyle, "zp-page"));
      },
      // z-pagingscroll-viewscrollTop
      updateScrollViewScrollTop(scrollTop, animate = true) {
        this._updatePrivateScrollWithAnimation(animate);
        this.scrollTop = this.oldScrollTop;
        this.$nextTick(() => {
          this.scrollTop = scrollTop;
          this.oldScrollTop = this.scrollTop;
        });
      },
      // 
      _onScrollToUpper() {
        this.$emit("scrolltoupper");
        this.$emit("scrollTopChange", 0);
        this.$nextTick(() => {
          this.oldScrollTop = 0;
        });
      },
      // 
      _onScrollToLower(e2) {
        (!e2.detail || !e2.detail.direction || e2.detail.direction === "bottom") && this.toBottomLoadingMoreEnabled && this._onLoadingMore(this.useChatRecordMode ? "click" : "toBottom");
      },
      // 
      _scrollToTop(animate = true, isPrivate = true) {
        if (this.usePageScroll) {
          this.$nextTick(() => {
            uni.pageScrollTo({
              scrollTop: 0,
              duration: animate ? 100 : 0
            });
          });
          return;
        }
        this._updatePrivateScrollWithAnimation(animate);
        this.scrollTop = this.oldScrollTop;
        this.$nextTick(() => {
          this.scrollTop = 0;
          this.oldScrollTop = this.scrollTop;
        });
      },
      // 
      async _scrollToBottom(animate = true) {
        if (this.usePageScroll) {
          this.$nextTick(() => {
            uni.pageScrollTo({
              scrollTop: Number.MAX_VALUE,
              duration: animate ? 100 : 0
            });
          });
          return;
        }
        try {
          this._updatePrivateScrollWithAnimation(animate);
          const pagingContainerNode = await this._getNodeClientRect(".zp-paging-container");
          const scrollViewNode = await this._getNodeClientRect(".zp-scroll-view");
          const pagingContainerH = pagingContainerNode ? pagingContainerNode[0].height : 0;
          const scrollViewH = scrollViewNode ? scrollViewNode[0].height : 0;
          if (pagingContainerH > scrollViewH) {
            this.scrollTop = this.oldScrollTop;
            this.$nextTick(() => {
              this.scrollTop = pagingContainerH - scrollViewH + this.virtualPlaceholderTopHeight;
              this.oldScrollTop = this.scrollTop;
            });
          }
        } catch (e2) {
        }
      },
      // view
      _scrollIntoView(sel, offset2 = 0, animate = false, finishCallback) {
        try {
          this.scrollTop = this.oldScrollTop;
          this.$nextTick(() => {
            this._getNodeClientRect("#" + sel.replace("#", ""), this.$parent).then((node) => {
              if (node) {
                let nodeTop = node[0].top;
                this._scrollIntoViewByNodeTop(nodeTop, offset2, animate);
                finishCallback && finishCallback();
              }
            });
          });
        } catch (e2) {
        }
      },
      // nodeTopview
      _scrollIntoViewByNodeTop(nodeTop, offset2 = 0, animate = false) {
        if (this.isChatRecordModeAndInversion) {
          this._getNodeClientRect(".zp-scroll-view").then((sNode) => {
            if (sNode) {
              this._scrollToY(sNode[0].height - nodeTop, offset2, animate, true);
            }
          });
        } else {
          this._scrollToY(nodeTop, offset2, animate, true);
        }
      },
      // 
      _scrollToY(y, offset2 = 0, animate = false, addScrollTop = false) {
        this._updatePrivateScrollWithAnimation(animate);
        u$1.delay(() => {
          if (this.usePageScroll) {
            if (addScrollTop && this.pageScrollTop !== -1) {
              y += this.pageScrollTop;
            }
            const scrollTop = y - offset2;
            uni.pageScrollTo({
              scrollTop,
              duration: animate ? 100 : 0
            });
          } else {
            if (addScrollTop) {
              y += this.oldScrollTop;
            }
            this.scrollTop = y - offset2;
          }
        }, 10);
      },
      // scroll-view
      _scroll(e2) {
        this.$emit("scroll", e2);
        const scrollTop = e2.detail.scrollTop;
        this.finalUseVirtualList && this._updateVirtualScroll(scrollTop, this.oldScrollTop - scrollTop);
        this.oldScrollTop = scrollTop;
        const scrollDiff = e2.detail.scrollHeight - this.oldScrollTop;
        !this.isIos && this._checkScrolledToBottom(scrollDiff);
      },
      // scroll-view
      _updatePrivateScrollWithAnimation(animate) {
        this.privateScrollWithAnimation = animate ? 1 : 0;
        u$1.delay(() => this.$nextTick(() => {
          this.privateScrollWithAnimation = -1;
        }), 100, "updateScrollWithAnimationDelay");
      },
      // scrollView
      _doCheckScrollViewShouldFullHeight(totalData) {
        if (this.autoFullHeight && this.usePageScroll && this.isTotalChangeFromAddData) {
          this.$nextTick(() => {
            this._checkScrollViewShouldFullHeight((scrollViewNode, pagingContainerNode) => {
              this._preCheckShowNoMoreInside(totalData, scrollViewNode, pagingContainerNode);
            });
          });
        } else {
          this._preCheckShowNoMoreInside(totalData);
        }
      },
      // z-paging(z-pagingempty-view)
      async _checkScrollViewShouldFullHeight(callback) {
        try {
          const scrollViewNode = await this._getNodeClientRect(".zp-scroll-view");
          const pagingContainerNode = await this._getNodeClientRect(".zp-paging-container-content");
          if (!scrollViewNode || !pagingContainerNode)
            return;
          const scrollViewHeight = pagingContainerNode[0].height;
          const scrollViewTop = scrollViewNode[0].top;
          if (this.isAddedData && scrollViewHeight + scrollViewTop <= this.windowHeight) {
            this._setAutoHeight(true, scrollViewNode);
            callback(scrollViewNode, pagingContainerNode);
          } else {
            this._setAutoHeight(false);
            callback(null, null);
          }
        } catch (e2) {
          callback(null, null);
        }
      },
      // z-paging
      async _updateCachedSuperContentHeight() {
        const superContentNode = await this._getNodeClientRect(".z-paging-content");
        if (superContentNode) {
          this.superContentHeight = superContentNode[0].height;
        }
      },
      // scrollTop
      _scrollTopChange(newVal, isPageScrollTop) {
        this.$emit("scrollTopChange", newVal);
        this.$emit("update:scrollTop", newVal);
        this._checkShouldShowBackToTop(newVal);
        const scrollTop = newVal > 5 ? 6 : 0;
        if (isPageScrollTop && this.wxsPageScrollTop !== scrollTop) {
          this.wxsPageScrollTop = scrollTop;
        } else if (!isPageScrollTop && this.wxsScrollTop !== scrollTop) {
          this.wxsScrollTop = scrollTop;
          if (scrollTop > 6) {
            this.scrollEnable = true;
          }
        }
      },
      // slot="top""bottom"view
      _updatePageScrollTopOrBottomHeight(type) {
        if (!this.usePageScroll)
          return;
        this._doCheckScrollViewShouldFullHeight(this.realTotalData);
        const node = `.zp-page-${type}`;
        const marginText = `margin${type.slice(0, 1).toUpperCase() + type.slice(1)}`;
        let safeAreaInsetBottomAdd = this.safeAreaInsetBottom;
        this.$nextTick(() => {
          let delayTime = 0;
          u$1.delay(() => {
            this._getNodeClientRect(node).then((res) => {
              if (res) {
                let pageScrollNodeHeight = res[0].height;
                if (type === "bottom") {
                  if (safeAreaInsetBottomAdd) {
                    pageScrollNodeHeight += this.safeAreaBottom;
                  }
                } else {
                  this.cacheTopHeight = pageScrollNodeHeight;
                }
                this.$set(this.scrollViewStyle, marginText, `${pageScrollNodeHeight}px`);
              } else if (safeAreaInsetBottomAdd) {
                this.$set(this.scrollViewStyle, marginText, `${this.safeAreaBottom}px`);
              }
            });
          }, delayTime);
        });
      }
    }
  };
  const backToTopModule = {
    props: {
      // 
      autoShowBackToTop: {
        type: Boolean,
        default: u$1.gc("autoShowBackToTop", false)
      },
      // /()px400rpx
      backToTopThreshold: {
        type: [Number, String],
        default: u$1.gc("backToTopThreshold", "400rpx")
      },
      // z-paging
      backToTopImg: {
        type: String,
        default: u$1.gc("backToTopImg", "")
      },
      // 
      backToTopWithAnimate: {
        type: Boolean,
        default: u$1.gc("backToTopWithAnimate", true)
      },
      // pxrpx160rpx
      backToTopBottom: {
        type: [Number, String],
        default: u$1.gc("backToTopBottom", "160rpx")
      },
      // 
      backToTopStyle: {
        type: Object,
        default: u$1.gc("backToTopStyle", {})
      },
      // iOS
      enableBackToTop: {
        type: Boolean,
        default: u$1.gc("enableBackToTop", true)
      }
    },
    data() {
      return {
        // class
        backToTopClass: "zp-back-to-top zp-back-to-top-hide",
        // 
        lastBackToTopShowTime: 0,
        // class/
        showBackToTopClass: false
      };
    },
    computed: {
      backToTopThresholdUnitConverted() {
        return u$1.addUnit(this.backToTopThreshold, this.unit);
      },
      backToTopBottomUnitConverted() {
        return u$1.addUnit(this.backToTopBottom, this.unit);
      },
      finalEnableBackToTop() {
        return this.usePageScroll ? false : this.enableBackToTop;
      },
      finalBackToTopThreshold() {
        return u$1.convertToPx(this.backToTopThresholdUnitConverted);
      },
      finalBackToTopStyle() {
        const backToTopStyle = this.backToTopStyle;
        if (!backToTopStyle.bottom) {
          backToTopStyle.bottom = this.windowBottom + u$1.convertToPx(this.backToTopBottomUnitConverted) + "px";
        }
        if (!backToTopStyle.position) {
          backToTopStyle.position = this.usePageScroll ? "fixed" : "absolute";
        }
        return backToTopStyle;
      },
      finalBackToTopClass() {
        return `${this.backToTopClass} zp-back-to-top-${this.unit}`;
      }
    },
    methods: {
      // 
      _backToTopClick() {
        let callbacked = false;
        this.$emit("backToTopClick", (toTop) => {
          (toTop === void 0 || toTop === true) && this._handleToTop();
          callbacked = true;
        });
        this.$nextTick(() => {
          !callbacked && this._handleToTop();
        });
      },
      // 
      _handleToTop() {
        !this.backToTopWithAnimate && this._checkShouldShowBackToTop(0);
        !this.useChatRecordMode ? this.scrollToTop(this.backToTopWithAnimate) : this.scrollToBottom(this.backToTopWithAnimate);
      },
      // 
      _checkShouldShowBackToTop(scrollTop) {
        if (!this.autoShowBackToTop) {
          this.showBackToTopClass = false;
          return;
        }
        if (scrollTop > this.finalBackToTopThreshold) {
          if (!this.showBackToTopClass) {
            this.showBackToTopClass = true;
            this.lastBackToTopShowTime = (/* @__PURE__ */ new Date()).getTime();
            u$1.delay(() => {
              this.backToTopClass = "zp-back-to-top zp-back-to-top-show";
            }, 300);
          }
        } else {
          if (this.showBackToTopClass) {
            this.backToTopClass = "zp-back-to-top zp-back-to-top-hide";
            u$1.delay(() => {
              this.showBackToTopClass = false;
            }, (/* @__PURE__ */ new Date()).getTime() - this.lastBackToTopShowTime < 500 ? 0 : 300);
          }
        }
      }
    }
  };
  const virtualListModule = {
    props: {
      // 
      useVirtualList: {
        type: Boolean,
        default: u$1.gc("useVirtualList", false)
      },
      // 
      useCompatibilityMode: {
        type: Boolean,
        default: u$1.gc("useCompatibilityMode", false)
      },
      // 
      extraData: {
        type: Object,
        default: u$1.gc("extraData", {})
      },
      // z-paging()use-virtual-listtruetrue
      useInnerList: {
        type: Boolean,
        default: u$1.gc("useInnerList", false)
      },
      // inner-listfalsetrueinnerListinner-list
      forceCloseInnerList: {
        type: Boolean,
        default: u$1.gc("forceCloseInnerList", false)
      },
      // cellkeynvuenvueuse-inner-list
      cellKeyName: {
        type: String,
        default: u$1.gc("cellKeyName", "")
      },
      // innerList
      innerListStyle: {
        type: Object,
        default: u$1.gc("innerListStyle", {})
      },
      // innerCell
      innerCellStyle: {
        type: Object,
        default: u$1.gc("innerCellStyle", {})
      },
      // ()1212celldom()
      preloadPage: {
        type: [Number, String],
        default: u$1.gc("preloadPage", 12),
        validator: (value) => {
          if (value <= 0)
            u$1.consoleErr("preload-page0");
          return value > 0;
        }
      },
      // cellfixedcellcelldynamicdynamicfixed
      cellHeightMode: {
        type: String,
        default: u$1.gc("cellHeightMode", Enum.CellHeightMode.Fixed)
      },
      // cellcellHeightMode=fixedcellcell
      fixedCellHeight: {
        type: [Number, String],
        default: u$1.gc("fixedCellHeight", 0)
      },
      // 122
      virtualListCol: {
        type: [Number, String],
        default: u$1.gc("virtualListCol", 1)
      },
      // scroll80
      virtualScrollFps: {
        type: [Number, String],
        default: u$1.gc("virtualScrollFps", 80)
      }
    },
    data() {
      return {
        virtualListKey: u$1.getInstanceId(),
        virtualPageHeight: 0,
        virtualCellHeight: 0,
        virtualScrollTimeStamp: 0,
        virtualList: [],
        virtualPlaceholderTopHeight: 0,
        virtualPlaceholderBottomHeight: 0,
        virtualTopRangeIndex: 0,
        virtualBottomRangeIndex: 0,
        lastVirtualTopRangeIndex: 0,
        lastVirtualBottomRangeIndex: 0,
        virtualItemInsertedCount: 0,
        virtualHeightCacheList: [],
        getCellHeightRetryCount: {
          fixed: 0,
          dynamic: 0
        },
        pagingOrgTop: -1,
        updateVirtualListFromDataChange: false
      };
    },
    watch: {
      // 
      realTotalData() {
        this.updateVirtualListRender();
      },
      // emit
      virtualList(newVal) {
        this.$emit("update:virtualList", newVal);
        this.$emit("virtualListChange", newVal);
      },
      // emit
      virtualPlaceholderTopHeight(newVal) {
        this.$emit("virtualTopHeightChange", newVal);
      }
    },
    computed: {
      virtualCellIndexKey() {
        return c$1.listCellIndexKey;
      },
      finalUseVirtualList() {
        if (this.useVirtualList && this.usePageScroll) {
          u$1.consoleErr("");
        }
        return this.useVirtualList && !this.usePageScroll;
      },
      finalUseInnerList() {
        return this.useInnerList || this.finalUseVirtualList && !this.forceCloseInnerList;
      },
      finalCellKeyName() {
        return this.cellKeyName;
      },
      finalVirtualPageHeight() {
        return this.virtualPageHeight > 0 ? this.virtualPageHeight : this.windowHeight;
      },
      finalFixedCellHeight() {
        return u$1.convertToPx(this.fixedCellHeight);
      },
      virtualRangePageHeight() {
        return this.finalVirtualPageHeight * this.preloadPage;
      },
      virtualScrollDisTimeStamp() {
        return 1e3 / this.virtualScrollFps;
      }
    },
    methods: {
      // itemitem:itemindex:cellindex2itemlistindex=1index0
      doInsertVirtualListItem(item, index2) {
        if (this.cellHeightMode !== Enum.CellHeightMode.Dynamic)
          return;
        this.virtualItemInsertedCount++;
        if (!item || Object.prototype.toString.call(item) !== "[object Object]") {
          item = { item };
        }
        const cellIndexKey = this.virtualCellIndexKey;
        item[cellIndexKey] = `custom-${this.virtualItemInsertedCount}`;
        item[c$1.listCellIndexUniqueKey] = `${this.virtualListKey}-${item[cellIndexKey]}`;
        this.$nextTick(async () => {
          let retryCount = 0;
          while (retryCount <= 10) {
            await u$1.wait(c$1.delayTime);
            const cellNode = await this._getNodeClientRect(`#zp-id-${item[cellIndexKey]}`, this.finalUseInnerList);
            if (!cellNode) {
              retryCount++;
              continue;
            }
            const currentHeight = cellNode ? cellNode[0].height : 0;
            const lastHeightCache = this.virtualHeightCacheList[index2 - 1];
            const lastTotalHeight = lastHeightCache ? lastHeightCache.totalHeight : 0;
            this.virtualHeightCacheList.splice(index2, 0, {
              height: currentHeight,
              lastTotalHeight,
              totalHeight: lastTotalHeight + currentHeight
            });
            for (let i2 = index2 + 1; i2 < this.virtualHeightCacheList.length; i2++) {
              const thisNode = this.virtualHeightCacheList[i2];
              thisNode.lastTotalHeight += currentHeight;
              thisNode.totalHeight += currentHeight;
            }
            this._updateVirtualScroll(this.oldScrollTop);
            break;
          }
        });
      },
      // cell(cell)index:cell0
      didUpdateVirtualListCell(index2) {
        if (this.cellHeightMode !== Enum.CellHeightMode.Dynamic)
          return;
        const currentNode = this.virtualHeightCacheList[index2];
        this.$nextTick(() => {
          this._getNodeClientRect(`#zp-id-${index2}`, this.finalUseInnerList).then((cellNode) => {
            const cellNodeHeight = cellNode ? cellNode[0].height : 0;
            const heightDis = cellNodeHeight - currentNode.height;
            currentNode.height = cellNodeHeight;
            currentNode.totalHeight = currentNode.lastTotalHeight + cellNodeHeight;
            for (let i2 = index2 + 1; i2 < this.virtualHeightCacheList.length; i2++) {
              const thisNode = this.virtualHeightCacheList[i2];
              thisNode.totalHeight += heightDis;
              thisNode.lastTotalHeight += heightDis;
            }
          });
        });
      },
      // itemindex:cell0
      didDeleteVirtualListCell(index2) {
        if (this.cellHeightMode !== Enum.CellHeightMode.Dynamic)
          return;
        const currentNode = this.virtualHeightCacheList[index2];
        for (let i2 = index2 + 1; i2 < this.virtualHeightCacheList.length; i2++) {
          const thisNode = this.virtualHeightCacheList[i2];
          thisNode.totalHeight -= currentNode.height;
          thisNode.lastTotalHeight -= currentNode.height;
        }
        this.virtualHeightCacheList.splice(index2, 1);
      },
      // 
      updateVirtualListRender() {
        if (this.finalUseVirtualList) {
          this.updateVirtualListFromDataChange = true;
          this.$nextTick(() => {
            this.getCellHeightRetryCount.fixed = 0;
            if (this.realTotalData.length) {
              this.cellHeightMode === Enum.CellHeightMode.Fixed && this.isFirstPage && this._updateFixedCellHeight();
            } else {
              this._resetDynamicListState(!this.isUserPullDown);
            }
            this._updateVirtualScroll(this.oldScrollTop);
          });
        }
      },
      // 
      _virtualListInit() {
        this.$nextTick(() => {
          u$1.delay(() => {
            this._getNodeClientRect(".zp-scroll-view").then((node) => {
              if (node) {
                this.pagingOrgTop = node[0].top;
                this.virtualPageHeight = node[0].height;
              }
            });
          });
        });
      },
      // cellHeightModefixedcell
      _updateFixedCellHeight() {
        if (!this.finalFixedCellHeight) {
          this.$nextTick(() => {
            u$1.delay(() => {
              this._getNodeClientRect(`#zp-id-${0}`, this.finalUseInnerList).then((cellNode) => {
                if (!cellNode) {
                  if (this.getCellHeightRetryCount.fixed > 10)
                    return;
                  this.getCellHeightRetryCount.fixed++;
                  this._updateFixedCellHeight();
                } else {
                  this.virtualCellHeight = cellNode[0].height;
                  this._updateVirtualScroll(this.oldScrollTop);
                }
              });
            }, c$1.delayTime, "updateFixedCellHeightDelay");
          });
        } else {
          this.virtualCellHeight = this.finalFixedCellHeight;
        }
      },
      // cellHeightModedynamiccell
      _updateDynamicCellHeight(list, dataFrom = "bottom") {
        const dataFromTop = dataFrom === "top";
        const heightCacheList = this.virtualHeightCacheList;
        const currentCacheList = dataFromTop ? [] : heightCacheList;
        let listTotalHeight = 0;
        this.$nextTick(() => {
          u$1.delay(async () => {
            for (let i2 = 0; i2 < list.length; i2++) {
              const cellNode = await this._getNodeClientRect(`#zp-id-${list[i2][this.virtualCellIndexKey]}`, this.finalUseInnerList);
              const currentHeight = cellNode ? cellNode[0].height : 0;
              if (!cellNode) {
                if (this.getCellHeightRetryCount.dynamic <= 10) {
                  heightCacheList.splice(heightCacheList.length - i2, i2);
                  this.getCellHeightRetryCount.dynamic++;
                  this._updateDynamicCellHeight(list, dataFrom);
                }
                return;
              }
              const lastHeightCache = currentCacheList.length ? currentCacheList.slice(-1)[0] : null;
              const lastTotalHeight = lastHeightCache ? lastHeightCache.totalHeight : 0;
              currentCacheList.push({
                height: currentHeight,
                lastTotalHeight,
                totalHeight: lastTotalHeight + currentHeight
              });
              if (dataFromTop) {
                listTotalHeight += currentHeight;
              }
            }
            if (dataFromTop && list.length) {
              for (let i2 = 0; i2 < heightCacheList.length; i2++) {
                const heightCacheItem = heightCacheList[i2];
                heightCacheItem.lastTotalHeight += listTotalHeight;
                heightCacheItem.totalHeight += listTotalHeight;
              }
              this.virtualHeightCacheList = currentCacheList.concat(heightCacheList);
            }
            this._updateVirtualScroll(this.oldScrollTop);
          }, c$1.delayTime, "updateDynamicCellHeightDelay");
        });
      },
      // cellItemindex
      _setCellIndex(list, dataFrom = "bottom") {
        let currentItemIndex = 0;
        const cellIndexKey = this.virtualCellIndexKey;
        [Enum.QueryFrom.Refresh, Enum.QueryFrom.Reload].indexOf(this.queryFrom) >= 0 && this._resetDynamicListState();
        if (this.totalData.length) {
          if (dataFrom === "bottom") {
            currentItemIndex = this.realTotalData.length;
            const lastItem = this.realTotalData.length ? this.realTotalData.slice(-1)[0] : null;
            if (lastItem && lastItem[cellIndexKey] !== void 0) {
              currentItemIndex = lastItem[cellIndexKey] + 1;
            }
          } else if (dataFrom === "top") {
            const firstItem = this.realTotalData.length ? this.realTotalData[0] : null;
            if (firstItem && firstItem[cellIndexKey] !== void 0) {
              currentItemIndex = firstItem[cellIndexKey] - list.length;
            }
          }
        } else {
          this._resetDynamicListState();
        }
        for (let i2 = 0; i2 < list.length; i2++) {
          let item = list[i2];
          if (!item || Object.prototype.toString.call(item) !== "[object Object]") {
            item = { item };
          }
          if (item[c$1.listCellIndexUniqueKey]) {
            item = u$1.deepCopy(item);
          }
          item[cellIndexKey] = currentItemIndex + i2;
          item[c$1.listCellIndexUniqueKey] = `${this.virtualListKey}-${item[cellIndexKey]}`;
          list[i2] = item;
        }
        this.getCellHeightRetryCount.dynamic = 0;
        this.cellHeightMode === Enum.CellHeightMode.Dynamic && this._updateDynamicCellHeight(list, dataFrom);
      },
      // scroll
      _updateVirtualScroll(scrollTop, scrollDiff = 0) {
        const currentTimeStamp = u$1.getTime();
        scrollTop === 0 && this._resetTopRange();
        if (scrollTop !== 0 && this.virtualScrollTimeStamp && currentTimeStamp - this.virtualScrollTimeStamp <= this.virtualScrollDisTimeStamp) {
          return;
        }
        this.virtualScrollTimeStamp = currentTimeStamp;
        let scrollIndex = 0;
        const cellHeightMode = this.cellHeightMode;
        if (cellHeightMode === Enum.CellHeightMode.Fixed) {
          scrollIndex = parseInt(scrollTop / this.virtualCellHeight) || 0;
          this._updateFixedTopRangeIndex(scrollIndex);
          this._updateFixedBottomRangeIndex(scrollIndex);
        } else if (cellHeightMode === Enum.CellHeightMode.Dynamic) {
          const scrollDirection = scrollDiff > 0 ? "top" : "bottom";
          const rangePageHeight = this.virtualRangePageHeight;
          const topRangePageOffset = scrollTop - rangePageHeight;
          const bottomRangePageOffset = scrollTop + this.finalVirtualPageHeight + rangePageHeight;
          let virtualBottomRangeIndex = 0;
          let virtualPlaceholderBottomHeight = 0;
          let reachedLimitBottom = false;
          const heightCacheList = this.virtualHeightCacheList;
          const lastHeightCache = !!heightCacheList ? heightCacheList.slice(-1)[0] : null;
          let startTopRangeIndex = this.virtualTopRangeIndex;
          if (scrollDirection === "bottom") {
            for (let i2 = startTopRangeIndex; i2 < heightCacheList.length; i2++) {
              const heightCacheItem = heightCacheList[i2];
              if (heightCacheItem && heightCacheItem.totalHeight > topRangePageOffset) {
                this.virtualTopRangeIndex = i2;
                this.virtualPlaceholderTopHeight = heightCacheItem.lastTotalHeight;
                break;
              }
            }
          } else {
            let topRangeMatched = false;
            for (let i2 = startTopRangeIndex; i2 >= 0; i2--) {
              const heightCacheItem = heightCacheList[i2];
              if (heightCacheItem && heightCacheItem.totalHeight < topRangePageOffset) {
                this.virtualTopRangeIndex = i2;
                this.virtualPlaceholderTopHeight = heightCacheItem.lastTotalHeight;
                topRangeMatched = true;
                break;
              }
            }
            !topRangeMatched && this._resetTopRange();
          }
          for (let i2 = this.virtualTopRangeIndex; i2 < heightCacheList.length; i2++) {
            const heightCacheItem = heightCacheList[i2];
            if (heightCacheItem && heightCacheItem.totalHeight > bottomRangePageOffset) {
              virtualBottomRangeIndex = i2;
              virtualPlaceholderBottomHeight = lastHeightCache.totalHeight - heightCacheItem.totalHeight;
              reachedLimitBottom = true;
              break;
            }
          }
          if (!reachedLimitBottom || this.virtualBottomRangeIndex === 0) {
            this.virtualBottomRangeIndex = this.realTotalData.length ? this.realTotalData.length - 1 : this.pageSize;
            this.virtualPlaceholderBottomHeight = 0;
          } else {
            this.virtualBottomRangeIndex = virtualBottomRangeIndex;
            this.virtualPlaceholderBottomHeight = virtualPlaceholderBottomHeight;
          }
          this._updateVirtualList();
        }
      },
      // fixedCelltopRangeIndex&placeholderTopHeight
      _updateFixedTopRangeIndex(scrollIndex) {
        let virtualTopRangeIndex = this.virtualCellHeight === 0 ? 0 : scrollIndex - (parseInt(this.finalVirtualPageHeight / this.virtualCellHeight) || 1) * this.preloadPage;
        virtualTopRangeIndex *= this.virtualListCol;
        virtualTopRangeIndex = Math.max(0, virtualTopRangeIndex);
        this.virtualTopRangeIndex = virtualTopRangeIndex;
        this.virtualPlaceholderTopHeight = virtualTopRangeIndex / this.virtualListCol * this.virtualCellHeight;
      },
      // fixedCellbottomRangeIndex&placeholderBottomHeight
      _updateFixedBottomRangeIndex(scrollIndex) {
        let virtualBottomRangeIndex = this.virtualCellHeight === 0 ? this.pageSize : scrollIndex + (parseInt(this.finalVirtualPageHeight / this.virtualCellHeight) || 1) * (this.preloadPage + 1);
        virtualBottomRangeIndex *= this.virtualListCol;
        virtualBottomRangeIndex = Math.min(this.realTotalData.length, virtualBottomRangeIndex);
        this.virtualBottomRangeIndex = virtualBottomRangeIndex;
        this.virtualPlaceholderBottomHeight = (this.realTotalData.length - virtualBottomRangeIndex) * this.virtualCellHeight / this.virtualListCol;
        this._updateVirtualList();
      },
      // virtualList
      _updateVirtualList() {
        const shouldUpdateList = this.updateVirtualListFromDataChange || (this.lastVirtualTopRangeIndex !== this.virtualTopRangeIndex || this.lastVirtualBottomRangeIndex !== this.virtualBottomRangeIndex);
        if (shouldUpdateList) {
          this.updateVirtualListFromDataChange = false;
          this.lastVirtualTopRangeIndex = this.virtualTopRangeIndex;
          this.lastVirtualBottomRangeIndex = this.virtualBottomRangeIndex;
          this.virtualList = this.realTotalData.slice(this.virtualTopRangeIndex, this.virtualBottomRangeIndex + 1);
        }
      },
      // cell
      _resetDynamicListState(resetVirtualList = false) {
        this.virtualHeightCacheList = [];
        if (resetVirtualList) {
          this.virtualList = [];
        }
        this.virtualTopRangeIndex = 0;
        this.virtualPlaceholderTopHeight = 0;
      },
      // topRangeIndexplaceholderTopHeight
      _resetTopRange() {
        this.virtualTopRangeIndex = 0;
        this.virtualPlaceholderTopHeight = 0;
        this._updateVirtualList();
      },
      // (AppApp)
      _checkVirtualListScroll() {
        if (this.finalUseVirtualList) {
          this.$nextTick(() => {
            this._getNodeClientRect(".zp-paging-touch-view").then((node) => {
              const currentTop = node ? node[0].top : 0;
              if (!node || currentTop === this.pagingOrgTop && this.virtualPlaceholderTopHeight !== 0) {
                this._updateVirtualScroll(0);
              }
            });
          });
        }
      },
      // cell
      _innerCellClick(item, index2) {
        this.$emit("innerCellClick", item, index2);
      }
    }
  };
  const systemInfo = uni.getSystemInfoSync();
  const _sfc_main$d = {
    name: "z-paging",
    components: {
      zPagingRefresh,
      zPagingLoadMore,
      zPagingEmptyView: __easycom_0$1
    },
    mixins: [
      commonLayoutModule,
      dataHandleModule,
      i18nModule,
      nvueModule,
      emptyModule,
      refresherModule,
      loadMoreModule,
      loadingModule,
      chatRecordModerModule,
      scrollerModule,
      backToTopModule,
      virtualListModule
    ],
    data() {
      return {
        // -----------------------------
        base64Arrow: zStatic.base64Arrow,
        base64Flower: zStatic.base64Flower,
        base64BackToTop: zStatic.base64BackToTop,
        // ---------------------------
        // 
        loadingType: Enum.LoadingType.Refresher,
        requestTimeStamp: 0,
        wxsPropType: "",
        renderPropScrollTop: -1,
        checkScrolledToBottomTimeOut: null,
        cacheTopHeight: -1,
        statusBarHeight: systemInfo.statusBarHeight,
        // --------------&---------------
        insideOfPaging: -1,
        isLoadFailed: false,
        isIos: systemInfo.platform === "ios",
        disabledBounce: false,
        fromCompleteEmit: false,
        disabledCompleteEmit: false,
        pageLaunched: false,
        active: false,
        // ---------------wxs---------------
        wxsIsScrollTopInTopRange: true,
        wxsScrollTop: 0,
        wxsPageScrollTop: 0,
        wxsOnPullingDown: false
      };
    },
    props: {
      // complete0minDelay
      delay: {
        type: [Number, String],
        default: u$1.gc("delay", 0)
      },
      // @query0delay300300complete[300-]300show-refresher-when-reloadtruereload(true)400
      minDelay: {
        type: [Number, String],
        default: u$1.gc("minDelay", 0)
      },
      // z-pagingstyle()style
      pagingStyle: {
        type: Object,
        default: u$1.gc("pagingStyle", {})
      },
      // z-pagingpagingStyleheight100px100rpx100%
      height: {
        type: String,
        default: u$1.gc("height", "")
      },
      // z-pagingpagingStylewidth100px100rpx100%
      width: {
        type: String,
        default: u$1.gc("width", "")
      },
      // z-pagingpagingStylemax-width100px100rpx100%margin: 0 auto
      maxWidth: {
        type: String,
        default: u$1.gc("maxWidth", "")
      },
      // z-pagingpagingStylebackground"#ffffff"
      bgColor: {
        type: String,
        default: u$1.gc("bgColor", "")
      },
      // z-paging(view)style
      pagingContentStyle: {
        type: Object,
        default: u$1.gc("pagingContentStyle", {})
      },
      // z-paging
      autoHeight: {
        type: Boolean,
        default: u$1.gc("autoHeight", false)
      },
      // z-pagingpxrpx
      autoHeightAddition: {
        type: [Number, String],
        default: u$1.gc("autoHeightAddition", "0px")
      },
      // loading()blackwhiteblack
      defaultThemeStyle: {
        type: String,
        default: u$1.gc("defaultThemeStyle", "black")
      },
      // z-pagingfixedfixedz-pagingviewz-paging100%(scroll-view)
      fixed: {
        type: Boolean,
        default: u$1.gc("fixed", true)
      },
      // 
      safeAreaInsetBottom: {
        type: Boolean,
        default: u$1.gc("safeAreaInsetBottom", false)
      },
      // placeholder
      useSafeAreaPlaceholder: {
        type: Boolean,
        default: u$1.gc("useSafeAreaPlaceholder", false)
      },
      // z-paging bottom"#ffffff"
      bottomBgColor: {
        type: String,
        default: u$1.gc("bottomBgColor", "")
      },
      // slot="top"viewz-index99
      topZIndex: {
        type: Number,
        default: u$1.gc("topZIndex", 99)
      },
      // z-pagingviewz-index1
      superContentZIndex: {
        type: Number,
        default: u$1.gc("superContentZIndex", 1)
      },
      // z-pagingz-index1
      contentZIndex: {
        type: Number,
        default: u$1.gc("contentZIndex", 1)
      },
      // z-pagingz-index100
      f2ZIndex: {
        type: Number,
        default: u$1.gc("f2ZIndex", 100)
      },
      // 
      autoFullHeight: {
        type: Boolean,
        default: u$1.gc("autoFullHeight", true)
      },
      // 
      watchTouchDirectionChange: {
        type: Boolean,
        default: u$1.gc("watchTouchDirectionChange", false)
      },
      // z-pagingrpx
      unit: {
        type: String,
        default: u$1.gc("unit", "rpx")
      }
    },
    created() {
      if (this.createdReload && !this.refresherOnly && this.auto) {
        this._startLoading();
        this.$nextTick(this._preReload);
      }
    },
    mounted() {
      this.active = true;
      this.wxsPropType = u$1.getTime().toString();
      this.renderJsIgnore;
      if (!this.createdReload && !this.refresherOnly && this.auto) {
        u$1.delay(() => this.$nextTick(this._preReload), 0);
      }
      this.finalUseCache && this._setListByLocalCache();
      this.$nextTick(() => {
        this.systemInfo = uni.getSystemInfoSync();
        !this.usePageScroll && this.autoHeight && this._setAutoHeight();
        this.loaded = true;
        u$1.delay(() => {
          this.updateFixedLayout();
          this._updateCachedSuperContentHeight();
        });
      });
      this.updatePageScrollTopHeight();
      this.updatePageScrollBottomHeight();
      this.updateLeftAndRightWidth();
      if (this.finalRefresherEnabled && this.useCustomRefresher) {
        this.$nextTick(() => {
          this.isTouchmoving = true;
        });
      }
      this._onEmit();
      this.finalUseVirtualList && this._virtualListInit();
    },
    destroyed() {
      this._handleUnmounted();
    },
    unmounted() {
      this._handleUnmounted();
    },
    watch: {
      defaultThemeStyle: {
        handler(newVal) {
          if (newVal.length) {
            this.finalRefresherDefaultStyle = newVal;
          }
        },
        immediate: true
      },
      autoHeight(newVal) {
        this.loaded && !this.usePageScroll && this._setAutoHeight(newVal);
      },
      autoHeightAddition(newVal) {
        this.loaded && !this.usePageScroll && this.autoHeight && this._setAutoHeight(newVal);
      }
    },
    computed: {
      // z-paging
      finalPagingStyle() {
        const pagingStyle = { ...this.pagingStyle };
        if (!this.systemInfo)
          return pagingStyle;
        const { windowTop, windowBottom } = this;
        if (!this.usePageScroll && this.fixed) {
          if (windowTop && !pagingStyle.top) {
            pagingStyle.top = windowTop + "px";
          }
          if (windowBottom && !pagingStyle.bottom) {
            pagingStyle.bottom = windowBottom + "px";
          }
        }
        if (this.bgColor.length && !pagingStyle["background"]) {
          pagingStyle["background"] = this.bgColor;
        }
        if (this.height.length && !pagingStyle["height"]) {
          pagingStyle["height"] = this.height;
        }
        if (this.width.length && !pagingStyle["width"]) {
          pagingStyle["width"] = this.width;
        }
        if (this.maxWidth.length && !pagingStyle["max-width"]) {
          pagingStyle["max-width"] = this.maxWidth;
          pagingStyle["margin"] = "0 auto";
        }
        return pagingStyle;
      },
      // z-paging
      finalPagingContentStyle() {
        if (this.contentZIndex != 1) {
          this.pagingContentStyle["z-index"] = this.contentZIndex;
          this.pagingContentStyle["position"] = "relative";
        }
        return this.pagingContentStyle;
      },
      renderJsIgnore() {
        if (this.usePageScroll && this.useChatRecordMode || !this.refresherEnabled && this.scrollable || !this.useCustomRefresher) {
          this.$nextTick(() => {
            this.renderPropScrollTop = 10;
          });
        }
        return 0;
      },
      windowHeight() {
        if (!this.systemInfo)
          return 0;
        return this.systemInfo.windowHeight || 0;
      },
      windowBottom() {
        if (!this.systemInfo)
          return 0;
        let windowBottom = this.systemInfo.windowBottom || 0;
        if (this.safeAreaInsetBottom && !this.useSafeAreaPlaceholder && !this.useChatRecordMode) {
          windowBottom += this.safeAreaBottom;
        }
        return windowBottom;
      },
      isIosAndH5() {
        return false;
      }
    },
    methods: {
      // 
      getVersion() {
        return `z-paging v${c$1.version}`;
      },
      // nvue ListspecialEffects
      setSpecialEffects(args) {
        this.setListSpecialEffects(args);
      },
      // setSpecialEffects
      setListSpecialEffects(args) {
        this.nFixFreezing = args && Object.keys(args).length;
        if (this.isIos) {
          this.privateRefresherEnabled = 0;
        }
        !this.usePageScroll && this.$refs["zp-n-list"].setSpecialEffects(args);
      },
      // appapp
      _handlePageLaunch() {
        if (this.pageLaunched) {
          this.refresherThresholdUpdateTag = 1;
          this.$nextTick(() => {
            this.refresherThresholdUpdateTag = 0;
          });
          this._checkVirtualListScroll();
        }
        this.pageLaunched = true;
      },
      // 15ms
      _doVibrateShort() {
        if (this.isIos) {
          const UISelectionFeedbackGenerator = plus.ios.importClass("UISelectionFeedbackGenerator");
          const feedbackGenerator = new UISelectionFeedbackGenerator();
          feedbackGenerator.init();
          setTimeout(() => {
            feedbackGenerator.selectionChanged();
          }, 0);
        } else {
          plus.device.vibrate(15);
        }
      },
      // z-paging
      async _setAutoHeight(shouldFullHeight = true, scrollViewNode = null) {
        let heightKey = "min-height";
        heightKey = "min-height";
        try {
          if (shouldFullHeight) {
            let finalScrollViewNode = scrollViewNode || await this._getNodeClientRect(".zp-scroll-view");
            let finalScrollBottomNode = await this._getNodeClientRect(".zp-page-bottom");
            if (finalScrollViewNode) {
              const scrollViewTop = finalScrollViewNode[0].top;
              let scrollViewHeight = this.windowHeight - scrollViewTop;
              scrollViewHeight -= finalScrollBottomNode ? finalScrollBottomNode[0].height : 0;
              const additionHeight = u$1.convertToPx(this.autoHeightAddition);
              const finalHeight = scrollViewHeight + additionHeight - (this.insideMore ? 1 : 0) + "px !important";
              this.$set(this.scrollViewStyle, heightKey, finalHeight);
              this.$set(this.scrollViewInStyle, heightKey, finalHeight);
            }
          } else {
            this.$delete(this.scrollViewStyle, heightKey);
            this.$delete(this.scrollViewInStyle, heightKey);
          }
        } catch (e2) {
        }
      },
      // 
      _handleUnmounted() {
        this.active = false;
        this._offEmit();
        this.useChatRecordMode && uni.offKeyboardHeightChange(this._handleKeyboardHeightChange);
      },
      // 
      _updateInsideOfPaging() {
        this.insideMore && this.insideOfPaging === true && setTimeout(this.doLoadMore, 200);
      },
      // timeout
      _cleanTimeout(timeout2) {
        if (timeout2) {
          clearTimeout(timeout2);
          timeout2 = null;
        }
        return timeout2;
      },
      // emit
      _onEmit() {
        uni.$on(c$1.errorUpdateKey, (errorMsg) => {
          if (this.loading) {
            if (!!errorMsg) {
              this.customerEmptyViewErrorText = errorMsg;
            }
            this.complete(false).catch(() => {
            });
          }
        });
        uni.$on(c$1.completeUpdateKey, (data) => {
          setTimeout(() => {
            if (this.loading) {
              if (!this.disabledCompleteEmit) {
                const type = data.type || "normal";
                const list = data.list || data;
                const rule = data.rule;
                this.fromCompleteEmit = true;
                switch (type) {
                  case "normal":
                    this.complete(list);
                    break;
                  case "total":
                    this.completeByTotal(list, rule);
                    break;
                  case "nomore":
                    this.completeByNoMore(list, rule);
                    break;
                  case "key":
                    this.completeByKey(list, rule);
                    break;
                }
              } else {
                this.disabledCompleteEmit = false;
              }
            }
          }, 1);
        });
      },
      // emitlistener
      _offEmit() {
        uni.$off(c$1.errorUpdateKey);
        uni.$off(c$1.completeUpdateKey);
      }
    }
  };
  const block0 = (Comp) => {
    (Comp.$wxs || (Comp.$wxs = [])).push("pagingWxs");
    (Comp.$wxsModules || (Comp.$wxsModules = {}))["pagingWxs"] = "1bc91ffb";
  };
  const block1 = (Comp) => {
    (Comp.$renderjs || (Comp.$renderjs = [])).push("pagingRenderjs");
    (Comp.$renderjsModules || (Comp.$renderjsModules = {}))["pagingRenderjs"] = "e35e5c7c";
  };
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_z_paging_refresh = vue.resolveComponent("z-paging-refresh");
    const _component_z_paging_load_more = vue.resolveComponent("z-paging-load-more");
    const _component_z_paging_empty_view = resolveEasycom(vue.resolveDynamicComponent("z-paging-empty-view"), __easycom_0$1);
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass({ "z-paging-content": true, "z-paging-content-full": !_ctx.usePageScroll, "z-paging-content-fixed": !_ctx.usePageScroll && _ctx.fixed, "z-paging-content-page": _ctx.usePageScroll, "z-paging-reached-top": _ctx.renderPropScrollTop < 1, "z-paging-use-chat-record-mode": _ctx.useChatRecordMode }),
        style: vue.normalizeStyle([_ctx.finalPagingStyle])
      },
      [
        vue.createCommentVNode(" view "),
        _ctx.showF2 && _ctx.showRefresherF2 ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 0,
            onTouchmove: _cache[0] || (_cache[0] = vue.withModifiers(() => {
            }, ["stop", "prevent"])),
            class: "zp-f2-content",
            style: vue.normalizeStyle([{ "transform": _ctx.f2Transform, "transition": `transform .2s linear`, "height": _ctx.superContentHeight + "px", "z-index": _ctx.f2ZIndex }])
          },
          [
            vue.renderSlot(_ctx.$slots, "f2", {}, void 0, true)
          ],
          36
          /* STYLE, NEED_HYDRATION */
        )) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode(" slot "),
        !_ctx.usePageScroll && _ctx.zSlots.top ? vue.renderSlot(_ctx.$slots, "top", { key: 1 }, void 0, true) : _ctx.usePageScroll && _ctx.zSlots.top ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 2,
            class: "zp-page-top",
            onTouchmove: _cache[1] || (_cache[1] = vue.withModifiers(() => {
            }, ["stop", "prevent"])),
            style: vue.normalizeStyle([{ "top": `${_ctx.windowTop}px`, "z-index": _ctx.topZIndex }])
          },
          [
            vue.renderSlot(_ctx.$slots, "top", {}, void 0, true)
          ],
          36
          /* STYLE, NEED_HYDRATION */
        )) : vue.createCommentVNode("v-if", true),
        vue.createElementVNode(
          "view",
          {
            class: vue.normalizeClass({ "zp-view-super": true, "zp-scroll-view-super": !_ctx.usePageScroll }),
            style: vue.normalizeStyle([_ctx.finalScrollViewStyle])
          },
          [
            _ctx.zSlots.left ? (vue.openBlock(), vue.createElementBlock(
              "view",
              {
                key: 0,
                class: vue.normalizeClass({ "zp-page-left": true, "zp-absoulte": _ctx.finalIsOldWebView })
              },
              [
                vue.renderSlot(_ctx.$slots, "left", {}, void 0, true)
              ],
              2
              /* CLASS */
            )) : vue.createCommentVNode("v-if", true),
            vue.createElementVNode(
              "view",
              {
                class: vue.normalizeClass({ "zp-scroll-view-container": true, "zp-absoulte": _ctx.finalIsOldWebView }),
                style: vue.normalizeStyle([_ctx.scrollViewContainerStyle])
              },
              [
                vue.createElementVNode("scroll-view", {
                  ref: "zp-scroll-view",
                  class: vue.normalizeClass({ "zp-scroll-view": true, "zp-scroll-view-absolute": !_ctx.usePageScroll, "zp-scroll-view-hide-scrollbar": !_ctx.showScrollbar }),
                  style: vue.normalizeStyle([_ctx.chatRecordRotateStyle]),
                  "scroll-top": _ctx.scrollTop,
                  "scroll-x": _ctx.scrollX,
                  "scroll-y": _ctx.finalScrollable,
                  "enable-back-to-top": _ctx.finalEnableBackToTop,
                  "show-scrollbar": _ctx.showScrollbar,
                  "scroll-with-animation": _ctx.finalScrollWithAnimation,
                  "scroll-into-view": _ctx.scrollIntoView,
                  "lower-threshold": _ctx.finalLowerThreshold,
                  "upper-threshold": 5,
                  "refresher-enabled": _ctx.finalRefresherEnabled && !_ctx.useCustomRefresher,
                  "refresher-threshold": _ctx.finalRefresherThreshold,
                  "refresher-default-style": _ctx.finalRefresherDefaultStyle,
                  "refresher-background": _ctx.refresherBackground,
                  "refresher-triggered": _ctx.finalRefresherTriggered,
                  onScroll: _cache[12] || (_cache[12] = (...args) => _ctx._scroll && _ctx._scroll(...args)),
                  onScrolltolower: _cache[13] || (_cache[13] = (...args) => _ctx._onScrollToLower && _ctx._onScrollToLower(...args)),
                  onScrolltoupper: _cache[14] || (_cache[14] = (...args) => _ctx._onScrollToUpper && _ctx._onScrollToUpper(...args)),
                  onRefresherrestore: _cache[15] || (_cache[15] = (...args) => _ctx._onRestore && _ctx._onRestore(...args)),
                  onRefresherrefresh: _cache[16] || (_cache[16] = ($event) => _ctx._onRefresh(true))
                }, [
                  vue.createElementVNode(
                    "view",
                    {
                      class: "zp-paging-touch-view",
                      onTouchstart: _cache[4] || (_cache[4] = (...args) => _ctx.pagingWxs.touchstart && _ctx.pagingWxs.touchstart(...args)),
                      onTouchmove: _cache[5] || (_cache[5] = (...args) => _ctx.pagingWxs.touchmove && _ctx.pagingWxs.touchmove(...args)),
                      onTouchend: _cache[6] || (_cache[6] = (...args) => _ctx.pagingWxs.touchend && _ctx.pagingWxs.touchend(...args)),
                      onTouchcancel: _cache[7] || (_cache[7] = (...args) => _ctx.pagingWxs.touchend && _ctx.pagingWxs.touchend(...args)),
                      onMousedown: _cache[8] || (_cache[8] = (...args) => _ctx.pagingWxs.mousedown && _ctx.pagingWxs.mousedown(...args)),
                      onMousemove: _cache[9] || (_cache[9] = (...args) => _ctx.pagingWxs.mousemove && _ctx.pagingWxs.mousemove(...args)),
                      onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.pagingWxs.mouseup && _ctx.pagingWxs.mouseup(...args)),
                      onMouseleave: _cache[11] || (_cache[11] = (...args) => _ctx.pagingWxs.mouseleave && _ctx.pagingWxs.mouseleave(...args))
                    },
                    [
                      _ctx.finalRefresherFixedBacHeight > 0 ? (vue.openBlock(), vue.createElementBlock(
                        "view",
                        {
                          key: 0,
                          class: "zp-fixed-bac-view",
                          style: vue.normalizeStyle([{ "background": _ctx.refresherFixedBackground, "height": `${_ctx.finalRefresherFixedBacHeight}px` }])
                        },
                        null,
                        4
                        /* STYLE */
                      )) : vue.createCommentVNode("v-if", true),
                      vue.createElementVNode("view", {
                        class: "zp-paging-main",
                        style: vue.normalizeStyle([_ctx.scrollViewInStyle, { "transform": _ctx.finalRefresherTransform, "transition": _ctx.refresherTransition }]),
                        "change:prop": _ctx.pagingWxs.propObserver,
                        prop: vue.wp(_ctx.wxsPropType),
                        "data-refresherThreshold": _ctx.finalRefresherThreshold,
                        "data-refresherF2Enabled": _ctx.refresherF2Enabled,
                        "data-refresherF2Threshold": _ctx.finalRefresherF2Threshold,
                        "data-isIos": _ctx.isIos,
                        "data-loading": _ctx.loading || _ctx.isRefresherInComplete,
                        "data-useChatRecordMode": _ctx.useChatRecordMode,
                        "data-refresherEnabled": _ctx.refresherEnabled,
                        "data-useCustomRefresher": _ctx.useCustomRefresher,
                        "data-pageScrollTop": _ctx.wxsPageScrollTop,
                        "data-scrollTop": _ctx.wxsScrollTop,
                        "data-refresherMaxAngle": _ctx.refresherMaxAngle,
                        "data-refresherNoTransform": _ctx.refresherNoTransform,
                        "data-refresherAecc": _ctx.refresherAngleEnableChangeContinued,
                        "data-usePageScroll": _ctx.usePageScroll,
                        "data-watchTouchDirectionChange": _ctx.watchTouchDirectionChange,
                        "data-oldIsTouchmoving": _ctx.isTouchmoving,
                        "data-refresherOutRate": _ctx.finalRefresherOutRate,
                        "data-refresherPullRate": _ctx.finalRefresherPullRate,
                        "data-hasTouchmove": _ctx.hasTouchmove,
                        "change:renderPropIsIosAndH5": _ctx.pagingRenderjs.renderPropIsIosAndH5Change,
                        renderPropIsIosAndH5: vue.wp(_ctx.isIosAndH5)
                      }, [
                        _ctx.showRefresher ? (vue.openBlock(), vue.createElementBlock(
                          "view",
                          {
                            key: 0,
                            class: "zp-custom-refresher-view",
                            style: vue.normalizeStyle([{ "margin-top": `-${_ctx.finalRefresherThreshold + _ctx.refresherThresholdUpdateTag}px`, "background": _ctx.refresherBackground, "opacity": _ctx.isTouchmoving ? 1 : 0 }])
                          },
                          [
                            vue.createElementVNode(
                              "view",
                              {
                                class: "zp-custom-refresher-container",
                                style: vue.normalizeStyle([{ "height": `${_ctx.finalRefresherThreshold}px`, "background": _ctx.refresherBackground }])
                              },
                              [
                                _ctx.useRefresherStatusBarPlaceholder ? (vue.openBlock(), vue.createElementBlock(
                                  "view",
                                  {
                                    key: 0,
                                    class: "zp-custom-refresher-status-bar-placeholder",
                                    style: vue.normalizeStyle([{ "height": `${_ctx.statusBarHeight}px` }])
                                  },
                                  null,
                                  4
                                  /* STYLE */
                                )) : vue.createCommentVNode("v-if", true),
                                vue.createCommentVNode(" view "),
                                vue.createElementVNode("view", { class: "zp-custom-refresher-slot-view" }, [
                                  !(_ctx.zSlots.refresherComplete && _ctx.refresherStatus === _ctx.R.Complete) && !(_ctx.zSlots.refresherF2 && _ctx.refresherStatus === _ctx.R.GoF2) ? vue.renderSlot(_ctx.$slots, "refresher", {
                                    key: 0,
                                    refresherStatus: _ctx.refresherStatus
                                  }, void 0, true) : vue.createCommentVNode("v-if", true)
                                ]),
                                _ctx.zSlots.refresherComplete && _ctx.refresherStatus === _ctx.R.Complete ? vue.renderSlot(_ctx.$slots, "refresherComplete", { key: 1 }, void 0, true) : _ctx.zSlots.refresherF2 && _ctx.refresherStatus === _ctx.R.GoF2 ? vue.renderSlot(_ctx.$slots, "refresherF2", { key: 2 }, void 0, true) : !_ctx.showCustomRefresher ? (vue.openBlock(), vue.createBlock(_component_z_paging_refresh, {
                                  key: 3,
                                  ref: "refresh",
                                  class: "zp-custom-refresher-refresh",
                                  style: vue.normalizeStyle([{ "height": `${_ctx.finalRefresherThreshold - _ctx.finalRefresherThresholdPlaceholder}px` }]),
                                  status: _ctx.refresherStatus,
                                  defaultThemeStyle: _ctx.finalRefresherThemeStyle,
                                  defaultText: _ctx.finalRefresherDefaultText,
                                  pullingText: _ctx.finalRefresherPullingText,
                                  refreshingText: _ctx.finalRefresherRefreshingText,
                                  completeText: _ctx.finalRefresherCompleteText,
                                  goF2Text: _ctx.finalRefresherGoF2Text,
                                  defaultImg: _ctx.refresherDefaultImg,
                                  pullingImg: _ctx.refresherPullingImg,
                                  refreshingImg: _ctx.refresherRefreshingImg,
                                  completeImg: _ctx.refresherCompleteImg,
                                  refreshingAnimated: _ctx.refresherRefreshingAnimated,
                                  showUpdateTime: _ctx.showRefresherUpdateTime,
                                  updateTimeKey: _ctx.refresherUpdateTimeKey,
                                  updateTimeTextMap: _ctx.finalRefresherUpdateTimeTextMap,
                                  imgStyle: _ctx.refresherImgStyle,
                                  titleStyle: _ctx.refresherTitleStyle,
                                  updateTimeStyle: _ctx.refresherUpdateTimeStyle,
                                  unit: _ctx.unit
                                }, null, 8, ["style", "status", "defaultThemeStyle", "defaultText", "pullingText", "refreshingText", "completeText", "goF2Text", "defaultImg", "pullingImg", "refreshingImg", "completeImg", "refreshingAnimated", "showUpdateTime", "updateTimeKey", "updateTimeTextMap", "imgStyle", "titleStyle", "updateTimeStyle", "unit"])) : vue.createCommentVNode("v-if", true)
                              ],
                              4
                              /* STYLE */
                            )
                          ],
                          4
                          /* STYLE */
                        )) : vue.createCommentVNode("v-if", true),
                        vue.createElementVNode(
                          "view",
                          {
                            class: "zp-paging-container",
                            style: vue.normalizeStyle([{ justifyContent: _ctx.useChatRecordMode ? "flex-end" : "flex-start" }])
                          },
                          [
                            vue.createCommentVNode(" Loading "),
                            _ctx.showLoading && _ctx.zSlots.loading && !_ctx.loadingFullFixed ? vue.renderSlot(_ctx.$slots, "loading", { key: 0 }, void 0, true) : vue.createCommentVNode("v-if", true),
                            vue.createCommentVNode("  "),
                            vue.createElementVNode(
                              "view",
                              {
                                class: "zp-paging-container-content",
                                style: vue.normalizeStyle([{ transform: _ctx.virtualPlaceholderTopHeight > 0 ? `translateY(${_ctx.virtualPlaceholderTopHeight}px)` : "none" }, _ctx.finalPagingContentStyle])
                              },
                              [
                                vue.renderSlot(_ctx.$slots, "default", {}, void 0, true),
                                vue.createCommentVNode(" & "),
                                _ctx.finalUseInnerList ? (vue.openBlock(), vue.createElementBlock(
                                  vue.Fragment,
                                  { key: 0 },
                                  [
                                    vue.renderSlot(_ctx.$slots, "header", {}, void 0, true),
                                    vue.createElementVNode(
                                      "view",
                                      {
                                        class: "zp-list-container",
                                        style: vue.normalizeStyle([_ctx.innerListStyle])
                                      },
                                      [
                                        _ctx.finalUseVirtualList ? (vue.openBlock(true), vue.createElementBlock(
                                          vue.Fragment,
                                          { key: 0 },
                                          vue.renderList(_ctx.virtualList, (item, index2) => {
                                            return vue.openBlock(), vue.createElementBlock("view", {
                                              class: "zp-list-cell",
                                              style: vue.normalizeStyle([_ctx.innerCellStyle]),
                                              id: `zp-id-${item[_ctx.virtualCellIndexKey]}`,
                                              key: item["zp_unique_index"],
                                              onClick: ($event) => _ctx._innerCellClick(item, _ctx.virtualTopRangeIndex + index2)
                                            }, [
                                              _ctx.useCompatibilityMode ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, "z-paging.vue99")) : (vue.openBlock(), vue.createElementBlock(
                                                vue.Fragment,
                                                { key: 1 },
                                                [
                                                  vue.createCommentVNode(' <zp-public-virtual-cell v-if="useCompatibilityMode" :extraData="extraData" :item="item" :index="virtualTopRangeIndex+index" /> '),
                                                  vue.renderSlot(_ctx.$slots, "cell", {
                                                    item,
                                                    index: _ctx.virtualTopRangeIndex + index2
                                                  }, void 0, true)
                                                ],
                                                2112
                                                /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                                              ))
                                            ], 12, ["id", "onClick"]);
                                          }),
                                          128
                                          /* KEYED_FRAGMENT */
                                        )) : (vue.openBlock(true), vue.createElementBlock(
                                          vue.Fragment,
                                          { key: 1 },
                                          vue.renderList(_ctx.realTotalData, (item, index2) => {
                                            return vue.openBlock(), vue.createElementBlock("view", {
                                              class: "zp-list-cell",
                                              key: index2,
                                              onClick: ($event) => _ctx._innerCellClick(item, index2)
                                            }, [
                                              vue.renderSlot(_ctx.$slots, "cell", {
                                                item,
                                                index: index2
                                              }, void 0, true)
                                            ], 8, ["onClick"]);
                                          }),
                                          128
                                          /* KEYED_FRAGMENT */
                                        ))
                                      ],
                                      4
                                      /* STYLE */
                                    ),
                                    vue.renderSlot(_ctx.$slots, "footer", {}, void 0, true)
                                  ],
                                  64
                                  /* STABLE_FRAGMENT */
                                )) : vue.createCommentVNode("v-if", true),
                                vue.createCommentVNode(" loading "),
                                _ctx.useChatRecordMode && _ctx.realTotalData.length >= _ctx.defaultPageSize && (_ctx.loadingStatus !== _ctx.M.NoMore || _ctx.zSlots.chatNoMore) && (_ctx.realTotalData.length || _ctx.showChatLoadingWhenReload && _ctx.showLoading) && !_ctx.isFirstPageAndNoMore ? (vue.openBlock(), vue.createElementBlock(
                                  "view",
                                  {
                                    key: 1,
                                    style: vue.normalizeStyle([_ctx.chatRecordRotateStyle])
                                  },
                                  [
                                    _ctx.loadingStatus === _ctx.M.NoMore && _ctx.zSlots.chatNoMore ? vue.renderSlot(_ctx.$slots, "chatNoMore", { key: 0 }, void 0, true) : (vue.openBlock(), vue.createElementBlock(
                                      vue.Fragment,
                                      { key: 1 },
                                      [
                                        _ctx.zSlots.chatLoading ? vue.renderSlot(_ctx.$slots, "chatLoading", {
                                          key: 0,
                                          loadingMoreStatus: _ctx.loadingStatus
                                        }, void 0, true) : (vue.openBlock(), vue.createBlock(_component_z_paging_load_more, {
                                          key: 1,
                                          onDoClick: _cache[2] || (_cache[2] = ($event) => _ctx._onLoadingMore("click")),
                                          zConfig: _ctx.zLoadMoreConfig
                                        }, null, 8, ["zConfig"]))
                                      ],
                                      64
                                      /* STABLE_FRAGMENT */
                                    ))
                                  ],
                                  4
                                  /* STYLE */
                                )) : vue.createCommentVNode("v-if", true),
                                vue.createCommentVNode(" view "),
                                _ctx.useVirtualList ? (vue.openBlock(), vue.createElementBlock(
                                  "view",
                                  {
                                    key: 2,
                                    class: "zp-virtual-placeholder",
                                    style: vue.normalizeStyle([{ height: _ctx.virtualPlaceholderBottomHeight + "px" }])
                                  },
                                  null,
                                  4
                                  /* STYLE */
                                )) : vue.createCommentVNode("v-if", true),
                                vue.createCommentVNode(" view "),
                                _ctx.showLoadingMoreDefault ? vue.renderSlot(_ctx.$slots, "loadingMoreDefault", { key: 3 }, void 0, true) : _ctx.showLoadingMoreLoading ? vue.renderSlot(_ctx.$slots, "loadingMoreLoading", { key: 4 }, void 0, true) : _ctx.showLoadingMoreNoMore ? vue.renderSlot(_ctx.$slots, "loadingMoreNoMore", { key: 5 }, void 0, true) : _ctx.showLoadingMoreFail ? vue.renderSlot(_ctx.$slots, "loadingMoreFail", { key: 6 }, void 0, true) : _ctx.showLoadingMoreCustom ? (vue.openBlock(), vue.createBlock(_component_z_paging_load_more, {
                                  key: 7,
                                  onDoClick: _cache[3] || (_cache[3] = ($event) => _ctx._onLoadingMore("click")),
                                  zConfig: _ctx.zLoadMoreConfig
                                }, null, 8, ["zConfig"])) : vue.createCommentVNode("v-if", true),
                                _ctx.safeAreaInsetBottom && _ctx.useSafeAreaPlaceholder && !_ctx.useChatRecordMode ? (vue.openBlock(), vue.createElementBlock(
                                  "view",
                                  {
                                    key: 8,
                                    class: "zp-safe-area-placeholder",
                                    style: vue.normalizeStyle([{ height: _ctx.safeAreaBottom + "px" }])
                                  },
                                  null,
                                  4
                                  /* STYLE */
                                )) : vue.createCommentVNode("v-if", true)
                              ],
                              4
                              /* STYLE */
                            ),
                            vue.createCommentVNode("  "),
                            _ctx.showEmpty ? (vue.openBlock(), vue.createElementBlock(
                              "view",
                              {
                                key: 1,
                                class: vue.normalizeClass({ "zp-empty-view": true, "zp-empty-view-center": _ctx.emptyViewCenter }),
                                style: vue.normalizeStyle([_ctx.emptyViewSuperStyle, _ctx.chatRecordRotateStyle])
                              },
                              [
                                _ctx.zSlots.empty ? vue.renderSlot(_ctx.$slots, "empty", {
                                  key: 0,
                                  isLoadFailed: _ctx.isLoadFailed
                                }, void 0, true) : (vue.openBlock(), vue.createBlock(_component_z_paging_empty_view, {
                                  key: 1,
                                  emptyViewImg: _ctx.finalEmptyViewImg,
                                  emptyViewText: _ctx.finalEmptyViewText,
                                  showEmptyViewReload: _ctx.finalShowEmptyViewReload,
                                  emptyViewReloadText: _ctx.finalEmptyViewReloadText,
                                  isLoadFailed: _ctx.isLoadFailed,
                                  emptyViewStyle: _ctx.emptyViewStyle,
                                  emptyViewTitleStyle: _ctx.emptyViewTitleStyle,
                                  emptyViewImgStyle: _ctx.emptyViewImgStyle,
                                  emptyViewReloadStyle: _ctx.emptyViewReloadStyle,
                                  emptyViewZIndex: _ctx.emptyViewZIndex,
                                  emptyViewFixed: _ctx.emptyViewFixed,
                                  unit: _ctx.unit,
                                  onReload: _ctx._emptyViewReload,
                                  onViewClick: _ctx._emptyViewClick
                                }, null, 8, ["emptyViewImg", "emptyViewText", "showEmptyViewReload", "emptyViewReloadText", "isLoadFailed", "emptyViewStyle", "emptyViewTitleStyle", "emptyViewImgStyle", "emptyViewReloadStyle", "emptyViewZIndex", "emptyViewFixed", "unit", "onReload", "onViewClick"]))
                              ],
                              6
                              /* CLASS, STYLE */
                            )) : vue.createCommentVNode("v-if", true)
                          ],
                          4
                          /* STYLE */
                        )
                      ], 12, ["change:prop", "prop", "data-refresherThreshold", "data-refresherF2Enabled", "data-refresherF2Threshold", "data-isIos", "data-loading", "data-useChatRecordMode", "data-refresherEnabled", "data-useCustomRefresher", "data-pageScrollTop", "data-scrollTop", "data-refresherMaxAngle", "data-refresherNoTransform", "data-refresherAecc", "data-usePageScroll", "data-watchTouchDirectionChange", "data-oldIsTouchmoving", "data-refresherOutRate", "data-refresherPullRate", "data-hasTouchmove", "change:renderPropIsIosAndH5", "renderPropIsIosAndH5"])
                    ],
                    32
                    /* NEED_HYDRATION */
                  )
                ], 46, ["scroll-top", "scroll-x", "scroll-y", "enable-back-to-top", "show-scrollbar", "scroll-with-animation", "scroll-into-view", "lower-threshold", "refresher-enabled", "refresher-threshold", "refresher-default-style", "refresher-background", "refresher-triggered"])
              ],
              6
              /* CLASS, STYLE */
            ),
            _ctx.zSlots.right ? (vue.openBlock(), vue.createElementBlock(
              "view",
              {
                key: 1,
                class: vue.normalizeClass({ "zp-page-right": true, "zp-absoulte zp-right": _ctx.finalIsOldWebView })
              },
              [
                vue.renderSlot(_ctx.$slots, "right", {}, void 0, true)
              ],
              2
              /* CLASS */
            )) : vue.createCommentVNode("v-if", true)
          ],
          6
          /* CLASS, STYLE */
        ),
        vue.createCommentVNode(" slot "),
        vue.createElementVNode(
          "view",
          {
            class: "zp-page-bottom-container",
            style: vue.normalizeStyle({ "background": _ctx.bottomBgColor })
          },
          [
            !_ctx.usePageScroll && _ctx.zSlots.bottom ? vue.renderSlot(_ctx.$slots, "bottom", { key: 0 }, void 0, true) : _ctx.usePageScroll && _ctx.zSlots.bottom ? (vue.openBlock(), vue.createElementBlock(
              "view",
              {
                key: 1,
                class: "zp-page-bottom",
                onTouchmove: _cache[17] || (_cache[17] = vue.withModifiers(() => {
                }, ["stop", "prevent"])),
                style: vue.normalizeStyle([{ "bottom": `${_ctx.windowBottom}px` }])
              },
              [
                vue.renderSlot(_ctx.$slots, "bottom", {}, void 0, true)
              ],
              36
              /* STYLE, NEED_HYDRATION */
            )) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode("  "),
            _ctx.useChatRecordMode && _ctx.autoAdjustPositionWhenChat ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 2 },
              [
                vue.createElementVNode(
                  "view",
                  {
                    style: vue.normalizeStyle([{ height: _ctx.chatRecordModeSafeAreaBottom + "px" }])
                  },
                  null,
                  4
                  /* STYLE */
                ),
                vue.createElementVNode(
                  "view",
                  {
                    class: "zp-page-bottom-keyboard-placeholder-animate",
                    style: vue.normalizeStyle([{ height: _ctx.keyboardHeight + "px" }])
                  },
                  null,
                  4
                  /* STYLE */
                )
              ],
              64
              /* STABLE_FRAGMENT */
            )) : vue.createCommentVNode("v-if", true)
          ],
          4
          /* STYLE */
        ),
        vue.createCommentVNode(" view "),
        _ctx.showBackToTopClass ? (vue.openBlock(), vue.createElementBlock(
          "view",
          {
            key: 3,
            class: vue.normalizeClass(_ctx.finalBackToTopClass),
            style: vue.normalizeStyle([_ctx.finalBackToTopStyle]),
            onClick: _cache[18] || (_cache[18] = vue.withModifiers((...args) => _ctx._backToTopClick && _ctx._backToTopClick(...args), ["stop"]))
          },
          [
            _ctx.zSlots.backToTop ? vue.renderSlot(_ctx.$slots, "backToTop", { key: 0 }, void 0, true) : (vue.openBlock(), vue.createElementBlock("image", {
              key: 1,
              class: vue.normalizeClass(["zp-back-to-top-img", { "zp-back-to-top-img-inversion": _ctx.useChatRecordMode && !_ctx.backToTopImg.length }]),
              src: _ctx.backToTopImg.length ? _ctx.backToTopImg : _ctx.base64BackToTop
            }, null, 10, ["src"]))
          ],
          6
          /* CLASS, STYLE */
        )) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode(" Loading(z-paging) "),
        _ctx.showLoading && _ctx.zSlots.loading && _ctx.loadingFullFixed ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 4,
          class: "zp-loading-fixed"
        }, [
          vue.renderSlot(_ctx.$slots, "loading", {}, void 0, true)
        ])) : vue.createCommentVNode("v-if", true)
      ],
      6
      /* CLASS, STYLE */
    );
  }
  if (typeof block0 === "function")
    block0(_sfc_main$d);
  if (typeof block1 === "function")
    block1(_sfc_main$d);
  const __easycom_0 = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$c], ["__scopeId", "data-v-fb5441fe"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/z-paging/components/z-paging/z-paging.vue"]]);
  var dayjs_min = { exports: {} };
  (function(module, exports) {
    !function(t2, e2) {
      module.exports = e2();
    }(commonjsGlobal, function() {
      var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
      } }, m2 = function(t3, e3, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
      }, v2 = { s: m2, z: function(t3) {
        var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
      }, m: function t3(e3, n3) {
        if (e3.date() < n3.date())
          return -t3(n3, e3);
        var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
        return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g2 = "en", D = {};
      D[g2] = M;
      var p2 = "$isDayjsObject", S = function(t3) {
        return t3 instanceof _ || !(!t3 || !t3[p2]);
      }, w = function t3(e3, n3, r3) {
        var i3;
        if (!e3)
          return g2;
        if ("string" == typeof e3) {
          var s3 = e3.toLowerCase();
          D[s3] && (i3 = s3), n3 && (D[s3] = n3, i3 = s3);
          var u3 = e3.split("-");
          if (!i3 && u3.length > 1)
            return t3(u3[0]);
        } else {
          var a3 = e3.name;
          D[a3] = e3, i3 = a3;
        }
        return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
      }, O = function(t3, e3) {
        if (S(t3))
          return t3.clone();
        var n3 = "object" == typeof e3 ? e3 : {};
        return n3.date = t3, n3.args = arguments, new _(n3);
      }, b2 = v2;
      b2.l = w, b2.i = S, b2.w = function(t3, e3) {
        return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
      };
      var _ = function() {
        function M2(t3) {
          this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
        }
        var m3 = M2.prototype;
        return m3.parse = function(t3) {
          this.$d = function(t4) {
            var e3 = t4.date, n3 = t4.utc;
            if (null === e3)
              return /* @__PURE__ */ new Date(NaN);
            if (b2.u(e3))
              return /* @__PURE__ */ new Date();
            if (e3 instanceof Date)
              return new Date(e3);
            if ("string" == typeof e3 && !/Z$/i.test(e3)) {
              var r3 = e3.match($);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
              }
            }
            return new Date(e3);
          }(t3), this.init();
        }, m3.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m3.$utils = function() {
          return b2;
        }, m3.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m3.isSame = function(t3, e3) {
          var n3 = O(t3);
          return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
        }, m3.isAfter = function(t3, e3) {
          return O(t3) < this.startOf(e3);
        }, m3.isBefore = function(t3, e3) {
          return this.endOf(e3) < O(t3);
        }, m3.$g = function(t3, e3, n3) {
          return b2.u(t3) ? this[e3] : this.set(n3, t3);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t3, e3) {
          var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
            var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
            return r3 ? i3 : i3.endOf(a2);
          }, $2 = function(t4, e4) {
            return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
          }, y2 = this.$W, M3 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
          switch (f3) {
            case h2:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c2:
              return r3 ? l3(1, M3) : l3(0, M3 + 1);
            case o2:
              var g3 = this.$locale().weekStart || 0, D2 = (y2 < g3 ? y2 + 7 : y2) - g3;
              return l3(r3 ? m4 - D2 : m4 + (6 - D2), M3);
            case a2:
            case d2:
              return $2(v3 + "Hours", 0);
            case u2:
              return $2(v3 + "Minutes", 1);
            case s2:
              return $2(v3 + "Seconds", 2);
            case i2:
              return $2(v3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m3.$set = function(t3, e3) {
          var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
          if (o3 === c2 || o3 === h2) {
            var y2 = this.clone().set(d2, 1);
            y2.$d[l3]($2), y2.init(), this.$d = y2.set(d2, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l3 && this.$d[l3]($2);
          return this.init(), this;
        }, m3.set = function(t3, e3) {
          return this.clone().$set(t3, e3);
        }, m3.get = function(t3) {
          return this[b2.p(t3)]();
        }, m3.add = function(r3, f3) {
          var d3, l3 = this;
          r3 = Number(r3);
          var $2 = b2.p(f3), y2 = function(t3) {
            var e3 = O(l3);
            return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
          };
          if ($2 === c2)
            return this.set(c2, this.$M + r3);
          if ($2 === h2)
            return this.set(h2, this.$y + r3);
          if ($2 === a2)
            return y2(1);
          if ($2 === o2)
            return y2(7);
          var M3 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M3;
          return b2.w(m4, this);
        }, m3.subtract = function(t3, e3) {
          return this.add(-1 * t3, e3);
        }, m3.format = function(t3) {
          var e3 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
            return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
          }, d3 = function(t4) {
            return b2.s(s3 % 12 || 12, t4, "0");
          }, $2 = f3 || function(t4, e4, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e3.$y).slice(-2);
                case "YYYY":
                  return b2.s(e3.$y, 4, "0");
                case "M":
                  return a3 + 1;
                case "MM":
                  return b2.s(a3 + 1, 2, "0");
                case "MMM":
                  return h3(n3.monthsShort, a3, c3, 3);
                case "MMMM":
                  return h3(c3, a3);
                case "D":
                  return e3.$D;
                case "DD":
                  return b2.s(e3.$D, 2, "0");
                case "d":
                  return String(e3.$W);
                case "dd":
                  return h3(n3.weekdaysMin, e3.$W, o3, 2);
                case "ddd":
                  return h3(n3.weekdaysShort, e3.$W, o3, 3);
                case "dddd":
                  return o3[e3.$W];
                case "H":
                  return String(s3);
                case "HH":
                  return b2.s(s3, 2, "0");
                case "h":
                  return d3(1);
                case "hh":
                  return d3(2);
                case "a":
                  return $2(s3, u3, true);
                case "A":
                  return $2(s3, u3, false);
                case "m":
                  return String(u3);
                case "mm":
                  return b2.s(u3, 2, "0");
                case "s":
                  return String(e3.$s);
                case "ss":
                  return b2.s(e3.$s, 2, "0");
                case "SSS":
                  return b2.s(e3.$ms, 3, "0");
                case "Z":
                  return i3;
              }
              return null;
            }(t4) || i3.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r3, d3, l3) {
          var $2, y2 = this, M3 = b2.p(d3), m4 = O(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D2 = function() {
            return b2.m(y2, m4);
          };
          switch (M3) {
            case h2:
              $2 = D2() / 12;
              break;
            case c2:
              $2 = D2();
              break;
            case f2:
              $2 = D2() / 3;
              break;
            case o2:
              $2 = (g3 - v3) / 6048e5;
              break;
            case a2:
              $2 = (g3 - v3) / 864e5;
              break;
            case u2:
              $2 = g3 / n2;
              break;
            case s2:
              $2 = g3 / e2;
              break;
            case i2:
              $2 = g3 / t2;
              break;
            default:
              $2 = g3;
          }
          return l3 ? $2 : b2.a($2);
        }, m3.daysInMonth = function() {
          return this.endOf(c2).$D;
        }, m3.$locale = function() {
          return D[this.$L];
        }, m3.locale = function(t3, e3) {
          if (!t3)
            return this.$L;
          var n3 = this.clone(), r3 = w(t3, e3, true);
          return r3 && (n3.$L = r3), n3;
        }, m3.clone = function() {
          return b2.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
        k[t3[1]] = function(e3) {
          return this.$g(e3, t3[0], t3[1]);
        };
      }), O.extend = function(t3, e3) {
        return t3.$i || (t3(e3, _, O), t3.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
        return O(1e3 * t3);
      }, O.en = D[g2], O.Ls = D, O.p = {}, O;
    });
  })(dayjs_min);
  function timeFormat$1(dateTime = null, formatStr = "yyyy-mm-dd") {
    let date2;
    if (!dateTime) {
      date2 = /* @__PURE__ */ new Date();
    } else if (/^\d{10}$/.test(dateTime == null ? void 0 : dateTime.toString().trim())) {
      date2 = new Date(dateTime * 1e3);
    } else if (typeof dateTime === "string" && /^\d+$/.test(dateTime.trim())) {
      date2 = new Date(Number(dateTime));
    } else {
      date2 = new Date(typeof dateTime === "string" ? dateTime.replace(/-/g, "/") : dateTime);
    }
    const timeSource = {
      y: date2.getFullYear().toString(),
      // 
      m: (date2.getMonth() + 1).toString().padStart(2, "0"),
      // 
      d: date2.getDate().toString().padStart(2, "0"),
      // 
      h: date2.getHours().toString().padStart(2, "0"),
      // 
      M: date2.getMinutes().toString().padStart(2, "0"),
      // 
      s: date2.getSeconds().toString().padStart(2, "0")
      // 
      // 
    };
    for (const key in timeSource) {
      const [ret] = new RegExp(`${key}+`).exec(formatStr) || [];
      if (ret) {
        const beginIndex = key === "y" && ret.length === 2 ? 2 : 0;
        formatStr = formatStr.replace(ret, timeSource[key].slice(beginIndex));
      }
    }
    return formatStr;
  }
  const _imports_1$7 = "/static/icons/search.png";
  const _imports_1$6 = "/static/icons/copy.png";
  const _sfc_main$c = {
    __name: "warehouseMen",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const copyHandle = async (data) => {
        uni.setClipboardData({
          data,
          success: function() {
            uni.showToast({
              title: "Copy Success",
              icon: "none"
            });
          }
        });
      };
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pages2 = vue.ref({
        pageNo: 1,
        pageSize: 10
      });
      const queryList = (page2) => {
        pages2.value.pageNo = page2;
        request({
          url: "/admin-api/storage/local/goods/outbound/page",
          data: pages2.value
        }).then((res) => {
          paging.value.complete(res.list);
          pages2.value.pageNo++;
        });
      };
      const allChecked = vue.ref(false);
      const childBoxChange = (e2) => {
        e2.checked = !e2.checked;
        if (e2.checked) {
          let arr = dataList.value.filter((item) => {
            return item.checked;
          });
          if (arr.length == dataList.value.length) {
            allChecked.value = true;
          } else {
            allChecked.value = false;
          }
        } else {
          allChecked.value = false;
        }
      };
      const parentChange = (e2) => {
        allChecked.value = !allChecked.value;
        dataList.value.forEach((item) => {
          item.checked = allChecked.value;
        });
      };
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { toClipboard, copyHandle, dataList, paging, pages: pages2, queryList, allChecked, childBoxChange, parentChange, changePage, goBack, topNavbar, get request() {
        return request;
      }, get useClipboard() {
        return useClipboard;
      }, get timeFormat() {
        return timeFormat$1;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_z_paging = resolveEasycom(vue.resolveDynamicComponent("z-paging"), __easycom_0);
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.createElementVNode("image", {
            src: _imports_1$7,
            class: "ww24 hh24"
          })
        ])
      ]),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createVNode(_component_z_paging, {
          ref: "paging",
          modelValue: $setup.dataList,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.dataList = $event),
          onQuery: $setup.queryList,
          fixed: false,
          "use-page-scroll": true,
          "refresher-enabled": false
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "dataItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "flex col_center" }, [
                    vue.createElementVNode("view", null, [
                      vue.createElementVNode("image", {
                        src: item.checked ? "/static/icons/actChe.png" : "/static/icons/invChe.png",
                        class: "ww18 hh18",
                        onClick: ($event) => $setup.childBoxChange(item)
                      }, null, 8, ["src", "onClick"])
                    ]),
                    vue.createElementVNode("view", { class: "ml13 flex1" }, [
                      vue.createElementVNode("view", { class: "between" }, [
                        vue.createElementVNode("view", { class: "f12 colorAf flex col_center" }, [
                          vue.createTextVNode(
                            ":" + vue.toDisplayString(item.no) + " ",
                            1
                            /* TEXT */
                          ),
                          vue.createElementVNode("image", {
                            src: _imports_1$6,
                            class: "ww14 hh14 ml8",
                            onClick: ($event) => $setup.copyHandle(item.no)
                          }, null, 8, ["onClick"])
                        ]),
                        vue.createElementVNode("view", {
                          onClick: ($event) => $setup.changePage("./warehouseDeatil?id=" + item.id)
                        }, [
                          vue.createElementVNode("image", {
                            src: _imports_2$2,
                            class: "ww24 hh24"
                          })
                        ], 8, ["onClick"])
                      ]),
                      vue.createElementVNode("view", { class: "mt12 goodsBox between" }, [
                        vue.createElementVNode(
                          "view",
                          { class: "f16 text_bold" },
                          vue.toDisplayString(item.storageTypeName),
                          1
                          /* TEXT */
                        ),
                        vue.createElementVNode(
                          "view",
                          { class: "f13" },
                          "x" + vue.toDisplayString(item.num),
                          1
                          /* TEXT */
                        )
                      ]),
                      vue.createElementVNode("view", { class: "mt12 flex col_center f12 colorAf" }, [
                        vue.createElementVNode(
                          "view",
                          { class: "" },
                          vue.toDisplayString($setup.timeFormat(item.time, "yyyy:mm:dd hh:MM:ss")),
                          1
                          /* TEXT */
                        ),
                        vue.createElementVNode(
                          "view",
                          { class: "ml30" },
                          " " + vue.toDisplayString(item.creatorName),
                          1
                          /* TEXT */
                        )
                      ])
                    ])
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue"])
      ]),
      vue.createElementVNode("view", { class: "fixedBot" }, [
        vue.createElementVNode("view", { class: "pdlr12 pb10 between pt4" }, [
          vue.createElementVNode("view", { class: "flex col_center" }, [
            vue.createElementVNode("image", {
              src: $setup.allChecked ? "/static/icons/actChe.png" : "/static/icons/invChe.png",
              class: "ww18 hh18",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.parentChange($setup.allChecked))
            }, null, 8, ["src"]),
            vue.createElementVNode("span", { class: "f14 color7C pl5" }, "")
          ]),
          vue.createElementVNode("view", { class: "botBtn center text_white" }, "")
        ])
      ])
    ]);
  }
  const PagesGdWarehouseMen = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$b], ["__scopeId", "data-v-806aa5b3"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/warehouseMen.vue"]]);
  const _sfc_main$b = {
    __name: "warehouseDeatil",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const showPopCenter = vue.ref(false);
      const popConfirmHandle = () => {
        request({
          url: "/admin-api/storage/local/goods/outbound/cancel",
          data: {
            outboundId: deatilId.value
          },
          methods: "PUT"
        }).then((res) => {
          showPopCenter.value = false;
          uni.showToast({
            title: "",
            icon: "none"
          });
          uni.navigateTo({
            url: "/"
          });
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const deatilId = vue.ref("");
      onLoad((e2) => {
        if (e2.id) {
          deatilId.value = e2.id;
          getPageDeatil(deatilId.value);
        }
      });
      const pageData = vue.ref({
        itemList: []
      });
      const getPageDeatil = (id) => {
        request({
          url: "/admin-api/storage/local/goods/outbound/detail/" + id,
          method: "GET"
        }).then((res) => {
          pageData.value = res;
          formatAppLog("log", "at pages/gd/warehouseDeatil.vue:65", res);
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { toClipboard, showPopCenter, popConfirmHandle, deatilId, pageData, getPageDeatil, goBack, topNavbar, get request() {
        return request;
      }, get showToast() {
        return showToast;
      }, get useClipboard() {
        return useClipboard;
      }, ref: vue.ref, onMounted: vue.onMounted, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createElementVNode("view", { class: "topBox pdlr12 pt21 pb16" }, [
          vue.createElementVNode("view", { class: "f14" }, ""),
          vue.createElementVNode("view", { class: "mt19 shelfBox center flex-col" }, [
            vue.createElementVNode(
              "view",
              { class: "f20 text_bold colorBlue" },
              vue.toDisplayString($setup.pageData.storageTypeName),
              1
              /* TEXT */
            )
          ])
        ]),
        vue.createElementVNode("view", { class: "mt12 copyBox" }, [
          vue.createElementVNode(
            "view",
            { class: "pb6 f14" },
            "  x " + vue.toDisplayString($setup.pageData.itemList.length),
            1
            /* TEXT */
          ),
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.pageData.itemList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: "mt12 between dataItem",
                key: index2
              }, [
                vue.createElementVNode("view", null, [
                  vue.createElementVNode(
                    "view",
                    { class: "f15 text_bold" },
                    vue.toDisplayString(item.categoryName),
                    1
                    /* TEXT */
                  )
                ]),
                vue.createElementVNode(
                  "view",
                  { class: "printBtn f12 center" },
                  " x" + vue.toDisplayString(item.num),
                  1
                  /* TEXT */
                )
              ]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]),
        vue.createElementVNode("view", { class: "fixedBot" }, [
          vue.createElementVNode("view", { class: "girdBtn" }, [
            vue.createElementVNode("view", { class: "botBtn center text_white confirmBtn" }, ""),
            vue.createElementVNode("view", {
              class: "botBtn cancelBtn center color7C",
              onClick: _cache[0] || (_cache[0] = ($event) => $setup.showPopCenter = true)
            }, "")
          ])
        ])
      ]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPopCenter,
        "onUpdate:show": _cache[2] || (_cache[2] = ($event) => $setup.showPopCenter = $event),
        round: "",
        style: { "width": "280px" }
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "pt30 pdlr26" }, [
            vue.createElementVNode("view", {
              class: "f15 text_center borderB pb24",
              style: { "line-height": "18px" }
            }, "  ")
          ]),
          vue.createElementVNode("view", { class: "pop pdlr20 pdtb16" }, [
            vue.createElementVNode("view", { class: "girdBtn" }, [
              vue.createElementVNode("view", {
                class: "botBtn cancelBtn center color7C",
                onClick: _cache[1] || (_cache[1] = ($event) => $setup.showPopCenter = false)
              }, ""),
              vue.createElementVNode("view", {
                class: "botBtn center text_white confirmBtn",
                onClick: $setup.popConfirmHandle
              }, "")
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"])
    ]);
  }
  const PagesGdWarehouseDeatil = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$a], ["__scopeId", "data-v-ddef898c"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/warehouseDeatil.vue"]]);
  const _sfc_main$a = {
    __name: "goodsMen",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const copyHandle = async (data) => {
        uni.setClipboardData({
          data,
          success: function() {
            uni.showToast({
              title: "Copy Success",
              icon: "none"
            });
          }
        });
      };
      const tabActive = vue.ref(0);
      const changeHandle = (e2) => {
        tabActive.value = e2;
        paging.value.clean();
        queryList(1);
      };
      const tabsList = vue.ref([]);
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pages2 = vue.ref({
        pageNo: 1,
        pageSize: 10,
        status: 0
        // status:tabsList.value[tabActive.value].type
      });
      const getTypeList = () => {
        request({
          url: "/admin-api/storage/local/goods/status-list"
        }).then((res) => {
          tabsList.value = res;
          queryList(1);
        });
      };
      getTypeList();
      const queryList = (page2) => {
        pages2.value.status = tabsList.value[tabActive.value].type;
        pages2.value.pageNo = page2;
        request({
          url: "/admin-api/storage/local/goods/page",
          data: pages2.value
        }).then((res) => {
          pages2.value.pageNo++;
          paging.value.complete(res.list);
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { toClipboard, copyHandle, tabActive, changeHandle, tabsList, dataList, paging, pages: pages2, getTypeList, queryList, goBack, topNavbar, get request() {
        return request;
      }, ref: vue.ref, get useClipboard() {
        return useClipboard;
      }, get timeFormat() {
        return timeFormat$1;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_z_paging = resolveEasycom(vue.resolveDynamicComponent("z-paging"), __easycom_0);
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Management",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      $setup.tabsList.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, [
        vue.createElementVNode("view", { class: "flex tabListEl" }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.tabsList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: vue.normalizeClass(["tabItem", $setup.tabActive == index2 ? "actTabItem" : ""]),
                key: index2,
                onClick: ($event) => $setup.changeHandle(index2)
              }, vue.toDisplayString(item.name), 11, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createVNode(_component_z_paging, {
          ref: "paging",
          modelValue: $setup.dataList,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.dataList = $event),
          onQuery: $setup.queryList,
          fixed: false,
          "use-page-scroll": true,
          "refresher-enabled": false,
          auto: false
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "dataItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "between" }, [
                    vue.createElementVNode("view", { class: "f12 colorAf flex col_center" }, [
                      vue.createTextVNode(
                        ":" + vue.toDisplayString(item.orderNo) + " ",
                        1
                        /* TEXT */
                      ),
                      vue.createElementVNode("image", {
                        src: _imports_1$6,
                        class: "ww14 hh14 ml8",
                        onClick: ($event) => $setup.copyHandle(item.orderNo)
                      }, null, 8, ["onClick"])
                    ]),
                    vue.createElementVNode(
                      "view",
                      {
                        class: vue.normalizeClass(["f11 rightEl center", item.status == 1 ? "Received" : item.status == 2 ? "Warehoused" : "Outbound"])
                      },
                      vue.toDisplayString(item.statusInfo),
                      3
                      /* TEXT, CLASS */
                    )
                  ]),
                  vue.createElementVNode("view", { class: "mt12 goodsBox between" }, [
                    vue.createElementVNode(
                      "view",
                      { class: "f16 text_bold" },
                      vue.toDisplayString(item.categoryName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "f13" },
                      "x" + vue.toDisplayString(item.num),
                      1
                      /* TEXT */
                    )
                  ]),
                  vue.createElementVNode("view", { class: "mt12 between f12 colorAf" }, [
                    vue.createElementVNode(
                      "view",
                      { class: "" },
                      vue.toDisplayString($setup.timeFormat(item.time, "yyyy:mm:dd hh:MM:ss")),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "ml30" },
                      " " + vue.toDisplayString(item.operatorName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode("view", { class: "printBtn f12 center" }, "  ")
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue"])
      ])
    ]);
  }
  const PagesGdGoodsMen = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$9], ["__scopeId", "data-v-0481e2b6"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/gd/goodsMen.vue"]]);
  const _sfc_main$9 = {
    __name: "goodsList",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        toClipboard
      } = useClipboard();
      const copyHandle = async (data) => {
        uni.setClipboardData({
          data,
          success: function() {
            uni.showToast({
              title: "Copy Success",
              icon: "none"
            });
          }
        });
      };
      const tabActive = vue.ref(0);
      const changeHandle = (e2) => {
        tabActive.value = e2;
        pages2.value.status = tabsList.value[e2].type;
        paging.value.clean();
        queryList(1);
      };
      const tabsList = vue.ref([]);
      const getType = () => {
        request({
          url: "/admin-api/storage/overseas/goods/status-list"
        }).then((res) => {
          tabsList.value = res;
        });
      };
      getType();
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pages2 = vue.ref({
        pageNo: 1,
        pageSize: 10,
        status: 0
      });
      const queryList = (page2) => {
        pages2.value.pageNo = page2;
        request({
          url: "/admin-api/storage/overseas/goods/page",
          data: pages2.value
        }).then((res) => {
          paging.value.complete(res.list);
          pages2.value.pageNo++;
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      queryList(1);
      const __returned__ = { toClipboard, copyHandle, tabActive, changeHandle, tabsList, getType, dataList, paging, pages: pages2, queryList, goBack, topNavbar, get request() {
        return request;
      }, get showToast() {
        return showToast;
      }, get useClipboard() {
        return useClipboard;
      }, get timeFormat() {
        return timeFormat$1;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_z_paging = resolveEasycom(vue.resolveDynamicComponent("z-paging"), __easycom_0);
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Management",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createCommentVNode(' <van-tabs v-model:active="tabActive" shrink swipeable title-active-color="#3178FC"\r\n			title-inactive-color="#AFAFAF" color="#3178FC" line-width="20" line-height="4" @change="changeHandle"\r\n			style="background: #fff;">\r\n			<van-tab v-for="(item,index) in tabsList" :title="item.name" :key="index">\r\n\r\n			</van-tab>\r\n		</van-tabs> '),
      $setup.tabsList.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", { key: 0 }, [
        vue.createElementVNode("view", { class: "flex tabListEl" }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.tabsList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", {
                class: vue.normalizeClass(["tabItem", $setup.tabActive == index2 ? "actTabItem" : ""]),
                key: index2,
                onClick: ($event) => $setup.changeHandle(index2)
              }, vue.toDisplayString(item.name), 11, ["onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ])) : vue.createCommentVNode("v-if", true),
      vue.createElementVNode("view", { class: "mt12 pdlr12" }, [
        vue.createVNode(_component_z_paging, {
          ref: "paging",
          modelValue: $setup.dataList,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.dataList = $event),
          onQuery: $setup.queryList,
          fixed: false,
          "use-page-scroll": true,
          "refresher-enabled": false,
          auto: false
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "dataItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "between" }, [
                    vue.createElementVNode("view", { class: "f12 colorAf flex col_center" }, [
                      vue.createTextVNode(
                        "ID:" + vue.toDisplayString(item.orderNo) + " ",
                        1
                        /* TEXT */
                      ),
                      vue.createElementVNode("image", {
                        src: _imports_1$6,
                        class: "ww14 hh14 ml8",
                        onClick: ($event) => $setup.copyHandle(item.orderNo)
                      }, null, 8, ["onClick"])
                    ]),
                    vue.createElementVNode(
                      "view",
                      {
                        class: vue.normalizeClass(["f11 rightEl center", item.status == 1 ? "Received" : item.status == 2 ? "Warehoused" : "Outbound"])
                      },
                      vue.toDisplayString($setup.tabsList[item.status].name),
                      3
                      /* TEXT, CLASS */
                    )
                  ]),
                  vue.createElementVNode("view", { class: "mt12 goodsBox between" }, [
                    vue.createElementVNode(
                      "view",
                      { class: "f16 text_bold" },
                      vue.toDisplayString(item.categoryName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "f13" },
                      "x" + vue.toDisplayString(item.num),
                      1
                      /* TEXT */
                    )
                  ]),
                  item.status == 2 ? (vue.openBlock(), vue.createElementBlock(
                    "view",
                    {
                      key: 0,
                      class: "mt12"
                    },
                    vue.toDisplayString(item.shelf + "-" + item.floor),
                    1
                    /* TEXT */
                  )) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("view", { class: "mt12 flex col_center f12 colorAf" }, [
                    vue.createElementVNode(
                      "view",
                      { class: "" },
                      vue.toDisplayString($setup.timeFormat(item.time, "yyyy:mm:dd hh:MM:ss")),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "ml30" },
                      " Operator" + vue.toDisplayString(item.operatorName),
                      1
                      /* TEXT */
                    )
                  ])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue"])
      ])
    ]);
  }
  const PagesHomeGoodsList = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$8], ["__scopeId", "data-v-6a88c941"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/goodsList.vue"]]);
  const HWHJStore = defineStore("HWHJStore", {
    //  
    state: () => {
      return {
        // 
        LAYERSLIST: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        default_shelf: [],
        warehouseList: [],
        PICKCODE: "",
        USERGOODS: [],
        NOW_VERCODE: "",
        USERSUCCESSGOODS: []
        //
      };
    },
    actions: {}
  });
  const _imports_0 = "/static/icons/back_white.png";
  const _imports_1$5 = "/static/icons/info.png";
  const _sfc_main$8 = {
    __name: "scanCode",
    setup(__props, { expose: __expose }) {
      __expose();
      const {
        locale,
        t: t2
      } = useI18n();
      const GDHPStoreInfo = GDHPStore();
      const HWHJStoreInfo = HWHJStore();
      const showPop = vue.ref(false);
      const cameraId = vue.ref(0);
      const list = vue.ref([]);
      const getCameras = () => {
        if (type.value == 4) {
          uni.scanCode({
            scanType: ["qrCode"],
            success(res) {
              inpVal.value = res.result;
              formatAppLog("log", "at pages/home/scanCode.vue:95", res.result);
              popComfirm();
            },
            fail(e2) {
              formatAppLog("log", "at pages/home/scanCode.vue:99", e2);
            }
          });
        } else {
          uni.scanCode({
            scanType: ["barCode", "qrCode", "datamatrix"],
            success: function(res) {
              inpVal.value = res.result;
              formatAppLog("log", "at pages/home/scanCode.vue:107", res.result);
              popComfirm();
            },
            complete() {
              formatAppLog("log", "at pages/home/scanCode.vue:111", "");
            }
          });
        }
      };
      const type = vue.ref(0);
      onLoad((e2) => {
        if (e2.type) {
          type.value = e2.type;
          getCameras();
        }
      });
      const inpVal = vue.ref("");
      const popComfirm = () => {
        if (type.value == 1) {
          hwRecHandle("/pages/home/receiveSuccess", inpVal.value);
        } else if (type.value == 2) {
          vertifyShelf("/pages/home/warehouse", inpVal.value);
        } else if (type.value == 3) {
          hwWarehouseHandle("/pages/home/warehouse", inpVal.value);
        } else if (type.value == 4) {
          hwCollect("/pages/collect/index", inpVal.value);
        } else if (type.value == 5) {
          hwUserGet("/pages/collect/index", inpVal.value);
        } else if (type.value == 6) {
          gdShouhuo("/pages/gd/recive", inpVal.value);
        } else if (type.value == 7) {
          gdChuku("/pages/gd/warehouse", inpVal.value);
        }
        showPop.value = false;
      };
      const hwUserGet = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/pickup",
          data: {
            orderNo: val
          },
          methods: "PUT"
        }).then((res) => {
          uni.showToast({
            title: HWHJStoreInfo.$state.NOW_VERCODE + " Delivery successful",
            icon: "none"
          });
          HWHJStoreInfo.$state.USERSUCCESSGOODS.push(HWHJStoreInfo.$state.NOW_VERCODE);
          if (HWHJStoreInfo.$state.USERSUCCESSGOODS.length == HWHJStoreInfo.$state.USERGOODS.length) {
            uni.navigateTo({
              url: "../collect/collectSuccess"
            });
          } else {
            uni.navigateTo({
              url: "../collect/index"
            });
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const hwCollect = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/pickup-goods-list/" + val
        }).then((res) => {
          HWHJStoreInfo.$state.PICKCODE = val;
          HWHJStoreInfo.$state.USERGOODS = res;
          uni.navigateTo({
            url: "../collect/index"
          });
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const hwWarehouseHandle = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/get-info/" + val
        }).then((res) => {
          if (HWHJStoreInfo.$state.warehouseList.findIndexOf(res) == -1) {
            HWHJStoreInfo.$state.warehouseList.push(res);
            uni.navigateTo({
              url: url2
            });
          } else {
            uni.showToast({
              title: "Please do not scan again",
              icon: "none"
            });
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const vertifyShelf = (url2, val) => {
        let arr = val.split("-");
        request({
          url: "/admin-api/storage/overseas/goods-location/exist",
          data: {
            shelf: arr[0],
            floor: arr[1]
          }
        }).then((res) => {
          if (res) {
            HWHJStoreInfo.$state.default_shelf = arr;
            uni.navigateTo({
              url: "./warehouse"
            });
          } else {
            uni.showToast({
              title: "Container does not exist",
              icon: "none"
            });
          }
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
        });
      };
      const gdShouhuo = (url2, val) => {
        request({
          url: "/admin-api/storage/local/goods/receive",
          data: {
            supplierLogisticsNo: val
          },
          methods: "POST"
        }).then((res) => {
          uni.showToast({
            title: "",
            icon: "none"
          });
          changePage(url2, val);
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const gdChuku = (url2, val) => {
        let storageType;
        try {
          storageType = GDHPStoreInfo.$state.outboundList[0].storageType;
        } catch (e2) {
        }
        request({
          url: "/admin-api/storage/local/goods/get-for-outbound",
          data: {
            orderNo: val,
            storageType
          }
        }).then((res) => {
          if (!GDHPStoreInfo.$state.outboundList.some((item) => item.orderNo == res.orderNo)) {
            GDHPStoreInfo.addToList(res);
          } else {
            uni.showToast({
              title: "",
              icon: "none"
            });
          }
          changePage(url2, inpVal.value);
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "none"
          });
          getCameras();
        });
      };
      const hwRecHandle = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/receive",
          data: {
            orderNo: val
          },
          methods: "POST"
        }).then((res) => {
          GDHPStoreInfo.$state.reviceObj = res;
          changePage(url2, val);
        }).catch((e2) => {
          uni.showToast({
            title: e2.msg,
            icon: "error"
          });
          getCameras();
        });
      };
      const hwWareHandle = (url2, val) => {
        request({
          url: "/admin-api/storage/overseas/goods/receive",
          data: {
            orderNo: val
          },
          methods: "POST"
        }).then((res) => {
          GDHPStoreInfo.$state.reviceObj = res;
          changePage(url2, val);
        });
      };
      const changePage = (url2, code2) => {
        uni.navigateTo({
          url: url2 + "?code=" + code2
        });
      };
      const goBack = () => {
        uni.navigateTo({
          url: "../tab/index"
        });
      };
      const __returned__ = { locale, t: t2, GDHPStoreInfo, HWHJStoreInfo, showPop, cameraId, list, getCameras, type, inpVal, popComfirm, hwUserGet, hwCollect, hwWarehouseHandle, vertifyShelf, gdShouhuo, gdChuku, hwRecHandle, hwWareHandle, changePage, goBack, get request() {
        return request;
      }, get showToast() {
        return showToast;
      }, get onLoad() {
        return onLoad;
      }, get useI18n() {
        return useI18n;
      }, ref: vue.ref, get GDHPStore() {
        return GDHPStore;
      }, get HWHJStore() {
        return HWHJStore;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10 topNav" }, [
        vue.createElementVNode("view", { onClick: $setup.goBack }, [
          vue.createElementVNode("image", {
            src: _imports_0,
            class: "ww24 hh24"
          })
        ]),
        vue.createElementVNode(
          "view",
          { class: "text_white text_bold f17" },
          vue.toDisplayString($setup.t("home.h_a1")),
          1
          /* TEXT */
        ),
        vue.createElementVNode("view", { class: "ww24" })
      ]),
      vue.createElementVNode("view", { class: "sectionview" }, [
        vue.createElementVNode("view", {
          id: "qr-reader",
          style: { "width": "100%", "height": "550px" }
        })
      ]),
      $setup.type == 1 || $setup.type == 5 ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 0,
          class: "centerWord pdlr35 f13 text_white text_center"
        },
        vue.toDisplayString($setup.t("home.h_a2")),
        1
        /* TEXT */
      )) : vue.createCommentVNode("v-if", true),
      $setup.type == 2 ? (vue.openBlock(), vue.createElementBlock(
        "view",
        {
          key: 1,
          class: "centerWord pdlr35 f13 text_white text_center"
        },
        vue.toDisplayString($setup.t("home.h_a3")),
        1
        /* TEXT */
      )) : vue.createCommentVNode("v-if", true),
      vue.createCommentVNode(' v-if="type != 4" '),
      vue.createElementVNode("view", { class: "botBtn center" }, [
        vue.createElementVNode("view", {
          class: "inpEl mt24 flex col_center",
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.showPop = true)
        }, [
          vue.createElementVNode("image", {
            src: _imports_1$5,
            class: "ww24 hh24"
          }),
          vue.createElementVNode(
            "view",
            { class: "colorAf ml12" },
            vue.toDisplayString($setup.t("home.h_a4")),
            1
            /* TEXT */
          )
        ])
      ]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPop,
        "onUpdate:show": _cache[2] || (_cache[2] = ($event) => $setup.showPop = $event),
        round: "",
        style: vue.normalizeStyle({ padding: "30px 20px", width: "calc(100vw - 90px)" }),
        closeable: true
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", null, [
            vue.createElementVNode(
              "view",
              { class: "text_bold text_center f17" },
              vue.toDisplayString($setup.t("home.h_a5")),
              1
              /* TEXT */
            ),
            vue.createElementVNode(
              "view",
              {
                class: "mt16 f11 colorAf text_center",
                style: { "line-height": "13px" }
              },
              vue.toDisplayString($setup.type != 2 ? $setup.t("home.h_a6") : $setup.t("home.h_a7")),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", {
              class: "inpEl mt30 flex col_center",
              style: { "width": "calc(100% - 20px)", "background": "#F1F1F3" }
            }, [
              vue.createElementVNode("image", {
                src: _imports_1$5,
                class: "ww24 hh24"
              }),
              vue.withDirectives(vue.createElementVNode("input", {
                type: "text",
                class: "ml8",
                placeholder: $setup.t("home.h_a4"),
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.inpVal = $event)
              }, null, 8, ["placeholder"]), [
                [vue.vModelText, $setup.inpVal]
              ])
            ]),
            vue.createElementVNode(
              "view",
              {
                class: "btns f14 text_white",
                onClick: $setup.popComfirm
              },
              vue.toDisplayString($setup.t("setting.s_s6")),
              1
              /* TEXT */
            )
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show", "style"])
    ]);
  }
  const PagesHomeScanCode = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$7], ["__scopeId", "data-v-dbed8a33"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/scanCode.vue"]]);
  const _imports_1$4 = "/static/icons/smallScan.png";
  const _sfc_main$7 = {
    __name: "receiveSuccess",
    setup(__props, { expose: __expose }) {
      __expose();
      const GDHPStoreInfo = GDHPStore();
      const scanVal = vue.ref(0);
      onLoad((e2) => {
        if (e2.code) {
          scanVal.value = e2.code;
        }
      });
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const pageData = vue.computed(() => {
        return GDHPStoreInfo.$state.reviceObj;
      });
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { GDHPStoreInfo, scanVal, changePage, pageData, goBack, onMounted: vue.onMounted, topNavbar, get showToast() {
        return showToast;
      }, get GDHPStore() {
        return GDHPStore;
      }, get request() {
        return request;
      }, get onLoad() {
        return onLoad;
      }, ref: vue.ref, computed: vue.computed };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10" }, [
        vue.createElementVNode("view", { class: "ww50" }),
        vue.createElementVNode("view", { class: "text_bold f17" }, "Receiving"),
        vue.createElementVNode("view", {
          class: "color999 ww50 f14",
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("/pages/tab/index"))
        }, "Return")
      ]),
      vue.createElementVNode("view", { class: "pdlr20 mt73" }, [
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("image", {
            src: _imports_0$1,
            style: { "width": "69px", "height": "94px" }
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f20 text_bold mt20" }, " Succeeded "),
        vue.createElementVNode("view", {
          class: "colorAf pdlr35 f12 mt8 text_center",
          style: { "line-height": "18px" }
        }, " The current product has been successfully warehoused "),
        vue.createElementVNode("view", { class: "resBox" }, [
          vue.createElementVNode("view", { class: "between flex1" }, [
            vue.createElementVNode(
              "view",
              { class: "f15 text_bold" },
              vue.toDisplayString($setup.pageData.categoryName),
              1
              /* TEXT */
            ),
            vue.createElementVNode(
              "view",
              { class: "f12" },
              "x" + vue.toDisplayString($setup.pageData.num),
              1
              /* TEXT */
            )
          ])
        ]),
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("view", {
            class: "center botBtn",
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.changePage("./scanCode?type=1"))
          }, [
            vue.createElementVNode("image", {
              src: _imports_1$4,
              class: "ww24 hh24"
            }),
            vue.createElementVNode("view", { class: "f14 ml8" }, " Continue ")
          ])
        ])
      ])
    ]);
  }
  const PagesHomeReceiveSuccess = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$6], ["__scopeId", "data-v-dabd1912"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/receiveSuccess.vue"]]);
  const _imports_3$1 = "/static/icons/upload.png";
  const _sfc_main$6 = {
    __name: "warehouse",
    setup(__props, { expose: __expose }) {
      __expose();
      const HWHJStoreInfo = HWHJStore();
      const cancelHandle = () => {
        HWHJStoreInfo.$state.warehouseList = [];
        uni.navigateTo({
          url: "/pages/tab/index"
        });
      };
      const goodsList = vue.computed(() => {
        return HWHJStoreInfo.$state.warehouseList;
      });
      const shelfVal = vue.ref([1]);
      const columns = vue.ref([]);
      const showPicker = vue.ref(false);
      const confirmShelfHandle = (e2) => {
        HWHJStoreInfo.$state.default_shelf[1] = e2.selectedValues[0];
        showPicker.value = false;
      };
      const deleteHandle = (item, index2) => {
        HWHJStoreInfo.$state.warehouseList.splice(index2, 1);
      };
      const uploadGoods = () => {
        const orderNoList = goodsList.value.map((item) => {
          return item.orderNo;
        });
        request({
          url: "/admin-api/storage/overseas/goods/batch-put-on-shelf",
          data: {
            shelf: default_shelfVal.value[0],
            floor: default_shelfVal.value[1],
            orderNoList
          },
          methods: "PUT"
        }).then((res) => {
          showToast("Batch success");
          changePage("./wareSuccess");
        }).catch((e2) => {
          showToast(e2.msg);
        });
      };
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const default_shelfVal = vue.computed(() => {
        return HWHJStoreInfo.$state.default_shelf;
      });
      const layersList = vue.ref([]);
      const getClassList = () => {
        request({
          url: "/admin-api/storage/overseas/goods-location/floor-list/" + default_shelfVal.value[0]
        }).then((res) => {
          layersList.value = res.floorList.map((item) => {
            return {
              name: item,
              value: item
            };
          });
        });
      };
      getClassList();
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { HWHJStoreInfo, cancelHandle, goodsList, shelfVal, columns, showPicker, confirmShelfHandle, deleteHandle, uploadGoods, changePage, default_shelfVal, layersList, getClassList, goBack, topNavbar, get request() {
        return request;
      }, get HWHJStore() {
        return HWHJStore;
      }, get showToast() {
        return showToast;
      }, ref: vue.ref, computed: vue.computed };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_picker = vue.resolveComponent("van-picker");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Warehousing",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.createElementVNode("view", {
            class: "color999 f14",
            onClick: $setup.cancelHandle
          }, "Cancel")
        ])
      ]),
      vue.createElementVNode("view", { class: "pdlr12 pt12" }, [
        vue.createElementVNode("view", { class: "topBox pdlr12 pt21 pb16" }, [
          vue.createElementVNode("view", { class: "f16" }, [
            vue.createElementVNode("span", { class: "colorFc" }, "*"),
            vue.createTextVNode(" Shelf")
          ]),
          vue.createElementVNode("view", {
            class: "mt19 shelfBox center flex-col",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.showPicker = true)
          }, [
            vue.createElementVNode(
              "view",
              { class: "f24 text_bold" },
              "Shelf " + vue.toDisplayString($setup.default_shelfVal[0]) + "- Layer " + vue.toDisplayString($setup.default_shelfVal[1]),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", { class: "mt4 f15 color7C" }, "current shelf")
          ])
        ]),
        vue.createElementVNode("view", { class: "mt12 botBox" }, [
          vue.createElementVNode("view", { class: "between" }, [
            vue.createElementVNode("view", { class: "f16 text_bold" }, "Goods"),
            vue.createElementVNode("view", {
              class: "rightBtn flex col_center f12",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.changePage("./scanCode?type=3"))
            }, [
              vue.createElementVNode("image", {
                src: _imports_1$8,
                class: "ww24 hh24"
              }),
              vue.createTextVNode(" Scan ")
            ])
          ]),
          vue.createElementVNode("view", { class: "goodsBox" }, [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.goodsList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", {
                  class: "between goodsItem",
                  key: index2
                }, [
                  vue.createElementVNode("view", { class: "flex col_center" }, [
                    vue.createElementVNode(
                      "view",
                      null,
                      vue.toDisplayString(item.categoryName),
                      1
                      /* TEXT */
                    ),
                    vue.createElementVNode(
                      "view",
                      { class: "pl15" },
                      "X" + vue.toDisplayString(item.num),
                      1
                      /* TEXT */
                    )
                  ]),
                  vue.createElementVNode("image", {
                    src: _imports_2$1,
                    class: "ww24 hh24",
                    onClick: ($event) => $setup.deleteHandle(item, index2)
                  }, null, 8, ["onClick"])
                ]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ]),
        $setup.goodsList.length > 0 ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "btns f14 text_white center",
          onClick: $setup.uploadGoods
        }, [
          vue.createElementVNode("image", {
            src: _imports_3$1,
            class: "ww24 hh24"
          }),
          vue.createTextVNode(),
          vue.createElementVNode("view", { class: "ml8" }, "Batch Warehousing")
        ])) : vue.createCommentVNode("v-if", true)
      ]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPicker,
        "onUpdate:show": _cache[4] || (_cache[4] = ($event) => $setup.showPicker = $event),
        round: "",
        position: "bottom"
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_van_picker, {
            modelValue: $setup.shelfVal,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.shelfVal = $event),
            title: "Layers",
            columns: $setup.layersList,
            "confirm-button-text": "Confirm",
            "cancel-button-text": "Cancel",
            onConfirm: $setup.confirmShelfHandle,
            "columns-field-names": { text: "name" },
            onCancel: _cache[3] || (_cache[3] = ($event) => $setup.showPicker = false)
          }, null, 8, ["modelValue", "columns"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createElementVNode("view", { style: { "height": "50px" } })
    ]);
  }
  const PagesHomeWarehouse = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$5], ["__scopeId", "data-v-48e114f6"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/warehouse.vue"]]);
  const _imports_1$3 = "/static/icons/r_back.png";
  const _sfc_main$5 = {
    __name: "wareSuccess",
    setup(__props, { expose: __expose }) {
      __expose();
      const scanVal = vue.ref(0);
      onLoad((e2) => {
        if (e2.code) {
          scanVal.value = e2.code;
        }
      });
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const changeTabPage = (url2) => {
        uni.switchTab({
          url: url2
        });
      };
      const __returned__ = { scanVal, changePage, changeTabPage, onMounted: vue.onMounted, topNavbar, get showToast() {
        return showToast;
      }, ref: vue.ref, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "between pdlr20 pdtb10" }, [
        vue.createElementVNode("view", { class: "ww50" }),
        vue.createElementVNode("view", { class: "text_bold f17" }, "Receiving"),
        vue.createElementVNode("view", { class: "color999 f14 ww50" })
      ]),
      vue.createElementVNode("view", { class: "pdlr20 mt73" }, [
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("image", {
            src: _imports_0$1,
            style: { "width": "69px", "height": "94px" }
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f20 text_bold mt20" }, " Succeeded "),
        vue.createElementVNode("view", {
          class: "colorAf pdlr35 f12 mt8 text_center",
          style: { "line-height": "18px" }
        }, [
          vue.createTextVNode(" Warehousing on "),
          vue.createElementVNode("span", { class: "colorBlue text_bold" }, " shelf 1- layer 1"),
          vue.createTextVNode(" is successful Please place the goods at this position ")
        ]),
        vue.createElementVNode("view", { class: "center" }, [
          vue.createElementVNode("view", {
            class: "center botBtn",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("/pages/tab/index"))
          }, [
            vue.createElementVNode("image", {
              src: _imports_1$3,
              class: "ww24 hh24"
            }),
            vue.createElementVNode("view", { class: "f14 ml8" }, " Return ")
          ])
        ])
      ])
    ]);
  }
  const PagesHomeWareSuccess = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$4], ["__scopeId", "data-v-1a124ae9"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/home/wareSuccess.vue"]]);
  const _imports_1$2 = "/static/icons/add.png";
  const _sfc_main$4 = {
    __name: "index",
    setup(__props, { expose: __expose }) {
      __expose();
      const shelfList = vue.ref([]);
      const changePage = (url2) => {
        uni.navigateTo({
          url: url2
        });
      };
      const checkShelf = (item) => {
        uni.navigateTo({
          url: "./deatil?item=" + item
        });
      };
      const dataList = vue.ref([]);
      const paging = vue.ref("");
      const pages2 = vue.ref({
        pageNo: 1,
        pageSize: 10
      });
      const queryList = (page2) => {
        pages2.value.pageNo = page2;
        request({
          url: "/admin-api/storage/overseas/goods-location/shelf-page",
          data: pages2.value
        }).then((res) => {
          paging.value.complete(res.list);
          pages2.value.pageNo++;
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { shelfList, changePage, checkShelf, dataList, paging, pages: pages2, queryList, goBack, get request() {
        return request;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_z_paging = resolveEasycom(vue.resolveDynamicComponent("z-paging"), __easycom_0);
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Shelf",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.createElementVNode("view", {
            class: "flex col_center",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.changePage("./add"))
          }, [
            vue.createElementVNode("image", {
              src: _imports_1$2,
              class: "ww24 hh24"
            }),
            vue.createTextVNode(),
            vue.createElementVNode("view", { class: "ml4 f14" }, "Compile")
          ])
        ])
      ]),
      vue.createElementVNode("view", { class: "pdlr12 pt12" }, [
        vue.createVNode(_component_z_paging, {
          ref: "paging",
          modelValue: $setup.dataList,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.dataList = $event),
          onQuery: $setup.queryList,
          fixed: false,
          "use-page-scroll": true,
          "refresher-enabled": false
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList($setup.dataList, (item, index2) => {
                return vue.openBlock(), vue.createElementBlock("view", { class: "shelfItem between" }, [
                  vue.createElementVNode(
                    "view",
                    {
                      class: vue.normalizeClass(["hasBeforeLine f16 text_bold", index2 % 3 == 0 ? "borderBlue" : index2 % 3 == 1 ? "borderGreen" : "borderOrange"])
                    },
                    " Shelf " + vue.toDisplayString(item),
                    3
                    /* TEXT, CLASS */
                  ),
                  vue.createElementVNode("view", {
                    class: "color7C f12 flex col_center",
                    onClick: ($event) => $setup.checkShelf(item)
                  }, [
                    vue.createTextVNode(" Check "),
                    vue.createElementVNode("image", {
                      src: _imports_2$2,
                      class: "ww24 hh24"
                    })
                  ], 8, ["onClick"])
                ]);
              }),
              256
              /* UNKEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue"])
      ])
    ]);
  }
  const PagesShelfIndex = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$3], ["__scopeId", "data-v-bb118f84"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/shelf/index.vue"]]);
  const _imports_1$1 = "/static/icons/b_down.png";
  const _imports_1 = "/static/icons/blue_add.png";
  const _imports_2 = "/static/icons/rt_delete.png";
  const _sfc_main$3 = {
    __name: "add",
    setup(__props, { expose: __expose }) {
      __expose();
      const HWHJStoreDeatil = HWHJStore();
      const shelfVal = vue.ref([0]);
      const layerVal = vue.ref([0]);
      const showPickerShelf = vue.ref(false);
      const confirmShelfHandle = (e2) => {
        shelfVal.value = e2.selectedValues;
        showPickerShelf.value = false;
      };
      const showPickerLayer = vue.ref(false);
      const confirmLayerHandle = (e2) => {
        if (layerList.value.length > 0) {
          layerList.value.forEach((item, index2) => {
            if (item.value == Number(e2.selectedValues[0])) {
              layerList.value.splice(index2, 1);
            }
          });
          choLayerList.value.push(e2.selectedValues[0]);
          choLayerList.value.sort((a2, b2) => a2 - b2);
          if (layerList.value.length > 0) {
            layerVal.value = [layerList.value[0].name];
          }
        }
        showPickerLayer.value = false;
      };
      const deleteItem = (item, ind) => {
        let obj = {
          name: item,
          value: item
        };
        layerList.value.push(obj);
        layerList.value.sort((a2, b2) => a2.value - b2.value);
        choLayerList.value.splice(ind, 1);
      };
      const choLayerList = vue.ref([]);
      const shelfList = vue.ref([]);
      const layerListStatic = HWHJStoreDeatil.LAYERSLIST;
      const layerList = vue.ref([]);
      const getShelfList = () => {
        request({
          url: "/admin-api/storage/overseas/goods-location/new-shelf-list/"
        }).then((res) => {
          shelfList.value = res.map((item) => {
            return {
              name: item,
              value: item
            };
          });
          layerList.value = layerListStatic.map((item) => {
            return {
              name: item,
              value: item
            };
          });
          shelfVal.value = [shelfList.value[0].name];
        });
      };
      getShelfList();
      const confirmAddHandle = () => {
        if (choLayerList.value.length == 0)
          return;
        let floorList = choLayerList.value;
        request({
          url: "/admin-api/storage/overseas/goods-location/create-shelf",
          data: {
            shelf: shelfVal.value[0],
            floorList
          },
          methods: "POST"
        }).then((res) => {
          uni.showToast({
            title: "Add success",
            icon: "none"
          });
          uni.navigateTo({
            url: "./index"
          });
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { HWHJStoreDeatil, shelfVal, layerVal, showPickerShelf, confirmShelfHandle, showPickerLayer, confirmLayerHandle, deleteItem, choLayerList, shelfList, layerListStatic, layerList, getShelfList, confirmAddHandle, goBack, get request() {
        return request;
      }, get HWHJStore() {
        return HWHJStore;
      }, ref: vue.ref };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_picker = vue.resolveComponent("van-picker");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", null, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Compile",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "mt20 pdlr12" }, [
        vue.createElementVNode("view", { class: "between" }, [
          vue.createElementVNode("view", { class: "f16 text_bold" }, "New Shelves"),
          vue.createElementVNode("view", { class: "colorAf f12" }, "Please complete the required fields")
        ]),
        vue.createElementVNode("view", { class: "mt20 shelfBox between" }, [
          vue.createElementVNode("view", { class: "f15" }, [
            vue.createElementVNode("span", { class: "colorFc" }, "*"),
            vue.createTextVNode(" Shelf ")
          ]),
          vue.createElementVNode("view", {
            class: "flex col_center",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.showPickerShelf = true)
          }, [
            vue.createTextVNode(
              vue.toDisplayString($setup.shelfVal[0]) + " ",
              1
              /* TEXT */
            ),
            vue.createElementVNode("image", {
              src: _imports_1$1,
              class: "ww24 hh24"
            })
          ])
        ]),
        vue.createElementVNode("view", { class: "mt47" }, [
          vue.createElementVNode("view", { class: "between" }, [
            vue.createElementVNode("view", null, "Layers"),
            vue.createElementVNode("view", {
              class: "flex col_center f12",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.showPickerLayer = true)
            }, [
              vue.createElementVNode("image", {
                src: _imports_1,
                class: "ww12 hh12"
              }),
              vue.createElementVNode("view", { class: "ml6 colorBlue" }, "Add")
            ])
          ])
        ]),
        vue.createElementVNode("view", { class: "layersBox mt27" }, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.choLayerList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", { class: "layersItem between" }, [
                vue.createElementVNode("view", { class: "f15" }, "Layer"),
                vue.createElementVNode("view", { class: "flex col_center" }, [
                  vue.createElementVNode(
                    "view",
                    { class: "mr5" },
                    vue.toDisplayString(item),
                    1
                    /* TEXT */
                  ),
                  vue.createElementVNode("image", {
                    src: _imports_1$1,
                    class: "ww24 hh24"
                  })
                ]),
                vue.createElementVNode("view", {
                  class: "deleteIcon",
                  onClick: vue.withModifiers(($event) => $setup.deleteItem(item, index2), ["stop"])
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_2,
                    class: "ww14 hh14"
                  })
                ], 8, ["onClick"])
              ]);
            }),
            256
            /* UNKEYED_FRAGMENT */
          ))
        ])
      ]),
      vue.createCommentVNode(" shelf "),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPickerShelf,
        "onUpdate:show": _cache[4] || (_cache[4] = ($event) => $setup.showPickerShelf = $event),
        round: "",
        position: "bottom"
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_van_picker, {
            modelValue: $setup.shelfVal,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.shelfVal = $event),
            title: "Shelf",
            columns: $setup.shelfList,
            "confirm-button-text": "Confirm",
            "cancel-button-text": "Cancel",
            onConfirm: $setup.confirmShelfHandle,
            "columns-field-names": { text: "name" },
            onCancel: _cache[3] || (_cache[3] = ($event) => $setup.showPickerShelf = false)
          }, null, 8, ["modelValue", "columns"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPickerLayer,
        "onUpdate:show": _cache[7] || (_cache[7] = ($event) => $setup.showPickerLayer = $event),
        round: "",
        position: "bottom"
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_van_picker, {
            modelValue: $setup.layerVal,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $setup.layerVal = $event),
            title: "Layers",
            columns: $setup.layerList,
            "confirm-button-text": "Confirm",
            "cancel-button-text": "Cancel",
            onConfirm: $setup.confirmLayerHandle,
            "columns-field-names": { text: "name" },
            onCancel: _cache[6] || (_cache[6] = ($event) => $setup.showPickerLayer = false)
          }, null, 8, ["modelValue", "columns"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createElementVNode("view", { class: "fixedBot" }, [
        vue.createElementVNode("view", { class: "girdBtn" }, [
          vue.createElementVNode("view", {
            class: "botBtn cancelBtn center color7C",
            onClick: $setup.goBack
          }, "Cancel"),
          vue.createElementVNode(
            "view",
            {
              class: vue.normalizeClass(["botBtn center text_white confirmBtn", $setup.choLayerList.length == 0 ? "disabledBtn" : ""]),
              onClick: $setup.confirmAddHandle
            },
            " Confirm",
            2
            /* CLASS */
          )
        ])
      ])
    ]);
  }
  const PagesShelfAdd = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2], ["__scopeId", "data-v-465b5518"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/shelf/add.vue"]]);
  const props = {
    props: {
      //
      value: {
        type: [String, Number]
      },
      //
      options: {
        type: Object,
        default: () => {
          return {};
        }
      },
      //
      size: {
        type: [String, Number],
        default: 200
      },
      //
      fileType: {
        type: String,
        default: "png"
      },
      //
      start: {
        type: Boolean,
        default: true
      },
      //
      auto: {
        type: Boolean,
        default: true
      },
      //
      hide: {
        type: Boolean,
        default: false
      },
      /**
       * canvas 2d2d
       * type2dPCtoDataURLPC2d
       */
      type: {
        type: String,
        default: () => {
          return "normal";
        }
      },
      //NVue
      queue: {
        type: Boolean,
        default: false
      },
      //canvas
      isQueueLoadImage: {
        type: Boolean,
        default: false
      },
      //loading
      loading: {
        type: Boolean,
        default: void 0
      },
      //H5false
      h5SaveIsDownload: {
        type: Boolean,
        default: false
      },
      //H5
      h5DownloadName: {
        type: String,
        default: "uvQRCode"
      },
      // H5
      h5SaveTip: {
        type: Boolean,
        default: true
      }
    }
  };
  const mpMixin = {};
  function email(value) {
    return /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/.test(value);
  }
  function mobile(value) {
    return /^1([3589]\d|4[5-9]|6[1-2,4-7]|7[0-8])\d{8}$/.test(value);
  }
  function url(value) {
    return /^((https|http|ftp|rtsp|mms):\/\/)(([0-9a-zA-Z_!~*'().&=+$%-]+: )?[0-9a-zA-Z_!~*'().&=+$%-]+@)?(([0-9]{1,3}.){3}[0-9]{1,3}|([0-9a-zA-Z_!~*'()-]+.)*([0-9a-zA-Z][0-9a-zA-Z-]{0,61})?[0-9a-zA-Z].[a-zA-Z]{2,6})(:[0-9]{1,4})?((\/?)|(\/[0-9a-zA-Z_!~*'().;?:@&=+$,%#-]+)+\/?)$/.test(value);
  }
  function date(value) {
    if (!value)
      return false;
    if (number(value))
      value = +value;
    return !/Invalid|NaN/.test(new Date(value).toString());
  }
  function dateISO(value) {
    return /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
  }
  function number(value) {
    return /^[\+-]?(\d+\.?\d*|\.\d+|\d\.\d+e\+\d+)$/.test(value);
  }
  function string(value) {
    return typeof value === "string";
  }
  function digits(value) {
    return /^\d+$/.test(value);
  }
  function idCard(value) {
    return /^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$/.test(
      value
    );
  }
  function carNo(value) {
    const xreg = /^[A-Z]{1}[A-Z]{1}(([0-9]{5}[DF]$)|([DF][A-HJ-NP-Z0-9][0-9]{4}$))/;
    const creg = /^[A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9]{1}$/;
    if (value.length === 7) {
      return creg.test(value);
    }
    if (value.length === 8) {
      return xreg.test(value);
    }
    return false;
  }
  function amount(value) {
    return /^[1-9]\d*(,\d{3})*(\.\d{1,2})?$|^0\.\d{1,2}$/.test(value);
  }
  function chinese(value) {
    const reg = /^[\u4e00-\u9fa5]+$/gi;
    return reg.test(value);
  }
  function letter(value) {
    return /^[a-zA-Z]*$/.test(value);
  }
  function enOrNum(value) {
    const reg = /^[0-9a-zA-Z]*$/g;
    return reg.test(value);
  }
  function contains(value, param) {
    return value.indexOf(param) >= 0;
  }
  function range$1(value, param) {
    return value >= param[0] && value <= param[1];
  }
  function rangeLength(value, param) {
    return value.length >= param[0] && value.length <= param[1];
  }
  function landline(value) {
    const reg = /^\d{3,4}-\d{7,8}(-\d{3,4})?$/;
    return reg.test(value);
  }
  function empty(value) {
    switch (typeof value) {
      case "undefined":
        return true;
      case "string":
        if (value.replace(/(^[ \t\n\r]*)|([ \t\n\r]*$)/g, "").length == 0)
          return true;
        break;
      case "boolean":
        if (!value)
          return true;
        break;
      case "number":
        if (value === 0 || isNaN(value))
          return true;
        break;
      case "object":
        if (value === null || value.length === 0)
          return true;
        for (const i2 in value) {
          return false;
        }
        return true;
    }
    return false;
  }
  function jsonString(value) {
    if (typeof value === "string") {
      try {
        const obj = JSON.parse(value);
        if (typeof obj === "object" && obj) {
          return true;
        }
        return false;
      } catch (e2) {
        return false;
      }
    }
    return false;
  }
  function array(value) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(value);
    }
    return Object.prototype.toString.call(value) === "[object Array]";
  }
  function object(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function code(value, len = 6) {
    return new RegExp(`^\\d{${len}}$`).test(value);
  }
  function func(value) {
    return typeof value === "function";
  }
  function promise(value) {
    return object(value) && func(value.then) && func(value.catch);
  }
  function image(value) {
    const newValue = value.split("?")[0];
    const IMAGE_REGEXP2 = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg)/i;
    return IMAGE_REGEXP2.test(newValue);
  }
  function video(value) {
    const VIDEO_REGEXP = /\.(mp4|mpg|mpeg|dat|asf|avi|rm|rmvb|mov|wmv|flv|mkv|m3u8)/i;
    return VIDEO_REGEXP.test(value);
  }
  function regExp(o2) {
    return o2 && Object.prototype.toString.call(o2) === "[object RegExp]";
  }
  const test = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    amount,
    array,
    carNo,
    chinese,
    code,
    contains,
    date,
    dateISO,
    digits,
    email,
    empty,
    enOrNum,
    func,
    idCard,
    image,
    jsonString,
    landline,
    letter,
    mobile,
    number,
    object,
    promise,
    range: range$1,
    rangeLength,
    regExp,
    string,
    url,
    video
  }, Symbol.toStringTag, { value: "Module" }));
  function strip(num, precision = 15) {
    return +parseFloat(Number(num).toPrecision(precision));
  }
  function digitLength(num) {
    const eSplit = num.toString().split(/[eE]/);
    const len = (eSplit[0].split(".")[1] || "").length - +(eSplit[1] || 0);
    return len > 0 ? len : 0;
  }
  function float2Fixed(num) {
    if (num.toString().indexOf("e") === -1) {
      return Number(num.toString().replace(".", ""));
    }
    const dLen = digitLength(num);
    return dLen > 0 ? strip(Number(num) * Math.pow(10, dLen)) : Number(num);
  }
  function checkBoundary(num) {
    {
      if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {
        formatAppLog("warn", "at node_modules/@climblee/uv-ui/libs/function/digit.js:45", `${num} `);
      }
    }
  }
  function iteratorOperation(arr, operation) {
    const [num1, num2, ...others] = arr;
    let res = operation(num1, num2);
    others.forEach((num) => {
      res = operation(res, num);
    });
    return res;
  }
  function times(...nums) {
    if (nums.length > 2) {
      return iteratorOperation(nums, times);
    }
    const [num1, num2] = nums;
    const num1Changed = float2Fixed(num1);
    const num2Changed = float2Fixed(num2);
    const baseNum = digitLength(num1) + digitLength(num2);
    const leftValue = num1Changed * num2Changed;
    checkBoundary(leftValue);
    return leftValue / Math.pow(10, baseNum);
  }
  function divide(...nums) {
    if (nums.length > 2) {
      return iteratorOperation(nums, divide);
    }
    const [num1, num2] = nums;
    const num1Changed = float2Fixed(num1);
    const num2Changed = float2Fixed(num2);
    checkBoundary(num1Changed);
    checkBoundary(num2Changed);
    return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
  }
  function round(num, ratio) {
    const base = Math.pow(10, ratio);
    let result = divide(Math.round(Math.abs(times(num, base))), base);
    if (num < 0 && result !== 0) {
      result = times(result, -1);
    }
    return result;
  }
  function range(min = 0, max = 0, value = 0) {
    return Math.max(min, Math.min(max, Number(value)));
  }
  function getPx(value, unit = false) {
    if (number(value)) {
      return unit ? `${value}px` : Number(value);
    }
    if (/(rpx|upx)$/.test(value)) {
      return unit ? `${uni.upx2px(parseInt(value))}px` : Number(uni.upx2px(parseInt(value)));
    }
    return unit ? `${parseInt(value)}px` : parseInt(value);
  }
  function sleep(value = 30) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, value);
    });
  }
  function os() {
    return uni.getSystemInfoSync().platform.toLowerCase();
  }
  function sys() {
    return uni.getSystemInfoSync();
  }
  function random(min, max) {
    if (min >= 0 && max > 0 && max >= min) {
      const gab = max - min + 1;
      return Math.floor(Math.random() * gab + min);
    }
    return 0;
  }
  function guid(len = 32, firstU = true, radix = null) {
    const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
    const uuid = [];
    radix = radix || chars.length;
    if (len) {
      for (let i2 = 0; i2 < len; i2++)
        uuid[i2] = chars[0 | Math.random() * radix];
    } else {
      let r2;
      uuid[8] = uuid[13] = uuid[18] = uuid[23] = "-";
      uuid[14] = "4";
      for (let i2 = 0; i2 < 36; i2++) {
        if (!uuid[i2]) {
          r2 = 0 | Math.random() * 16;
          uuid[i2] = chars[i2 == 19 ? r2 & 3 | 8 : r2];
        }
      }
    }
    if (firstU) {
      uuid.shift();
      return `u${uuid.join("")}`;
    }
    return uuid.join("");
  }
  function $parent(name2 = void 0) {
    let parent = this.$parent;
    while (parent) {
      if (parent.$options && parent.$options.name !== name2) {
        parent = parent.$parent;
      } else {
        return parent;
      }
    }
    return false;
  }
  function addStyle(customStyle, target = "object") {
    if (empty(customStyle) || typeof customStyle === "object" && target === "object" || target === "string" && typeof customStyle === "string") {
      return customStyle;
    }
    if (target === "object") {
      customStyle = trim(customStyle);
      const styleArray = customStyle.split(";");
      const style = {};
      for (let i2 = 0; i2 < styleArray.length; i2++) {
        if (styleArray[i2]) {
          const item = styleArray[i2].split(":");
          style[trim(item[0])] = trim(item[1]);
        }
      }
      return style;
    }
    let string2 = "";
    for (const i2 in customStyle) {
      const key = i2.replace(/([A-Z])/g, "-$1").toLowerCase();
      string2 += `${key}:${customStyle[i2]};`;
    }
    return trim(string2);
  }
  function addUnit(value = "auto", unit = ((_b) => (_b = ((_a) => (_a = uni == null ? void 0 : uni.$uv) == null ? void 0 : _a.config)()) == null ? void 0 : _b.unit)() ? ((_d) => (_d = ((_c) => (_c = uni == null ? void 0 : uni.$uv) == null ? void 0 : _c.config)()) == null ? void 0 : _d.unit)() : "px") {
    value = String(value);
    return number(value) ? `${value}${unit}` : value;
  }
  function deepClone(obj, cache2 = /* @__PURE__ */ new WeakMap()) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (cache2.has(obj))
      return cache2.get(obj);
    let clone;
    if (obj instanceof Date) {
      clone = new Date(obj.getTime());
    } else if (obj instanceof RegExp) {
      clone = new RegExp(obj);
    } else if (obj instanceof Map) {
      clone = new Map(Array.from(obj, ([key, value]) => [key, deepClone(value, cache2)]));
    } else if (obj instanceof Set) {
      clone = new Set(Array.from(obj, (value) => deepClone(value, cache2)));
    } else if (Array.isArray(obj)) {
      clone = obj.map((value) => deepClone(value, cache2));
    } else if (Object.prototype.toString.call(obj) === "[object Object]") {
      clone = Object.create(Object.getPrototypeOf(obj));
      cache2.set(obj, clone);
      for (const [key, value] of Object.entries(obj)) {
        clone[key] = deepClone(value, cache2);
      }
    } else {
      clone = Object.assign({}, obj);
    }
    cache2.set(obj, clone);
    return clone;
  }
  function deepMerge(target = {}, source = {}) {
    target = deepClone(target);
    if (typeof target !== "object" || target === null || typeof source !== "object" || source === null)
      return target;
    const merged = Array.isArray(target) ? target.slice() : Object.assign({}, target);
    for (const prop in source) {
      if (!source.hasOwnProperty(prop))
        continue;
      const sourceValue = source[prop];
      const targetValue = merged[prop];
      if (sourceValue instanceof Date) {
        merged[prop] = new Date(sourceValue);
      } else if (sourceValue instanceof RegExp) {
        merged[prop] = new RegExp(sourceValue);
      } else if (sourceValue instanceof Map) {
        merged[prop] = new Map(sourceValue);
      } else if (sourceValue instanceof Set) {
        merged[prop] = new Set(sourceValue);
      } else if (typeof sourceValue === "object" && sourceValue !== null) {
        merged[prop] = deepMerge(targetValue, sourceValue);
      } else {
        merged[prop] = sourceValue;
      }
    }
    return merged;
  }
  function error(err) {
    {
      formatAppLog("error", "at node_modules/@climblee/uv-ui/libs/function/index.js:250", `uvui${err}`);
    }
  }
  function randomArray(array2 = []) {
    return array2.sort(() => Math.random() - 0.5);
  }
  if (!String.prototype.padStart) {
    String.prototype.padStart = function(maxLength, fillString = " ") {
      if (Object.prototype.toString.call(fillString) !== "[object String]") {
        throw new TypeError(
          "fillString must be String"
        );
      }
      const str = this;
      if (str.length >= maxLength)
        return String(str);
      const fillLength = maxLength - str.length;
      let times2 = Math.ceil(fillLength / fillString.length);
      while (times2 >>= 1) {
        fillString += fillString;
        if (times2 === 1) {
          fillString += fillString;
        }
      }
      return fillString.slice(0, fillLength) + str;
    };
  }
  function timeFormat(dateTime = null, formatStr = "yyyy-mm-dd") {
    let date2;
    if (!dateTime) {
      date2 = /* @__PURE__ */ new Date();
    } else if (/^\d{10}$/.test(dateTime == null ? void 0 : dateTime.toString().trim())) {
      date2 = new Date(dateTime * 1e3);
    } else if (typeof dateTime === "string" && /^\d+$/.test(dateTime.trim())) {
      date2 = new Date(Number(dateTime));
    } else if (typeof dateTime === "string" && dateTime.includes("-") && !dateTime.includes("T")) {
      date2 = new Date(dateTime.replace(/-/g, "/"));
    } else {
      date2 = new Date(dateTime);
    }
    const timeSource = {
      "y": date2.getFullYear().toString(),
      // 
      "m": (date2.getMonth() + 1).toString().padStart(2, "0"),
      // 
      "d": date2.getDate().toString().padStart(2, "0"),
      // 
      "h": date2.getHours().toString().padStart(2, "0"),
      // 
      "M": date2.getMinutes().toString().padStart(2, "0"),
      // 
      "s": date2.getSeconds().toString().padStart(2, "0")
      // 
      // 
    };
    for (const key in timeSource) {
      const [ret] = new RegExp(`${key}+`).exec(formatStr) || [];
      if (ret) {
        const beginIndex = key === "y" && ret.length === 2 ? 2 : 0;
        formatStr = formatStr.replace(ret, timeSource[key].slice(beginIndex));
      }
    }
    return formatStr;
  }
  function timeFrom(timestamp = null, format2 = "yyyy-mm-dd") {
    if (timestamp == null)
      timestamp = Number(/* @__PURE__ */ new Date());
    timestamp = parseInt(timestamp);
    if (timestamp.toString().length == 10)
      timestamp *= 1e3;
    let timer = (/* @__PURE__ */ new Date()).getTime() - timestamp;
    timer = parseInt(timer / 1e3);
    let tips = "";
    switch (true) {
      case timer < 300:
        tips = "";
        break;
      case (timer >= 300 && timer < 3600):
        tips = `${parseInt(timer / 60)}`;
        break;
      case (timer >= 3600 && timer < 86400):
        tips = `${parseInt(timer / 3600)}`;
        break;
      case (timer >= 86400 && timer < 2592e3):
        tips = `${parseInt(timer / 86400)}`;
        break;
      default:
        if (format2 === false) {
          if (timer >= 2592e3 && timer < 365 * 86400) {
            tips = `${parseInt(timer / (86400 * 30))}`;
          } else {
            tips = `${parseInt(timer / (86400 * 365))}`;
          }
        } else {
          tips = timeFormat(timestamp, format2);
        }
    }
    return tips;
  }
  function trim(str, pos = "both") {
    str = String(str);
    if (pos == "both") {
      return str.replace(/^\s+|\s+$/g, "");
    }
    if (pos == "left") {
      return str.replace(/^\s*/, "");
    }
    if (pos == "right") {
      return str.replace(/(\s*$)/g, "");
    }
    if (pos == "all") {
      return str.replace(/\s+/g, "");
    }
    return str;
  }
  function queryParams(data = {}, isPrefix = true, arrayFormat = "brackets") {
    const prefix = isPrefix ? "?" : "";
    const _result = [];
    if (["indices", "brackets", "repeat", "comma"].indexOf(arrayFormat) == -1)
      arrayFormat = "brackets";
    for (const key in data) {
      const value = data[key];
      if (["", void 0, null].indexOf(value) >= 0) {
        continue;
      }
      if (value.constructor === Array) {
        switch (arrayFormat) {
          case "indices":
            for (let i2 = 0; i2 < value.length; i2++) {
              _result.push(`${key}[${i2}]=${value[i2]}`);
            }
            break;
          case "brackets":
            value.forEach((_value) => {
              _result.push(`${key}[]=${_value}`);
            });
            break;
          case "repeat":
            value.forEach((_value) => {
              _result.push(`${key}=${_value}`);
            });
            break;
          case "comma":
            let commaStr = "";
            value.forEach((_value) => {
              commaStr += (commaStr ? "," : "") + _value;
            });
            _result.push(`${key}=${commaStr}`);
            break;
          default:
            value.forEach((_value) => {
              _result.push(`${key}[]=${_value}`);
            });
        }
      } else {
        _result.push(`${key}=${value}`);
      }
    }
    return _result.length ? prefix + _result.join("&") : "";
  }
  function toast(title, duration = 2e3) {
    uni.showToast({
      title: String(title),
      icon: "none",
      duration
    });
  }
  function type2icon(type = "success", fill = false) {
    if (["primary", "info", "error", "warning", "success"].indexOf(type) == -1)
      type = "success";
    let iconName = "";
    switch (type) {
      case "primary":
        iconName = "info-circle";
        break;
      case "info":
        iconName = "info-circle";
        break;
      case "error":
        iconName = "close-circle";
        break;
      case "warning":
        iconName = "error-circle";
        break;
      case "success":
        iconName = "checkmark-circle";
        break;
      default:
        iconName = "checkmark-circle";
    }
    if (fill)
      iconName += "-fill";
    return iconName;
  }
  function priceFormat(number2, decimals = 0, decimalPoint = ".", thousandsSeparator = ",") {
    number2 = `${number2}`.replace(/[^0-9+-Ee.]/g, "");
    const n2 = !isFinite(+number2) ? 0 : +number2;
    const prec = !isFinite(+decimals) ? 0 : Math.abs(decimals);
    const sep = typeof thousandsSeparator === "undefined" ? "," : thousandsSeparator;
    const dec = typeof decimalPoint === "undefined" ? "." : decimalPoint;
    let s2 = "";
    s2 = (prec ? round(n2, prec) + "" : `${Math.round(n2)}`).split(".");
    const re = /(-?\d+)(\d{3})/;
    while (re.test(s2[0])) {
      s2[0] = s2[0].replace(re, `$1${sep}$2`);
    }
    if ((s2[1] || "").length < prec) {
      s2[1] = s2[1] || "";
      s2[1] += new Array(prec - s2[1].length + 1).join("0");
    }
    return s2.join(dec);
  }
  function getDuration(value, unit = true) {
    const valueNum = parseInt(value);
    if (unit) {
      if (/s$/.test(value))
        return value;
      return value > 30 ? `${value}ms` : `${value}s`;
    }
    if (/ms$/.test(value))
      return valueNum;
    if (/s$/.test(value))
      return valueNum > 30 ? valueNum : valueNum * 1e3;
    return valueNum;
  }
  function padZero(value) {
    return `00${value}`.slice(-2);
  }
  function formValidate(instance2, event) {
    const formItem = $parent.call(instance2, "uv-form-item");
    const form = $parent.call(instance2, "uv-form");
    if (formItem && form) {
      form.validateField(formItem.prop, () => {
      }, event);
    }
  }
  function getProperty(obj, key) {
    if (!obj) {
      return;
    }
    if (typeof key !== "string" || key === "") {
      return "";
    }
    if (key.indexOf(".") !== -1) {
      const keys = key.split(".");
      let firstObj = obj[keys[0]] || {};
      for (let i2 = 1; i2 < keys.length; i2++) {
        if (firstObj) {
          firstObj = firstObj[keys[i2]];
        }
      }
      return firstObj;
    }
    return obj[key];
  }
  function setProperty(obj, key, value) {
    if (!obj) {
      return;
    }
    const inFn = function(_obj, keys, v2) {
      if (keys.length === 1) {
        _obj[keys[0]] = v2;
        return;
      }
      while (keys.length > 1) {
        const k = keys[0];
        if (!_obj[k] || typeof _obj[k] !== "object") {
          _obj[k] = {};
        }
        keys.shift();
        inFn(_obj[k], keys, v2);
      }
    };
    if (typeof key !== "string" || key === "")
      ;
    else if (key.indexOf(".") !== -1) {
      const keys = key.split(".");
      inFn(obj, keys, value);
    } else {
      obj[key] = value;
    }
  }
  function page() {
    var _a;
    const pages2 = getCurrentPages();
    const route2 = (_a = pages2[pages2.length - 1]) == null ? void 0 : _a.route;
    return `/${route2 ? route2 : ""}`;
  }
  function pages() {
    const pages2 = getCurrentPages();
    return pages2;
  }
  function getHistoryPage(back = 0) {
    const pages2 = getCurrentPages();
    const len = pages2.length;
    return pages2[len - 1 + back];
  }
  function setConfig({
    props: props2 = {},
    config: config2 = {},
    color = {},
    zIndex = {}
  }) {
    const {
      deepMerge: deepMerge2
    } = uni.$uv;
    uni.$uv.config = deepMerge2(uni.$uv.config, config2);
    uni.$uv.props = deepMerge2(uni.$uv.props, props2);
    uni.$uv.color = deepMerge2(uni.$uv.color, color);
    uni.$uv.zIndex = deepMerge2(uni.$uv.zIndex, zIndex);
  }
  const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    $parent,
    addStyle,
    addUnit,
    deepClone,
    deepMerge,
    error,
    formValidate,
    getDuration,
    getHistoryPage,
    getProperty,
    getPx,
    guid,
    os,
    padZero,
    page,
    pages,
    priceFormat,
    queryParams,
    random,
    randomArray,
    range,
    setConfig,
    setProperty,
    sleep,
    sys,
    timeFormat,
    timeFrom,
    toast,
    trim,
    type2icon
  }, Symbol.toStringTag, { value: "Module" }));
  class Router {
    constructor() {
      this.config = {
        type: "navigateTo",
        url: "",
        delta: 1,
        // navigateBack,
        params: {},
        // 
        animationType: "pop-in",
        // ,APP
        animationDuration: 300,
        // ,,APP
        intercept: false,
        // 
        events: {}
        // hbuilderx 2.8.9+ 
      };
      this.route = this.route.bind(this);
    }
    // url"/"
    addRootPath(url2) {
      return url2[0] === "/" ? url2 : `/${url2}`;
    }
    // 
    mixinParam(url2, params) {
      url2 = url2 && this.addRootPath(url2);
      let query = "";
      if (/.*\/.*\?.*=.*/.test(url2)) {
        query = queryParams(params, false);
        return url2 += `&${query}`;
      }
      query = queryParams(params);
      return url2 += query;
    }
    // 
    async route(options = {}, params = {}) {
      let mergeConfig = {};
      if (typeof options === "string") {
        mergeConfig.url = this.mixinParam(options, params);
        mergeConfig.type = "navigateTo";
      } else {
        mergeConfig = deepMerge(this.config, options);
        mergeConfig.url = this.mixinParam(options.url, options.params);
      }
      if (mergeConfig.url === page())
        return;
      if (params.intercept) {
        mergeConfig.intercept = params.intercept;
      }
      mergeConfig.params = params;
      mergeConfig = deepMerge(this.config, mergeConfig);
      if (typeof mergeConfig.intercept === "function") {
        const isNext = await new Promise((resolve, reject) => {
          mergeConfig.intercept(mergeConfig, resolve);
        });
        isNext && this.openPage(mergeConfig);
      } else {
        this.openPage(mergeConfig);
      }
    }
    // 
    openPage(config2) {
      const {
        url: url2,
        type,
        delta,
        animationType,
        animationDuration,
        events
      } = config2;
      if (config2.type == "navigateTo" || config2.type == "to") {
        uni.navigateTo({
          url: url2,
          animationType,
          animationDuration,
          events
        });
      }
      if (config2.type == "redirectTo" || config2.type == "redirect") {
        uni.redirectTo({
          url: url2
        });
      }
      if (config2.type == "switchTab" || config2.type == "tab") {
        uni.switchTab({
          url: url2
        });
      }
      if (config2.type == "reLaunch" || config2.type == "launch") {
        uni.reLaunch({
          url: url2
        });
      }
      if (config2.type == "navigateBack" || config2.type == "back") {
        uni.navigateBack({
          delta
        });
      }
    }
  }
  const route = new Router().route;
  let timeout = null;
  function debounce(func2, wait2 = 500, immediate = false) {
    if (timeout !== null)
      clearTimeout(timeout);
    if (immediate) {
      const callNow = !timeout;
      timeout = setTimeout(() => {
        timeout = null;
      }, wait2);
      if (callNow)
        typeof func2 === "function" && func2();
    } else {
      timeout = setTimeout(() => {
        typeof func2 === "function" && func2();
      }, wait2);
    }
  }
  let flag;
  function throttle(func2, wait2 = 500, immediate = true) {
    if (immediate) {
      if (!flag) {
        flag = true;
        typeof func2 === "function" && func2();
        setTimeout(() => {
          flag = false;
        }, wait2);
      }
    } else if (!flag) {
      flag = true;
      setTimeout(() => {
        flag = false;
        typeof func2 === "function" && func2();
      }, wait2);
    }
  }
  const mixin = {
    // 
    props: {
      // 
      customStyle: {
        type: [Object, String],
        default: () => ({})
      },
      customClass: {
        type: String,
        default: ""
      },
      // 
      url: {
        type: String,
        default: ""
      },
      // 
      linkType: {
        type: String,
        default: "navigateTo"
      }
    },
    data() {
      return {};
    },
    onLoad() {
      this.$uv.getRect = this.$uvGetRect;
    },
    created() {
      this.$uv.getRect = this.$uvGetRect;
    },
    computed: {
      $uv() {
        var _a, _b;
        return {
          ...index,
          test,
          route,
          debounce,
          throttle,
          unit: (_b = (_a = uni == null ? void 0 : uni.$uv) == null ? void 0 : _a.config) == null ? void 0 : _b.unit
        };
      },
      /**
       * bem
       * H5nvueclass:class="[bem()]"
       * ['a', 'b', 'c']'a b c'
       * @param {String} name 
       * @param {Array} fixed 
       * @param {Array} change truefalse
       * @returns {Array|string}
       */
      bem() {
        return function(name2, fixed, change) {
          const prefix = `uv-${name2}--`;
          const classes = {};
          if (fixed) {
            fixed.map((item) => {
              classes[prefix + this[item]] = true;
            });
          }
          if (change) {
            change.map((item) => {
              this[item] ? classes[prefix + item] = this[item] : delete classes[prefix + item];
            });
          }
          return Object.keys(classes);
        };
      }
    },
    methods: {
      // 
      openPage(urlKey = "url") {
        const url2 = this[urlKey];
        if (url2) {
          uni[this.linkType]({
            url: url2
          });
        }
      },
      // 
      // bug(2020-07-21)
      // view
      $uvGetRect(selector, all) {
        return new Promise((resolve) => {
          uni.createSelectorQuery().in(this)[all ? "selectAll" : "select"](selector).boundingClientRect((rect) => {
            if (all && Array.isArray(rect) && rect.length) {
              resolve(rect);
            }
            if (!all && rect) {
              resolve(rect);
            }
          }).exec();
        });
      },
      getParentData(parentName = "") {
        if (!this.parent)
          this.parent = {};
        this.parent = this.$uv.$parent.call(this, parentName);
        if (this.parent.children) {
          this.parent.children.indexOf(this) === -1 && this.parent.children.push(this);
        }
        if (this.parent && this.parentData) {
          Object.keys(this.parentData).map((key) => {
            this.parentData[key] = this.parent[key];
          });
        }
      },
      // 
      preventEvent(e2) {
        e2 && typeof e2.stopPropagation === "function" && e2.stopPropagation();
      },
      // 
      noop(e2) {
        this.preventEvent(e2);
      }
    },
    onReachBottom() {
      uni.$emit("uvOnReachBottom");
    },
    beforeDestroy() {
      if (this.parent && array(this.parent.children)) {
        const childrenList = this.parent.children;
        childrenList.map((child, index2) => {
          if (child === this) {
            childrenList.splice(index2, 1);
          }
        });
      }
    },
    // vue3
    unmounted() {
      if (this.parent && array(this.parent.children)) {
        const childrenList = this.parent.children;
        childrenList.map((child, index2) => {
          if (child === this) {
            childrenList.splice(index2, 1);
          }
        });
      }
    }
  };
  function o(o2) {
    this.mode = r.MODE_8BIT_BYTE, this.data = o2;
  }
  function e(o2, e2) {
    this.typeNumber = o2, this.errorCorrectLevel = e2, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = new Array();
  }
  o.prototype = { getLength: function(o2) {
    return this.data.length;
  }, write: function(o2) {
    for (var e2 = 0; e2 < this.data.length; e2++)
      o2.put(this.data.charCodeAt(e2), 8);
  } }, e.prototype = { addData: function(e2) {
    var r2 = new o(e2);
    this.dataList.push(r2), this.dataCache = null;
  }, isDark: function(o2, e2) {
    if (o2 < 0 || this.moduleCount <= o2 || e2 < 0 || this.moduleCount <= e2)
      throw new Error(o2 + "," + e2);
    return this.modules[o2][e2];
  }, getModuleCount: function() {
    return this.moduleCount;
  }, make: function() {
    if (this.typeNumber < 1) {
      var o2 = 1;
      for (o2 = 1; o2 < 40; o2++) {
        for (var e2 = v.getRSBlocks(o2, this.errorCorrectLevel), r2 = new p(), t2 = 0, i2 = 0; i2 < e2.length; i2++)
          t2 += e2[i2].dataCount;
        for (i2 = 0; i2 < this.dataList.length; i2++) {
          var n2 = this.dataList[i2];
          r2.put(n2.mode, 4), r2.put(n2.getLength(), h.getLengthInBits(n2.mode, o2)), n2.write(r2);
        }
        if (r2.getLengthInBits() <= 8 * t2)
          break;
      }
      this.typeNumber = o2;
    }
    this.makeImpl(false, this.getBestMaskPattern());
  }, makeImpl: function(o2, r2) {
    this.moduleCount = 4 * this.typeNumber + 17, this.modules = new Array(this.moduleCount);
    for (var t2 = 0; t2 < this.moduleCount; t2++) {
      this.modules[t2] = new Array(this.moduleCount);
      for (var i2 = 0; i2 < this.moduleCount; i2++)
        this.modules[t2][i2] = null;
    }
    this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(o2, r2), this.typeNumber >= 7 && this.setupTypeNumber(o2), null == this.dataCache && (this.dataCache = e.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, r2);
  }, setupPositionProbePattern: function(o2, e2) {
    for (var r2 = -1; r2 <= 7; r2++)
      if (!(o2 + r2 <= -1 || this.moduleCount <= o2 + r2))
        for (var t2 = -1; t2 <= 7; t2++)
          e2 + t2 <= -1 || this.moduleCount <= e2 + t2 || (this.modules[o2 + r2][e2 + t2] = 0 <= r2 && r2 <= 6 && (0 == t2 || 6 == t2) || 0 <= t2 && t2 <= 6 && (0 == r2 || 6 == r2) || 2 <= r2 && r2 <= 4 && 2 <= t2 && t2 <= 4);
  }, getBestMaskPattern: function() {
    for (var o2 = 0, e2 = 0, r2 = 0; r2 < 8; r2++) {
      this.makeImpl(true, r2);
      var t2 = h.getLostPoint(this);
      (0 == r2 || o2 > t2) && (o2 = t2, e2 = r2);
    }
    return e2;
  }, createMovieClip: function(o2, e2, r2) {
    var t2 = o2.createEmptyMovieClip(e2, r2);
    this.make();
    for (var i2 = 0; i2 < this.modules.length; i2++)
      for (var n2 = 1 * i2, a2 = 0; a2 < this.modules[i2].length; a2++) {
        var d2 = 1 * a2;
        this.modules[i2][a2] && (t2.beginFill(0, 100), t2.moveTo(d2, n2), t2.lineTo(d2 + 1, n2), t2.lineTo(d2 + 1, n2 + 1), t2.lineTo(d2, n2 + 1), t2.endFill());
      }
    return t2;
  }, setupTimingPattern: function() {
    for (var o2 = 8; o2 < this.moduleCount - 8; o2++)
      null == this.modules[o2][6] && (this.modules[o2][6] = o2 % 2 == 0);
    for (var e2 = 8; e2 < this.moduleCount - 8; e2++)
      null == this.modules[6][e2] && (this.modules[6][e2] = e2 % 2 == 0);
  }, setupPositionAdjustPattern: function() {
    for (var o2 = h.getPatternPosition(this.typeNumber), e2 = 0; e2 < o2.length; e2++)
      for (var r2 = 0; r2 < o2.length; r2++) {
        var t2 = o2[e2], i2 = o2[r2];
        if (null == this.modules[t2][i2])
          for (var n2 = -2; n2 <= 2; n2++)
            for (var a2 = -2; a2 <= 2; a2++)
              this.modules[t2 + n2][i2 + a2] = -2 == n2 || 2 == n2 || -2 == a2 || 2 == a2 || 0 == n2 && 0 == a2;
      }
  }, setupTypeNumber: function(o2) {
    for (var e2 = h.getBCHTypeNumber(this.typeNumber), r2 = 0; r2 < 18; r2++) {
      var t2 = !o2 && 1 == (e2 >> r2 & 1);
      this.modules[Math.floor(r2 / 3)][r2 % 3 + this.moduleCount - 8 - 3] = t2;
    }
    for (r2 = 0; r2 < 18; r2++) {
      t2 = !o2 && 1 == (e2 >> r2 & 1);
      this.modules[r2 % 3 + this.moduleCount - 8 - 3][Math.floor(r2 / 3)] = t2;
    }
  }, setupTypeInfo: function(o2, e2) {
    for (var r2 = this.errorCorrectLevel << 3 | e2, t2 = h.getBCHTypeInfo(r2), i2 = 0; i2 < 15; i2++) {
      var n2 = !o2 && 1 == (t2 >> i2 & 1);
      i2 < 6 ? this.modules[i2][8] = n2 : i2 < 8 ? this.modules[i2 + 1][8] = n2 : this.modules[this.moduleCount - 15 + i2][8] = n2;
    }
    for (i2 = 0; i2 < 15; i2++) {
      n2 = !o2 && 1 == (t2 >> i2 & 1);
      i2 < 8 ? this.modules[8][this.moduleCount - i2 - 1] = n2 : i2 < 9 ? this.modules[8][15 - i2 - 1 + 1] = n2 : this.modules[8][15 - i2 - 1] = n2;
    }
    this.modules[this.moduleCount - 8][8] = !o2;
  }, mapData: function(o2, e2) {
    for (var r2 = -1, t2 = this.moduleCount - 1, i2 = 7, n2 = 0, a2 = this.moduleCount - 1; a2 > 0; a2 -= 2)
      for (6 == a2 && a2--; ; ) {
        for (var d2 = 0; d2 < 2; d2++)
          if (null == this.modules[t2][a2 - d2]) {
            var u2 = false;
            n2 < o2.length && (u2 = 1 == (o2[n2] >>> i2 & 1)), h.getMask(e2, t2, a2 - d2) && (u2 = !u2), this.modules[t2][a2 - d2] = u2, -1 == --i2 && (n2++, i2 = 7);
          }
        if ((t2 += r2) < 0 || this.moduleCount <= t2) {
          t2 -= r2, r2 = -r2;
          break;
        }
      }
  } }, e.PAD0 = 236, e.PAD1 = 17, e.createData = function(o2, r2, t2) {
    for (var i2 = v.getRSBlocks(o2, r2), n2 = new p(), a2 = 0; a2 < t2.length; a2++) {
      var d2 = t2[a2];
      n2.put(d2.mode, 4), n2.put(d2.getLength(), h.getLengthInBits(d2.mode, o2)), d2.write(n2);
    }
    var u2 = 0;
    for (a2 = 0; a2 < i2.length; a2++)
      u2 += i2[a2].dataCount;
    if (n2.getLengthInBits() > 8 * u2)
      throw new Error("code length overflow. (" + n2.getLengthInBits() + ">" + 8 * u2 + ")");
    for (n2.getLengthInBits() + 4 <= 8 * u2 && n2.put(0, 4); n2.getLengthInBits() % 8 != 0; )
      n2.putBit(false);
    for (; !(n2.getLengthInBits() >= 8 * u2 || (n2.put(e.PAD0, 8), n2.getLengthInBits() >= 8 * u2)); )
      n2.put(e.PAD1, 8);
    return e.createBytes(n2, i2);
  }, e.createBytes = function(o2, e2) {
    for (var r2 = 0, t2 = 0, i2 = 0, n2 = new Array(e2.length), a2 = new Array(e2.length), d2 = 0; d2 < e2.length; d2++) {
      var u2 = e2[d2].dataCount, s2 = e2[d2].totalCount - u2;
      t2 = Math.max(t2, u2), i2 = Math.max(i2, s2), n2[d2] = new Array(u2);
      for (var g2 = 0; g2 < n2[d2].length; g2++)
        n2[d2][g2] = 255 & o2.buffer[g2 + r2];
      r2 += u2;
      var l2 = h.getErrorCorrectPolynomial(s2), c2 = new f(n2[d2], l2.getLength() - 1).mod(l2);
      a2[d2] = new Array(l2.getLength() - 1);
      for (g2 = 0; g2 < a2[d2].length; g2++) {
        var m2 = g2 + c2.getLength() - a2[d2].length;
        a2[d2][g2] = m2 >= 0 ? c2.get(m2) : 0;
      }
    }
    var v2 = 0;
    for (g2 = 0; g2 < e2.length; g2++)
      v2 += e2[g2].totalCount;
    var p2 = new Array(v2), C2 = 0;
    for (g2 = 0; g2 < t2; g2++)
      for (d2 = 0; d2 < e2.length; d2++)
        g2 < n2[d2].length && (p2[C2++] = n2[d2][g2]);
    for (g2 = 0; g2 < i2; g2++)
      for (d2 = 0; d2 < e2.length; d2++)
        g2 < a2[d2].length && (p2[C2++] = a2[d2][g2]);
    return p2;
  };
  for (var r = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 }, t = { L: 1, M: 0, Q: 3, H: 2 }, i = 0, n = 1, a = 2, d = 3, u = 4, s = 5, g = 6, l = 7, h = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1335, G18: 7973, G15_MASK: 21522, getBCHTypeInfo: function(o2) {
    for (var e2 = o2 << 10; h.getBCHDigit(e2) - h.getBCHDigit(h.G15) >= 0; )
      e2 ^= h.G15 << h.getBCHDigit(e2) - h.getBCHDigit(h.G15);
    return (o2 << 10 | e2) ^ h.G15_MASK;
  }, getBCHTypeNumber: function(o2) {
    for (var e2 = o2 << 12; h.getBCHDigit(e2) - h.getBCHDigit(h.G18) >= 0; )
      e2 ^= h.G18 << h.getBCHDigit(e2) - h.getBCHDigit(h.G18);
    return o2 << 12 | e2;
  }, getBCHDigit: function(o2) {
    for (var e2 = 0; 0 != o2; )
      e2++, o2 >>>= 1;
    return e2;
  }, getPatternPosition: function(o2) {
    return h.PATTERN_POSITION_TABLE[o2 - 1];
  }, getMask: function(o2, e2, r2) {
    switch (o2) {
      case i:
        return (e2 + r2) % 2 == 0;
      case n:
        return e2 % 2 == 0;
      case a:
        return r2 % 3 == 0;
      case d:
        return (e2 + r2) % 3 == 0;
      case u:
        return (Math.floor(e2 / 2) + Math.floor(r2 / 3)) % 2 == 0;
      case s:
        return e2 * r2 % 2 + e2 * r2 % 3 == 0;
      case g:
        return (e2 * r2 % 2 + e2 * r2 % 3) % 2 == 0;
      case l:
        return (e2 * r2 % 3 + (e2 + r2) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + o2);
    }
  }, getErrorCorrectPolynomial: function(o2) {
    for (var e2 = new f([1], 0), r2 = 0; r2 < o2; r2++)
      e2 = e2.multiply(new f([1, c.gexp(r2)], 0));
    return e2;
  }, getLengthInBits: function(o2, e2) {
    if (1 <= e2 && e2 < 10)
      switch (o2) {
        case r.MODE_NUMBER:
          return 10;
        case r.MODE_ALPHA_NUM:
          return 9;
        case r.MODE_8BIT_BYTE:
        case r.MODE_KANJI:
          return 8;
        default:
          throw new Error("mode:" + o2);
      }
    else if (e2 < 27)
      switch (o2) {
        case r.MODE_NUMBER:
          return 12;
        case r.MODE_ALPHA_NUM:
          return 11;
        case r.MODE_8BIT_BYTE:
          return 16;
        case r.MODE_KANJI:
          return 10;
        default:
          throw new Error("mode:" + o2);
      }
    else {
      if (!(e2 < 41))
        throw new Error("type:" + e2);
      switch (o2) {
        case r.MODE_NUMBER:
          return 14;
        case r.MODE_ALPHA_NUM:
          return 13;
        case r.MODE_8BIT_BYTE:
          return 16;
        case r.MODE_KANJI:
          return 12;
        default:
          throw new Error("mode:" + o2);
      }
    }
  }, getLostPoint: function(o2) {
    for (var e2 = o2.getModuleCount(), r2 = 0, t2 = 0; t2 < e2; t2++)
      for (var i2 = 0; i2 < e2; i2++) {
        for (var n2 = 0, a2 = o2.isDark(t2, i2), d2 = -1; d2 <= 1; d2++)
          if (!(t2 + d2 < 0 || e2 <= t2 + d2))
            for (var u2 = -1; u2 <= 1; u2++)
              i2 + u2 < 0 || e2 <= i2 + u2 || 0 == d2 && 0 == u2 || a2 == o2.isDark(t2 + d2, i2 + u2) && n2++;
        n2 > 5 && (r2 += 3 + n2 - 5);
      }
    for (t2 = 0; t2 < e2 - 1; t2++)
      for (i2 = 0; i2 < e2 - 1; i2++) {
        var s2 = 0;
        o2.isDark(t2, i2) && s2++, o2.isDark(t2 + 1, i2) && s2++, o2.isDark(t2, i2 + 1) && s2++, o2.isDark(t2 + 1, i2 + 1) && s2++, 0 != s2 && 4 != s2 || (r2 += 3);
      }
    for (t2 = 0; t2 < e2; t2++)
      for (i2 = 0; i2 < e2 - 6; i2++)
        o2.isDark(t2, i2) && !o2.isDark(t2, i2 + 1) && o2.isDark(t2, i2 + 2) && o2.isDark(t2, i2 + 3) && o2.isDark(t2, i2 + 4) && !o2.isDark(t2, i2 + 5) && o2.isDark(t2, i2 + 6) && (r2 += 40);
    for (i2 = 0; i2 < e2; i2++)
      for (t2 = 0; t2 < e2 - 6; t2++)
        o2.isDark(t2, i2) && !o2.isDark(t2 + 1, i2) && o2.isDark(t2 + 2, i2) && o2.isDark(t2 + 3, i2) && o2.isDark(t2 + 4, i2) && !o2.isDark(t2 + 5, i2) && o2.isDark(t2 + 6, i2) && (r2 += 40);
    var g2 = 0;
    for (i2 = 0; i2 < e2; i2++)
      for (t2 = 0; t2 < e2; t2++)
        o2.isDark(t2, i2) && g2++;
    return r2 += 10 * (Math.abs(100 * g2 / e2 / e2 - 50) / 5);
  } }, c = { glog: function(o2) {
    if (o2 < 1)
      throw new Error("glog(" + o2 + ")");
    return c.LOG_TABLE[o2];
  }, gexp: function(o2) {
    for (; o2 < 0; )
      o2 += 255;
    for (; o2 >= 256; )
      o2 -= 255;
    return c.EXP_TABLE[o2];
  }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) }, m = 0; m < 8; m++)
    c.EXP_TABLE[m] = 1 << m;
  for (m = 8; m < 256; m++)
    c.EXP_TABLE[m] = c.EXP_TABLE[m - 4] ^ c.EXP_TABLE[m - 5] ^ c.EXP_TABLE[m - 6] ^ c.EXP_TABLE[m - 8];
  for (m = 0; m < 255; m++)
    c.LOG_TABLE[c.EXP_TABLE[m]] = m;
  function f(o2, e2) {
    if (null == o2.length)
      throw new Error(o2.length + "/" + e2);
    for (var r2 = 0; r2 < o2.length && 0 == o2[r2]; )
      r2++;
    this.num = new Array(o2.length - r2 + e2);
    for (var t2 = 0; t2 < o2.length - r2; t2++)
      this.num[t2] = o2[t2 + r2];
  }
  function v(o2, e2) {
    this.totalCount = o2, this.dataCount = e2;
  }
  function p() {
    this.buffer = new Array(), this.length = 0;
  }
  function C(o2) {
    return o2.setFillStyle = o2.setFillStyle || function(e2) {
      o2.fillStyle = e2;
    }, o2.setFontSize = o2.setFontSize || function(e2) {
      o2.font = `${e2}px`;
    }, o2.setTextAlign = o2.setTextAlign || function(e2) {
      o2.textAlign = e2;
    }, o2.setTextBaseline = o2.setTextBaseline || function(e2) {
      o2.textBaseline = e2;
    }, o2.setGlobalAlpha = o2.setGlobalAlpha || function(e2) {
      o2.globalAlpha = e2;
    }, o2.setStrokeStyle = o2.setStrokeStyle || function(e2) {
      o2.strokeStyle = e2;
    }, o2.setShadow = o2.setShadow || function(e2, r2, t2, i2) {
      o2.shadowOffsetX = e2, o2.shadowOffsetY = r2, o2.shadowBlur = t2, o2.shadowColor = i2;
    }, o2.draw = o2.draw || function(o3, e2) {
      e2 && e2();
    }, o2.clearRect = o2.clearRect || function(e2, r2, t2, i2) {
      o2.draw(false);
    }, o2;
  }
  function b(o2, e2) {
    var r2 = this.data = "", t2 = this.size = 200;
    this.useDynamicSize = false, this.dynamicSize = t2;
    var i2 = this.typeNumber = -1;
    this.errorCorrectLevel = b.errorCorrectLevel.H;
    var n2 = this.margin = 0;
    this.areaColor = "#FFFFFF", this.backgroundColor = "rgba(255,255,255,0)", this.backgroundImageSrc = void 0;
    var a2 = this.backgroundImageWidth = void 0, d2 = this.backgroundImageHeight = void 0, u2 = this.backgroundImageX = void 0, s2 = this.backgroundImageY = void 0;
    this.backgroundImageAlpha = 1, this.backgroundImageBorderRadius = 0;
    var g2 = this.backgroundPadding = 0;
    this.foregroundColor = "#000000", this.foregroundImageSrc = void 0;
    var l2 = this.foregroundImageWidth = void 0, h2 = this.foregroundImageHeight = void 0, c2 = this.foregroundImageX = void 0, m2 = this.foregroundImageY = void 0, f2 = this.foregroundImagePadding = 0;
    this.foregroundImageBackgroundColor = "#FFFFFF";
    var v2 = this.foregroundImageBorderRadius = 0, p2 = this.foregroundImageShadowOffsetX = 0, k = this.foregroundImageShadowOffsetY = 0, y = this.foregroundImageShadowBlur = 0;
    this.foregroundImageShadowColor = "#808080";
    var w = this.foregroundPadding = 0, I = this.positionProbeBackgroundColor = void 0, B = this.positionProbeForegroundColor = void 0, S = this.separatorColor = void 0, P = this.positionAdjustBackgroundColor = void 0, L = this.positionAdjustForegroundColor = void 0, D = this.timingBackgroundColor = void 0, A = this.timingForegroundColor = void 0, E = this.typeNumberBackgroundColor = void 0, T = this.typeNumberForegroundColor = void 0, N = this.darkBlockColor = void 0;
    this.base = void 0, this.modules = [], this.moduleCount = 0, this.drawModules = [];
    var M = this.canvasContext = void 0;
    this.loadImage, this.drawReserve = false, this.isMaked = false, Object.defineProperties(this, { data: { get() {
      if ("" === r2 || void 0 === r2)
        throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", "[uQRCode]: data must be set!"), new b.Error("data must be set!");
      return r2;
    }, set(o3) {
      r2 = String(o3);
    } }, size: { get: () => t2, set(o3) {
      t2 = Number(o3);
    } }, typeNumber: { get: () => i2, set(o3) {
      i2 = Number(o3);
    } }, margin: { get: () => n2, set(o3) {
      n2 = Number(o3);
    } }, backgroundImageWidth: { get() {
      return void 0 === a2 ? this.dynamicSize : this.useDynamicSize ? this.dynamicSize / this.size * a2 : a2;
    }, set(o3) {
      a2 = Number(o3);
    } }, backgroundImageHeight: { get() {
      return void 0 === d2 ? this.dynamicSize : this.useDynamicSize ? this.dynamicSize / this.size * d2 : d2;
    }, set(o3) {
      d2 = Number(o3);
    } }, backgroundImageX: { get() {
      return void 0 === u2 ? 0 : this.useDynamicSize ? this.dynamicSize / this.size * u2 : u2;
    }, set(o3) {
      u2 = Number(o3);
    } }, backgroundImageY: { get() {
      return void 0 === s2 ? 0 : this.useDynamicSize ? this.dynamicSize / this.size * s2 : s2;
    }, set(o3) {
      s2 = Number(o3);
    } }, backgroundPadding: { get: () => g2, set(o3) {
      g2 = o3 > 1 ? 1 : o3 < 0 ? 0 : o3;
    } }, foregroundImageWidth: { get() {
      return void 0 === l2 ? (this.dynamicSize - 2 * this.margin) / 4 : this.useDynamicSize ? this.dynamicSize / this.size * l2 : l2;
    }, set(o3) {
      l2 = Number(o3);
    } }, foregroundImageHeight: { get() {
      return void 0 === h2 ? (this.dynamicSize - 2 * this.margin) / 4 : this.useDynamicSize ? this.dynamicSize / this.size * h2 : h2;
    }, set(o3) {
      h2 = Number(o3);
    } }, foregroundImageX: { get() {
      return void 0 === c2 ? this.dynamicSize / 2 - this.foregroundImageWidth / 2 : this.useDynamicSize ? this.dynamicSize / this.size * c2 : c2;
    }, set(o3) {
      c2 = Number(o3);
    } }, foregroundImageY: { get() {
      return void 0 === m2 ? this.dynamicSize / 2 - this.foregroundImageHeight / 2 : this.useDynamicSize ? this.dynamicSize / this.size * m2 : m2;
    }, set(o3) {
      m2 = Number(o3);
    } }, foregroundImagePadding: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * f2 : f2;
    }, set(o3) {
      f2 = Number(o3);
    } }, foregroundImageBorderRadius: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * v2 : v2;
    }, set(o3) {
      v2 = Number(o3);
    } }, foregroundImageShadowOffsetX: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * p2 : p2;
    }, set(o3) {
      p2 = Number(o3);
    } }, foregroundImageShadowOffsetY: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * k : k;
    }, set(o3) {
      k = Number(o3);
    } }, foregroundImageShadowBlur: { get() {
      return this.useDynamicSize ? this.dynamicSize / this.size * y : y;
    }, set(o3) {
      y = Number(o3);
    } }, foregroundPadding: { get: () => w, set(o3) {
      w = o3 > 1 ? 1 : o3 < 0 ? 0 : o3;
    } }, positionProbeBackgroundColor: { get() {
      return I || this.backgroundColor;
    }, set(o3) {
      I = o3;
    } }, positionProbeForegroundColor: { get() {
      return B || this.foregroundColor;
    }, set(o3) {
      B = o3;
    } }, separatorColor: { get() {
      return S || this.backgroundColor;
    }, set(o3) {
      S = o3;
    } }, positionAdjustBackgroundColor: { get() {
      return P || this.backgroundColor;
    }, set(o3) {
      P = o3;
    } }, positionAdjustForegroundColor: { get() {
      return L || this.foregroundColor;
    }, set(o3) {
      L = o3;
    } }, timingBackgroundColor: { get() {
      return D || this.backgroundColor;
    }, set(o3) {
      D = o3;
    } }, timingForegroundColor: { get() {
      return A || this.foregroundColor;
    }, set(o3) {
      A = o3;
    } }, typeNumberBackgroundColor: { get() {
      return E || this.backgroundColor;
    }, set(o3) {
      E = o3;
    } }, typeNumberForegroundColor: { get() {
      return T || this.foregroundColor;
    }, set(o3) {
      T = o3;
    } }, darkBlockColor: { get() {
      return N || this.foregroundColor;
    }, set(o3) {
      N = o3;
    } }, canvasContext: { get() {
      if (void 0 === M)
        throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", "[uQRCode]: use drawCanvas, you need to set the canvasContext!"), new b.Error("use drawCanvas, you need to set the canvasContext!");
      return M;
    }, set(o3) {
      M = C(o3);
    } } }), b.plugins.forEach((o3) => o3(b, this, false)), o2 && this.setOptions(o2), e2 && (this.canvasContext = C(e2));
  }
  f.prototype = { get: function(o2) {
    return this.num[o2];
  }, getLength: function() {
    return this.num.length;
  }, multiply: function(o2) {
    for (var e2 = new Array(this.getLength() + o2.getLength() - 1), r2 = 0; r2 < this.getLength(); r2++)
      for (var t2 = 0; t2 < o2.getLength(); t2++)
        e2[r2 + t2] ^= c.gexp(c.glog(this.get(r2)) + c.glog(o2.get(t2)));
    return new f(e2, 0);
  }, mod: function(o2) {
    if (this.getLength() - o2.getLength() < 0)
      return this;
    for (var e2 = c.glog(this.get(0)) - c.glog(o2.get(0)), r2 = new Array(this.getLength()), t2 = 0; t2 < this.getLength(); t2++)
      r2[t2] = this.get(t2);
    for (t2 = 0; t2 < o2.getLength(); t2++)
      r2[t2] ^= c.gexp(c.glog(o2.get(t2)) + e2);
    return new f(r2, 0).mod(o2);
  } }, v.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], v.getRSBlocks = function(o2, e2) {
    var r2 = v.getRsBlockTable(o2, e2);
    if (null == r2)
      throw new Error("bad rs block @ typeNumber:" + o2 + "/errorCorrectLevel:" + e2);
    for (var t2 = r2.length / 3, i2 = new Array(), n2 = 0; n2 < t2; n2++)
      for (var a2 = r2[3 * n2 + 0], d2 = r2[3 * n2 + 1], u2 = r2[3 * n2 + 2], s2 = 0; s2 < a2; s2++)
        i2.push(new v(d2, u2));
    return i2;
  }, v.getRsBlockTable = function(o2, e2) {
    switch (e2) {
      case t.L:
        return v.RS_BLOCK_TABLE[4 * (o2 - 1) + 0];
      case t.M:
        return v.RS_BLOCK_TABLE[4 * (o2 - 1) + 1];
      case t.Q:
        return v.RS_BLOCK_TABLE[4 * (o2 - 1) + 2];
      case t.H:
        return v.RS_BLOCK_TABLE[4 * (o2 - 1) + 3];
      default:
        return;
    }
  }, p.prototype = { get: function(o2) {
    var e2 = Math.floor(o2 / 8);
    return 1 == (this.buffer[e2] >>> 7 - o2 % 8 & 1);
  }, put: function(o2, e2) {
    for (var r2 = 0; r2 < e2; r2++)
      this.putBit(1 == (o2 >>> e2 - r2 - 1 & 1));
  }, getLengthInBits: function() {
    return this.length;
  }, putBit: function(o2) {
    var e2 = Math.floor(this.length / 8);
    this.buffer.length <= e2 && this.buffer.push(0), o2 && (this.buffer[e2] |= 128 >>> this.length % 8), this.length++;
  } }, e.errorCorrectLevel = t, b.errorCorrectLevel = e.errorCorrectLevel, b.Error = function(o2) {
    this.errMsg = "[uQRCode]: " + o2;
  }, b.plugins = [], b.use = function(o2) {
    "function" == typeof o2 && b.plugins.push(o2);
  }, b.prototype.loadImage = function(o2) {
    return Promise.resolve(o2);
  }, b.prototype.setOptions = function(o2) {
    var e2, r2, t2, i2, n2, a2, d2, u2, s2, g2, l2, h2, c2, m2, f2, v2, p2, C2, b2, k, y, w, I, B, S, P, L, D, A, E, T, N, M, z, R, _, O, F, x, H, X, Y, j, W, G, K, Q, U, $, J, q, V, Z, oo, eo, ro;
    o2 && (Object.keys(o2).forEach((e3) => {
      this[e3] = o2[e3];
    }), function(o3 = {}, e3 = {}, r3 = false) {
      let t3;
      t3 = r3 ? o3 : { ...o3 };
      for (let o4 in e3) {
        var i3 = e3[o4];
        null != i3 && (i3.constructor == Object ? t3[o4] = this.deepReplace(t3[o4], i3) : i3.constructor != String || i3 ? t3[o4] = i3 : t3[o4] = t3[o4]);
      }
    }(this, { data: o2.data || o2.text, size: o2.size, useDynamicSize: o2.useDynamicSize, typeNumber: o2.typeNumber, errorCorrectLevel: o2.errorCorrectLevel, margin: o2.margin, areaColor: o2.areaColor, backgroundColor: o2.backgroundColor || (null === (e2 = o2.background) || void 0 === e2 ? void 0 : e2.color), backgroundImageSrc: o2.backgroundImageSrc || (null === (r2 = o2.background) || void 0 === r2 || null === (t2 = r2.image) || void 0 === t2 ? void 0 : t2.src), backgroundImageWidth: o2.backgroundImageWidth || (null === (i2 = o2.background) || void 0 === i2 || null === (n2 = i2.image) || void 0 === n2 ? void 0 : n2.width), backgroundImageHeight: o2.backgroundImageHeight || (null === (a2 = o2.background) || void 0 === a2 || null === (d2 = a2.image) || void 0 === d2 ? void 0 : d2.height), backgroundImageX: o2.backgroundImageX || (null === (u2 = o2.background) || void 0 === u2 || null === (s2 = u2.image) || void 0 === s2 ? void 0 : s2.x), backgroundImageY: o2.backgroundImageY || (null === (g2 = o2.background) || void 0 === g2 || null === (l2 = g2.image) || void 0 === l2 ? void 0 : l2.y), backgroundImageAlpha: o2.backgroundImageAlpha || (null === (h2 = o2.background) || void 0 === h2 || null === (c2 = h2.image) || void 0 === c2 ? void 0 : c2.alpha), backgroundImageBorderRadius: o2.backgroundImageBorderRadius || (null === (m2 = o2.background) || void 0 === m2 || null === (f2 = m2.image) || void 0 === f2 ? void 0 : f2.borderRadius), backgroundPadding: o2.backgroundPadding, foregroundColor: o2.foregroundColor || (null === (v2 = o2.foreground) || void 0 === v2 ? void 0 : v2.color), foregroundImageSrc: o2.foregroundImageSrc || (null === (p2 = o2.foreground) || void 0 === p2 || null === (C2 = p2.image) || void 0 === C2 ? void 0 : C2.src), foregroundImageWidth: o2.foregroundImageWidth || (null === (b2 = o2.foreground) || void 0 === b2 || null === (k = b2.image) || void 0 === k ? void 0 : k.width), foregroundImageHeight: o2.foregroundImageHeight || (null === (y = o2.foreground) || void 0 === y || null === (w = y.image) || void 0 === w ? void 0 : w.height), foregroundImageX: o2.foregroundImageX || (null === (I = o2.foreground) || void 0 === I || null === (B = I.image) || void 0 === B ? void 0 : B.x), foregroundImageY: o2.foregroundImageY || (null === (S = o2.foreground) || void 0 === S || null === (P = S.image) || void 0 === P ? void 0 : P.y), foregroundImagePadding: o2.foregroundImagePadding || (null === (L = o2.foreground) || void 0 === L || null === (D = L.image) || void 0 === D ? void 0 : D.padding), foregroundImageBackgroundColor: o2.foregroundImageBackgroundColor || (null === (A = o2.foreground) || void 0 === A || null === (E = A.image) || void 0 === E ? void 0 : E.backgroundColor), foregroundImageBorderRadius: o2.foregroundImageBorderRadius || (null === (T = o2.foreground) || void 0 === T || null === (N = T.image) || void 0 === N ? void 0 : N.borderRadius), foregroundImageShadowOffsetX: o2.foregroundImageShadowOffsetX || (null === (M = o2.foreground) || void 0 === M || null === (z = M.image) || void 0 === z ? void 0 : z.shadowOffsetX), foregroundImageShadowOffsetY: o2.foregroundImageShadowOffsetY || (null === (R = o2.foreground) || void 0 === R || null === (_ = R.image) || void 0 === _ ? void 0 : _.shadowOffsetY), foregroundImageShadowBlur: o2.foregroundImageShadowBlur || (null === (O = o2.foreground) || void 0 === O || null === (F = O.image) || void 0 === F ? void 0 : F.shadowBlur), foregroundImageShadowColor: o2.foregroundImageShadowColor || (null === (x = o2.foreground) || void 0 === x || null === (H = x.image) || void 0 === H ? void 0 : H.shadowColor), foregroundPadding: o2.foregroundPadding, positionProbeBackgroundColor: o2.positionProbeBackgroundColor || (null === (X = o2.positionProbe) || void 0 === X ? void 0 : X.backgroundColor) || (null === (Y = o2.positionDetection) || void 0 === Y ? void 0 : Y.backgroundColor), positionProbeForegroundColor: o2.positionProbeForegroundColor || (null === (j = o2.positionProbe) || void 0 === j ? void 0 : j.foregroundColor) || (null === (W = o2.positionDetection) || void 0 === W ? void 0 : W.foregroundColor), separatorColor: o2.separatorColor || (null === (G = o2.separator) || void 0 === G ? void 0 : G.color), positionAdjustBackgroundColor: o2.positionAdjustBackgroundColor || (null === (K = o2.positionAdjust) || void 0 === K ? void 0 : K.backgroundColor) || (null === (Q = o2.alignment) || void 0 === Q ? void 0 : Q.backgroundColor), positionAdjustForegroundColor: o2.positionAdjustForegroundColor || (null === (U = o2.positionAdjust) || void 0 === U ? void 0 : U.foregroundColor) || (null === ($ = o2.alignment) || void 0 === $ ? void 0 : $.foregroundColor), timingBackgroundColor: o2.timingBackgroundColor || (null === (J = o2.timing) || void 0 === J ? void 0 : J.backgroundColor), timingForegroundColor: o2.timingForegroundColor || (null === (q = o2.timing) || void 0 === q ? void 0 : q.foregroundColor), typeNumberBackgroundColor: o2.typeNumberBackgroundColor || (null === (V = o2.typeNumber) || void 0 === V ? void 0 : V.backgroundColor) || (null === (Z = o2.versionInformation) || void 0 === Z ? void 0 : Z.backgroundColor), typeNumberForegroundColor: o2.typeNumberForegroundColor || (null === (oo = o2.typeNumber) || void 0 === oo ? void 0 : oo.foregroundColor) || (null === (eo = o2.versionInformation) || void 0 === eo ? void 0 : eo.foregroundColor), darkBlockColor: o2.darkBlockColor || (null === (ro = o2.darkBlock) || void 0 === ro ? void 0 : ro.color) }, true));
  }, b.prototype.make = function() {
    let { foregroundColor: o2, backgroundColor: r2, typeNumber: t2, errorCorrectLevel: i2, data: n2, size: a2, margin: d2, useDynamicSize: u2 } = this;
    if (o2 === r2)
      throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", "[uQRCode]: foregroundColor and backgroundColor cannot be the same!"), new b.Error("foregroundColor and backgroundColor cannot be the same!");
    var s2 = new e(t2, i2);
    s2.addData(function(o3) {
      o3 = o3.toString();
      for (var e2, r3 = "", t3 = 0; t3 < o3.length; t3++)
        (e2 = o3.charCodeAt(t3)) >= 1 && e2 <= 127 ? r3 += o3.charAt(t3) : e2 > 2047 ? (r3 += String.fromCharCode(224 | e2 >> 12 & 15), r3 += String.fromCharCode(128 | e2 >> 6 & 63), r3 += String.fromCharCode(128 | e2 >> 0 & 63)) : (r3 += String.fromCharCode(192 | e2 >> 6 & 31), r3 += String.fromCharCode(128 | e2 >> 0 & 63));
      return r3;
    }(n2)), s2.make(), this.base = s2, this.typeNumber = s2.typeNumber, this.modules = s2.modules, this.moduleCount = s2.moduleCount, this.dynamicSize = u2 ? Math.ceil((a2 - 2 * d2) / s2.moduleCount) * s2.moduleCount + 2 * d2 : a2, function(o3) {
      let { dynamicSize: e2, margin: r3, backgroundColor: t3, backgroundPadding: i3, foregroundColor: n3, foregroundPadding: a3, modules: d3, moduleCount: u3 } = o3, s3 = (e2 - 2 * r3) / u3, g2 = s3, l2 = 0;
      i3 > 0 && (l2 = g2 * i3 / 2, g2 -= 2 * l2);
      let h2 = s3, c2 = 0;
      a3 > 0 && (c2 = h2 * a3 / 2, h2 -= 2 * c2);
      for (var m2 = 0; m2 < u3; m2++)
        for (var f2 = 0; f2 < u3; f2++) {
          var v2 = f2 * s3 + r3, p2 = m2 * s3 + r3;
          if (d3[m2][f2]) {
            var C2 = c2, b2 = v2 + c2, k = p2 + c2, y = h2, w = h2;
            d3[m2][f2] = { type: ["foreground"], color: n3, isBlack: true, isDrawn: false, destX: v2, destY: p2, destWidth: s3, destHeight: s3, x: b2, y: k, width: y, height: w, paddingTop: C2, paddingRight: C2, paddingBottom: C2, paddingLeft: C2 };
          } else
            C2 = l2, b2 = v2 + l2, k = p2 + l2, y = g2, w = g2, d3[m2][f2] = { type: ["background"], color: t3, isBlack: false, isDrawn: false, destX: v2, destY: p2, destWidth: s3, destHeight: s3, x: b2, y: k, width: y, height: w, paddingTop: C2, paddingRight: C2, paddingBottom: C2, paddingLeft: C2 };
        }
    }(this), function(o3) {
      let { modules: e2, moduleCount: r3, positionProbeBackgroundColor: t3, positionProbeForegroundColor: i3 } = o3, n3 = r3 - 7;
      [[0, 0, 1], [1, 0, 1], [2, 0, 1], [3, 0, 1], [4, 0, 1], [5, 0, 1], [6, 0, 1], [0, 1, 1], [1, 1, 0], [2, 1, 0], [3, 1, 0], [4, 1, 0], [5, 1, 0], [6, 1, 1], [0, 2, 1], [1, 2, 0], [2, 2, 1], [3, 2, 1], [4, 2, 1], [5, 2, 0], [6, 2, 1], [0, 3, 1], [1, 3, 0], [2, 3, 1], [3, 3, 1], [4, 3, 1], [5, 3, 0], [6, 3, 1], [0, 4, 1], [1, 4, 0], [2, 4, 1], [3, 4, 1], [4, 4, 1], [5, 4, 0], [6, 4, 1], [0, 5, 1], [1, 5, 0], [2, 5, 0], [3, 5, 0], [4, 5, 0], [5, 5, 0], [6, 5, 1], [0, 6, 1], [1, 6, 1], [2, 6, 1], [3, 6, 1], [4, 6, 1], [5, 6, 1], [6, 6, 1]].forEach((o4) => {
        var r4 = e2[o4[0]][o4[1]], a3 = e2[o4[0] + n3][o4[1]], d3 = e2[o4[0]][o4[1] + n3];
        d3.type.push("positionProbe"), a3.type.push("positionProbe"), r4.type.push("positionProbe"), r4.color = 1 == o4[2] ? i3 : t3, a3.color = 1 == o4[2] ? i3 : t3, d3.color = 1 == o4[2] ? i3 : t3;
      });
    }(this), function(o3) {
      let { modules: e2, moduleCount: r3, separatorColor: t3 } = o3;
      [[7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7], [0, 7], [1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]].forEach((o4) => {
        var i3 = e2[o4[0]][o4[1]], n3 = e2[r3 - o4[0] - 1][o4[1]], a3 = e2[o4[0]][r3 - o4[1] - 1];
        a3.type.push("separator"), n3.type.push("separator"), i3.type.push("separator"), i3.color = t3, n3.color = t3, a3.color = t3;
      });
    }(this), function(o3) {
      let { typeNumber: e2, modules: r3, moduleCount: t3, foregroundColor: i3, backgroundColor: n3, positionAdjustForegroundColor: a3, positionAdjustBackgroundColor: d3, timingForegroundColor: u3, timingBackgroundColor: s3 } = o3;
      const g2 = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]][e2 - 1];
      if (g2) {
        const o4 = [[-2, -2, 1], [-1, -2, 1], [0, -2, 1], [1, -2, 1], [2, -2, 1], [-2, -1, 1], [-1, -1, 0], [0, -1, 0], [1, -1, 0], [2, -1, 1], [-2, 0, 1], [-1, 0, 0], [0, 0, 1], [1, 0, 0], [2, 0, 1], [-2, 1, 1], [-1, 1, 0], [0, 1, 0], [1, 1, 0], [2, 1, 1], [-2, 2, 1], [-1, 2, 1], [0, 2, 1], [1, 2, 1], [2, 2, 1]], e3 = g2.length;
        for (let l2 = 0; l2 < e3; l2++)
          for (let h2 = 0; h2 < e3; h2++) {
            let { x: e4, y: c2 } = { x: g2[l2], y: g2[h2] };
            e4 < 9 && c2 < 9 || e4 > t3 - 9 - 1 && c2 < 9 || c2 > t3 - 9 - 1 && e4 < 9 || o4.forEach((o5) => {
              var t4 = r3[e4 + o5[0]][c2 + o5[1]];
              t4.type.push("positionAdjust"), t4.type.includes("timing") ? 1 == o5[2] ? t4.color = a3 == i3 ? u3 : a3 : t4.color = a3 == i3 && d3 == n3 ? s3 : d3 : t4.color = 1 == o5[2] ? a3 : d3;
            });
          }
      }
    }(this), function(o3) {
      let { modules: e2, moduleCount: r3, timingForegroundColor: t3, timingBackgroundColor: i3 } = o3, n3 = r3 - 16;
      for (let o4 = 0; o4 < n3; o4++) {
        var a3 = e2[6][8 + o4], d3 = e2[8 + o4][6];
        a3.type.push("timing"), d3.type.push("timing"), a3.color = 1 & o4 ^ 1 ? t3 : i3, d3.color = 1 & o4 ^ 1 ? t3 : i3;
      }
    }(this), function(o3) {
      let { modules: e2, moduleCount: r3, darkBlockColor: t3 } = o3;
      var i3 = e2[r3 - 7 - 1][8];
      i3.type.push("darkBlock"), i3.color = t3;
    }(this), function(o3) {
      let { typeNumber: e2, modules: r3, moduleCount: t3, typeNumberBackgroundColor: i3, typeNumberForegroundColor: n3 } = o3;
      if (e2 < 7)
        return r3;
      const a3 = [0, 0, 0, 0, 0, 0, 0, "000111110010010100", "001000010110111100", "001001101010011001", "001010010011010011", "001011101111110110", "001100011101100010", "001101100001000111", "001110011000001101", "001111100100101000", "010000101101111000", "010001010001011101", "010010101000010111", "010011010100110010", "010100100110100110", "010101011010000011", "010110100011001001", "010111011111101100", "011000111011000100", "011001000111100001", "011010111110101011", "011011000010001110", "011100110000011010", "011101001100111111", "011110110101110101", "011111001001010000", "100000100111010101", "100001011011110000", "100010100010111010", "100011011110011111", "100100101100001011", "100101010000101110", "100110101001100100", "100111010101000001", "101000110001101001"];
      let d3 = a3[e2] + a3[e2], u3 = [t3 - 11, t3 - 10, t3 - 9];
      [[5, u3[2]], [5, u3[1]], [5, u3[0]], [4, u3[2]], [4, u3[1]], [4, u3[0]], [3, u3[2]], [3, u3[1]], [3, u3[0]], [2, u3[2]], [2, u3[1]], [2, u3[0]], [1, u3[2]], [1, u3[1]], [1, u3[0]], [0, u3[2]], [0, u3[1]], [0, u3[0]], [u3[2], 5], [u3[1], 5], [u3[0], 5], [u3[2], 4], [u3[1], 4], [u3[0], 4], [u3[2], 3], [u3[1], 3], [u3[0], 3], [u3[2], 2], [u3[1], 2], [u3[0], 2], [u3[2], 1], [u3[1], 1], [u3[0], 1], [u3[2], 0], [u3[1], 0], [u3[0], 0]].forEach((o4, e3) => {
        var t4 = r3[o4[0]][o4[1]];
        t4.type.push("typeNumber"), t4.color = "1" == d3[e3] ? n3 : i3;
      });
    }(this), this.isMaked = true, this.drawModules = [];
  }, b.prototype.getDrawModules = function() {
    if (this.drawModules && this.drawModules.length > 0)
      return this.drawModules;
    let o2 = this.drawModules = [], { modules: e2, moduleCount: r2, dynamicSize: t2, areaColor: i2, backgroundImageSrc: n2, backgroundImageX: a2, backgroundImageY: d2, backgroundImageWidth: u2, backgroundImageHeight: s2, backgroundImageAlpha: g2, backgroundImageBorderRadius: l2, foregroundImageSrc: h2, foregroundImageX: c2, foregroundImageY: m2, foregroundImageWidth: f2, foregroundImageHeight: v2, foregroundImagePadding: p2, foregroundImageBackgroundColor: C2, foregroundImageBorderRadius: b2, foregroundImageShadowOffsetX: k, foregroundImageShadowOffsetY: y, foregroundImageShadowBlur: w, foregroundImageShadowColor: I } = this;
    i2 && o2.push({ name: "area", type: "area", color: i2, x: 0, y: 0, width: t2, height: t2 }), n2 && o2.push({ name: "backgroundImage", type: "image", imageSrc: n2, mappingName: "backgroundImageSrc", x: a2, y: d2, width: u2, height: s2, alpha: g2, borderRadius: l2 });
    for (var B = 0; B < r2; B++)
      for (var S = 0; S < r2; S++) {
        var P = e2[B][S];
        P.isDrawn || (P.type.includes("foreground") ? o2.push({ name: "foreground", type: "tile", color: P.color, destX: P.destX, destY: P.destY, destWidth: P.destWidth, destHeight: P.destHeight, x: P.x, y: P.y, width: P.width, height: P.height, paddingTop: P.paddingTop, paddingRight: P.paddingRight, paddingBottom: P.paddingBottom, paddingLeft: P.paddingLeft, rowIndex: B, colIndex: S }) : o2.push({ name: "background", type: "tile", color: P.color, destX: P.destX, destY: P.destY, destWidth: P.destWidth, destHeight: P.destHeight, x: P.x, y: P.y, width: P.width, height: P.height, paddingTop: P.paddingTop, paddingRight: P.paddingRight, paddingBottom: P.paddingBottom, paddingLeft: P.paddingLeft, rowIndex: B, colIndex: S }), P.isDrawn = true);
      }
    return h2 && o2.push({ name: "foregroundImage", type: "image", imageSrc: h2, mappingName: "foregroundImageSrc", x: c2, y: m2, width: f2, height: v2, padding: p2, backgroundColor: C2, borderRadius: b2, shadowOffsetX: k, shadowOffsetY: y, shadowBlur: w, shadowColor: I }), o2;
  }, b.prototype.isBlack = function(o2, e2) {
    var r2 = this.moduleCount;
    return !(0 > o2 || 0 > e2 || o2 >= r2 || e2 >= r2) && this.modules[o2][e2].isBlack;
  }, b.prototype.drawCanvas = function() {
    let { isMaked: o2, canvasContext: e2, useDynamicSize: r2, dynamicSize: t2, foregroundColor: i2, foregroundPadding: n2, backgroundColor: a2, backgroundPadding: d2, drawReserve: u2, margin: s2 } = this;
    if (!o2)
      return formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", "[uQRCode]: please execute the make method first!"), Promise.reject(new b.Error("please execute the make method first!"));
    let g2 = this.getDrawModules(), l2 = async (o3, r3) => {
      try {
        e2.clearRect(0, 0, t2, t2), e2.draw(false);
        for (var i3 = 0; i3 < g2.length; i3++) {
          var n3 = g2[i3];
          switch (e2.save(), n3.type) {
            case "area":
              e2.setFillStyle(n3.color), e2.fillRect(n3.x, n3.y, n3.width, n3.height);
              break;
            case "tile":
              var a3 = n3.x, d3 = n3.y, s3 = n3.width, l3 = n3.height;
              e2.setFillStyle(n3.color), e2.fillRect(a3, d3, s3, l3);
              break;
            case "image":
              if ("backgroundImage" === n3.name) {
                a3 = Math.round(n3.x), d3 = Math.round(n3.y), s3 = Math.round(n3.width), l3 = Math.round(n3.height);
                s3 < 2 * (c2 = Math.round(n3.borderRadius)) && (c2 = s3 / 2), l3 < 2 * c2 && (c2 = l3 / 2), e2.setGlobalAlpha(n3.alpha), c2 > 0 && (e2.beginPath(), e2.moveTo(a3 + c2, d3), e2.arcTo(a3 + s3, d3, a3 + s3, d3 + l3, c2), e2.arcTo(a3 + s3, d3 + l3, a3, d3 + l3, c2), e2.arcTo(a3, d3 + l3, a3, d3, c2), e2.arcTo(a3, d3, a3 + s3, d3, c2), e2.closePath(), e2.setStrokeStyle("rgba(0,0,0,0)"), e2.stroke(), e2.clip());
                try {
                  var h2 = await this.loadImage(n3.imageSrc);
                  e2.drawImage(h2, a3, d3, s3, l3);
                } catch (o4) {
                  throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", `[uQRCode]: ${n3.mappingName} invalid!`), new b.Error(`${n3.mappingName} invalid!`);
                }
              } else if ("foregroundImage" === n3.name) {
                a3 = Math.round(n3.x), d3 = Math.round(n3.y), s3 = Math.round(n3.width), l3 = Math.round(n3.height);
                var c2, m2 = Math.round(n3.padding);
                s3 < 2 * (c2 = Math.round(n3.borderRadius)) && (c2 = s3 / 2), l3 < 2 * c2 && (c2 = l3 / 2);
                var f2 = a3 - m2, v2 = d3 - m2, p2 = s3 + 2 * m2, C2 = l3 + 2 * m2, k = Math.round(p2 / s3 * c2);
                p2 < 2 * k && (k = p2 / 2), C2 < 2 * k && (k = C2 / 2), e2.save(), e2.setShadow(n3.shadowOffsetX, n3.shadowOffsetY, n3.shadowBlur, n3.shadowColor), k > 0 ? (e2.beginPath(), e2.moveTo(f2 + k, v2), e2.arcTo(f2 + p2, v2, f2 + p2, v2 + C2, k), e2.arcTo(f2 + p2, v2 + C2, f2, v2 + C2, k), e2.arcTo(f2, v2 + C2, f2, v2, k), e2.arcTo(f2, v2, f2 + p2, v2, k), e2.closePath(), e2.setFillStyle(n3.backgroundColor), e2.fill()) : (e2.setFillStyle(n3.backgroundColor), e2.fillRect(f2, v2, p2, C2)), e2.restore(), e2.save(), k > 0 ? (e2.beginPath(), e2.moveTo(f2 + k, v2), e2.arcTo(f2 + p2, v2, f2 + p2, v2 + C2, k), e2.arcTo(f2 + p2, v2 + C2, f2, v2 + C2, k), e2.arcTo(f2, v2 + C2, f2, v2, k), e2.arcTo(f2, v2, f2 + p2, v2, k), e2.closePath(), e2.setFillStyle(m2 > 0 ? n3.backgroundColor : "rgba(0,0,0,0)"), e2.fill()) : (e2.setFillStyle(m2 > 0 ? n3.backgroundColor : "rgba(0,0,0,0)"), e2.fillRect(f2, v2, p2, C2)), e2.restore(), c2 > 0 && (e2.beginPath(), e2.moveTo(a3 + c2, d3), e2.arcTo(a3 + s3, d3, a3 + s3, d3 + l3, c2), e2.arcTo(a3 + s3, d3 + l3, a3, d3 + l3, c2), e2.arcTo(a3, d3 + l3, a3, d3, c2), e2.arcTo(a3, d3, a3 + s3, d3, c2), e2.closePath(), e2.setStrokeStyle("rgba(0,0,0,0)"), e2.stroke(), e2.clip());
                try {
                  h2 = await this.loadImage(n3.imageSrc);
                  e2.drawImage(h2, a3, d3, s3, l3);
                } catch (o4) {
                  throw formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/qrcode.js:34", `[uQRCode]: ${n3.mappingName} invalid!`), new b.Error(`${n3.mappingName} invalid!`);
                }
              }
          }
          u2 && e2.draw(true), e2.restore();
        }
        e2.draw(true), setTimeout(o3, 150);
      } catch (o4) {
        if (!(o4 instanceof b.Error))
          throw o4;
        r3(o4);
      }
    };
    return new Promise((o3, e3) => {
      l2(o3, e3);
    });
  }, b.prototype.draw = function() {
    return this.drawCanvas();
  }, b.prototype.register = function(o2) {
    o2 && o2(b, this, true);
  };
  function Queue() {
    let waitingQueue = this.waitingQueue = [];
    let isRunning = this.isRunning = false;
    function execute(task, resolve, reject) {
      task().then((data) => {
        resolve(data);
      }).catch((e2) => {
        reject(e2);
      }).finally(() => {
        if (waitingQueue.length) {
          const next = waitingQueue.shift();
          execute(next.task, next.resolve, next.reject);
        } else {
          isRunning = false;
        }
      });
    }
    this.exec = function(task) {
      return new Promise((resolve, reject) => {
        if (isRunning) {
          waitingQueue.push({
            task,
            resolve,
            reject
          });
        } else {
          isRunning = true;
          execute(task, resolve, reject);
        }
      });
    };
  }
  const queueDraw = new Queue();
  const queueLoadImage = new Queue();
  const cacheImageList = [];
  let instance = null;
  const _sfc_main$2 = {
    name: "uv-qrcode",
    mixins: [mpMixin, mixin, props],
    emits: ["click", "change", "complete"],
    data() {
      return {
        canvasId: "",
        canvas: void 0,
        canvasType: void 0,
        canvasContext: void 0,
        makeDelegate: void 0,
        drawDelegate: void 0,
        toTempFilePathDelegate: void 0,
        makeExecuted: false,
        makeing: false,
        drawing: false,
        isError: false,
        error: void 0,
        isH5Save: false,
        tempFilePath: "",
        templateOptions: {
          size: 0,
          width: 0,
          // 
          height: 0,
          canvasWidth: 0,
          // canvas
          canvasHeight: 0,
          canvasTransform: "",
          canvasDisplay: false
        },
        uqrcodeOptions: {
          data: ""
        },
        plugins: [],
        makeingPattern: [
          [
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true]
          ],
          [
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, true, true, true, false, true, true, true],
            [true, true, true, true, true, true, false, true, true, true],
            [true, true, true, true, true, true, false, true, true, true]
          ],
          [
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, true, true, true, true, false, false, false],
            [true, true, true, true, true, true, true, false, false, false],
            [true, true, true, true, true, true, true, false, false, false],
            [true, true, true, false, false, false, false, true, true, true],
            [true, true, true, false, false, false, false, true, true, true]
          ],
          [
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, false, false, false, false, false, false, false],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, true, true, true, true, true]
          ]
        ]
      };
    },
    watch: {
      type: {
        handler(val) {
          const types = ["2d"];
          if (types.includes(val)) {
            this.canvasType = val;
          } else {
            this.canvasType = void 0;
          }
        },
        immediate: true
      },
      value: {
        handler() {
          if (this.auto) {
            this.remake();
          }
        }
      },
      size: {
        handler() {
          if (this.auto) {
            this.remake();
          }
        }
      },
      options: {
        handler() {
          if (this.auto) {
            this.remake();
          }
        },
        deep: true
      },
      makeing: {
        handler(val) {
          if (!val) {
            if (typeof this.toTempFilePathDelegate === "function") {
              this.toTempFilePathDelegate();
            }
          }
        }
      }
    },
    created() {
      this.canvasId = this.$uv.guid();
    },
    mounted() {
      this.templateOptions.size = this.$uv.getPx(this.size);
      this.templateOptions.width = this.templateOptions.size;
      this.templateOptions.height = this.templateOptions.size;
      this.templateOptions.canvasWidth = this.templateOptions.size;
      this.templateOptions.canvasHeight = this.templateOptions.size;
      if (this.canvasType == "2d") {
        this.templateOptions.canvasTransform = `scale(${this.templateOptions.size / this.templateOptions.canvasWidth}, ${this.templateOptions.size / this.templateOptions.canvasHeight})`;
      } else {
        this.templateOptions.canvasTransform = `scale(${this.templateOptions.size / this.templateOptions.canvasWidth}, ${this.templateOptions.size / this.templateOptions.canvasHeight})`;
      }
      if (this.start) {
        this.$nextTick(() => {
          this.make();
        });
      }
    },
    methods: {
      /**
       * 
       */
      getTemplateOptions() {
        var size = this.$uv.getPx(this.size);
        return deepReplace(this.templateOptions, {
          size,
          width: size,
          height: size
        });
      },
      /**
       * 
       */
      getUqrcodeOptions() {
        return deepReplace(this.options, {
          data: String(this.value),
          size: Number(this.templateOptions.size)
        });
      },
      /**
       * 
       */
      resetCanvas(callback) {
        this.templateOptions.canvasDisplay = false;
        this.$nextTick(() => {
          this.templateOptions.canvasDisplay = true;
          this.$nextTick(() => {
            callback && callback();
          });
        });
      },
      /**
       * 
       */
      async draw(callback = {}, isDrawDelegate = false) {
        if (typeof callback.success != "function") {
          callback.success = () => {
          };
        }
        if (typeof callback.fail != "function") {
          callback.fail = () => {
          };
        }
        if (typeof callback.complete != "function") {
          callback.complete = () => {
          };
        }
        if (this.drawing) {
          if (!isDrawDelegate) {
            this.drawDelegate = () => {
              this.draw(callback, true);
            };
            return;
          }
        } else {
          this.drawing = true;
        }
        if (!this.canvasId) {
          formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:325", "[uQRCode]: canvasId must be set!");
          this.isError = true;
          this.drawing = false;
          callback.fail({
            errMsg: "[uQRCode]: canvasId must be set!"
          });
          callback.complete({
            errMsg: "[uQRCode]: canvasId must be set!"
          });
          return;
        }
        if (!this.value) {
          formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:337", "[uQRCode]: value must be set!");
          this.isError = true;
          this.drawing = false;
          callback.fail({
            errMsg: "[uQRCode]: value must be set!"
          });
          callback.complete({
            errMsg: "[uQRCode]: value must be set!"
          });
          return;
        }
        this.templateOptions = this.getTemplateOptions();
        this.uqrcodeOptions = this.getUqrcodeOptions();
        if (typeof this.uqrcodeOptions.errorCorrectLevel === "string") {
          this.uqrcodeOptions.errorCorrectLevel = b.errorCorrectLevel[this.uqrcodeOptions.errorCorrectLevel];
        }
        if (typeof this.options.useDynamicSize === "undefined") {
          this.uqrcodeOptions.useDynamicSize = true;
        }
        const qr = instance = new b();
        this.plugins.forEach((p2) => qr.register(p2.plugin));
        qr.setOptions(this.uqrcodeOptions);
        qr.make();
        let canvasContext = null;
        if (this.canvasType === "2d") {
          canvasContext = this.canvasContext = uni.createCanvasContext(this.canvasId, this);
          this.templateOptions.canvasWidth = qr.dynamicSize;
          this.templateOptions.canvasHeight = qr.dynamicSize;
          this.templateOptions.canvasTransform = `scale(${this.templateOptions.size / this.templateOptions.canvasWidth}, ${this.templateOptions.size / this.templateOptions.canvasHeight})`;
          qr.loadImage = this.getLoadImage(function(src) {
            return new Promise((resolve, reject) => {
              if (src.startsWith("http")) {
                uni.getImageInfo({
                  src,
                  success: (res) => {
                    resolve(res.path);
                  },
                  fail: (err) => {
                    reject(err);
                  }
                });
              } else {
                if (src.startsWith(".")) {
                  formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:448", "[uQRCode]: ");
                  throw new Error("[uQRCode]: local image path only supports absolute path!");
                } else {
                  resolve(src);
                }
              }
            });
          });
        } else {
          canvasContext = this.canvasContext = uni.createCanvasContext(this.canvasId, this);
          this.templateOptions.canvasWidth = qr.dynamicSize;
          this.templateOptions.canvasHeight = qr.dynamicSize;
          this.templateOptions.canvasTransform = `scale(${this.templateOptions.size / this.templateOptions.canvasWidth}, ${this.templateOptions.size / this.templateOptions.canvasHeight})`;
          qr.loadImage = this.getLoadImage(function(src) {
            return new Promise((resolve, reject) => {
              if (src.startsWith("http")) {
                uni.getImageInfo({
                  src,
                  success: (res) => {
                    resolve(res.path);
                  },
                  fail: (err) => {
                    reject(err);
                  }
                });
              } else {
                if (src.startsWith(".")) {
                  formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:481", "[uQRCode]: ");
                  throw new Error("[uQRCode]: local image path only supports absolute path!");
                } else {
                  resolve(src);
                }
              }
            });
          });
        }
        qr.canvasContext = canvasContext;
        setTimeout(() => {
          var plugin = this.plugins.find((p2) => p2.name == qr.style);
          var drawCanvasName = plugin ? plugin.drawCanvas : "drawCanvas";
          var drawCanvas;
          if (this.queue) {
            drawCanvas = () => queueDraw.exec(() => qr[drawCanvasName]());
          } else {
            drawCanvas = () => qr[drawCanvasName]();
          }
          drawCanvas().then(() => {
            if (this.drawDelegate) {
              let delegate = this.drawDelegate;
              this.drawDelegate = void 0;
              delegate();
            } else {
              this.drawing = false;
              callback.success();
            }
          }).catch((err) => {
            formatAppLog("log", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:553", err);
            if (this.drawDelegate) {
              let delegate = this.drawDelegate;
              this.drawDelegate = void 0;
              delegate();
            } else {
              this.drawing = false;
              this.isError = true;
              callback.fail(err);
            }
          }).finally(() => {
            callback.complete();
          });
        }, 300);
      },
      /**
       * 
       */
      make(callback = {}) {
        this.makeExecuted = true;
        this.makeing = true;
        this.isError = false;
        if (typeof callback.success != "function") {
          callback.success = () => {
          };
        }
        if (typeof callback.fail != "function") {
          callback.fail = () => {
          };
        }
        if (typeof callback.complete != "function") {
          callback.complete = () => {
          };
        }
        this.resetCanvas(() => {
          clearTimeout(this.makeDelegate);
          this.makeDelegate = setTimeout(() => {
            this.draw({
              success: () => {
                setTimeout(() => {
                  callback.success();
                  this.complete(true);
                }, 300);
              },
              fail: (err) => {
                callback.fail(err);
                this.error = err;
                this.complete(false, err.errMsg);
              },
              complete: () => {
                callback.complete();
                this.makeing = false;
              }
            });
          }, 300);
        });
      },
      /**
       * 
       */
      remake(callback) {
        this.$emit("change");
        this.make(callback);
      },
      /**
       * 
       */
      complete(success = true, errMsg = "") {
        if (success) {
          this.$emit("complete", {
            success
          });
        } else {
          this.$emit("complete", {
            success,
            errMsg
          });
        }
      },
      /**
       * 
       */
      toTempFilePath(callback = {}) {
        if (typeof callback.success != "function") {
          callback.success = () => {
          };
        }
        if (typeof callback.fail != "function") {
          callback.fail = () => {
          };
        }
        if (typeof callback.complete != "function") {
          callback.complete = () => {
          };
        }
        if (!this.makeExecuted) {
          formatAppLog("error", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:648", "[uQRCode]: make()  make() ");
          var err = {
            errMsg: "[uQRCode]: make() method has never been executed! please execute make() successfully before operating."
          };
          callback.fail(err);
          callback.complete(err);
          return;
        }
        if (this.isError) {
          callback.fail(this.error);
          callback.complete(this.error);
          return;
        }
        if (this.makeing) {
          this.toTempFilePathDelegate = () => {
            this.toTempFilePath(callback);
          };
          return;
        } else {
          this.toTempFilePathDelegate = null;
        }
        if (this.canvasType === "2d")
          ;
        else {
          uni.canvasToTempFilePath(
            {
              canvasId: this.canvasId,
              fileType: this.fileType,
              width: Number(this.templateOptions.canvasWidth),
              height: Number(this.templateOptions.canvasHeight),
              destWidth: Number(this.templateOptions.size),
              destHeight: Number(this.templateOptions.size),
              success: (res) => {
                callback.success(res);
              },
              fail: (err2) => {
                callback.fail(err2);
              },
              complete: () => {
                callback.complete();
              }
            },
            this
          );
        }
      },
      /**
       * 
       */
      save(callback = {}) {
        if (typeof callback.success != "function") {
          callback.success = () => {
          };
        }
        if (typeof callback.fail != "function") {
          callback.fail = () => {
          };
        }
        if (typeof callback.complete != "function") {
          callback.complete = () => {
          };
        }
        this.toTempFilePath({
          success: (res) => {
            if (this.canvasType === "2d")
              ;
            else {
              uni.saveImageToPhotosAlbum({
                filePath: res.tempFilePath,
                success: (res1) => {
                  callback.success(res1);
                },
                fail: (err1) => {
                  callback.fail(err1);
                },
                complete: () => {
                  callback.complete();
                }
              });
            }
          },
          fail: (err) => {
            callback.fail(err);
            callback.complete(err);
          }
        });
      },
      /**
       * click
       */
      onClick(e2) {
        this.$emit("click", e2);
      },
      /**
       * 
       */
      getInstance() {
        return instance;
      },
      /**
       * typestyledrawCanvas
       * @param {Object} plugin
       */
      registerStyle(plugin) {
        if (plugin.Type != "style") {
          formatAppLog("warn", "at node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue:850", "[uQRCode]: registerStyle  style ");
          return {
            errMsg: "registerStyle  style "
          };
        }
        if (typeof plugin === "function") {
          this.plugins.push({
            plugin,
            name: plugin.Name,
            drawCanvas: plugin.DrawCanvas
          });
        }
      },
      getLoadImage(loadImage) {
        var that = this;
        if (typeof loadImage == "function") {
          return function(src) {
            if (that.isQueueLoadImage) {
              return queueLoadImage.exec(() => {
                return new Promise((resolve, reject) => {
                  setTimeout(() => {
                    const cache2 = cacheImageList.find((x) => x.src == src);
                    if (cache2) {
                      resolve(cache2.img);
                    } else {
                      loadImage(src).then((img) => {
                        cacheImageList.push({
                          src,
                          img
                        });
                        resolve(img);
                      }).catch((err) => {
                        reject(err);
                      });
                    }
                  }, 10);
                });
              });
            } else {
              return loadImage(src);
            }
          };
        } else {
          return function(src) {
            return Promise.resolve(src);
          };
        }
      }
    }
  };
  function deepReplace(o2 = {}, r2 = {}, c2 = false) {
    let obj;
    if (c2) {
      obj = o2;
    } else {
      obj = {
        ...o2
      };
    }
    for (let k in r2) {
      var vr = r2[k];
      if (vr != void 0) {
        if (vr.constructor == Object) {
          obj[k] = this.deepReplace(obj[k], vr);
        } else if (vr.constructor == String && !vr) {
          obj[k] = obj[k];
        } else {
          obj[k] = vr;
        }
      }
    }
    return obj;
  }
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock(
      "view",
      {
        class: vue.normalizeClass(["uqrcode", { "uqrcode-hide": _ctx.hide }]),
        style: vue.normalizeStyle({ width: `${$data.templateOptions.width}px`, height: `${$data.templateOptions.height}px` })
      },
      [
        vue.createElementVNode("view", { class: "uqrcode-canvas-wrapper" }, [
          vue.createCommentVNode("  "),
          $data.templateOptions.canvasDisplay ? (vue.openBlock(), vue.createElementBlock("canvas", {
            key: 0,
            class: "uqrcode-canvas",
            id: $data.canvasId,
            "canvas-id": $data.canvasId,
            type: $data.canvasType,
            style: vue.normalizeStyle({
              width: `${$data.templateOptions.canvasWidth}px`,
              height: `${$data.templateOptions.canvasHeight}px`,
              transform: $data.templateOptions.canvasTransform
            }),
            onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
          }, null, 12, ["id", "canvas-id", "type"])) : vue.createCommentVNode("v-if", true),
          vue.createCommentVNode(" nvuegcanvas ")
        ]),
        vue.createCommentVNode("  "),
        (_ctx.loading === void 0 || !_ctx.loading ? $data.makeing : _ctx.loading) ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 0,
          class: "uqrcode-makeing"
        }, [
          vue.renderSlot(_ctx.$slots, "loading", {}, () => [
            vue.createElementVNode(
              "image",
              {
                class: "uqrcode-makeing-image",
                style: vue.normalizeStyle({ width: `${$data.templateOptions.size / 4}px`, height: `${$data.templateOptions.size / 4}px` }),
                src: "data:image/gif;base64,R0lGODlhAAEAAfIEAOHh4SSsWuDg4N3d3f///wAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDYuMC1jMDAyIDc5LjE2NDQ4OCwgMjAyMC8wNy8xMC0yMjowNjo1MyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjAgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjAyODhGMzM4RDEwMTExRUM4MDhCRkVBQkE2QUZDQzkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjAyODhGMzM5RDEwMTExRUM4MDhCRkVBQkE2QUZDQzkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDI4OEYzMzZEMTAxMTFFQzgwOEJGRUFCQTZBRkNDOTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4OEYzMzdEMTAxMTFFQzgwOEJGRUFCQTZBRkNDOTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4B//79/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vby7urm4t7a1tLOysbCvrq2sq6qpqKempaSjoqGgn56dnJuamZiXlpWUk5KRkI+OjYyLiomIh4aFhIOCgYB/fn18e3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwrKikoJyYlJCMiISAfHh0cGxoZGBcWFRQTEhEQDw4NDAsKCQgHBgUEAwIBAAAh+QQFFAAEACwAAAAAAAEAAQAD/0i63P4wykmrvTjrzbv/YCiOZGmeaKqubOu+cCzPdG3feK7vfO//wKBwSCwaj8ikcslsOp/QqHRKrVqv2Kx2y+16v+CweEwum8/otHrNbrvf8Lh8Tq/b7/i8fs/v+/+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanigCqq6ytrieusbISAbW2t7i5uru8vb66bLLCrLDDw7S/ycrLzLXBxsLF0LHIzdbXzc/Trybb1BHY4eK92t6r0uaq1ePs4+Xp6PDg7fTh7+bx+PP1/Mz33vkA7utH0Ne/bQERDizIMNfBaQkhLmxIMcBDaBExTqzI8P+isYwfN3Ik6PFYt3TnRI7kVzLaSZQA1q0s2HLWS5QyZ/ar+a0ETHUqdbLjyc3nz5xC6RFtBdIkhKQ01/yMeVPeU6g7pR6tqu8q1npLiXEV6PVru7ApjcJEquyEPa1rxyosm83EWzVTm7qk688uNrRA1eIMatDvNcBUBVt9cJdEYzR55Urku8ztX7iDFXdlfLnE4zORNZPlfNiwNcR6bVJua7ou3q2i55I+3brv67ixJ8927bhzmtAkgDv4HIJ4GeEikDMw/oH5GOUgoCtw3oF6GOkesFvfsP0L9g7afY/o7uU7h/ClPYsHDTt4++Hri8c//j55/eXzm+d/fj96/+n/+1UX4HX/ZVcgeRggyIV5G6BHmycMauAgb5xEmMGEtnViIQYYVvbJhhd0yBqEBYJ34ICUgGiBiMmAomIFLP7iYonnnZiehjQ2aOODOE7l449MERbVai1iBuSRO67EVpG3IenkYvDptKSMRj5pZUhENjRlYU1e6aVqu420JTlVfmlmYGFyNCYviJ2ZWZoVrblLm25uFuVMcgJTZp1X5gmWkGzuyeeTfioF6JyCDopkoWcdqmeXilrJ6FCOOpRopD9O6k6luNCJ6V5wUqSpRZd+mqSYnN7iqalFhaplqrasyqpYWXYEqzOlzmpnA0mNKquuiblqa61kQgrsqWreSqqx/8e+eaeSyqIi7bTUVmvttdhmq+223Hbr7bejCCDuuOSWa+656Kar7rrnSjDAu/DGK++89NZr77340vsru/z2224E+QYs8MAEw7uvvwj3627BDDfM8MEJR5zuwg5XbHG9EEusMbkUX+zxxRlvvHHHH5f8cK4ip+wvySa3HHDIKifMsss0Y4xyzDijO3PNPBt8c85Aj7tzzzzDHPS6QxNNs9FHTwyw0lAPwHTT/0IQNdRTU11u0ld/nLXWQj/dddE/g50y12Nb/LXZaKft8Npgt+32ycyafbTccxMMt9Z45y3w3lT37Xe+qEnGruDxzihxalU/ULHiETNuLuI+k7i44f9Ii013j5Fjri7l70Ius+dOW/32hxpLvrXmBYuOsOocs6436pfndrjsA7u+Muk64/437Z3bnrnpDeuuMO+NO/A48KML/7nvLzP/OvKTQ0+49Ls7X7rjp1sevHu1c1889sdr3zvxm1eYOvWro986+fzCHrb7s3vfPPjfK9895/ePMLL1+DKe3c6Hv/fZb4DPM5++4IfA9hWwfvxrIAH9tz/1STCBD8wdAy8oNfYlboMXlF/oQChBEXbwgByMnQLnJcAUmrCFHDTh4FhYNrZ5cIY2q5sLb4hDGuowhjzs4Qd/GMIgCnGERCyhEY8IOAxS8IgVZE8Kk2cfKI4viQ2UIRPAaxi3JQqxiXcDoBXtVbgVOlB/YzTgb9ZnRhWKL40axCIVQ/A/+sExgFwU1wvFeMchrjF8T8xfA/oYxz8Kko5sfCMh71XGDJZPkYvMoSH7V8VDLiCS15Nj9do4P0hiUl6NDCQlGfBJRoLrlKhMpSpXycpWuvKVsIylLGdJy1ra8pa4zKUud8nLXvryl8AMpjCHScxiGvOYyEymMpfJzGY685nQjKY0p0nNalrzmtjMpja3yc1uevOb4AynOMdJhwQAACH5BAUUAAQALDIAMgCcAJwAAAP/KLrcTjDKSWt0OFsIuv9gKI5kaZ6Ztq1s6iorKs90/apsTt1pbP/AIA+mK16Gj41wyWwan8ikpUmtRp/GaMNn7Xq3WJ2Wwf2arWHxmDg9u6np3JpdeduX8da8fO8j83xXSn6EQ4CDa4GFi2CHO3uIjJJkjo+JkZOTlZZjipmFmxNzAp6ffqESo6Wmd6hHl22sjK4ckLGyoLSqmLh9tAS7t72+urZ1QL+LycacNcuEz528M9HErsHHP9WtxbDZNtt24YbTMuNu5zerJulm7S7rJe9e8zjfzt2n+VrxJPVo+wQJo/GvSsFG9wgGFLeQ3EBqDdFFVFcOxUEnE1/0G3GR/0lHOs0UXss10ltIiCX1peRX8cRHIS83iniJLVRNUcgyfonZkp1Oej/tnTT3K87NSkdfgSuaJukhp8ByMsUCNQ/UIFPDVDXKDKe2rFC6IhWrFB/YIlubkq319awak5uuSnWrB+5Yu2VF0pUpBZXctnt7jhqMl63KhMMIU3z4hm9ixY4xMn6sGENkj4IpVyaVuctlzdImn/kMWiDixp1L/z08VPVm0lhTuw59WqLo2YNhz22NO7dsOL9789ANmLfwwlGhBT8Obzke58wtQ499O/qf6bu9WvddHWj37RqxF9cOHrky8ZvTs/wOkH2IwPDjy59Pv779+/jz69/Pv7////8ABijggAQWaOCBCCao4FQDNOjggxBGKOGEFFZooYQrBKDhhhx26OGHIIYo4ogfXmjiiSim6GCGJLbo4oswaqjijDTSyGKMOOYYY4089ljhjToGKWSJPhZpJJBDJimkkUz2iKSSUO7Y5JQqPhnllSRSqeWJVmLpJZFbhjlhl1+WKaOYaEJIpplfpulmg2uyieWbbsYpZ5R0pmnnnUrmieaefA7pp5iABhrkoGEWamiOiG6p6KJSNjrlo5C+KCmVlFba4qWTbqCpl5w2memnIvLIkwVB6mdqUBh6qqOqNZ5aQar5rbpSiqMGAKuNrEaY664zykoBrfjZ6lesruYIbJX/vaqZLI7L4trsg7/WiuytKFZb7LXH8orqq9Z6222wz8YYbbbTrlgujOdymS6c677YronCTkDsfcbaxO2w4G4rrr7/2tsvvvvGVbAE99qXr8EBIzywwgc7srDDyoZLLrbufluxv6EOUFTC9XWsLi0g0ycyvCQ/HPLJH6tsMsu/lDzfyR7H7PLMMKe8McEit7wzxD3b/PPKQesMrcWh+kxqnzm7sjSeTaPyNJQ0Kz31oVGHcnWSVQu9tY5dG/01jmE7PTbYWW9yNtpFm712pDQ3HMHbZEf8lN0E0A03sxjTG6/eIU4sMd6AW4q3VYQXvunhXMkNgeKLOw6I4I9DPiLlGZMnbnngjKsl+ealdq6V5qB7iDnin5f+YQIAIfkEBRQABAAsMgAyAJwAnAAAA/84utxOMMpJa3Q4Wyi6/2AojmRpnpm2rWzqKisqz3T9qmxO3Wls/8AgD6YrXoaPjXDJbBqfyKSlSa1Gn8Zow2fterdYnZbB/ZqtYfGYOD27qencml1525fx1rx87yPzfFdKfoRDgINrgYWLYIc7e4iMkmSOj4mRk5OVlmOKmYWbE3MDnp9+oRKjpaZ3qEeXbayMrhyQsbKgtKqYuH20BLu3vb66tnVAv4vJxpw1y4TPnbwz0cSuwcc/1a3FsNk223bhhtMy427nN6sm6WbtLusl717zON/O3af5WvEk9Wj7BAmj8a9KwUb3CAYUt5DcQGoN0UVUVw7FQScTX/QbcZH/SUc6zRReyzXSW0iIJfWl5FfxxEchLzeKeIktVE1RyDJ+idmSnU56P+2dNPcrzs1KR1+BK5om6SGnwHIyxQI1D9QgU8NUNcoMp7asULoiFasUH9giW5uSrfX1rBqTm65KdasH7li7ZUXSlSkFldy2e3uOGoyXrcqEwwhTfPiGb2LFjjEyfqwYQ2SPgilXJpW5y2XN0iaf+QxaIOLGnUv/PTxU9WbSWFO7Dn1aoujZg2HPbY07t2w4v3vz0A2Yt/DCUaEFPw5vOR7nzC1Dj307+p/pu71a910daPftGrEX1w4euTLxm9Oz/A6QfYjA8OPLn0+/vv37+PPr38+/v////wAGKOCABBZo4IEIJqjgVAE06OCDEEYo4YQUVmihhMQBoOGGHHbo4YcghsjhhSSWaOKJDmYo4oostqghijDGGKOKLtZo44sy5qgjhTTe6OOKOwYpZAA9/mikh0MmKWORRzYJgJJQnsikk0ZGaeWFU1Lp45VcTpilljZ2KeaDX4Lp4pholmkmi2iOqeaaIrYp5ptwgihnl3TWieSdV+ap54h8WunnnzgGCuWghBoaJaJ/KnooeoTW6KiSjOo5aZKV1pnjL5tCp1+nroBaG4ufLkmLqMaJWOqMp5rqXoerwsipq6OuGCuKs7L6Koe3StmqrrWqmh+qmxCbipG9mpirrP+eDktrKMbmVWOyJS6La7P4RXuItsn5SC2J1vq664bfYvkrs+NqWK6F4SqL7X3c5sHtketW2G6179oXbxzzIusssNA+S56N9fJ47rXpAlCwlweLG2yIC7fJU7aXkhnUhxGnebGHGbu5Maz/Vkzkx7yGXPHE8IrcIMr6qjzySgSbfCnL9bn8sl/+UqwyTZHeaDPPPUvqMtBBt/gzyUVvOTTSSYe5NMxNr3k01FGDOTXOVWv6NNZZS721TV3DaXO/YZu5bxpkl63l2WGkrbaTbGPh9ttHxv3E3HT/aLcReOfts8CV9O230AAXC7i0gxOOLiqCJ87m4dtC3q3jThceuOQElP+YAAAh+QQFFAAEACwyADIAnACcAAAD/xi63E4wyklrdDhbOLr/YCiOZGmKWcpsbEuoMHvOdG17sOruVJ7Kt6Aw6NPwjq/iYzNsOkvKJXIXbQCfWGx1NaVuFdesWPgFd13lQHjMpqXP6PK6TSe94ay7pc6HyvEbehV9hCGCgBOHE4WMHYqIEI8RjYySiJYElIWYeJiahJxwnp98oWejpHSmXaipbKtTra5isEiys1p/kIm6g7hjtUe3v03BPMM0uxTFvcpJX3M1zhLM0NORzYtD1xxDxl7We9vc1Vvcz+ZM49flVefIM+ftUe/Z1OvT80r14b5C8t7sQYJ3AiAZgZcQZsLnTF8RfunE/SMXsJ8zgiYMElHYSf9hE403vsWxqG0iu4oRp2EsAdKGyBYrSbSs8TKPR4bKHPqA6E6dyXwoe16LOWKmG46ibv5sGJQeN6IijM6oGUhpkHMdSe6CGgJrUq0Drd7wegppWbDdlpIFl/KiWBtrY5ll9VZaXGFz5aJdqPZu1b1Z25a86petUJV1kxUeKXhr4niLYaaZTFmKP03RjlbePDkzIc8nOIt+3Ae0idGonUrE7HNj6tc6WlMy7Qe2bcvLSNG2c7v3gt1tgKPw7Vv4GOMgiBeX3Qj5B+W9nWOR7gi6bepOsFu/zpyR9u2vsX/srhn8aPE47x00f578Z/eh2bdfPRv+afmi0fed1BQ/VzH/3/lXmX6E0eeSgAPaV0eACP6XBXaRRSjhhBRWaOGFGGao4YYcdujhhyCGKOKIJJZo4okopqjiimQB4OKLMMYo44w01mjjjTMSKMCOPPbo449ABinkkDgWaeSROOpI5JJMNonkk1BGqaSTVFYZ5ZVY3jillVx2meWXSG7p5Zhkgmmmi2KWqeaZbBqZ5ppwtilnjG/GaeecbNZ55554Yqknn4D2eeSfgRYqaI2EGqrooS8muiijkDr6KKSCSjoppXNaeimmeSq46aec2qgpqKH66SmpqJYKwKipqjroqa3yKVWSsP64oaknSVmrj7deOauWu/bYq665QgmhhrgCRexl/1UOayxFy+bGpbNP/ipqsDxSGya0zxropLavFlsttjuC6ya343rbpLlFWosouQKwS6u426rLpLzA0hsus1Tie62+59q7pL/vAtwuvATT6K7CCCPrK7r18vutw9Hm9LDARCacI8T7SmulxjIuvDHGQ4JMJ8cBS7wuxa6GjPK9LLcMo8i2xiwzmi8PbPPNNPO6s8w9C/tzy0FnO7SrRZd7tKpJx7t0qU2bzGjUT4fadKxYn2xw1lwfvHXXYDP8ddhkN5pz2WhfjTbQZ68dttpuM9123De7PDbddZvJatZUk4x3xbsk6/Hfa/atMuGCWww4f4gXPrfYhzferbKTDy554hmBXxz55R0rXvlgnGvO1OJphS665+luTncCADs="
              },
              null,
              4
              /* STYLE */
            )
          ], true)
        ])) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode("  "),
        $data.isError ? (vue.openBlock(), vue.createElementBlock("view", {
          key: 1,
          class: "uqrcode-error",
          onClick: _cache[1] || (_cache[1] = (...args) => $options.onClick && $options.onClick(...args))
        }, [
          vue.renderSlot(_ctx.$slots, "error", { error: $data.error }, () => [
            vue.createElementVNode(
              "text",
              { class: "uqrcode-error-message" },
              vue.toDisplayString($data.error.errMsg),
              1
              /* TEXT */
            )
          ], true)
        ])) : vue.createCommentVNode("v-if", true),
        vue.createCommentVNode(" H5 ")
      ],
      6
      /* CLASS, STYLE */
    );
  }
  const uvQrcode = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$1], ["__scopeId", "data-v-6fbe98c8"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/node_modules/@climblee/uv-ui/components/uv-qrcode/uv-qrcode.vue"]]);
  const _imports_3 = "/static/icons/downLoad.png";
  const _imports_4 = "/static/icons/closeIcon.png";
  const _sfc_main$1 = {
    __name: "deatil",
    setup(__props, { expose: __expose }) {
      __expose();
      const HWHJStoreDeatil = HWHJStore();
      const shelfVal = vue.ref(0);
      const layersList = vue.ref([]);
      const deletePopInd = vue.ref({});
      const showPopCenter = vue.ref(false);
      const deleteHandle = (index2) => {
        deletePopInd.value = index2;
        showPopCenter.value = true;
      };
      const confirmDeleteHandle = () => {
        request({
          url: "/admin-api/storage/overseas/goods-location/delete-floor?shelf=" + shelfVal.value + "&floor=" + layersList.value[deletePopInd.value],
          methods: "DELETE"
        }).then((res) => {
          uni.showToast({
            title: "Delete success",
            icon: "none"
          });
          getClassList();
          showPopCenter.value = false;
        });
      };
      const popObj = vue.ref({});
      const showCenter = vue.ref(false);
      const qrCodeData = vue.ref("");
      const showQrCode = (item) => {
        qrCodeData.value = shelfVal.value + "-" + item;
        popObj.value = item;
        showCenter.value = true;
      };
      const qrcodeRef = vue.ref("");
      const qrCodeComplete = (res) => {
        formatAppLog("log", "at pages/shelf/deatil.vue:63", qrcodeRef.value);
        formatAppLog("log", "at pages/shelf/deatil.vue:64", "");
      };
      const qrCodeBase64 = vue.ref("");
      const downloadHandle = () => {
        qrcodeRef.value.save({
          success: (res) => {
            uni.showToast({
              title: "Save Success",
              icon: "none"
            });
          }
        });
      };
      onLoad((e2) => {
        if (e2.item) {
          shelfVal.value = e2.item;
          getClassList();
        }
      });
      const getClassList = () => {
        request({
          url: "/admin-api/storage/overseas/goods-location/floor-list/" + shelfVal.value
        }).then((res) => {
          layersList.value = res.floorList.sort((a2, b2) => a2 - b2);
          let arr = findDifferentValues(layerListStatic, res.floorList);
          layerList.value = arr.map((item) => {
            return {
              name: item,
              value: item
            };
          });
        });
      };
      function findDifferentValues(arr1, arr2) {
        return [
          ...arr1.filter((item) => !arr2.includes(item)),
          ...arr2.filter((item) => !arr1.includes(item))
        ];
      }
      const layerVal = vue.ref([0]);
      const layerListStatic = HWHJStoreDeatil.LAYERSLIST;
      const layerList = vue.ref([]);
      const showPickerLayer = vue.ref(false);
      const confirmLayerHandle = (e2) => {
        request({
          url: "/admin-api/storage/overseas/goods-location/create-floor",
          methods: "POST",
          data: {
            shelf: shelfVal.value,
            floor: layerList.value[0].name
          }
        }).then((res) => {
          uni.showToast({
            title: "Add success",
            icon: "none"
          });
          getClassList();
          showPickerLayer.value = false;
        });
      };
      const goBack = () => {
        uni.navigateBack();
      };
      const __returned__ = { HWHJStoreDeatil, shelfVal, layersList, deletePopInd, showPopCenter, deleteHandle, confirmDeleteHandle, popObj, showCenter, qrCodeData, showQrCode, qrcodeRef, qrCodeComplete, qrCodeBase64, downloadHandle, getClassList, findDifferentValues, layerVal, layerListStatic, layerList, showPickerLayer, confirmLayerHandle, goBack, get request() {
        return request;
      }, get HWHJStore() {
        return HWHJStore;
      }, onMounted: vue.onMounted, uvQrcode, ref: vue.ref, get onLoad() {
        return onLoad;
      } };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_van_text_ellipsis = vue.resolveComponent("van-text-ellipsis");
    const _component_van_overlay = vue.resolveComponent("van-overlay");
    const _component_van_picker = vue.resolveComponent("van-picker");
    const _component_van_popup = vue.resolveComponent("van-popup");
    return vue.openBlock(), vue.createElementBlock("view", { class: "" }, [
      vue.createElementVNode("view", { class: "pdlr10 pdtb10 between topNav" }, [
        vue.createElementVNode("view", { class: "left" }, [
          vue.createElementVNode("image", {
            src: _imports_0$2,
            class: "ww32 hh32",
            onClick: $setup.goBack
          })
        ]),
        vue.createElementVNode("view", { class: "text_center f17" }, [
          vue.createVNode(_component_van_text_ellipsis, {
            rows: "1",
            content: "Details",
            class: "text_bold",
            style: { "width": "100%" }
          })
        ]),
        vue.createElementVNode("view", {
          class: "right",
          style: { "min-width": "24px" }
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      vue.createElementVNode("view", { class: "pdlr12 mt20" }, [
        vue.createElementVNode("view", { class: "topBox" }, [
          vue.createElementVNode("view", {
            class: "mt19 shelfBox center flex-col",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.showPicker = true)
          }, [
            vue.createElementVNode(
              "view",
              { class: "f24 text_bold" },
              "Shelf " + vue.toDisplayString($setup.shelfVal),
              1
              /* TEXT */
            ),
            vue.createElementVNode("view", { class: "mt4 f15 color7C" }, "current shelf")
          ])
        ]),
        vue.createElementVNode("view", { class: "mt35 botBox" }, [
          vue.createElementVNode("view", { class: "between" }, [
            vue.createElementVNode("view", { class: "f16 text_bold" }, "Layers"),
            vue.createElementVNode("view", {
              class: "flex col_center f12",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.showPickerLayer = true)
            }, [
              vue.createElementVNode("image", {
                src: _imports_1,
                class: "ww12 hh12"
              }),
              vue.createElementVNode("view", { class: "ml6 colorBlue" }, "Add")
            ])
          ]),
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList($setup.layersList, (item, index2) => {
              return vue.openBlock(), vue.createElementBlock("view", { class: "between goodsItem" }, [
                vue.createElementVNode("view", { class: "flex col_center" }, [
                  vue.createElementVNode(
                    "view",
                    { class: "f15 text_bold" },
                    vue.toDisplayString($setup.shelfVal + "-" + item),
                    1
                    /* TEXT */
                  )
                ]),
                vue.createElementVNode("view", {
                  class: "f13 colorBlue",
                  onClick: ($event) => $setup.showQrCode(item)
                }, " QR Code ", 8, ["onClick"]),
                vue.createElementVNode("view", {
                  class: "deleteIcon",
                  onClick: ($event) => $setup.deleteHandle(index2)
                }, [
                  vue.createElementVNode("image", {
                    src: _imports_2,
                    class: "ww14 hh14"
                  })
                ], 8, ["onClick"])
              ]);
            }),
            256
            /* UNKEYED_FRAGMENT */
          ))
        ])
      ]),
      vue.createElementVNode("view", { style: { "height": "50px" } }),
      vue.createVNode(_component_van_overlay, { show: $setup.showCenter }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "center flex_col pdtb30 codeBoxEl" }, [
            vue.createElementVNode("div", { id: "imgNode" }, [
              vue.createElementVNode(
                "view",
                { class: "f22 text_bold text_center" },
                vue.toDisplayString($setup.shelfVal + "-" + $setup.popObj),
                1
                /* TEXT */
              ),
              vue.createElementVNode("view", { class: "f14 color7C mt4 text_center" }, "current shelf"),
              vue.createCommentVNode(' <image :src="qrCodeBase64" style="width:200px;height:200px" /> '),
              vue.createElementVNode("view", { class: "qrimg mgtb20" }, [
                vue.createVNode($setup["uvQrcode"], {
                  ref: "qrcodeRef",
                  size: "150px",
                  value: $setup.qrCodeData,
                  onComplete: $setup.qrCodeComplete
                }, null, 8, ["value"])
              ])
            ]),
            vue.createElementVNode("view", {
              class: "codeBtn f14 text_white center",
              onClick: $setup.downloadHandle
            }, [
              vue.createElementVNode("image", {
                src: _imports_3,
                class: "ww25 hh24"
              }),
              vue.createTextVNode(" Download ")
            ]),
            vue.createElementVNode("view", {
              class: "closeIconEl",
              onClick: _cache[2] || (_cache[2] = ($event) => $setup.showCenter = false)
            }, [
              vue.createElementVNode("image", {
                src: _imports_4,
                class: "ww24 hh24"
              })
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPickerLayer,
        "onUpdate:show": _cache[5] || (_cache[5] = ($event) => $setup.showPickerLayer = $event),
        round: "",
        position: "bottom"
      }, {
        default: vue.withCtx(() => [
          vue.createVNode(_component_van_picker, {
            modelValue: $setup.layerVal,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.layerVal = $event),
            title: "Layers",
            columns: $setup.layerList,
            "confirm-button-text": "Confirm",
            "cancel-button-text": "Cancel",
            onConfirm: $setup.confirmLayerHandle,
            "columns-field-names": { text: "name" },
            onCancel: _cache[4] || (_cache[4] = ($event) => $setup.showPickerLayer = false)
          }, null, 8, ["modelValue", "columns"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"]),
      vue.createVNode(_component_van_popup, {
        show: $setup.showPopCenter,
        "onUpdate:show": _cache[7] || (_cache[7] = ($event) => $setup.showPopCenter = $event),
        round: "",
        style: { "width": "280px" }
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("view", { class: "pt30 pdlr26" }, [
            vue.createElementVNode("view", {
              class: "f15 text_center borderB pb24",
              style: { "line-height": "18px" }
            }, " Are you sure you want to delete the current layer number? ")
          ]),
          vue.createElementVNode("view", { class: "pdlr20" }, [
            vue.createElementVNode("view", { class: "girdBtn pop" }, [
              vue.createElementVNode("view", {
                class: "botBtn cancelBtn center color7C",
                onClick: _cache[6] || (_cache[6] = ($event) => $setup.showPopCenter = false)
              }, "Cancel"),
              vue.createElementVNode("view", {
                class: "botBtn center text_white confirmBtn",
                onClick: $setup.confirmDeleteHandle
              }, "Confirm")
            ])
          ])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show"])
    ]);
  }
  const PagesShelfDeatil = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-71d48cec"], ["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/pages/shelf/deatil.vue"]]);
  __definePage("pages/tab/index", PagesTabIndex);
  __definePage("pages/home/login", PagesHomeLogin);
  __definePage("pages/setting/index", PagesSettingIndex);
  __definePage("pages/setting/updatePwd", PagesSettingUpdatePwd);
  __definePage("pages/gd/recive", PagesGdRecive);
  __definePage("pages/gd/reciveSuccess", PagesGdReciveSuccess);
  __definePage("pages/gd/warehouse", PagesGdWarehouse);
  __definePage("pages/gd/warehouseSuccess", PagesGdWarehouseSuccess);
  __definePage("pages/gd/warehouseMen", PagesGdWarehouseMen);
  __definePage("pages/gd/warehouseDeatil", PagesGdWarehouseDeatil);
  __definePage("pages/gd/goodsMen", PagesGdGoodsMen);
  __definePage("pages/home/goodsList", PagesHomeGoodsList);
  __definePage("pages/home/scanCode", PagesHomeScanCode);
  __definePage("pages/home/receiveSuccess", PagesHomeReceiveSuccess);
  __definePage("pages/home/warehouse", PagesHomeWarehouse);
  __definePage("pages/home/wareSuccess", PagesHomeWareSuccess);
  __definePage("pages/shelf/index", PagesShelfIndex);
  __definePage("pages/shelf/add", PagesShelfAdd);
  __definePage("pages/shelf/deatil", PagesShelfDeatil);
  const _sfc_main = {
    onLaunch: function() {
      formatAppLog("log", "at App.vue:4", "App Launch");
    },
    onShow: function() {
      formatAppLog("log", "at App.vue:7", "App Show");
    },
    onHide: function() {
      formatAppLog("log", "at App.vue:11", "App Hide");
    }
  };
  const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "C:/Users/Admin/Desktop/10-15/plantUpgrade/App.vue"]]);
  const en = {
    paging: {
      lmdt: "Click to load more",
      lmlt: "Loading...",
      lmnmt: "No more",
      lmft: "Load failed, click to reload",
      evt: "No data~",
      evrt: "Reload",
      evet: "Sorry, loading failed"
    },
    login: {
      l1: "Hello",
      l2: "Welcome to login [Warehouse Management Portal]",
      l3: "Phone Number",
      l4: "Please enter your phone number",
      l5: "Password",
      l6: "Please enter your password",
      l7: "Login"
    },
    setting: {
      s_t1: "Password",
      s_s1: "Set",
      s_s2: "Change Password",
      s_s3: "Log Out",
      s_s4: "Are you sure you want to log out of the current account?",
      s_s5: "Cancel",
      s_s6: "Confirm",
      s_s7: "Account",
      s_s8: "Old password",
      s_s9: "Please enter",
      s_s10: "New password",
      s_j1: "Update Success"
    },
    home: {
      h_h1: " Overseas ",
      h_h2: "Warehouse",
      h_h3: "Welcome to log in ",
      h_h4: "Failed to enable camera",
      h_a1: "Scan",
      h_a2: "Put the logistics tracking number in the box and it will be automatically scanned",
      h_a3: `Please scan the 'shelf layer number' first so that it can be used to place the goods`,
      h_a4: "Manual Input",
      h_a5: "Input",
      h_a6: "Please manually input the 'logistics order number' to query the order",
      h_a7: "Please enter the container number(for example:1-1)",
      h_a8: "Scan code failed"
    }
  };
  const zh = {
    paging: {
      lmdt: "",
      lmlt: "...",
      lmnmt: "",
      lmft: "",
      evt: "~",
      evrt: "",
      evet: ""
    },
    login: {
      l1: "",
      l2: " []",
      l3: "",
      l4: "",
      l5: "",
      l6: "",
      l7: ""
    },
    setting: {
      s_t1: "",
      s_s1: "",
      s_s2: "",
      s_s3: "",
      s_s4: "",
      s_s5: "",
      s_s6: "",
      s_s7: "",
      s_s8: "",
      s_s9: "",
      s_s10: "",
      s_j1: ""
    },
    home: {
      h_h1: "",
      h_h2: "",
      h_h3: "",
      h_h4: "",
      h_a1: "",
      h_a2: "",
      h_a3: "",
      h_a4: "",
      h_a5: "",
      h_a6: "",
      h_a7: "1-1",
      h_a8: ""
    }
  };
  let lang;
  uni.getStorageSync("language");
  try {
    lang = uni.getStorageSync("language");
    if (!uni.getStorageSync("language")) {
      uni.setStorageSync("language", "en");
    }
  } catch (e2) {
  }
  const i18n = createI18n({
    locale: lang || "en",
    // 
    globalInjection: true,
    // ,$t
    legacy: false,
    messages: {
      en,
      zh
    }
  });
  uni.$zp = {
    config: {
      //pageSize15
      "loading-more-default-text": i18n.global.t("paging.lmdt"),
      "loading-more-loading-text": i18n.global.t("paging.lmlt"),
      "loading-more-no-more-text": i18n.global.t("paging.lmnmt"),
      "loading-more-fail-text": i18n.global.t("paging.lmft"),
      "empty-view-text": i18n.global.t("paging.evt"),
      "empty-view-reload-text": i18n.global.t("paging.evrt"),
      "empty-view-error-text": i18n.global.t("paging.evet"),
      "loading-more-loading-icon-type": "circle"
    }
  };
  const pinia = createPinia();
  function createApp() {
    const app = vue.createVueApp(App);
    app.use(stdin_default);
    app.use(i18n);
    app.use(pinia);
    return {
      app
    };
  }
  const { app: __app__, Vuex: __Vuex__, Pinia: __Pinia__ } = createApp();
  uni.Vuex = __Vuex__;
  uni.Pinia = __Pinia__;
  __app__.provide("__globalStyles", __uniConfig.styles);
  __app__._component.mpType = "app";
  __app__._component.render = () => {
  };
  __app__.mount("#app");
})(Vue, uni.VueShared);
